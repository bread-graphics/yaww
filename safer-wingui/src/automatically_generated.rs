// Automatically generated by yaww-generator
use crate::{abort_on_panic, Cow, Lparam, Wparam, wide_strlen};
use core::{mem, slice};
use core_cstr::Cstr;
#[cfg(feature = "alloc")]
use alloc::vec::Vec;
#[cfg(feature = "alloc")]
use cstr_core::CString;
#[cfg(feature = "std")]
use std::ffi::{OsStr, OsString};
#[doc(inline)]
pub use windows_sys::Win32::Foundation::BOOL;
#[doc(inline)]
pub use windows_sys::Win32::Foundation::BOOLEAN;
#[doc(inline)]
pub use windows_sys::Win32::Foundation::BSTR;
#[doc(inline)]
pub use windows_sys::Win32::Foundation::CHAR;
#[doc(inline)]
pub use windows_sys::Win32::Foundation::HANDLE_PTR;
#[doc(inline)]
pub use windows_sys::Win32::Foundation::NTSTATUS;
#[doc(inline)]
pub use windows_sys::Win32::Foundation::PSID;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Aashellmenufilename {
    pub cb_total: i16,
    pub rgb_reserved: [u8; 12],
    pub sz_file_name: [u8; 1],
}
impl Aashellmenufilename {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::AASHELLMENUFILENAME {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::AASHELLMENUFILENAME) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
//  Not generated due to containing a void type
//  #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Aashellmenuitem<'a> {
//      pub lp_reserved1: &'a mut todo_void,
//      pub i_reserved: i32,
//      pub ui_reserved: u32,
//      pub lp_name: &'a mut Aashellmenufilename,
//      pub psz: Cow<'a, [u16]>,
//  }
//  impl Aashellmenuitem {
//      fn to_win32(&self) -> windows_sys::Win32::UI::Shell::AASHELLMENUITEM {
//          let Self { lp_reserved1, i_reserved, ui_reserved, lp_name, psz } = self;
//          let lpReserved1 = unsafe { &mut *(lp_reserved1 as *mut _ as *mut _) };
//          let iReserved = *i_reserved;
//          let uiReserved = *ui_reserved;
//          let lpName = unsafe { &mut *(lp_name as *mut _ as *mut _) };
//          assert_eq!(psz.last(), Some(0));
//          let psz = psz.as_ptr();
//          windows_sys::Win32::UI::Shell::AASHELLMENUITEM { lpReserved1, iReserved, uiReserved, lpName, psz }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::AASHELLMENUITEM) -> Self {
//          let windows_sys::Win32::UI::Shell::AASHELLMENUITEM { lpReserved1, iReserved, uiReserved, lpName, psz } = win32;
//          let lp_reserved1 = unsafe { &mut *(lpReserved1 as *mut _ as *mut _) };
//          let i_reserved = iReserved;
//          let ui_reserved = uiReserved;
//          let lp_name = unsafe { &mut *(lpName as *mut _ as *mut _) };
//          let slen = unsafe { wide_strlen(psz as *const u16) };
//          let psz = unsafe { slice::from_raw_parts(psz, slen + 1) };
//          let psz = psz.to_vec();
//          Self { lp_reserved1, i_reserved, ui_reserved, lp_name, psz }
//      }
//  }
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Abc {
    pub abc_a: i32,
    pub abc_b: u32,
    pub abc_c: i32,
}
impl Abc {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::ABC {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::ABC) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Abcfloat {
    pub abcf_a: f32,
    pub abcf_b: f32,
    pub abcf_c: f32,
}
impl Abcfloat {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::ABCFLOAT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::ABCFLOAT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Accel {
    pub f_virt: u8,
    pub key: u16,
    pub cmd: u16,
}
impl Accel {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::ACCEL {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::ACCEL) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const ACEO_NONE: i32 = 0x0;
pub const ACEO_MOSTRECENTFIRST: i32 = 0x1;
pub const ACEO_FIRSTUNUSED: i32 = 0x10000;
pub const AO_NONE: i32 = 0x0;
pub const AO_DESIGNMODE: i32 = 0x1;
pub const AO_NOERRORUI: i32 = 0x2;
pub const AO_NOSPLASHSCREEN: i32 = 0x4;
pub const AO_PRELAUNCH: i32 = 0x2000000;
pub const ADE_NONE: i32 = 0x0;
pub const ADE_LEFT: i32 = 0x1;
pub const ADE_RIGHT: i32 = 0x2;
pub const AHE_DESKTOP: i32 = 0x0;
pub const AHE_IMMERSIVE: i32 = 0x1;
pub const AHTYPE_UNDEFINED: i32 = 0x0;
pub const AHTYPE_USER_APPLICATION: i32 = 0x8;
pub const AHTYPE_ANY_APPLICATION: i32 = 0x10;
pub const AHTYPE_MACHINEDEFAULT: i32 = 0x20;
pub const AHTYPE_PROGID: i32 = 0x40;
pub const AHTYPE_APPLICATION: i32 = 0x80;
pub const AHTYPE_CLASS_APPLICATION: i32 = 0x100;
pub const AHTYPE_ANY_PROGID: i32 = 0x200;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Alttabinfo {
    pub cb_size: u32,
    pub c_items: i32,
    pub c_columns: i32,
    pub c_rows: i32,
    pub i_col_focus: i32,
    pub i_row_focus: i32,
    pub cx_item: i32,
    pub cy_item: i32,
    pub pt_start: Point,
}
impl Alttabinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::ALTTABINFO {
        let Self { cb_size, c_items, c_columns, c_rows, i_col_focus, i_row_focus, cx_item, cy_item, pt_start } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::ALTTABINFO>() as _;
        let cItems = *c_items;
        let cColumns = *c_columns;
        let cRows = *c_rows;
        let iColFocus = *i_col_focus;
        let iRowFocus = *i_row_focus;
        let cxItem = *cx_item;
        let cyItem = *cy_item;
        let ptStart = pt_start.to_win32();
        windows_sys::Win32::UI::WindowsAndMessaging::ALTTABINFO { cbSize, cItems, cColumns, cRows, iColFocus, iRowFocus, cxItem, cyItem, ptStart }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::ALTTABINFO) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::ALTTABINFO { cbSize, cItems, cColumns, cRows, iColFocus, iRowFocus, cxItem, cyItem, ptStart } = win32;
        let cb_size = cbSize;
        let c_items = cItems;
        let c_columns = cColumns;
        let c_rows = cRows;
        let i_col_focus = iColFocus;
        let i_row_focus = iRowFocus;
        let cx_item = cxItem;
        let cy_item = cyItem;
        let pt_start = unsafe { POINT::from_win32(ptStart) };
        Self { cb_size, c_items, c_columns, c_rows, i_col_focus, i_row_focus, cx_item, cy_item, pt_start }
    }
}
pub const AW_ACTIVATE: u32 = 0x20000;
pub const AW_BLEND: u32 = 0x80000;
pub const AW_CENTER: u32 = 0x10;
pub const AW_HIDE: u32 = 0x10000;
pub const AW_HOR_POSITIVE: u32 = 0x1;
pub const AW_HOR_NEGATIVE: u32 = 0x2;
pub const AW_SLIDE: u32 = 0x40000;
pub const AW_VER_POSITIVE: u32 = 0x4;
pub const AW_VER_NEGATIVE: u32 = 0x8;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Animationinfo {
    pub cb_size: u32,
    pub i_min_animate: i32,
}
impl Animationinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::ANIMATIONINFO {
        let Self { cb_size, i_min_animate } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::ANIMATIONINFO>() as _;
        let iMinAnimate = *i_min_animate;
        windows_sys::Win32::UI::WindowsAndMessaging::ANIMATIONINFO { cbSize, iMinAnimate }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::ANIMATIONINFO) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::ANIMATIONINFO { cbSize, iMinAnimate } = win32;
        let cb_size = cbSize;
        let i_min_animate = iMinAnimate;
        Self { cb_size, i_min_animate }
    }
}
pub const APPACTION_INSTALL: i32 = 0x1;
pub const APPACTION_UNINSTALL: i32 = 0x2;
pub const APPACTION_MODIFY: i32 = 0x4;
pub const APPACTION_REPAIR: i32 = 0x8;
pub const APPACTION_UPGRADE: i32 = 0x10;
pub const APPACTION_CANGETSIZE: i32 = 0x20;
pub const APPACTION_MODIFYREMOVE: i32 = 0x80;
pub const APPACTION_ADDLATER: i32 = 0x100;
pub const APPACTION_UNSCHEDULE: i32 = 0x200;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Appbardata {
    pub cb_size: u32,
    pub h_wnd: Option<Hwnd>,
    pub u_callback_message: u32,
    pub u_edge: u32,
    pub rc: Rect,
    pub l_param: Lparam,
}
impl Appbardata {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::APPBARDATA {
        let Self { cb_size, h_wnd, u_callback_message, u_edge, rc, l_param } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::APPBARDATA>() as _;
        let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
        let uCallbackMessage = *u_callback_message;
        let uEdge = *u_edge;
        let rc = rc.to_win32();
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::Shell::APPBARDATA { cbSize, hWnd, uCallbackMessage, uEdge, rc, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::APPBARDATA) -> Self {
        let windows_sys::Win32::UI::Shell::APPBARDATA { cbSize, hWnd, uCallbackMessage, uEdge, rc, lParam } = win32;
        let cb_size = cbSize;
        let h_wnd = unsafe { Hwnd::new_optional(hWnd) };
        let u_callback_message = uCallbackMessage;
        let u_edge = uEdge;
        let rc = unsafe { RECT::from_win32(rc) };
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { cb_size, h_wnd, u_callback_message, u_edge, rc, l_param }
    }
}
pub const ADLT_RECENT: i32 = 0x0;
pub const ADLT_FREQUENT: i32 = 0x1;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Appinfodata<'a> {
    pub cb_size: u32,
    pub dw_mask: u32,
    pub psz_display_name: Cow<'a, [u16]>,
    pub psz_version: Cow<'a, [u16]>,
    pub psz_publisher: Cow<'a, [u16]>,
    pub psz_product_id: Cow<'a, [u16]>,
    pub psz_registered_owner: Cow<'a, [u16]>,
    pub psz_registered_company: Cow<'a, [u16]>,
    pub psz_language: Cow<'a, [u16]>,
    pub psz_support_url: Cow<'a, [u16]>,
    pub psz_support_telephone: Cow<'a, [u16]>,
    pub psz_help_link: Cow<'a, [u16]>,
    pub psz_install_location: Cow<'a, [u16]>,
    pub psz_install_source: Cow<'a, [u16]>,
    pub psz_install_date: Cow<'a, [u16]>,
    pub psz_contact: Cow<'a, [u16]>,
    pub psz_comments: Cow<'a, [u16]>,
    pub psz_image: Cow<'a, [u16]>,
    pub psz_readme_url: Cow<'a, [u16]>,
    pub psz_update_info_url: Cow<'a, [u16]>,
}
impl Appinfodata {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::APPINFODATA {
        let Self { cb_size, dw_mask, psz_display_name, psz_version, psz_publisher, psz_product_id, psz_registered_owner, psz_registered_company, psz_language, psz_support_url, psz_support_telephone, psz_help_link, psz_install_location, psz_install_source, psz_install_date, psz_contact, psz_comments, psz_image, psz_readme_url, psz_update_info_url } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::APPINFODATA>() as _;
        let dwMask = *dw_mask;
        assert_eq!(psz_display_name.last(), Some(0));
        let pszDisplayName = psz_display_name.as_ptr();
        assert_eq!(psz_version.last(), Some(0));
        let pszVersion = psz_version.as_ptr();
        assert_eq!(psz_publisher.last(), Some(0));
        let pszPublisher = psz_publisher.as_ptr();
        assert_eq!(psz_product_id.last(), Some(0));
        let pszProductID = psz_product_id.as_ptr();
        assert_eq!(psz_registered_owner.last(), Some(0));
        let pszRegisteredOwner = psz_registered_owner.as_ptr();
        assert_eq!(psz_registered_company.last(), Some(0));
        let pszRegisteredCompany = psz_registered_company.as_ptr();
        assert_eq!(psz_language.last(), Some(0));
        let pszLanguage = psz_language.as_ptr();
        assert_eq!(psz_support_url.last(), Some(0));
        let pszSupportUrl = psz_support_url.as_ptr();
        assert_eq!(psz_support_telephone.last(), Some(0));
        let pszSupportTelephone = psz_support_telephone.as_ptr();
        assert_eq!(psz_help_link.last(), Some(0));
        let pszHelpLink = psz_help_link.as_ptr();
        assert_eq!(psz_install_location.last(), Some(0));
        let pszInstallLocation = psz_install_location.as_ptr();
        assert_eq!(psz_install_source.last(), Some(0));
        let pszInstallSource = psz_install_source.as_ptr();
        assert_eq!(psz_install_date.last(), Some(0));
        let pszInstallDate = psz_install_date.as_ptr();
        assert_eq!(psz_contact.last(), Some(0));
        let pszContact = psz_contact.as_ptr();
        assert_eq!(psz_comments.last(), Some(0));
        let pszComments = psz_comments.as_ptr();
        assert_eq!(psz_image.last(), Some(0));
        let pszImage = psz_image.as_ptr();
        assert_eq!(psz_readme_url.last(), Some(0));
        let pszReadmeUrl = psz_readme_url.as_ptr();
        assert_eq!(psz_update_info_url.last(), Some(0));
        let pszUpdateInfoUrl = psz_update_info_url.as_ptr();
        windows_sys::Win32::UI::Shell::APPINFODATA { cbSize, dwMask, pszDisplayName, pszVersion, pszPublisher, pszProductID, pszRegisteredOwner, pszRegisteredCompany, pszLanguage, pszSupportUrl, pszSupportTelephone, pszHelpLink, pszInstallLocation, pszInstallSource, pszInstallDate, pszContact, pszComments, pszImage, pszReadmeUrl, pszUpdateInfoUrl }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::APPINFODATA) -> Self {
        let windows_sys::Win32::UI::Shell::APPINFODATA { cbSize, dwMask, pszDisplayName, pszVersion, pszPublisher, pszProductID, pszRegisteredOwner, pszRegisteredCompany, pszLanguage, pszSupportUrl, pszSupportTelephone, pszHelpLink, pszInstallLocation, pszInstallSource, pszInstallDate, pszContact, pszComments, pszImage, pszReadmeUrl, pszUpdateInfoUrl } = win32;
        let cb_size = cbSize;
        let dw_mask = dwMask;
        let slen = unsafe { wide_strlen(pszDisplayName as *const u16) };
        let pszDisplayName = unsafe { slice::from_raw_parts(pszDisplayName, slen + 1) };
        let psz_display_name = pszDisplayName.to_vec();
        let slen = unsafe { wide_strlen(pszVersion as *const u16) };
        let pszVersion = unsafe { slice::from_raw_parts(pszVersion, slen + 1) };
        let psz_version = pszVersion.to_vec();
        let slen = unsafe { wide_strlen(pszPublisher as *const u16) };
        let pszPublisher = unsafe { slice::from_raw_parts(pszPublisher, slen + 1) };
        let psz_publisher = pszPublisher.to_vec();
        let slen = unsafe { wide_strlen(pszProductID as *const u16) };
        let pszProductID = unsafe { slice::from_raw_parts(pszProductID, slen + 1) };
        let psz_product_id = pszProductID.to_vec();
        let slen = unsafe { wide_strlen(pszRegisteredOwner as *const u16) };
        let pszRegisteredOwner = unsafe { slice::from_raw_parts(pszRegisteredOwner, slen + 1) };
        let psz_registered_owner = pszRegisteredOwner.to_vec();
        let slen = unsafe { wide_strlen(pszRegisteredCompany as *const u16) };
        let pszRegisteredCompany = unsafe { slice::from_raw_parts(pszRegisteredCompany, slen + 1) };
        let psz_registered_company = pszRegisteredCompany.to_vec();
        let slen = unsafe { wide_strlen(pszLanguage as *const u16) };
        let pszLanguage = unsafe { slice::from_raw_parts(pszLanguage, slen + 1) };
        let psz_language = pszLanguage.to_vec();
        let slen = unsafe { wide_strlen(pszSupportUrl as *const u16) };
        let pszSupportUrl = unsafe { slice::from_raw_parts(pszSupportUrl, slen + 1) };
        let psz_support_url = pszSupportUrl.to_vec();
        let slen = unsafe { wide_strlen(pszSupportTelephone as *const u16) };
        let pszSupportTelephone = unsafe { slice::from_raw_parts(pszSupportTelephone, slen + 1) };
        let psz_support_telephone = pszSupportTelephone.to_vec();
        let slen = unsafe { wide_strlen(pszHelpLink as *const u16) };
        let pszHelpLink = unsafe { slice::from_raw_parts(pszHelpLink, slen + 1) };
        let psz_help_link = pszHelpLink.to_vec();
        let slen = unsafe { wide_strlen(pszInstallLocation as *const u16) };
        let pszInstallLocation = unsafe { slice::from_raw_parts(pszInstallLocation, slen + 1) };
        let psz_install_location = pszInstallLocation.to_vec();
        let slen = unsafe { wide_strlen(pszInstallSource as *const u16) };
        let pszInstallSource = unsafe { slice::from_raw_parts(pszInstallSource, slen + 1) };
        let psz_install_source = pszInstallSource.to_vec();
        let slen = unsafe { wide_strlen(pszInstallDate as *const u16) };
        let pszInstallDate = unsafe { slice::from_raw_parts(pszInstallDate, slen + 1) };
        let psz_install_date = pszInstallDate.to_vec();
        let slen = unsafe { wide_strlen(pszContact as *const u16) };
        let pszContact = unsafe { slice::from_raw_parts(pszContact, slen + 1) };
        let psz_contact = pszContact.to_vec();
        let slen = unsafe { wide_strlen(pszComments as *const u16) };
        let pszComments = unsafe { slice::from_raw_parts(pszComments, slen + 1) };
        let psz_comments = pszComments.to_vec();
        let slen = unsafe { wide_strlen(pszImage as *const u16) };
        let pszImage = unsafe { slice::from_raw_parts(pszImage, slen + 1) };
        let psz_image = pszImage.to_vec();
        let slen = unsafe { wide_strlen(pszReadmeUrl as *const u16) };
        let pszReadmeUrl = unsafe { slice::from_raw_parts(pszReadmeUrl, slen + 1) };
        let psz_readme_url = pszReadmeUrl.to_vec();
        let slen = unsafe { wide_strlen(pszUpdateInfoUrl as *const u16) };
        let pszUpdateInfoUrl = unsafe { slice::from_raw_parts(pszUpdateInfoUrl, slen + 1) };
        let psz_update_info_url = pszUpdateInfoUrl.to_vec();
        Self { cb_size, dw_mask, psz_display_name, psz_version, psz_publisher, psz_product_id, psz_registered_owner, psz_registered_company, psz_language, psz_support_url, psz_support_telephone, psz_help_link, psz_install_location, psz_install_source, psz_install_date, psz_contact, psz_comments, psz_image, psz_readme_url, psz_update_info_url }
    }
}
pub const AIM_DISPLAYNAME: i32 = 0x1;
pub const AIM_VERSION: i32 = 0x2;
pub const AIM_PUBLISHER: i32 = 0x4;
pub const AIM_PRODUCTID: i32 = 0x8;
pub const AIM_REGISTEREDOWNER: i32 = 0x10;
pub const AIM_REGISTEREDCOMPANY: i32 = 0x20;
pub const AIM_LANGUAGE: i32 = 0x40;
pub const AIM_SUPPORTURL: i32 = 0x80;
pub const AIM_SUPPORTTELEPHONE: i32 = 0x100;
pub const AIM_HELPLINK: i32 = 0x200;
pub const AIM_INSTALLLOCATION: i32 = 0x400;
pub const AIM_INSTALLSOURCE: i32 = 0x800;
pub const AIM_INSTALLDATE: i32 = 0x1000;
pub const AIM_CONTACT: i32 = 0x4000;
pub const AIM_COMMENTS: i32 = 0x8000;
pub const AIM_IMAGE: i32 = 0x20000;
pub const AIM_READMEURL: i32 = 0x40000;
pub const AIM_UPDATEINFOURL: i32 = 0x80000;
pub const AVMW_DEFAULT: i32 = 0x0;
pub const AVMW_320: i32 = 0x1;
pub const AVMW_500: i32 = 0x2;
pub const AVO_LANDSCAPE: i32 = 0x0;
pub const AVO_PORTRAIT: i32 = 0x1;
pub const AVSP_DEFAULT: i32 = 0x0;
pub const AVSP_USE_LESS: i32 = 0x1;
pub const AVSP_USE_HALF: i32 = 0x2;
pub const AVSP_USE_MORE: i32 = 0x3;
pub const AVSP_USE_MINIMUM: i32 = 0x4;
pub const AVSP_USE_NONE: i32 = 0x5;
pub const AVSP_CUSTOM: i32 = 0x6;
pub const AVS_FULLSCREEN_LANDSCAPE: i32 = 0x0;
pub const AVS_FILLED: i32 = 0x1;
pub const AVS_SNAPPED: i32 = 0x2;
pub const AVS_FULLSCREEN_PORTRAIT: i32 = 0x3;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct AppLocalDeviceId {
    pub value: [u8; 32],
}
impl AppLocalDeviceId {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::APP_LOCAL_DEVICE_ID {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::APP_LOCAL_DEVICE_ID) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const AD_COUNTERCLOCKWISE: u32 = 0x1;
pub const AD_CLOCKWISE: u32 = 0x2;
pub const ASSOCCLASS_SHELL_KEY: i32 = 0x0;
pub const ASSOCCLASS_PROGID_KEY: i32 = 0x1;
pub const ASSOCCLASS_PROGID_STR: i32 = 0x2;
pub const ASSOCCLASS_CLSID_KEY: i32 = 0x3;
pub const ASSOCCLASS_CLSID_STR: i32 = 0x4;
pub const ASSOCCLASS_APP_KEY: i32 = 0x5;
pub const ASSOCCLASS_APP_STR: i32 = 0x6;
pub const ASSOCCLASS_SYSTEM_STR: i32 = 0x7;
pub const ASSOCCLASS_FOLDER: i32 = 0x8;
pub const ASSOCCLASS_STAR: i32 = 0x9;
pub const ASSOCCLASS_FIXED_PROGID_STR: i32 = 0xA;
pub const ASSOCCLASS_PROTOCOL_STR: i32 = 0xB;
pub const ASSOCDATA_MSIDESCRIPTOR: i32 = 0x1;
pub const ASSOCDATA_NOACTIVATEHANDLER: i32 = 0x2;
pub const ASSOCDATA_UNUSED1: i32 = 0x3;
pub const ASSOCDATA_HASPERUSERASSOC: i32 = 0x4;
pub const ASSOCDATA_EDITFLAGS: i32 = 0x5;
pub const ASSOCDATA_VALUE: i32 = 0x6;
pub const ASSOCDATA_MAX: i32 = 0x7;
pub const ASSOCENUM_NONE: i32 = 0x0;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Associationelement<'a> {
    pub ac: i32,
    pub hk_class: Option<Hkey>,
    pub psz_class: Cow<'a, [u16]>,
}
impl Associationelement {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::ASSOCIATIONELEMENT {
        let Self { ac, hk_class, psz_class } = self;
        let ac = ac;
        let hkClass = hk_class.map_or(0, Hkey::into_raw);
        assert_eq!(psz_class.last(), Some(0));
        let pszClass = psz_class.as_ptr();
        windows_sys::Win32::UI::Shell::ASSOCIATIONELEMENT { ac, hkClass, pszClass }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::ASSOCIATIONELEMENT) -> Self {
        let windows_sys::Win32::UI::Shell::ASSOCIATIONELEMENT { ac, hkClass, pszClass } = win32;
        let ac = ac;
        let hk_class = unsafe { Hkey::new_optional(hkClass) };
        let slen = unsafe { wide_strlen(pszClass as *const u16) };
        let pszClass = unsafe { slice::from_raw_parts(pszClass, slen + 1) };
        let psz_class = pszClass.to_vec();
        Self { ac, hk_class, psz_class }
    }
}
pub const AL_MACHINE: i32 = 0x0;
pub const AL_EFFECTIVE: i32 = 0x1;
pub const AL_USER: i32 = 0x2;
pub const AT_FILEEXTENSION: i32 = 0x0;
pub const AT_URLPROTOCOL: i32 = 0x1;
pub const AT_STARTMENUCLIENT: i32 = 0x2;
pub const AT_MIMETYPE: i32 = 0x3;
pub const ASSOCKEY_SHELLEXECCLASS: i32 = 0x1;
pub const ASSOCKEY_APP: i32 = 0x2;
pub const ASSOCKEY_CLASS: i32 = 0x3;
pub const ASSOCKEY_BASECLASS: i32 = 0x4;
pub const ASSOCKEY_MAX: i32 = 0x5;
pub const ASSOCSTR_COMMAND: i32 = 0x1;
pub const ASSOCSTR_EXECUTABLE: i32 = 0x2;
pub const ASSOCSTR_FRIENDLYDOCNAME: i32 = 0x3;
pub const ASSOCSTR_FRIENDLYAPPNAME: i32 = 0x4;
pub const ASSOCSTR_NOOPEN: i32 = 0x5;
pub const ASSOCSTR_SHELLNEWVALUE: i32 = 0x6;
pub const ASSOCSTR_DDECOMMAND: i32 = 0x7;
pub const ASSOCSTR_DDEIFEXEC: i32 = 0x8;
pub const ASSOCSTR_DDEAPPLICATION: i32 = 0x9;
pub const ASSOCSTR_DDETOPIC: i32 = 0xA;
pub const ASSOCSTR_INFOTIP: i32 = 0xB;
pub const ASSOCSTR_QUICKTIP: i32 = 0xC;
pub const ASSOCSTR_TILEINFO: i32 = 0xD;
pub const ASSOCSTR_CONTENTTYPE: i32 = 0xE;
pub const ASSOCSTR_DEFAULTICON: i32 = 0xF;
pub const ASSOCSTR_SHELLEXTENSION: i32 = 0x10;
pub const ASSOCSTR_DROPTARGET: i32 = 0x11;
pub const ASSOCSTR_DELEGATEEXECUTE: i32 = 0x12;
pub const ASSOCSTR_SUPPORTED_URI_PROTOCOLS: i32 = 0x13;
pub const ASSOCSTR_PROGID: i32 = 0x14;
pub const ASSOCSTR_APPID: i32 = 0x15;
pub const ASSOCSTR_APPPUBLISHER: i32 = 0x16;
pub const ASSOCSTR_APPICONREFERENCE: i32 = 0x17;
pub const ASSOCSTR_MAX: i32 = 0x18;
pub const ASSOC_FILTER_NONE: i32 = 0x0;
pub const ASSOC_FILTER_RECOMMENDED: i32 = 0x1;
pub const ATTACHMENT_ACTION_CANCEL: i32 = 0x0;
pub const ATTACHMENT_ACTION_SAVE: i32 = 0x1;
pub const ATTACHMENT_ACTION_EXEC: i32 = 0x2;
pub const ATTACHMENT_PROMPT_NONE: i32 = 0x0;
pub const ATTACHMENT_PROMPT_SAVE: i32 = 0x1;
pub const ATTACHMENT_PROMPT_EXEC: i32 = 0x2;
pub const ATTACHMENT_PROMPT_EXEC_OR_SAVE: i32 = 0x3;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Audiodescription {
    pub cb_size: u32,
    pub enabled: BOOL,
    pub locale: u32,
}
impl Audiodescription {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::AUDIODESCRIPTION {
        let Self { cb_size, enabled, locale } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::AUDIODESCRIPTION>() as _;
        let Enabled = enabled;
        let Locale = *locale;
        windows_sys::Win32::UI::WindowsAndMessaging::AUDIODESCRIPTION { cbSize, Enabled, Locale }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::AUDIODESCRIPTION) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::AUDIODESCRIPTION { cbSize, Enabled, Locale } = win32;
        let cb_size = cbSize;
        let enabled = Enabled;
        let locale = Locale;
        Self { cb_size, enabled, locale }
    }
}
pub const ACLO_NONE: i32 = 0x0;
pub const ACLO_CURRENTDIR: i32 = 0x1;
pub const ACLO_MYCOMPUTER: i32 = 0x2;
pub const ACLO_DESKTOP: i32 = 0x4;
pub const ACLO_FAVORITES: i32 = 0x8;
pub const ACLO_FILESYSONLY: i32 = 0x10;
pub const ACLO_FILESYSDIRS: i32 = 0x20;
pub const ACLO_VIRTUALNAMESPACE: i32 = 0x40;
pub const ACO_NONE: i32 = 0x0;
pub const ACO_AUTOSUGGEST: i32 = 0x1;
pub const ACO_AUTOAPPEND: i32 = 0x2;
pub const ACO_SEARCH: i32 = 0x4;
pub const ACO_FILTERPREFIXES: i32 = 0x8;
pub const ACO_USETAB: i32 = 0x10;
pub const ACO_UPDOWNKEYDROPSLIST: i32 = 0x20;
pub const ACO_RTLREADING: i32 = 0x40;
pub const ACO_WORD_FILTER: i32 = 0x80;
pub const ACO_NOPREFIXFILTERING: i32 = 0x100;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct AutoScrollData {
    pub i_next_sample: i32,
    pub dw_last_scroll: u32,
    pub b_full: BOOL,
    pub pts: [Point; 3],
    pub dw_times: [u32; 3],
}
impl AutoScrollData {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::AUTO_SCROLL_DATA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::AUTO_SCROLL_DATA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Axeslista {
    pub axl_reserved: u32,
    pub axl_num_axes: u32,
    pub axl_axis_info: [Axisinfoa; 16],
}
impl Axeslista {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::AXESLISTA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::AXESLISTA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Axeslistw {
    pub axl_reserved: u32,
    pub axl_num_axes: u32,
    pub axl_axis_info: [Axisinfow; 16],
}
impl Axeslistw {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::AXESLISTW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::AXESLISTW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Axisinfoa {
    pub ax_min_value: i32,
    pub ax_max_value: i32,
    pub ax_axis_name: [u8; 16],
}
impl Axisinfoa {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::AXISINFOA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::AXISINFOA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Axisinfow {
    pub ax_min_value: i32,
    pub ax_max_value: i32,
    pub ax_axis_name: [u8; 16],
}
impl Axisinfow {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::AXISINFOW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::AXISINFOW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const OPAQUE: u32 = 0x2;
pub const TRANSPARENT: u32 = 0x1;
pub const BSID_BANDADDED: i32 = 0x0;
pub const BSID_BANDREMOVED: i32 = 0x1;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Bandsiteinfo {
    pub dw_mask: u32,
    pub dw_state: u32,
    pub dw_style: u32,
}
impl Bandsiteinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::BANDSITEINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::BANDSITEINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct BannerNotification<'a> {
    pub event: i32,
    pub provider_identity: Cow<'a, [u16]>,
    pub content_id: Cow<'a, [u16]>,
}
impl BannerNotification {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::BANNER_NOTIFICATION {
        let Self { event, provider_identity, content_id } = self;
        let event = event;
        assert_eq!(provider_identity.last(), Some(0));
        let providerIdentity = provider_identity.as_ptr();
        assert_eq!(content_id.last(), Some(0));
        let contentId = content_id.as_ptr();
        windows_sys::Win32::UI::Shell::BANNER_NOTIFICATION { event, providerIdentity, contentId }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::BANNER_NOTIFICATION) -> Self {
        let windows_sys::Win32::UI::Shell::BANNER_NOTIFICATION { event, providerIdentity, contentId } = win32;
        let event = event;
        let slen = unsafe { wide_strlen(providerIdentity as *const u16) };
        let providerIdentity = unsafe { slice::from_raw_parts(providerIdentity, slen + 1) };
        let provider_identity = providerIdentity.to_vec();
        let slen = unsafe { wide_strlen(contentId as *const u16) };
        let contentId = unsafe { slice::from_raw_parts(contentId, slen + 1) };
        let content_id = contentId.to_vec();
        Self { event, provider_identity, content_id }
    }
}
pub const BNE_RENDERED: i32 = 0x0;
pub const BNE_HOVERED: i32 = 0x1;
pub const BNE_CLOSED: i32 = 0x2;
pub const BNE_DISMISSED: i32 = 0x3;
pub const BNE_BUTTON1_CLICKED: i32 = 0x4;
pub const BNE_BUTTON2_CLICKED: i32 = 0x5;
pub const BT_IMAGEFILE: i32 = 0x0;
pub const BT_BORDERFILL: i32 = 0x1;
pub const BT_NONE: i32 = 0x2;
//  Not generated due to containing a void type
//  #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Bitmap<'a> {
//      pub bm_type: i32,
//      pub bm_width: i32,
//      pub bm_height: i32,
//      pub bm_width_bytes: i32,
//      pub bm_planes: u16,
//      pub bm_bits_pixel: u16,
//      pub bm_bits: &'a mut todo_void,
//  }
//  impl Bitmap {
//      fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::BITMAP {
//          let Self { bm_type, bm_width, bm_height, bm_width_bytes, bm_planes, bm_bits_pixel, bm_bits } = self;
//          let bmType = *bm_type;
//          let bmWidth = *bm_width;
//          let bmHeight = *bm_height;
//          let bmWidthBytes = *bm_width_bytes;
//          let bmPlanes = *bm_planes;
//          let bmBitsPixel = *bm_bits_pixel;
//          let bmBits = unsafe { &mut *(bm_bits as *mut _ as *mut _) };
//          windows_sys::Win32::Graphics::Gdi::BITMAP { bmType, bmWidth, bmHeight, bmWidthBytes, bmPlanes, bmBitsPixel, bmBits }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::BITMAP) -> Self {
//          let windows_sys::Win32::Graphics::Gdi::BITMAP { bmType, bmWidth, bmHeight, bmWidthBytes, bmPlanes, bmBitsPixel, bmBits } = win32;
//          let bm_type = bmType;
//          let bm_width = bmWidth;
//          let bm_height = bmHeight;
//          let bm_width_bytes = bmWidthBytes;
//          let bm_planes = bmPlanes;
//          let bm_bits_pixel = bmBitsPixel;
//          let bm_bits = unsafe { &mut *(bmBits as *mut _ as *mut _) };
//          Self { bm_type, bm_width, bm_height, bm_width_bytes, bm_planes, bm_bits_pixel, bm_bits }
//      }
//  }
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Bitmapcoreheader {
    pub bc_size: u32,
    pub bc_width: u16,
    pub bc_height: u16,
    pub bc_planes: u16,
    pub bc_bit_count: u16,
}
impl Bitmapcoreheader {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::BITMAPCOREHEADER {
        let Self { bc_size, bc_width, bc_height, bc_planes, bc_bit_count } = self;
        let bcSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::BITMAPCOREHEADER>() as _;
        let bcWidth = *bc_width;
        let bcHeight = *bc_height;
        let bcPlanes = *bc_planes;
        let bcBitCount = *bc_bit_count;
        windows_sys::Win32::Graphics::Gdi::BITMAPCOREHEADER { bcSize, bcWidth, bcHeight, bcPlanes, bcBitCount }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::BITMAPCOREHEADER) -> Self {
        let windows_sys::Win32::Graphics::Gdi::BITMAPCOREHEADER { bcSize, bcWidth, bcHeight, bcPlanes, bcBitCount } = win32;
        let bc_size = bcSize;
        let bc_width = bcWidth;
        let bc_height = bcHeight;
        let bc_planes = bcPlanes;
        let bc_bit_count = bcBitCount;
        Self { bc_size, bc_width, bc_height, bc_planes, bc_bit_count }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Bitmapcoreinfo {
    pub bmci_header: Bitmapcoreheader,
    pub bmci_colors: [Rgbtriple; 1],
}
impl Bitmapcoreinfo {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::BITMAPCOREINFO {
        let Self { bmci_header, bmci_colors } = self;
        let bmciHeader = bmci_header.to_win32();
        let bmciColors = [bmci_colors[0].to_win32()];
        windows_sys::Win32::Graphics::Gdi::BITMAPCOREINFO { bmciHeader, bmciColors }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::BITMAPCOREINFO) -> Self {
        let windows_sys::Win32::Graphics::Gdi::BITMAPCOREINFO { bmciHeader, bmciColors } = win32;
        let bmci_header = unsafe { BITMAPCOREHEADER::from_win32(bmciHeader) };
        let bmci_colors = [unsafe { RGBTRIPLE::from_win32(bmciColors[0]) }];
        Self { bmci_header, bmci_colors }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(2))]
pub struct Bitmapfileheader {
    pub bf_type: u16,
    pub bf_size: u32,
    pub bf_reserved1: u16,
    pub bf_reserved2: u16,
    pub bf_off_bits: u32,
}
impl Bitmapfileheader {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::BITMAPFILEHEADER {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::BITMAPFILEHEADER) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Bitmapinfo {
    pub bmi_header: Bitmapinfoheader,
    pub bmi_colors: [Rgbquad; 1],
}
impl Bitmapinfo {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::BITMAPINFO {
        let Self { bmi_header, bmi_colors } = self;
        let bmiHeader = bmi_header.to_win32();
        let bmiColors = [bmi_colors[0].to_win32()];
        windows_sys::Win32::Graphics::Gdi::BITMAPINFO { bmiHeader, bmiColors }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::BITMAPINFO) -> Self {
        let windows_sys::Win32::Graphics::Gdi::BITMAPINFO { bmiHeader, bmiColors } = win32;
        let bmi_header = unsafe { BITMAPINFOHEADER::from_win32(bmiHeader) };
        let bmi_colors = [unsafe { RGBQUAD::from_win32(bmiColors[0]) }];
        Self { bmi_header, bmi_colors }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Bitmapinfoheader {
    pub bi_size: u32,
    pub bi_width: i32,
    pub bi_height: i32,
    pub bi_planes: u16,
    pub bi_bit_count: u16,
    pub bi_compression: u32,
    pub bi_size_image: u32,
    pub bi_x_pels_per_meter: i32,
    pub bi_y_pels_per_meter: i32,
    pub bi_clr_used: u32,
    pub bi_clr_important: u32,
}
impl Bitmapinfoheader {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::BITMAPINFOHEADER {
        let Self { bi_size, bi_width, bi_height, bi_planes, bi_bit_count, bi_compression, bi_size_image, bi_x_pels_per_meter, bi_y_pels_per_meter, bi_clr_used, bi_clr_important } = self;
        let biSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::BITMAPINFOHEADER>() as _;
        let biWidth = *bi_width;
        let biHeight = *bi_height;
        let biPlanes = *bi_planes;
        let biBitCount = *bi_bit_count;
        let biCompression = *bi_compression;
        let biSizeImage = *bi_size_image;
        let biXPelsPerMeter = *bi_x_pels_per_meter;
        let biYPelsPerMeter = *bi_y_pels_per_meter;
        let biClrUsed = *bi_clr_used;
        let biClrImportant = *bi_clr_important;
        windows_sys::Win32::Graphics::Gdi::BITMAPINFOHEADER { biSize, biWidth, biHeight, biPlanes, biBitCount, biCompression, biSizeImage, biXPelsPerMeter, biYPelsPerMeter, biClrUsed, biClrImportant }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::BITMAPINFOHEADER) -> Self {
        let windows_sys::Win32::Graphics::Gdi::BITMAPINFOHEADER { biSize, biWidth, biHeight, biPlanes, biBitCount, biCompression, biSizeImage, biXPelsPerMeter, biYPelsPerMeter, biClrUsed, biClrImportant } = win32;
        let bi_size = biSize;
        let bi_width = biWidth;
        let bi_height = biHeight;
        let bi_planes = biPlanes;
        let bi_bit_count = biBitCount;
        let bi_compression = biCompression;
        let bi_size_image = biSizeImage;
        let bi_x_pels_per_meter = biXPelsPerMeter;
        let bi_y_pels_per_meter = biYPelsPerMeter;
        let bi_clr_used = biClrUsed;
        let bi_clr_important = biClrImportant;
        Self { bi_size, bi_width, bi_height, bi_planes, bi_bit_count, bi_compression, bi_size_image, bi_x_pels_per_meter, bi_y_pels_per_meter, bi_clr_used, bi_clr_important }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Bitmapv4header {
    pub b_v4_size: u32,
    pub b_v4_width: i32,
    pub b_v4_height: i32,
    pub b_v4_planes: u16,
    pub b_v4_bit_count: u16,
    pub b_v4v4_compression: u32,
    pub b_v4_size_image: u32,
    pub b_v4x_pels_per_meter: i32,
    pub b_v4y_pels_per_meter: i32,
    pub b_v4_clr_used: u32,
    pub b_v4_clr_important: u32,
    pub b_v4_red_mask: u32,
    pub b_v4_green_mask: u32,
    pub b_v4_blue_mask: u32,
    pub b_v4_alpha_mask: u32,
    pub b_v4cs_type: u32,
    pub b_v4_endpoints: Ciexyztriple,
    pub b_v4_gamma_red: u32,
    pub b_v4_gamma_green: u32,
    pub b_v4_gamma_blue: u32,
}
impl Bitmapv4header {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::BITMAPV4HEADER {
        let Self { b_v4_size, b_v4_width, b_v4_height, b_v4_planes, b_v4_bit_count, b_v4v4_compression, b_v4_size_image, b_v4x_pels_per_meter, b_v4y_pels_per_meter, b_v4_clr_used, b_v4_clr_important, b_v4_red_mask, b_v4_green_mask, b_v4_blue_mask, b_v4_alpha_mask, b_v4cs_type, b_v4_endpoints, b_v4_gamma_red, b_v4_gamma_green, b_v4_gamma_blue } = self;
        let bV4Size = mem::size_of::<windows_sys::Win32::Graphics::Gdi::BITMAPV4HEADER>() as _;
        let bV4Width = *b_v4_width;
        let bV4Height = *b_v4_height;
        let bV4Planes = *b_v4_planes;
        let bV4BitCount = *b_v4_bit_count;
        let bV4V4Compression = *b_v4v4_compression;
        let bV4SizeImage = *b_v4_size_image;
        let bV4XPelsPerMeter = *b_v4x_pels_per_meter;
        let bV4YPelsPerMeter = *b_v4y_pels_per_meter;
        let bV4ClrUsed = *b_v4_clr_used;
        let bV4ClrImportant = *b_v4_clr_important;
        let bV4RedMask = *b_v4_red_mask;
        let bV4GreenMask = *b_v4_green_mask;
        let bV4BlueMask = *b_v4_blue_mask;
        let bV4AlphaMask = *b_v4_alpha_mask;
        let bV4CSType = *b_v4cs_type;
        let bV4Endpoints = b_v4_endpoints.to_win32();
        let bV4GammaRed = *b_v4_gamma_red;
        let bV4GammaGreen = *b_v4_gamma_green;
        let bV4GammaBlue = *b_v4_gamma_blue;
        windows_sys::Win32::Graphics::Gdi::BITMAPV4HEADER { bV4Size, bV4Width, bV4Height, bV4Planes, bV4BitCount, bV4V4Compression, bV4SizeImage, bV4XPelsPerMeter, bV4YPelsPerMeter, bV4ClrUsed, bV4ClrImportant, bV4RedMask, bV4GreenMask, bV4BlueMask, bV4AlphaMask, bV4CSType, bV4Endpoints, bV4GammaRed, bV4GammaGreen, bV4GammaBlue }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::BITMAPV4HEADER) -> Self {
        let windows_sys::Win32::Graphics::Gdi::BITMAPV4HEADER { bV4Size, bV4Width, bV4Height, bV4Planes, bV4BitCount, bV4V4Compression, bV4SizeImage, bV4XPelsPerMeter, bV4YPelsPerMeter, bV4ClrUsed, bV4ClrImportant, bV4RedMask, bV4GreenMask, bV4BlueMask, bV4AlphaMask, bV4CSType, bV4Endpoints, bV4GammaRed, bV4GammaGreen, bV4GammaBlue } = win32;
        let b_v4_size = bV4Size;
        let b_v4_width = bV4Width;
        let b_v4_height = bV4Height;
        let b_v4_planes = bV4Planes;
        let b_v4_bit_count = bV4BitCount;
        let b_v4v4_compression = bV4V4Compression;
        let b_v4_size_image = bV4SizeImage;
        let b_v4x_pels_per_meter = bV4XPelsPerMeter;
        let b_v4y_pels_per_meter = bV4YPelsPerMeter;
        let b_v4_clr_used = bV4ClrUsed;
        let b_v4_clr_important = bV4ClrImportant;
        let b_v4_red_mask = bV4RedMask;
        let b_v4_green_mask = bV4GreenMask;
        let b_v4_blue_mask = bV4BlueMask;
        let b_v4_alpha_mask = bV4AlphaMask;
        let b_v4cs_type = bV4CSType;
        let b_v4_endpoints = unsafe { CIEXYZTRIPLE::from_win32(bV4Endpoints) };
        let b_v4_gamma_red = bV4GammaRed;
        let b_v4_gamma_green = bV4GammaGreen;
        let b_v4_gamma_blue = bV4GammaBlue;
        Self { b_v4_size, b_v4_width, b_v4_height, b_v4_planes, b_v4_bit_count, b_v4v4_compression, b_v4_size_image, b_v4x_pels_per_meter, b_v4y_pels_per_meter, b_v4_clr_used, b_v4_clr_important, b_v4_red_mask, b_v4_green_mask, b_v4_blue_mask, b_v4_alpha_mask, b_v4cs_type, b_v4_endpoints, b_v4_gamma_red, b_v4_gamma_green, b_v4_gamma_blue }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Bitmapv5header {
    pub b_v5_size: u32,
    pub b_v5_width: i32,
    pub b_v5_height: i32,
    pub b_v5_planes: u16,
    pub b_v5_bit_count: u16,
    pub b_v5_compression: u32,
    pub b_v5_size_image: u32,
    pub b_v5x_pels_per_meter: i32,
    pub b_v5y_pels_per_meter: i32,
    pub b_v5_clr_used: u32,
    pub b_v5_clr_important: u32,
    pub b_v5_red_mask: u32,
    pub b_v5_green_mask: u32,
    pub b_v5_blue_mask: u32,
    pub b_v5_alpha_mask: u32,
    pub b_v5cs_type: u32,
    pub b_v5_endpoints: Ciexyztriple,
    pub b_v5_gamma_red: u32,
    pub b_v5_gamma_green: u32,
    pub b_v5_gamma_blue: u32,
    pub b_v5_intent: u32,
    pub b_v5_profile_data: u32,
    pub b_v5_profile_size: u32,
    pub b_v5_reserved: u32,
}
impl Bitmapv5header {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::BITMAPV5HEADER {
        let Self { b_v5_size, b_v5_width, b_v5_height, b_v5_planes, b_v5_bit_count, b_v5_compression, b_v5_size_image, b_v5x_pels_per_meter, b_v5y_pels_per_meter, b_v5_clr_used, b_v5_clr_important, b_v5_red_mask, b_v5_green_mask, b_v5_blue_mask, b_v5_alpha_mask, b_v5cs_type, b_v5_endpoints, b_v5_gamma_red, b_v5_gamma_green, b_v5_gamma_blue, b_v5_intent, b_v5_profile_data, b_v5_profile_size, b_v5_reserved } = self;
        let bV5Size = mem::size_of::<windows_sys::Win32::Graphics::Gdi::BITMAPV5HEADER>() as _;
        let bV5Width = *b_v5_width;
        let bV5Height = *b_v5_height;
        let bV5Planes = *b_v5_planes;
        let bV5BitCount = *b_v5_bit_count;
        let bV5Compression = *b_v5_compression;
        let bV5SizeImage = *b_v5_size_image;
        let bV5XPelsPerMeter = *b_v5x_pels_per_meter;
        let bV5YPelsPerMeter = *b_v5y_pels_per_meter;
        let bV5ClrUsed = *b_v5_clr_used;
        let bV5ClrImportant = *b_v5_clr_important;
        let bV5RedMask = *b_v5_red_mask;
        let bV5GreenMask = *b_v5_green_mask;
        let bV5BlueMask = *b_v5_blue_mask;
        let bV5AlphaMask = *b_v5_alpha_mask;
        let bV5CSType = *b_v5cs_type;
        let bV5Endpoints = b_v5_endpoints.to_win32();
        let bV5GammaRed = *b_v5_gamma_red;
        let bV5GammaGreen = *b_v5_gamma_green;
        let bV5GammaBlue = *b_v5_gamma_blue;
        let bV5Intent = *b_v5_intent;
        let bV5ProfileData = *b_v5_profile_data;
        let bV5ProfileSize = *b_v5_profile_size;
        let bV5Reserved = *b_v5_reserved;
        windows_sys::Win32::Graphics::Gdi::BITMAPV5HEADER { bV5Size, bV5Width, bV5Height, bV5Planes, bV5BitCount, bV5Compression, bV5SizeImage, bV5XPelsPerMeter, bV5YPelsPerMeter, bV5ClrUsed, bV5ClrImportant, bV5RedMask, bV5GreenMask, bV5BlueMask, bV5AlphaMask, bV5CSType, bV5Endpoints, bV5GammaRed, bV5GammaGreen, bV5GammaBlue, bV5Intent, bV5ProfileData, bV5ProfileSize, bV5Reserved }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::BITMAPV5HEADER) -> Self {
        let windows_sys::Win32::Graphics::Gdi::BITMAPV5HEADER { bV5Size, bV5Width, bV5Height, bV5Planes, bV5BitCount, bV5Compression, bV5SizeImage, bV5XPelsPerMeter, bV5YPelsPerMeter, bV5ClrUsed, bV5ClrImportant, bV5RedMask, bV5GreenMask, bV5BlueMask, bV5AlphaMask, bV5CSType, bV5Endpoints, bV5GammaRed, bV5GammaGreen, bV5GammaBlue, bV5Intent, bV5ProfileData, bV5ProfileSize, bV5Reserved } = win32;
        let b_v5_size = bV5Size;
        let b_v5_width = bV5Width;
        let b_v5_height = bV5Height;
        let b_v5_planes = bV5Planes;
        let b_v5_bit_count = bV5BitCount;
        let b_v5_compression = bV5Compression;
        let b_v5_size_image = bV5SizeImage;
        let b_v5x_pels_per_meter = bV5XPelsPerMeter;
        let b_v5y_pels_per_meter = bV5YPelsPerMeter;
        let b_v5_clr_used = bV5ClrUsed;
        let b_v5_clr_important = bV5ClrImportant;
        let b_v5_red_mask = bV5RedMask;
        let b_v5_green_mask = bV5GreenMask;
        let b_v5_blue_mask = bV5BlueMask;
        let b_v5_alpha_mask = bV5AlphaMask;
        let b_v5cs_type = bV5CSType;
        let b_v5_endpoints = unsafe { CIEXYZTRIPLE::from_win32(bV5Endpoints) };
        let b_v5_gamma_red = bV5GammaRed;
        let b_v5_gamma_green = bV5GammaGreen;
        let b_v5_gamma_blue = bV5GammaBlue;
        let b_v5_intent = bV5Intent;
        let b_v5_profile_data = bV5ProfileData;
        let b_v5_profile_size = bV5ProfileSize;
        let b_v5_reserved = bV5Reserved;
        Self { b_v5_size, b_v5_width, b_v5_height, b_v5_planes, b_v5_bit_count, b_v5_compression, b_v5_size_image, b_v5x_pels_per_meter, b_v5y_pels_per_meter, b_v5_clr_used, b_v5_clr_important, b_v5_red_mask, b_v5_green_mask, b_v5_blue_mask, b_v5_alpha_mask, b_v5cs_type, b_v5_endpoints, b_v5_gamma_red, b_v5_gamma_green, b_v5_gamma_blue, b_v5_intent, b_v5_profile_data, b_v5_profile_size, b_v5_reserved }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Blendfunction {
    pub blend_op: u8,
    pub blend_flags: u8,
    pub source_constant_alpha: u8,
    pub alpha_format: u8,
}
impl Blendfunction {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::BLENDFUNCTION {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::BLENDFUNCTION) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const BNS_NORMAL: i32 = 0x0;
pub const BNS_BEGIN_NAVIGATE: i32 = 0x1;
pub const BNS_NAVIGATE: i32 = 0x2;
pub const BT_RECT: i32 = 0x0;
pub const BT_ROUNDRECT: i32 = 0x1;
pub const BT_ELLIPSE: i32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct BpAnimationparams {
    pub cb_size: u32,
    pub dw_flags: u32,
    pub style: i32,
    pub dw_duration: u32,
}
impl BpAnimationparams {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::BP_ANIMATIONPARAMS {
        let Self { cb_size, dw_flags, style, dw_duration } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::BP_ANIMATIONPARAMS>() as _;
        let dwFlags = *dw_flags;
        let style = style;
        let dwDuration = *dw_duration;
        windows_sys::Win32::UI::Controls::BP_ANIMATIONPARAMS { cbSize, dwFlags, style, dwDuration }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::BP_ANIMATIONPARAMS) -> Self {
        let windows_sys::Win32::UI::Controls::BP_ANIMATIONPARAMS { cbSize, dwFlags, style, dwDuration } = win32;
        let cb_size = cbSize;
        let dw_flags = dwFlags;
        let style = style;
        let dw_duration = dwDuration;
        Self { cb_size, dw_flags, style, dw_duration }
    }
}
pub const BPAS_NONE: i32 = 0x0;
pub const BPAS_LINEAR: i32 = 0x1;
pub const BPAS_CUBIC: i32 = 0x2;
pub const BPAS_SINE: i32 = 0x3;
pub const BPBF_COMPATIBLEBITMAP: i32 = 0x0;
pub const BPBF_DIB: i32 = 0x1;
pub const BPBF_TOPDOWNDIB: i32 = 0x2;
pub const BPBF_TOPDOWNMONODIB: i32 = 0x3;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct BpPaintparams<'a> {
    pub cb_size: u32,
    pub dw_flags: u32,
    pub prc_exclude: Cow<'a, Rect>,
    pub p_blend_function: Cow<'a, Blendfunction>,
}
impl BpPaintparams {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::BP_PAINTPARAMS {
        let Self { cb_size, dw_flags, prc_exclude, p_blend_function } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::BP_PAINTPARAMS>() as _;
        let dwFlags = dw_flags;
        let prcExclude = unsafe { &*(&**prc_exclude as *const _ as *const _) };
        let pBlendFunction = unsafe { &*(&**p_blend_function as *const _ as *const _) };
        windows_sys::Win32::UI::Controls::BP_PAINTPARAMS { cbSize, dwFlags, prcExclude, pBlendFunction }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::BP_PAINTPARAMS) -> Self {
        let windows_sys::Win32::UI::Controls::BP_PAINTPARAMS { cbSize, dwFlags, prcExclude, pBlendFunction } = win32;
        let cb_size = cbSize;
        let dw_flags = dwFlags;
        let prc_exclude = Cow::Borrowed(unsafe { &*(prcExclude as *const _ as *const _) });
        let p_blend_function = Cow::Borrowed(unsafe { &*(pBlendFunction as *const _ as *const _) });
        Self { cb_size, dw_flags, prc_exclude, p_blend_function }
    }
}
pub const BPPF_ERASE: u32 = 0x1;
pub const BPPF_NOCLIP: u32 = 0x2;
pub const BPPF_NONCLIENT: u32 = 0x4;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct ButtonImagelist {
    pub himl: Option<Himagelist>,
    pub margin: Rect,
    pub u_align: u32,
}
impl ButtonImagelist {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::BUTTON_IMAGELIST {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::BUTTON_IMAGELIST) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const BUTTON_IMAGELIST_ALIGN_LEFT: u32 = 0x0;
pub const BUTTON_IMAGELIST_ALIGN_RIGHT: u32 = 0x1;
pub const BUTTON_IMAGELIST_ALIGN_TOP: u32 = 0x2;
pub const BUTTON_IMAGELIST_ALIGN_BOTTOM: u32 = 0x3;
pub const BUTTON_IMAGELIST_ALIGN_CENTER: u32 = 0x4;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct ButtonSplitinfo {
    pub mask: u32,
    pub himl_glyph: Option<Himagelist>,
    pub u_split_style: u32,
    pub size: Size,
}
impl ButtonSplitinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::BUTTON_SPLITINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::BUTTON_SPLITINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const NAV_OPEN_IN_NEW_WINDOW: i32 = 0x1;
pub const NAV_NO_HISTORY: i32 = 0x2;
pub const NAV_NO_READ_FROM_CACHE: i32 = 0x4;
pub const NAV_NO_WRITE_TO_CACHE: i32 = 0x8;
pub const NAV_ALLOW_AUTOSEARCH: i32 = 0x10;
pub const NAV_BROWSER_BAR: i32 = 0x20;
pub const NAV_HYPERLINK: i32 = 0x40;
pub const NAV_ENFORCE_RESTRICTED: i32 = 0x80;
pub const NAV_NEW_WINDOWS_MANAGED: i32 = 0x100;
pub const NAV_UNTRUSTED_FOR_DOWNLOAD: i32 = 0x200;
pub const NAV_TRUSTED_FOR_ACTIVE_X: i32 = 0x400;
pub const NAV_OPEN_IN_NEW_TAB: i32 = 0x800;
pub const NAV_OPEN_IN_BACKGROUND_TAB: i32 = 0x1000;
pub const NAV_KEEP_WORD_WHEEL_TEXT: i32 = 0x2000;
pub const NAV_VIRTUAL_TAB: i32 = 0x4000;
pub const NAV_BLOCK_REDIRECTS_X_DOMAIN: i32 = 0x8000;
pub const NAV_OPEN_NEW_FOREGROUND_TAB: i32 = 0x10000;
pub const NAV_TRAVEL_LOG_SCREENSHOT: i32 = 0x20000;
pub const NAV_DEFER_UNLOAD: i32 = 0x40000;
pub const NAV_SPECULATIVE: i32 = 0x80000;
pub const NAV_SUGGEST_NEW_WINDOW: i32 = 0x100000;
pub const NAV_SUGGEST_NEW_TAB: i32 = 0x200000;
pub const NAV_RESERVED1: i32 = 0x400000;
pub const NAV_HOMEPAGE_NAVIGATE: i32 = 0x800000;
pub const NAV_REFRESH: i32 = 0x1000000;
pub const NAV_HOST_NAVIGATION: i32 = 0x2000000;
pub const NAV_RESERVED2: i32 = 0x4000000;
pub const NAV_RESERVED3: i32 = 0x8000000;
pub const NAV_RESERVED4: i32 = 0x10000000;
pub const NAV_RESERVED5: i32 = 0x20000000;
pub const NAV_RESERVED6: i32 = 0x40000000;
pub const NAV_RESERVED7: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFF80000000;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Cabinetstate {
    pub c_length: u16,
    pub n_version: u16,
    pub bitfield: i32,
    pub f_menu_enum_filter: u32,
}
impl Cabinetstate {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::CABINETSTATE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::CABINETSTATE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const MDITILE_SKIPDISABLED: u32 = 0x2;
pub const MDITILE_ZORDER: u32 = 0x4;
pub const CATINFO_NORMAL: i32 = 0x0;
pub const CATINFO_COLLAPSED: i32 = 0x1;
pub const CATINFO_HIDDEN: i32 = 0x2;
pub const CATINFO_EXPANDED: i32 = 0x4;
pub const CATINFO_NOHEADER: i32 = 0x8;
pub const CATINFO_NOTCOLLAPSIBLE: i32 = 0x10;
pub const CATINFO_NOHEADERCOUNT: i32 = 0x20;
pub const CATINFO_SUBSETTED: i32 = 0x40;
pub const CATINFO_SEPARATE_IMAGES: i32 = 0x80;
pub const CATINFO_SHOWEMPTY: i32 = 0x100;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct CategoryInfo {
    pub cif: i32,
    pub wsz_name: [u8; 260],
}
impl CategoryInfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::CATEGORY_INFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::CATEGORY_INFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const CATSORT_DEFAULT: i32 = 0x0;
pub const CATSORT_NAME: i32 = 0x1;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Cbtactivatestruct {
    pub f_mouse: BOOL,
    pub h_wnd_active: Option<Hwnd>,
}
impl Cbtactivatestruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::CBTACTIVATESTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::CBTACTIVATESTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Ccstylea {
    pub fl_style: u32,
    pub fl_ext_style: u32,
    pub sz_text: [CHAR; 256],
    pub lgid: u16,
    pub w_reserved1: u16,
}
impl Ccstylea {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::CCSTYLEA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::CCSTYLEA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Ccstyleflaga<'a> {
    pub fl_style: u32,
    pub fl_style_mask: u32,
    pub psz_style: Cow<'a, CStr>,
}
impl Ccstyleflaga {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::CCSTYLEFLAGA {
        let Self { fl_style, fl_style_mask, psz_style } = self;
        let flStyle = *fl_style;
        let flStyleMask = *fl_style_mask;
        let pszStyle = psz_style.as_ptr();
        windows_sys::Win32::UI::Controls::CCSTYLEFLAGA { flStyle, flStyleMask, pszStyle }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::CCSTYLEFLAGA) -> Self {
        let windows_sys::Win32::UI::Controls::CCSTYLEFLAGA { flStyle, flStyleMask, pszStyle } = win32;
        let fl_style = flStyle;
        let fl_style_mask = flStyleMask;
        let pszStyle = unsafe { CStr::from_ptr(pszStyle) };
        let pszStyle = pszStyle.to_bytes_with_nul().to_vec();
        let psz_style = Cow::Owned(unsafe { CString::from_vec_unchecked(pszStyle) });
        Self { fl_style, fl_style_mask, psz_style }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Ccstyleflagw<'a> {
    pub fl_style: u32,
    pub fl_style_mask: u32,
    pub psz_style: Cow<'a, [u16]>,
}
impl Ccstyleflagw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::CCSTYLEFLAGW {
        let Self { fl_style, fl_style_mask, psz_style } = self;
        let flStyle = *fl_style;
        let flStyleMask = *fl_style_mask;
        assert_eq!(psz_style.last(), Some(0));
        let pszStyle = psz_style.as_ptr();
        windows_sys::Win32::UI::Controls::CCSTYLEFLAGW { flStyle, flStyleMask, pszStyle }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::CCSTYLEFLAGW) -> Self {
        let windows_sys::Win32::UI::Controls::CCSTYLEFLAGW { flStyle, flStyleMask, pszStyle } = win32;
        let fl_style = flStyle;
        let fl_style_mask = flStyleMask;
        let slen = unsafe { wide_strlen(pszStyle as *const u16) };
        let pszStyle = unsafe { slice::from_raw_parts(pszStyle, slen + 1) };
        let psz_style = pszStyle.to_vec();
        Self { fl_style, fl_style_mask, psz_style }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Ccstylew {
    pub fl_style: u32,
    pub fl_ext_style: u32,
    pub sz_text: [u8; 256],
    pub lgid: u16,
    pub w_reserved1: u16,
}
impl Ccstylew {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::CCSTYLEW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::CCSTYLEW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const CDBE_RET_DEFAULT: i32 = 0x0;
pub const CDBE_RET_DONTRUNOTHEREXTS: i32 = 0x1;
pub const CDBE_RET_STOPWIZARD: i32 = 0x2;
pub const CDCS_INACTIVE: i32 = 0x0;
pub const CDCS_ENABLED: i32 = 0x1;
pub const CDCS_VISIBLE: i32 = 0x2;
pub const CDCS_ENABLEDVISIBLE: i32 = 0x3;
pub const CDS_FULLSCREEN: u32 = 0x4;
pub const CDS_GLOBAL: u32 = 0x8;
pub const CDS_NORESET: u32 = 0x10000000;
pub const CDS_RESET: u32 = 0x40000000;
pub const CDS_SET_PRIMARY: u32 = 0x10;
pub const CDS_TEST: u32 = 0x2;
pub const CDS_UPDATEREGISTRY: u32 = 0x1;
pub const CDS_VIDEOPARAMETERS: u32 = 0x20;
pub const CDS_ENABLE_UNSAFE_MODES: u32 = 0x100;
pub const CDS_DISABLE_UNSAFE_MODES: u32 = 0x200;
pub const CDS_RESET_EX: u32 = 0x20000000;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Changefilterstruct {
    pub cb_size: u32,
    pub ext_status: u32,
}
impl Changefilterstruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::CHANGEFILTERSTRUCT {
        let Self { cb_size, ext_status } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::CHANGEFILTERSTRUCT>() as _;
        let ExtStatus = ext_status;
        windows_sys::Win32::UI::WindowsAndMessaging::CHANGEFILTERSTRUCT { cbSize, ExtStatus }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::CHANGEFILTERSTRUCT) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::CHANGEFILTERSTRUCT { cbSize, ExtStatus } = win32;
        let cb_size = cbSize;
        let ext_status = ExtStatus;
        Self { cb_size, ext_status }
    }
}
pub const MSGFLT_ADD: u32 = 0x1;
pub const MSGFLT_REMOVE: u32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Cida {
    pub cidl: u32,
    pub aoffset: [u32; 1],
}
impl Cida {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::CIDA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::CIDA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Ciexyz {
    pub ciexyz_x: i32,
    pub ciexyz_y: i32,
    pub ciexyz_z: i32,
}
impl Ciexyz {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::CIEXYZ {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::CIEXYZ) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Ciexyztriple {
    pub ciexyz_red: Ciexyz,
    pub ciexyz_green: Ciexyz,
    pub ciexyz_blue: Ciexyz,
}
impl Ciexyztriple {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::CIEXYZTRIPLE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::CIEXYZTRIPLE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Clientcreatestruct {
    pub h_window_menu: Option<Handle>,
    pub id_first_child: u32,
}
impl Clientcreatestruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::CLIENTCREATESTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::CLIENTCREATESTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const CLP_TIME: i32 = 0x1;
pub const CLS_NORMAL: i32 = 0x1;
pub const CLS_HOT: i32 = 0x2;
pub const CLS_PRESSED: i32 = 0x3;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Cminvokecommandinfo<'a> {
    pub cb_size: u32,
    pub f_mask: u32,
    pub hwnd: Option<Hwnd>,
    pub lp_verb: Cow<'a, CStr>,
    pub lp_parameters: Cow<'a, CStr>,
    pub lp_directory: Cow<'a, CStr>,
    pub n_show: i32,
    pub dw_hot_key: u32,
    pub h_icon: Option<Handle>,
}
impl Cminvokecommandinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFO {
        let Self { cb_size, f_mask, hwnd, lp_verb, lp_parameters, lp_directory, n_show, dw_hot_key, h_icon } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFO>() as _;
        let fMask = *f_mask;
        let hwnd = hwnd.map_or(0, Hwnd::into_raw);
        let lpVerb = lp_verb.as_ptr();
        let lpParameters = lp_parameters.as_ptr();
        let lpDirectory = lp_directory.as_ptr();
        let nShow = *n_show;
        let dwHotKey = *dw_hot_key;
        let hIcon = h_icon.map_or(0, Handle::into_raw);
        windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFO { cbSize, fMask, hwnd, lpVerb, lpParameters, lpDirectory, nShow, dwHotKey, hIcon }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFO) -> Self {
        let windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFO { cbSize, fMask, hwnd, lpVerb, lpParameters, lpDirectory, nShow, dwHotKey, hIcon } = win32;
        let cb_size = cbSize;
        let f_mask = fMask;
        let hwnd = unsafe { Hwnd::new_optional(hwnd) };
        let lpVerb = unsafe { CStr::from_ptr(lpVerb) };
        let lpVerb = lpVerb.to_bytes_with_nul().to_vec();
        let lp_verb = Cow::Owned(unsafe { CString::from_vec_unchecked(lpVerb) });
        let lpParameters = unsafe { CStr::from_ptr(lpParameters) };
        let lpParameters = lpParameters.to_bytes_with_nul().to_vec();
        let lp_parameters = Cow::Owned(unsafe { CString::from_vec_unchecked(lpParameters) });
        let lpDirectory = unsafe { CStr::from_ptr(lpDirectory) };
        let lpDirectory = lpDirectory.to_bytes_with_nul().to_vec();
        let lp_directory = Cow::Owned(unsafe { CString::from_vec_unchecked(lpDirectory) });
        let n_show = nShow;
        let dw_hot_key = dwHotKey;
        let h_icon = unsafe { Handle::new_optional(hIcon) };
        Self { cb_size, f_mask, hwnd, lp_verb, lp_parameters, lp_directory, n_show, dw_hot_key, h_icon }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Cminvokecommandinfoex<'a> {
    pub cb_size: u32,
    pub f_mask: u32,
    pub hwnd: Option<Hwnd>,
    pub lp_verb: Cow<'a, CStr>,
    pub lp_parameters: Cow<'a, CStr>,
    pub lp_directory: Cow<'a, CStr>,
    pub n_show: i32,
    pub dw_hot_key: u32,
    pub h_icon: Option<Handle>,
    pub lp_title: Cow<'a, CStr>,
    pub lp_verb_w: Cow<'a, [u16]>,
    pub lp_parameters_w: Cow<'a, [u16]>,
    pub lp_directory_w: Cow<'a, [u16]>,
    pub lp_title_w: Cow<'a, [u16]>,
    pub pt_invoke: Point,
}
impl Cminvokecommandinfoex {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFOEX {
        let Self { cb_size, f_mask, hwnd, lp_verb, lp_parameters, lp_directory, n_show, dw_hot_key, h_icon, lp_title, lp_verb_w, lp_parameters_w, lp_directory_w, lp_title_w, pt_invoke } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFOEX>() as _;
        let fMask = *f_mask;
        let hwnd = hwnd.map_or(0, Hwnd::into_raw);
        let lpVerb = lp_verb.as_ptr();
        let lpParameters = lp_parameters.as_ptr();
        let lpDirectory = lp_directory.as_ptr();
        let nShow = *n_show;
        let dwHotKey = *dw_hot_key;
        let hIcon = h_icon.map_or(0, Handle::into_raw);
        let lpTitle = lp_title.as_ptr();
        assert_eq!(lp_verb_w.last(), Some(0));
        let lpVerbW = lp_verb_w.as_ptr();
        assert_eq!(lp_parameters_w.last(), Some(0));
        let lpParametersW = lp_parameters_w.as_ptr();
        assert_eq!(lp_directory_w.last(), Some(0));
        let lpDirectoryW = lp_directory_w.as_ptr();
        assert_eq!(lp_title_w.last(), Some(0));
        let lpTitleW = lp_title_w.as_ptr();
        let ptInvoke = pt_invoke.to_win32();
        windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFOEX { cbSize, fMask, hwnd, lpVerb, lpParameters, lpDirectory, nShow, dwHotKey, hIcon, lpTitle, lpVerbW, lpParametersW, lpDirectoryW, lpTitleW, ptInvoke }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFOEX) -> Self {
        let windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFOEX { cbSize, fMask, hwnd, lpVerb, lpParameters, lpDirectory, nShow, dwHotKey, hIcon, lpTitle, lpVerbW, lpParametersW, lpDirectoryW, lpTitleW, ptInvoke } = win32;
        let cb_size = cbSize;
        let f_mask = fMask;
        let hwnd = unsafe { Hwnd::new_optional(hwnd) };
        let lpVerb = unsafe { CStr::from_ptr(lpVerb) };
        let lpVerb = lpVerb.to_bytes_with_nul().to_vec();
        let lp_verb = Cow::Owned(unsafe { CString::from_vec_unchecked(lpVerb) });
        let lpParameters = unsafe { CStr::from_ptr(lpParameters) };
        let lpParameters = lpParameters.to_bytes_with_nul().to_vec();
        let lp_parameters = Cow::Owned(unsafe { CString::from_vec_unchecked(lpParameters) });
        let lpDirectory = unsafe { CStr::from_ptr(lpDirectory) };
        let lpDirectory = lpDirectory.to_bytes_with_nul().to_vec();
        let lp_directory = Cow::Owned(unsafe { CString::from_vec_unchecked(lpDirectory) });
        let n_show = nShow;
        let dw_hot_key = dwHotKey;
        let h_icon = unsafe { Handle::new_optional(hIcon) };
        let lpTitle = unsafe { CStr::from_ptr(lpTitle) };
        let lpTitle = lpTitle.to_bytes_with_nul().to_vec();
        let lp_title = Cow::Owned(unsafe { CString::from_vec_unchecked(lpTitle) });
        let slen = unsafe { wide_strlen(lpVerbW as *const u16) };
        let lpVerbW = unsafe { slice::from_raw_parts(lpVerbW, slen + 1) };
        let lp_verb_w = lpVerbW.to_vec();
        let slen = unsafe { wide_strlen(lpParametersW as *const u16) };
        let lpParametersW = unsafe { slice::from_raw_parts(lpParametersW, slen + 1) };
        let lp_parameters_w = lpParametersW.to_vec();
        let slen = unsafe { wide_strlen(lpDirectoryW as *const u16) };
        let lpDirectoryW = unsafe { slice::from_raw_parts(lpDirectoryW, slen + 1) };
        let lp_directory_w = lpDirectoryW.to_vec();
        let slen = unsafe { wide_strlen(lpTitleW as *const u16) };
        let lpTitleW = unsafe { slice::from_raw_parts(lpTitleW, slen + 1) };
        let lp_title_w = lpTitleW.to_vec();
        let pt_invoke = unsafe { POINT::from_win32(ptInvoke) };
        Self { cb_size, f_mask, hwnd, lp_verb, lp_parameters, lp_directory, n_show, dw_hot_key, h_icon, lp_title, lp_verb_w, lp_parameters_w, lp_directory_w, lp_title_w, pt_invoke }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct CminvokecommandinfoexRemote<'a> {
    pub cb_size: u32,
    pub f_mask: u32,
    pub hwnd: Option<Hwnd>,
    pub lp_verb_string: Cow<'a, CStr>,
    pub lp_parameters: Cow<'a, CStr>,
    pub lp_directory: Cow<'a, CStr>,
    pub n_show: i32,
    pub dw_hot_key: u32,
    pub lp_title: Cow<'a, CStr>,
    pub lp_verb_w_string: Cow<'a, [u16]>,
    pub lp_parameters_w: Cow<'a, [u16]>,
    pub lp_directory_w: Cow<'a, [u16]>,
    pub lp_title_w: Cow<'a, [u16]>,
    pub pt_invoke: Point,
    pub lp_verb_int: u32,
    pub lp_verb_w_int: u32,
}
impl CminvokecommandinfoexRemote {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFOEX_REMOTE {
        let Self { cb_size, f_mask, hwnd, lp_verb_string, lp_parameters, lp_directory, n_show, dw_hot_key, lp_title, lp_verb_w_string, lp_parameters_w, lp_directory_w, lp_title_w, pt_invoke, lp_verb_int, lp_verb_w_int } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFOEX_REMOTE>() as _;
        let fMask = *f_mask;
        let hwnd = hwnd.map_or(0, Hwnd::into_raw);
        let lpVerbString = lp_verb_string.as_ptr();
        let lpParameters = lp_parameters.as_ptr();
        let lpDirectory = lp_directory.as_ptr();
        let nShow = *n_show;
        let dwHotKey = *dw_hot_key;
        let lpTitle = lp_title.as_ptr();
        assert_eq!(lp_verb_w_string.last(), Some(0));
        let lpVerbWString = lp_verb_w_string.as_ptr();
        assert_eq!(lp_parameters_w.last(), Some(0));
        let lpParametersW = lp_parameters_w.as_ptr();
        assert_eq!(lp_directory_w.last(), Some(0));
        let lpDirectoryW = lp_directory_w.as_ptr();
        assert_eq!(lp_title_w.last(), Some(0));
        let lpTitleW = lp_title_w.as_ptr();
        let ptInvoke = pt_invoke.to_win32();
        let lpVerbInt = *lp_verb_int;
        let lpVerbWInt = *lp_verb_w_int;
        windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFOEX_REMOTE { cbSize, fMask, hwnd, lpVerbString, lpParameters, lpDirectory, nShow, dwHotKey, lpTitle, lpVerbWString, lpParametersW, lpDirectoryW, lpTitleW, ptInvoke, lpVerbInt, lpVerbWInt }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFOEX_REMOTE) -> Self {
        let windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFOEX_REMOTE { cbSize, fMask, hwnd, lpVerbString, lpParameters, lpDirectory, nShow, dwHotKey, lpTitle, lpVerbWString, lpParametersW, lpDirectoryW, lpTitleW, ptInvoke, lpVerbInt, lpVerbWInt } = win32;
        let cb_size = cbSize;
        let f_mask = fMask;
        let hwnd = unsafe { Hwnd::new_optional(hwnd) };
        let lpVerbString = unsafe { CStr::from_ptr(lpVerbString) };
        let lpVerbString = lpVerbString.to_bytes_with_nul().to_vec();
        let lp_verb_string = Cow::Owned(unsafe { CString::from_vec_unchecked(lpVerbString) });
        let lpParameters = unsafe { CStr::from_ptr(lpParameters) };
        let lpParameters = lpParameters.to_bytes_with_nul().to_vec();
        let lp_parameters = Cow::Owned(unsafe { CString::from_vec_unchecked(lpParameters) });
        let lpDirectory = unsafe { CStr::from_ptr(lpDirectory) };
        let lpDirectory = lpDirectory.to_bytes_with_nul().to_vec();
        let lp_directory = Cow::Owned(unsafe { CString::from_vec_unchecked(lpDirectory) });
        let n_show = nShow;
        let dw_hot_key = dwHotKey;
        let lpTitle = unsafe { CStr::from_ptr(lpTitle) };
        let lpTitle = lpTitle.to_bytes_with_nul().to_vec();
        let lp_title = Cow::Owned(unsafe { CString::from_vec_unchecked(lpTitle) });
        let slen = unsafe { wide_strlen(lpVerbWString as *const u16) };
        let lpVerbWString = unsafe { slice::from_raw_parts(lpVerbWString, slen + 1) };
        let lp_verb_w_string = lpVerbWString.to_vec();
        let slen = unsafe { wide_strlen(lpParametersW as *const u16) };
        let lpParametersW = unsafe { slice::from_raw_parts(lpParametersW, slen + 1) };
        let lp_parameters_w = lpParametersW.to_vec();
        let slen = unsafe { wide_strlen(lpDirectoryW as *const u16) };
        let lpDirectoryW = unsafe { slice::from_raw_parts(lpDirectoryW, slen + 1) };
        let lp_directory_w = lpDirectoryW.to_vec();
        let slen = unsafe { wide_strlen(lpTitleW as *const u16) };
        let lpTitleW = unsafe { slice::from_raw_parts(lpTitleW, slen + 1) };
        let lp_title_w = lpTitleW.to_vec();
        let pt_invoke = unsafe { POINT::from_win32(ptInvoke) };
        let lp_verb_int = lpVerbInt;
        let lp_verb_w_int = lpVerbWInt;
        Self { cb_size, f_mask, hwnd, lp_verb_string, lp_parameters, lp_directory, n_show, dw_hot_key, lp_title, lp_verb_w_string, lp_parameters_w, lp_directory_w, lp_title_w, pt_invoke, lp_verb_int, lp_verb_w_int }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct CmColumninfo {
    pub cb_size: u32,
    pub dw_mask: u32,
    pub dw_state: u32,
    pub u_width: u32,
    pub u_default_width: u32,
    pub u_ideal_width: u32,
    pub wsz_name: [u8; 80],
}
impl CmColumninfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::CM_COLUMNINFO {
        let Self { cb_size, dw_mask, dw_state, u_width, u_default_width, u_ideal_width, wsz_name } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::CM_COLUMNINFO>() as _;
        let dwMask = *dw_mask;
        let dwState = *dw_state;
        let uWidth = *u_width;
        let uDefaultWidth = *u_default_width;
        let uIdealWidth = *u_ideal_width;
        let wszName = [*wsz_name[0],*wsz_name[1],*wsz_name[2],*wsz_name[3],*wsz_name[4],*wsz_name[5],*wsz_name[6],*wsz_name[7],*wsz_name[8],*wsz_name[9],*wsz_name[10],*wsz_name[11],*wsz_name[12],*wsz_name[13],*wsz_name[14],*wsz_name[15],*wsz_name[16],*wsz_name[17],*wsz_name[18],*wsz_name[19],*wsz_name[20],*wsz_name[21],*wsz_name[22],*wsz_name[23],*wsz_name[24],*wsz_name[25],*wsz_name[26],*wsz_name[27],*wsz_name[28],*wsz_name[29],*wsz_name[30],*wsz_name[31],*wsz_name[32],*wsz_name[33],*wsz_name[34],*wsz_name[35],*wsz_name[36],*wsz_name[37],*wsz_name[38],*wsz_name[39],*wsz_name[40],*wsz_name[41],*wsz_name[42],*wsz_name[43],*wsz_name[44],*wsz_name[45],*wsz_name[46],*wsz_name[47],*wsz_name[48],*wsz_name[49],*wsz_name[50],*wsz_name[51],*wsz_name[52],*wsz_name[53],*wsz_name[54],*wsz_name[55],*wsz_name[56],*wsz_name[57],*wsz_name[58],*wsz_name[59],*wsz_name[60],*wsz_name[61],*wsz_name[62],*wsz_name[63],*wsz_name[64],*wsz_name[65],*wsz_name[66],*wsz_name[67],*wsz_name[68],*wsz_name[69],*wsz_name[70],*wsz_name[71],*wsz_name[72],*wsz_name[73],*wsz_name[74],*wsz_name[75],*wsz_name[76],*wsz_name[77],*wsz_name[78],*wsz_name[79]];
        windows_sys::Win32::UI::Shell::CM_COLUMNINFO { cbSize, dwMask, dwState, uWidth, uDefaultWidth, uIdealWidth, wszName }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::CM_COLUMNINFO) -> Self {
        let windows_sys::Win32::UI::Shell::CM_COLUMNINFO { cbSize, dwMask, dwState, uWidth, uDefaultWidth, uIdealWidth, wszName } = win32;
        let cb_size = cbSize;
        let dw_mask = dwMask;
        let dw_state = dwState;
        let u_width = uWidth;
        let u_default_width = uDefaultWidth;
        let u_ideal_width = uIdealWidth;
        let wsz_name = [wszName[0],wszName[1],wszName[2],wszName[3],wszName[4],wszName[5],wszName[6],wszName[7],wszName[8],wszName[9],wszName[10],wszName[11],wszName[12],wszName[13],wszName[14],wszName[15],wszName[16],wszName[17],wszName[18],wszName[19],wszName[20],wszName[21],wszName[22],wszName[23],wszName[24],wszName[25],wszName[26],wszName[27],wszName[28],wszName[29],wszName[30],wszName[31],wszName[32],wszName[33],wszName[34],wszName[35],wszName[36],wszName[37],wszName[38],wszName[39],wszName[40],wszName[41],wszName[42],wszName[43],wszName[44],wszName[45],wszName[46],wszName[47],wszName[48],wszName[49],wszName[50],wszName[51],wszName[52],wszName[53],wszName[54],wszName[55],wszName[56],wszName[57],wszName[58],wszName[59],wszName[60],wszName[61],wszName[62],wszName[63],wszName[64],wszName[65],wszName[66],wszName[67],wszName[68],wszName[69],wszName[70],wszName[71],wszName[72],wszName[73],wszName[74],wszName[75],wszName[76],wszName[77],wszName[78],wszName[79]];
        Self { cb_size, dw_mask, dw_state, u_width, u_default_width, u_ideal_width, wsz_name }
    }
}
pub const CM_ENUM_ALL: i32 = 0x1;
pub const CM_ENUM_VISIBLE: i32 = 0x2;
pub const CM_MASK_WIDTH: i32 = 0x1;
pub const CM_MASK_DEFAULTWIDTH: i32 = 0x2;
pub const CM_MASK_IDEALWIDTH: i32 = 0x4;
pub const CM_MASK_NAME: i32 = 0x8;
pub const CM_MASK_STATE: i32 = 0x10;
pub const CM_WIDTH_USEDEFAULT: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
pub const CM_WIDTH_AUTOSIZE: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE;
pub const CM_STATE_NONE: i32 = 0x0;
pub const CM_STATE_VISIBLE: i32 = 0x1;
pub const CM_STATE_FIXEDWIDTH: i32 = 0x2;
pub const CM_STATE_NOSORTBYFOLDERNESS: i32 = 0x4;
pub const CM_STATE_ALWAYSVISIBLE: i32 = 0x8;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Coloradjustment {
    pub ca_size: u16,
    pub ca_flags: u16,
    pub ca_illuminant_index: u16,
    pub ca_red_gamma: u16,
    pub ca_green_gamma: u16,
    pub ca_blue_gamma: u16,
    pub ca_reference_black: u16,
    pub ca_reference_white: u16,
    pub ca_contrast: i16,
    pub ca_brightness: i16,
    pub ca_colorfulness: i16,
    pub ca_red_green_tint: i16,
}
impl Coloradjustment {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::COLORADJUSTMENT {
        let Self { ca_size, ca_flags, ca_illuminant_index, ca_red_gamma, ca_green_gamma, ca_blue_gamma, ca_reference_black, ca_reference_white, ca_contrast, ca_brightness, ca_colorfulness, ca_red_green_tint } = self;
        let caSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::COLORADJUSTMENT>() as _;
        let caFlags = *ca_flags;
        let caIlluminantIndex = *ca_illuminant_index;
        let caRedGamma = *ca_red_gamma;
        let caGreenGamma = *ca_green_gamma;
        let caBlueGamma = *ca_blue_gamma;
        let caReferenceBlack = *ca_reference_black;
        let caReferenceWhite = *ca_reference_white;
        let caContrast = *ca_contrast;
        let caBrightness = *ca_brightness;
        let caColorfulness = *ca_colorfulness;
        let caRedGreenTint = *ca_red_green_tint;
        windows_sys::Win32::Graphics::Gdi::COLORADJUSTMENT { caSize, caFlags, caIlluminantIndex, caRedGamma, caGreenGamma, caBlueGamma, caReferenceBlack, caReferenceWhite, caContrast, caBrightness, caColorfulness, caRedGreenTint }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::COLORADJUSTMENT) -> Self {
        let windows_sys::Win32::Graphics::Gdi::COLORADJUSTMENT { caSize, caFlags, caIlluminantIndex, caRedGamma, caGreenGamma, caBlueGamma, caReferenceBlack, caReferenceWhite, caContrast, caBrightness, caColorfulness, caRedGreenTint } = win32;
        let ca_size = caSize;
        let ca_flags = caFlags;
        let ca_illuminant_index = caIlluminantIndex;
        let ca_red_gamma = caRedGamma;
        let ca_green_gamma = caGreenGamma;
        let ca_blue_gamma = caBlueGamma;
        let ca_reference_black = caReferenceBlack;
        let ca_reference_white = caReferenceWhite;
        let ca_contrast = caContrast;
        let ca_brightness = caBrightness;
        let ca_colorfulness = caColorfulness;
        let ca_red_green_tint = caRedGreenTint;
        Self { ca_size, ca_flags, ca_illuminant_index, ca_red_gamma, ca_green_gamma, ca_blue_gamma, ca_reference_black, ca_reference_white, ca_contrast, ca_brightness, ca_colorfulness, ca_red_green_tint }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Colorcorrectpalette {
    pub emr: Emr,
    pub ih_palette: u32,
    pub n_first_entry: u32,
    pub n_pal_entries: u32,
    pub n_reserved: u32,
}
impl Colorcorrectpalette {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::COLORCORRECTPALETTE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::COLORCORRECTPALETTE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Colormap {
    pub from: u32,
    pub to: u32,
}
impl Colormap {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::COLORMAP {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::COLORMAP) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Colormatchtotarget {
    pub emr: Emr,
    pub dw_action: u32,
    pub dw_flags: u32,
    pub cb_name: u32,
    pub cb_data: u32,
    pub data: [u8; 1],
}
impl Colormatchtotarget {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::COLORMATCHTOTARGET {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::COLORMATCHTOTARGET) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Colorscheme {
    pub dw_size: u32,
    pub clr_btn_highlight: u32,
    pub clr_btn_shadow: u32,
}
impl Colorscheme {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::COLORSCHEME {
        let Self { dw_size, clr_btn_highlight, clr_btn_shadow } = self;
        let dwSize = mem::size_of::<windows_sys::Win32::UI::Controls::COLORSCHEME>() as _;
        let clrBtnHighlight = *clr_btn_highlight;
        let clrBtnShadow = *clr_btn_shadow;
        windows_sys::Win32::UI::Controls::COLORSCHEME { dwSize, clrBtnHighlight, clrBtnShadow }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::COLORSCHEME) -> Self {
        let windows_sys::Win32::UI::Controls::COLORSCHEME { dwSize, clrBtnHighlight, clrBtnShadow } = win32;
        let dw_size = dwSize;
        let clr_btn_highlight = clrBtnHighlight;
        let clr_btn_shadow = clrBtnShadow;
        Self { dw_size, clr_btn_highlight, clr_btn_shadow }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Comboboxinfo {
    pub cb_size: u32,
    pub rc_item: Rect,
    pub rc_button: Rect,
    pub state_button: u32,
    pub hwnd_combo: Option<Hwnd>,
    pub hwnd_item: Option<Hwnd>,
    pub hwnd_list: Option<Hwnd>,
}
impl Comboboxinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::COMBOBOXINFO {
        let Self { cb_size, rc_item, rc_button, state_button, hwnd_combo, hwnd_item, hwnd_list } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::COMBOBOXINFO>() as _;
        let rcItem = rc_item.to_win32();
        let rcButton = rc_button.to_win32();
        let stateButton = state_button;
        let hwndCombo = hwnd_combo.map_or(0, Hwnd::into_raw);
        let hwndItem = hwnd_item.map_or(0, Hwnd::into_raw);
        let hwndList = hwnd_list.map_or(0, Hwnd::into_raw);
        windows_sys::Win32::UI::Controls::COMBOBOXINFO { cbSize, rcItem, rcButton, stateButton, hwndCombo, hwndItem, hwndList }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::COMBOBOXINFO) -> Self {
        let windows_sys::Win32::UI::Controls::COMBOBOXINFO { cbSize, rcItem, rcButton, stateButton, hwndCombo, hwndItem, hwndList } = win32;
        let cb_size = cbSize;
        let rc_item = unsafe { RECT::from_win32(rcItem) };
        let rc_button = unsafe { RECT::from_win32(rcButton) };
        let state_button = stateButton;
        let hwnd_combo = unsafe { Hwnd::new_optional(hwndCombo) };
        let hwnd_item = unsafe { Hwnd::new_optional(hwndItem) };
        let hwnd_list = unsafe { Hwnd::new_optional(hwndList) };
        Self { cb_size, rc_item, rc_button, state_button, hwnd_combo, hwnd_item, hwnd_list }
    }
}
pub const STATE_SYSTEM_INVISIBLE: u32 = 0x8000;
pub const STATE_SYSTEM_PRESSED: u32 = 0x8;
pub const STATE_SYSTEM_FOCUSABLE: u32 = 0x100000;
pub const STATE_SYSTEM_OFFSCREEN: u32 = 0x10000;
pub const STATE_SYSTEM_UNAVAILABLE: u32 = 0x1;
pub const CBEIF_DI_SETITEM: u32 = 0x10000000;
pub const CBEIF_IMAGE: u32 = 0x2;
pub const CBEIF_INDENT: u32 = 0x10;
pub const CBEIF_LPARAM: u32 = 0x20;
pub const CBEIF_OVERLAY: u32 = 0x8;
pub const CBEIF_SELECTEDIMAGE: u32 = 0x4;
pub const CBEIF_TEXT: u32 = 0x1;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Compareitemstruct {
    pub ctl_type: u32,
    pub ctl_id: u32,
    pub hwnd_item: Option<Hwnd>,
    pub item_id1: u32,
    pub item_data1: usize,
    pub item_id2: u32,
    pub item_data2: usize,
    pub dw_locale_id: u32,
}
impl Compareitemstruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::COMPAREITEMSTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::COMPAREITEMSTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct ConfirmConflictResultInfo<'a> {
    pub psz_new_name: Cow<'a, [u16]>,
    pub i_item_index: u32,
}
impl ConfirmConflictResultInfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::CONFIRM_CONFLICT_RESULT_INFO {
        let Self { psz_new_name, i_item_index } = self;
        assert_eq!(psz_new_name.last(), Some(0));
        let pszNewName = psz_new_name.as_ptr();
        let iItemIndex = *i_item_index;
        windows_sys::Win32::UI::Shell::CONFIRM_CONFLICT_RESULT_INFO { pszNewName, iItemIndex }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::CONFIRM_CONFLICT_RESULT_INFO) -> Self {
        let windows_sys::Win32::UI::Shell::CONFIRM_CONFLICT_RESULT_INFO { pszNewName, iItemIndex } = win32;
        let slen = unsafe { wide_strlen(pszNewName as *const u16) };
        let pszNewName = unsafe { slice::from_raw_parts(pszNewName, slen + 1) };
        let psz_new_name = pszNewName.to_vec();
        let i_item_index = iItemIndex;
        Self { psz_new_name, i_item_index }
    }
}
pub const CA_LEFT: i32 = 0x0;
pub const CA_CENTER: i32 = 0x1;
pub const CA_RIGHT: i32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Cplinfo {
    pub id_icon: i32,
    pub id_name: i32,
    pub id_info: i32,
    pub l_data: isize,
}
impl Cplinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::CPLINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::CPLINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const CPVIEW_CLASSIC: i32 = 0x0;
pub const CPVIEW_ALLITEMS: i32 = 0x0;
pub const CPVIEW_CATEGORY: i32 = 0x1;
pub const CPVIEW_HOME: i32 = 0x1;
//  Not generated due to containing a void type
//  #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Createstructa<'a> {
//      pub lp_create_params: &'a mut todo_void,
//      pub h_instance: Option<Hinstance>,
//      pub h_menu: Option<Hmenu>,
//      pub hwnd_parent: Option<Hwnd>,
//      pub cy: i32,
//      pub cx: i32,
//      pub y: i32,
//      pub x: i32,
//      pub style: i32,
//      pub lpsz_name: Cow<'a, CStr>,
//      pub lpsz_class: Cow<'a, CStr>,
//      pub dw_ex_style: u32,
//  }
//  impl Createstructa {
//      fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::CREATESTRUCTA {
//          let Self { lp_create_params, h_instance, h_menu, hwnd_parent, cy, cx, y, x, style, lpsz_name, lpsz_class, dw_ex_style } = self;
//          let lpCreateParams = unsafe { &mut *(lp_create_params as *mut _ as *mut _) };
//          let hInstance = h_instance.map_or(0, Hinstance::into_raw);
//          let hMenu = h_menu.map_or(0, Hmenu::into_raw);
//          let hwndParent = hwnd_parent.map_or(0, Hwnd::into_raw);
//          let cy = *cy;
//          let cx = *cx;
//          let y = *y;
//          let x = *x;
//          let style = *style;
//          let lpszName = lpsz_name.as_ptr();
//          let lpszClass = lpsz_class.as_ptr();
//          let dwExStyle = *dw_ex_style;
//          windows_sys::Win32::UI::WindowsAndMessaging::CREATESTRUCTA { lpCreateParams, hInstance, hMenu, hwndParent, cy, cx, y, x, style, lpszName, lpszClass, dwExStyle }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::CREATESTRUCTA) -> Self {
//          let windows_sys::Win32::UI::WindowsAndMessaging::CREATESTRUCTA { lpCreateParams, hInstance, hMenu, hwndParent, cy, cx, y, x, style, lpszName, lpszClass, dwExStyle } = win32;
//          let lp_create_params = unsafe { &mut *(lpCreateParams as *mut _ as *mut _) };
//          let h_instance = unsafe { Hinstance::new_optional(hInstance) };
//          let h_menu = unsafe { Hmenu::new_optional(hMenu) };
//          let hwnd_parent = unsafe { Hwnd::new_optional(hwndParent) };
//          let cy = cy;
//          let cx = cx;
//          let y = y;
//          let x = x;
//          let style = style;
//          let lpszName = unsafe { CStr::from_ptr(lpszName) };
//          let lpszName = lpszName.to_bytes_with_nul().to_vec();
//          let lpsz_name = Cow::Owned(unsafe { CString::from_vec_unchecked(lpszName) });
//          let lpszClass = unsafe { CStr::from_ptr(lpszClass) };
//          let lpszClass = lpszClass.to_bytes_with_nul().to_vec();
//          let lpsz_class = Cow::Owned(unsafe { CString::from_vec_unchecked(lpszClass) });
//          let dw_ex_style = dwExStyle;
//          Self { lp_create_params, h_instance, h_menu, hwnd_parent, cy, cx, y, x, style, lpsz_name, lpsz_class, dw_ex_style }
//      }
//  }
//  Not generated due to containing a void type
//  #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Createstructw<'a> {
//      pub lp_create_params: &'a mut todo_void,
//      pub h_instance: Option<Hinstance>,
//      pub h_menu: Option<Hmenu>,
//      pub hwnd_parent: Option<Hwnd>,
//      pub cy: i32,
//      pub cx: i32,
//      pub y: i32,
//      pub x: i32,
//      pub style: i32,
//      pub lpsz_name: Cow<'a, [u16]>,
//      pub lpsz_class: Cow<'a, [u16]>,
//      pub dw_ex_style: u32,
//  }
//  impl Createstructw {
//      fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::CREATESTRUCTW {
//          let Self { lp_create_params, h_instance, h_menu, hwnd_parent, cy, cx, y, x, style, lpsz_name, lpsz_class, dw_ex_style } = self;
//          let lpCreateParams = unsafe { &mut *(lp_create_params as *mut _ as *mut _) };
//          let hInstance = h_instance.map_or(0, Hinstance::into_raw);
//          let hMenu = h_menu.map_or(0, Hmenu::into_raw);
//          let hwndParent = hwnd_parent.map_or(0, Hwnd::into_raw);
//          let cy = *cy;
//          let cx = *cx;
//          let y = *y;
//          let x = *x;
//          let style = *style;
//          assert_eq!(lpsz_name.last(), Some(0));
//          let lpszName = lpsz_name.as_ptr();
//          assert_eq!(lpsz_class.last(), Some(0));
//          let lpszClass = lpsz_class.as_ptr();
//          let dwExStyle = *dw_ex_style;
//          windows_sys::Win32::UI::WindowsAndMessaging::CREATESTRUCTW { lpCreateParams, hInstance, hMenu, hwndParent, cy, cx, y, x, style, lpszName, lpszClass, dwExStyle }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::CREATESTRUCTW) -> Self {
//          let windows_sys::Win32::UI::WindowsAndMessaging::CREATESTRUCTW { lpCreateParams, hInstance, hMenu, hwndParent, cy, cx, y, x, style, lpszName, lpszClass, dwExStyle } = win32;
//          let lp_create_params = unsafe { &mut *(lpCreateParams as *mut _ as *mut _) };
//          let h_instance = unsafe { Hinstance::new_optional(hInstance) };
//          let h_menu = unsafe { Hmenu::new_optional(hMenu) };
//          let hwnd_parent = unsafe { Hwnd::new_optional(hwndParent) };
//          let cy = cy;
//          let cx = cx;
//          let y = y;
//          let x = x;
//          let style = style;
//          let slen = unsafe { wide_strlen(lpszName as *const u16) };
//          let lpszName = unsafe { slice::from_raw_parts(lpszName, slen + 1) };
//          let lpsz_name = lpszName.to_vec();
//          let slen = unsafe { wide_strlen(lpszClass as *const u16) };
//          let lpszClass = unsafe { slice::from_raw_parts(lpszClass, slen + 1) };
//          let lpsz_class = lpszClass.to_vec();
//          let dw_ex_style = dwExStyle;
//          Self { lp_create_params, h_instance, h_menu, hwnd_parent, cy, cx, y, x, style, lpsz_name, lpsz_class, dw_ex_style }
//      }
//  }
pub const TTFCFP_STD_MAC_CHAR_SET: u32 = 0x0;
pub const TTFCFP_SYMBOL_CHAR_SET: u32 = 0x0;
pub const TTFCFP_UNICODE_CHAR_SET: u32 = 0x1;
pub const TTFCFP_UNICODE_PLATFORMID: u32 = 0x0;
pub const TTFCFP_ISO_PLATFORMID: u32 = 0x2;
pub const ALTERNATE: u32 = 0x1;
pub const WINDING: u32 = 0x2;
pub const CPAO_NONE: i32 = 0x0;
pub const CPAO_EMPTY_LOCAL: i32 = 0x1;
pub const CPAO_EMPTY_CONNECTED: i32 = 0x2;
pub const CPCFO_NONE: i32 = 0x0;
pub const CPCFO_ENABLE_PASSWORD_REVEAL: i32 = 0x1;
pub const CPCFO_IS_EMAIL_ADDRESS: i32 = 0x2;
pub const CPCFO_ENABLE_TOUCH_KEYBOARD_AUTO_INVOKE: i32 = 0x4;
pub const CPCFO_NUMBERS_ONLY: i32 = 0x8;
pub const CPCFO_SHOW_ENGLISH_KEYBOARD: i32 = 0x10;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct CredentialProviderCredentialSerialization<'a> {
    pub ul_authentication_package: u32,
    pub clsid_credential_provider: GUID,
    pub cb_serialization: u32,
    pub rgb_serialization: &'a mut u8,
}
impl CredentialProviderCredentialSerialization {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION {
        let Self { ul_authentication_package, clsid_credential_provider, cb_serialization, rgb_serialization } = self;
        let ulAuthenticationPackage = *ul_authentication_package;
        let clsidCredentialProvider = *clsid_credential_provider;
        let cbSerialization = *cb_serialization;
        let rgbSerialization = unsafe { &mut *(rgb_serialization as *mut _ as *mut _) };
        windows_sys::Win32::UI::Shell::CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION { ulAuthenticationPackage, clsidCredentialProvider, cbSerialization, rgbSerialization }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION) -> Self {
        let windows_sys::Win32::UI::Shell::CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION { ulAuthenticationPackage, clsidCredentialProvider, cbSerialization, rgbSerialization } = win32;
        let ul_authentication_package = ulAuthenticationPackage;
        let clsid_credential_provider = clsidCredentialProvider;
        let cb_serialization = cbSerialization;
        let rgb_serialization = unsafe { &mut *(rgbSerialization as *mut _ as *mut _) };
        Self { ul_authentication_package, clsid_credential_provider, cb_serialization, rgb_serialization }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct CredentialProviderFieldDescriptor<'a> {
    pub dw_field_id: u32,
    pub cpft: i32,
    pub psz_label: Cow<'a, [u16]>,
    pub guid_field_type: GUID,
}
impl CredentialProviderFieldDescriptor {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR {
        let Self { dw_field_id, cpft, psz_label, guid_field_type } = self;
        let dwFieldID = *dw_field_id;
        let cpft = cpft;
        assert_eq!(psz_label.last(), Some(0));
        let pszLabel = psz_label.as_ptr();
        let guidFieldType = *guid_field_type;
        windows_sys::Win32::UI::Shell::CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR { dwFieldID, cpft, pszLabel, guidFieldType }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR) -> Self {
        let windows_sys::Win32::UI::Shell::CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR { dwFieldID, cpft, pszLabel, guidFieldType } = win32;
        let dw_field_id = dwFieldID;
        let cpft = cpft;
        let slen = unsafe { wide_strlen(pszLabel as *const u16) };
        let pszLabel = unsafe { slice::from_raw_parts(pszLabel, slen + 1) };
        let psz_label = pszLabel.to_vec();
        let guid_field_type = guidFieldType;
        Self { dw_field_id, cpft, psz_label, guid_field_type }
    }
}
pub const CPFIS_NONE: i32 = 0x0;
pub const CPFIS_READONLY: i32 = 0x1;
pub const CPFIS_DISABLED: i32 = 0x2;
pub const CPFIS_FOCUSED: i32 = 0x3;
pub const CPFS_HIDDEN: i32 = 0x0;
pub const CPFS_DISPLAY_IN_SELECTED_TILE: i32 = 0x1;
pub const CPFS_DISPLAY_IN_DESELECTED_TILE: i32 = 0x2;
pub const CPFS_DISPLAY_IN_BOTH: i32 = 0x3;
pub const CPFT_INVALID: i32 = 0x0;
pub const CPFT_LARGE_TEXT: i32 = 0x1;
pub const CPFT_SMALL_TEXT: i32 = 0x2;
pub const CPFT_COMMAND_LINK: i32 = 0x3;
pub const CPFT_EDIT_TEXT: i32 = 0x4;
pub const CPFT_PASSWORD_TEXT: i32 = 0x5;
pub const CPFT_TILE_IMAGE: i32 = 0x6;
pub const CPFT_CHECKBOX: i32 = 0x7;
pub const CPFT_COMBOBOX: i32 = 0x8;
pub const CPFT_SUBMIT_BUTTON: i32 = 0x9;
pub const CPGSR_NO_CREDENTIAL_NOT_FINISHED: i32 = 0x0;
pub const CPGSR_NO_CREDENTIAL_FINISHED: i32 = 0x1;
pub const CPGSR_RETURN_CREDENTIAL_FINISHED: i32 = 0x2;
pub const CPGSR_RETURN_NO_CREDENTIAL_FINISHED: i32 = 0x3;
pub const CPSI_NONE: i32 = 0x0;
pub const CPSI_ERROR: i32 = 0x1;
pub const CPSI_WARNING: i32 = 0x2;
pub const CPSI_SUCCESS: i32 = 0x3;
pub const CPUS_INVALID: i32 = 0x0;
pub const CPUS_LOGON: i32 = 0x1;
pub const CPUS_UNLOCK_WORKSTATION: i32 = 0x2;
pub const CPUS_CHANGE_PASSWORD: i32 = 0x3;
pub const CPUS_CREDUI: i32 = 0x4;
pub const CPUS_PLAP: i32 = 0x5;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Cursorinfo {
    pub cb_size: u32,
    pub flags: u32,
    pub h_cursor: Option<Hcursor>,
    pub pt_screen_pos: Point,
}
impl Cursorinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::CURSORINFO {
        let Self { cb_size, flags, h_cursor, pt_screen_pos } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::CURSORINFO>() as _;
        let flags = flags;
        let hCursor = h_cursor.map_or(0, Hcursor::into_raw);
        let ptScreenPos = pt_screen_pos.to_win32();
        windows_sys::Win32::UI::WindowsAndMessaging::CURSORINFO { cbSize, flags, hCursor, ptScreenPos }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::CURSORINFO) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::CURSORINFO { cbSize, flags, hCursor, ptScreenPos } = win32;
        let cb_size = cbSize;
        let flags = flags;
        let h_cursor = unsafe { Hcursor::new_optional(hCursor) };
        let pt_screen_pos = unsafe { POINT::from_win32(ptScreenPos) };
        Self { cb_size, flags, h_cursor, pt_screen_pos }
    }
}
pub const CURSOR_SHOWING: u32 = 0x1;
pub const CURSOR_SUPPRESSED: u32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Cursorshape {
    pub x_hot_spot: i32,
    pub y_hot_spot: i32,
    pub cx: i32,
    pub cy: i32,
    pub cb_width: i32,
    pub planes: u8,
    pub bits_pixel: u8,
}
impl Cursorshape {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::CURSORSHAPE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::CURSORSHAPE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Cwpretstruct {
    pub l_result: Option<Lresult>,
    pub l_param: Lparam,
    pub w_param: Wparam,
    pub message: u32,
    pub hwnd: Option<Hwnd>,
}
impl Cwpretstruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::CWPRETSTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::CWPRETSTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Cwpstruct {
    pub l_param: Lparam,
    pub w_param: Wparam,
    pub message: u32,
    pub hwnd: Option<Hwnd>,
}
impl Cwpstruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::CWPSTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::CWPSTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const CWP_ALL: u32 = 0x0;
pub const CWP_SKIPINVISIBLE: u32 = 0x1;
pub const CWP_SKIPDISABLED: u32 = 0x2;
pub const CWP_SKIPTRANSPARENT: u32 = 0x4;
pub const CSC_UPDATECOMMANDS: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
pub const CSC_NAVIGATEFORWARD: i32 = 0x1;
pub const CSC_NAVIGATEBACK: i32 = 0x2;

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CreatedHdc {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl CreatedHdc {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for CreatedHdc {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for CreatedHdc {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct DatablockHeader {
    pub cb_size: u32,
    pub dw_signature: u32,
}
impl DatablockHeader {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::DATABLOCK_HEADER {
        let Self { cb_size, dw_signature } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::DATABLOCK_HEADER>() as _;
        let dwSignature = *dw_signature;
        windows_sys::Win32::UI::Shell::DATABLOCK_HEADER { cbSize, dwSignature }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::DATABLOCK_HEADER) -> Self {
        let windows_sys::Win32::UI::Shell::DATABLOCK_HEADER { cbSize, dwSignature } = win32;
        let cb_size = cbSize;
        let dw_signature = dwSignature;
        Self { cb_size, dw_signature }
    }
}
pub const DOGIF_DEFAULT: i32 = 0x0;
pub const DOGIF_TRAVERSE_LINK: i32 = 0x1;
pub const DOGIF_NO_HDROP: i32 = 0x2;
pub const DOGIF_NO_URL: i32 = 0x4;
pub const DOGIF_ONLY_IF_ONE: i32 = 0x8;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Datetimepickerinfo {
    pub cb_size: u32,
    pub rc_check: Rect,
    pub state_check: u32,
    pub rc_button: Rect,
    pub state_button: u32,
    pub hwnd_edit: Option<Hwnd>,
    pub hwnd_ud: Option<Hwnd>,
    pub hwnd_drop_down: Option<Hwnd>,
}
impl Datetimepickerinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::DATETIMEPICKERINFO {
        let Self { cb_size, rc_check, state_check, rc_button, state_button, hwnd_edit, hwnd_ud, hwnd_drop_down } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::DATETIMEPICKERINFO>() as _;
        let rcCheck = rc_check.to_win32();
        let stateCheck = *state_check;
        let rcButton = rc_button.to_win32();
        let stateButton = *state_button;
        let hwndEdit = hwnd_edit.map_or(0, Hwnd::into_raw);
        let hwndUD = hwnd_ud.map_or(0, Hwnd::into_raw);
        let hwndDropDown = hwnd_drop_down.map_or(0, Hwnd::into_raw);
        windows_sys::Win32::UI::Controls::DATETIMEPICKERINFO { cbSize, rcCheck, stateCheck, rcButton, stateButton, hwndEdit, hwndUD, hwndDropDown }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::DATETIMEPICKERINFO) -> Self {
        let windows_sys::Win32::UI::Controls::DATETIMEPICKERINFO { cbSize, rcCheck, stateCheck, rcButton, stateButton, hwndEdit, hwndUD, hwndDropDown } = win32;
        let cb_size = cbSize;
        let rc_check = unsafe { RECT::from_win32(rcCheck) };
        let state_check = stateCheck;
        let rc_button = unsafe { RECT::from_win32(rcButton) };
        let state_button = stateButton;
        let hwnd_edit = unsafe { Hwnd::new_optional(hwndEdit) };
        let hwnd_ud = unsafe { Hwnd::new_optional(hwndUD) };
        let hwnd_drop_down = unsafe { Hwnd::new_optional(hwndDropDown) };
        Self { cb_size, rc_check, state_check, rc_button, state_button, hwnd_edit, hwnd_ud, hwnd_drop_down }
    }
}
pub const LAYOUT_BITMAPORIENTATIONPRESERVED: u32 = 0x8;
pub const LAYOUT_RTL: u32 = 0x1;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Debughookinfo {
    pub id_thread: u32,
    pub id_thread_installer: u32,
    pub l_param: Lparam,
    pub w_param: Wparam,
    pub code: i32,
}
impl Debughookinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::DEBUGHOOKINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::DEBUGHOOKINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const DSFT_DETECT: i32 = 0x1;
pub const DSFT_PRIVATE: i32 = 0x2;
pub const DSFT_PUBLIC: i32 = 0x3;
pub const DFMR_DEFAULT: i32 = 0x0;
pub const DFMR_NO_STATIC_VERBS: i32 = 0x8;
pub const DFMR_STATIC_VERBS_ONLY: i32 = 0x10;
pub const DFMR_NO_RESOURCE_VERBS: i32 = 0x20;
pub const DFMR_OPTIN_HANDLERS_ONLY: i32 = 0x40;
pub const DFMR_RESOURCE_AND_FOLDER_VERBS_ONLY: i32 = 0x80;
pub const DFMR_USE_SPECIFIED_HANDLERS: i32 = 0x100;
pub const DFMR_USE_SPECIFIED_VERBS: i32 = 0x200;
pub const DFMR_NO_ASYNC_VERBS: i32 = 0x400;
pub const DFMR_NO_NATIVECPU_VERBS: i32 = 0x800;
pub const DFMR_NO_NONWOW_VERBS: i32 = 0x1000;
pub const DEFSHAREID_USERS: i32 = 0x1;
pub const DEFSHAREID_PUBLIC: i32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Delegateitemid {
    pub cb_size: u16,
    pub w_outer: u16,
    pub cb_inner: u16,
    pub rgb: [u8; 1],
}
impl Delegateitemid {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::DELEGATEITEMID {
        let Self { cb_size, w_outer, cb_inner, rgb } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::DELEGATEITEMID>() as _;
        let wOuter = *w_outer;
        let cbInner = *cb_inner;
        let rgb = [*rgb[0]];
        windows_sys::Win32::UI::Shell::DELEGATEITEMID { cbSize, wOuter, cbInner, rgb }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::DELEGATEITEMID) -> Self {
        let windows_sys::Win32::UI::Shell::DELEGATEITEMID { cbSize, wOuter, cbInner, rgb } = win32;
        let cb_size = cbSize;
        let w_outer = wOuter;
        let cb_inner = cbInner;
        let rgb = [rgb[0]];
        Self { cb_size, w_outer, cb_inner, rgb }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Deleteitemstruct {
    pub ctl_type: u32,
    pub ctl_id: u32,
    pub item_id: u32,
    pub hwnd_item: Option<Hwnd>,
    pub item_data: usize,
}
impl Deleteitemstruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::DELETEITEMSTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::DELETEITEMSTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Designvector {
    pub dv_reserved: u32,
    pub dv_num_axes: u32,
    pub dv_values: [i32; 16],
}
impl Designvector {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::DESIGNVECTOR {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::DESIGNVECTOR) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const DBID_BANDINFOCHANGED: i32 = 0x0;
pub const DBID_SHOWONLY: i32 = 0x1;
pub const DBID_MAXIMIZEBAND: i32 = 0x2;
pub const DBID_PUSHCHEVRON: i32 = 0x3;
pub const DBID_DELAYINIT: i32 = 0x4;
pub const DBID_FINISHINIT: i32 = 0x5;
pub const DBID_SETWINDOWTHEME: i32 = 0x6;
pub const DBID_PERMITAUTOHIDE: i32 = 0x7;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Deskbandinfo {
    pub dw_mask: u32,
    pub pt_min_size: Pointl,
    pub pt_max_size: Pointl,
    pub pt_integral: Pointl,
    pub pt_actual: Pointl,
    pub wsz_title: [u8; 256],
    pub dw_mode_flags: u32,
    pub cr_bkgnd: u32,
}
impl Deskbandinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::DESKBANDINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::DESKBANDINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const DSD_FORWARD: i32 = 0x0;
pub const DSD_BACKWARD: i32 = 0x1;
pub const DSO_SHUFFLEIMAGES: i32 = 0x1;
pub const DSS_ENABLED: i32 = 0x1;
pub const DSS_SLIDESHOW: i32 = 0x2;
pub const DSS_DISABLED_BY_REMOTE_SESSION: i32 = 0x4;
pub const DWPOS_CENTER: i32 = 0x0;
pub const DWPOS_TILE: i32 = 0x1;
pub const DWPOS_STRETCH: i32 = 0x2;
pub const DWPOS_FIT: i32 = 0x3;
pub const DWPOS_FILL: i32 = 0x4;
pub const DWPOS_SPAN: i32 = 0x5;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Devmodea {
    pub dm_device_name: [u8; 32],
    pub dm_spec_version: u16,
    pub dm_driver_version: u16,
    pub dm_size: u16,
    pub dm_driver_extra: u16,
    pub dm_fields: u32,
    pub anonymous1: Devmodea0,
    pub dm_color: i16,
    pub dm_duplex: i16,
    pub dm_y_resolution: i16,
    pub dm_tt_option: i16,
    pub dm_collate: i16,
    pub dm_form_name: [u8; 32],
    pub dm_log_pixels: u16,
    pub dm_bits_per_pel: u32,
    pub dm_pels_width: u32,
    pub dm_pels_height: u32,
    pub anonymous2: Anonymous2EStruct1,
    pub dm_display_frequency: u32,
    pub dm_icm_method: u32,
    pub dm_icm_intent: u32,
    pub dm_media_type: u32,
    pub dm_dither_type: u32,
    pub dm_reserved1: u32,
    pub dm_reserved2: u32,
    pub dm_panning_width: u32,
    pub dm_panning_height: u32,
}
impl Devmodea {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::DEVMODEA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::DEVMODEA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[repr(C)]
pub union Devmodea0 {
    pub field0: Anonymous1EStruct,
    pub field1: Anonymous2EStruct,
}
impl Devmodea0 {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::DEVMODEA_0 {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::DEVMODEA_0) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Anonymous1EStruct {
    pub dm_orientation: i16,
    pub dm_paper_size: i16,
    pub dm_paper_length: i16,
    pub dm_paper_width: i16,
    pub dm_scale: i16,
    pub dm_copies: i16,
    pub dm_default_source: i16,
    pub dm_print_quality: i16,
}
impl Anonymous1EStruct {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::_Anonymous1_e__Struct {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::_Anonymous1_e__Struct) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Anonymous2EStruct {
    pub dm_position: Pointl,
    pub dm_display_orientation: u32,
    pub dm_display_fixed_output: u32,
}
impl Anonymous2EStruct {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::_Anonymous2_e__Struct {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::_Anonymous2_e__Struct) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Devmodew {
    pub dm_device_name: [u8; 32],
    pub dm_spec_version: u16,
    pub dm_driver_version: u16,
    pub dm_size: u16,
    pub dm_driver_extra: u16,
    pub dm_fields: u32,
    pub anonymous1: Devmodew2,
    pub dm_color: i16,
    pub dm_duplex: i16,
    pub dm_y_resolution: i16,
    pub dm_tt_option: i16,
    pub dm_collate: i16,
    pub dm_form_name: [u8; 32],
    pub dm_log_pixels: u16,
    pub dm_bits_per_pel: u32,
    pub dm_pels_width: u32,
    pub dm_pels_height: u32,
    pub anonymous2: Anonymous2EStruct3,
    pub dm_display_frequency: u32,
    pub dm_icm_method: u32,
    pub dm_icm_intent: u32,
    pub dm_media_type: u32,
    pub dm_dither_type: u32,
    pub dm_reserved1: u32,
    pub dm_reserved2: u32,
    pub dm_panning_width: u32,
    pub dm_panning_height: u32,
}
impl Devmodew {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::DEVMODEW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::DEVMODEW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[repr(C)]
pub union Devmodew2 {
    pub field0: Anonymous1EStruct,
    pub field1: Anonymous2EStruct,
}
impl Devmodew2 {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::DEVMODEW_2 {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::DEVMODEW_2) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Anonymous1EStruct {
    pub dm_orientation: i16,
    pub dm_paper_size: i16,
    pub dm_paper_length: i16,
    pub dm_paper_width: i16,
    pub dm_scale: i16,
    pub dm_copies: i16,
    pub dm_default_source: i16,
    pub dm_print_quality: i16,
}
impl Anonymous1EStruct {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::_Anonymous1_e__Struct {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::_Anonymous1_e__Struct) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Anonymous2EStruct {
    pub dm_position: Pointl,
    pub dm_display_orientation: u32,
    pub dm_display_fixed_output: u32,
}
impl Anonymous2EStruct {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::_Anonymous2_e__Struct {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::_Anonymous2_e__Struct) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const DFCS_CAPTIONCLOSE: u32 = 0x0;
pub const DFCS_CAPTIONMIN: u32 = 0x1;
pub const DFCS_CAPTIONMAX: u32 = 0x2;
pub const DFCS_CAPTIONRESTORE: u32 = 0x3;
pub const DFCS_CAPTIONHELP: u32 = 0x4;
pub const DFCS_MENUARROW: u32 = 0x0;
pub const DFCS_MENUCHECK: u32 = 0x1;
pub const DFCS_MENUBULLET: u32 = 0x2;
pub const DFCS_MENUARROWRIGHT: u32 = 0x4;
pub const DFCS_SCROLLUP: u32 = 0x0;
pub const DFCS_SCROLLDOWN: u32 = 0x1;
pub const DFCS_SCROLLLEFT: u32 = 0x2;
pub const DFCS_SCROLLRIGHT: u32 = 0x3;
pub const DFCS_SCROLLCOMBOBOX: u32 = 0x5;
pub const DFCS_SCROLLSIZEGRIP: u32 = 0x8;
pub const DFCS_SCROLLSIZEGRIPRIGHT: u32 = 0x10;
pub const DFCS_BUTTONCHECK: u32 = 0x0;
pub const DFCS_BUTTONRADIOIMAGE: u32 = 0x1;
pub const DFCS_BUTTONRADIOMASK: u32 = 0x2;
pub const DFCS_BUTTONRADIO: u32 = 0x4;
pub const DFCS_BUTTON3STATE: u32 = 0x8;
pub const DFCS_BUTTONPUSH: u32 = 0x10;
pub const DFCS_INACTIVE: u32 = 0x100;
pub const DFCS_PUSHED: u32 = 0x200;
pub const DFCS_CHECKED: u32 = 0x400;
pub const DFCS_TRANSPARENT: u32 = 0x800;
pub const DFCS_HOT: u32 = 0x1000;
pub const DFCS_ADJUSTRECT: u32 = 0x2000;
pub const DFCS_FLAT: u32 = 0x4000;
pub const DFCS_MONO: u32 = 0x8000;
pub const DFC_CAPTION: u32 = 0x1;
pub const DFC_MENU: u32 = 0x2;
pub const DFC_SCROLL: u32 = 0x3;
pub const DFC_BUTTON: u32 = 0x4;
pub const DFC_POPUPMENU: u32 = 0x5;
pub const DFM_CMD_DELETE: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
pub const DFM_CMD_MOVE: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE;
pub const DFM_CMD_COPY: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD;
pub const DFM_CMD_LINK: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC;
pub const DFM_CMD_PROPERTIES: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB;
pub const DFM_CMD_NEWFOLDER: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA;
pub const DFM_CMD_PASTE: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF9;
pub const DFM_CMD_VIEWLIST: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8;
pub const DFM_CMD_VIEWDETAILS: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7;
pub const DFM_CMD_PASTELINK: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF6;
pub const DFM_CMD_PASTESPECIAL: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5;
pub const DFM_CMD_MODALPROP: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4;
pub const DFM_CMD_RENAME: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3;
pub const DFM_MERGECONTEXTMENU: i32 = 0x1;
pub const DFM_INVOKECOMMAND: i32 = 0x2;
pub const DFM_GETHELPTEXT: i32 = 0x5;
pub const DFM_WM_MEASUREITEM: i32 = 0x6;
pub const DFM_WM_DRAWITEM: i32 = 0x7;
pub const DFM_WM_INITMENUPOPUP: i32 = 0x8;
pub const DFM_VALIDATECMD: i32 = 0x9;
pub const DFM_MERGECONTEXTMENU_TOP: i32 = 0xA;
pub const DFM_GETHELPTEXTW: i32 = 0xB;
pub const DFM_INVOKECOMMANDEX: i32 = 0xC;
pub const DFM_MAPCOMMANDNAME: i32 = 0xD;
pub const DFM_GETDEFSTATICID: i32 = 0xE;
pub const DFM_GETVERBW: i32 = 0xF;
pub const DFM_GETVERBA: i32 = 0x10;
pub const DFM_MERGECONTEXTMENU_BOTTOM: i32 = 0x11;
pub const DFM_MODIFYQCMFLAGS: i32 = 0x12;
//  Not generated due to containing a void type
//  #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Dibsection<'a> {
//      pub ds_bm: Bitmap<'a>,
//      pub ds_bmih: Bitmapinfoheader,
//      pub ds_bitfields: [u32; 3],
//      pub dsh_section: Option<Handle>,
//      pub ds_offset: u32,
//  }
//  impl Dibsection {
//      fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::DIBSECTION {
//          let Self { ds_bm, ds_bmih, ds_bitfields, dsh_section, ds_offset } = self;
//          let dsBm = ds_bm.to_win32();
//          let dsBmih = ds_bmih.to_win32();
//          let dsBitfields = [*ds_bitfields[0],*ds_bitfields[1],*ds_bitfields[2]];
//          let dshSection = dsh_section.map_or(0, Handle::into_raw);
//          let dsOffset = *ds_offset;
//          windows_sys::Win32::Graphics::Gdi::DIBSECTION { dsBm, dsBmih, dsBitfields, dshSection, dsOffset }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::DIBSECTION) -> Self {
//          let windows_sys::Win32::Graphics::Gdi::DIBSECTION { dsBm, dsBmih, dsBitfields, dshSection, dsOffset } = win32;
//          let ds_bm = unsafe { BITMAP::from_win32(dsBm) };
//          let ds_bmih = unsafe { BITMAPINFOHEADER::from_win32(dsBmih) };
//          let ds_bitfields = [dsBitfields[0],dsBitfields[1],dsBitfields[2]];
//          let dsh_section = unsafe { Handle::new_optional(dshSection) };
//          let ds_offset = dsOffset;
//          Self { ds_bm, ds_bmih, ds_bitfields, dsh_section, ds_offset }
//      }
//  }
pub const DIB_RGB_COLORS: u32 = 0x0;
pub const DIB_PAL_COLORS: u32 = 0x1;
pub const DISPLAYCONFIG_COLOR_ENCODING_RGB: i32 = 0x0;
pub const DISPLAYCONFIG_COLOR_ENCODING_YCBCR444: i32 = 0x1;
pub const DISPLAYCONFIG_COLOR_ENCODING_YCBCR422: i32 = 0x2;
pub const DISPLAYCONFIG_COLOR_ENCODING_YCBCR420: i32 = 0x3;
pub const DISPLAYCONFIG_COLOR_ENCODING_INTENSITY: i32 = 0x4;
pub const DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct DisplayDevicea {
    pub cb: u32,
    pub device_name: [CHAR; 32],
    pub device_string: [CHAR; 128],
    pub state_flags: u32,
    pub device_id: [CHAR; 128],
    pub device_key: [CHAR; 128],
}
impl DisplayDevicea {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::DISPLAY_DEVICEA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::DISPLAY_DEVICEA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct DisplayDevicew {
    pub cb: u32,
    pub device_name: [u8; 32],
    pub device_string: [u8; 128],
    pub state_flags: u32,
    pub device_id: [u8; 128],
    pub device_key: [u8; 128],
}
impl DisplayDevicew {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::DISPLAY_DEVICEW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::DISPLAY_DEVICEW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const DEVICE_PRIMARY: i32 = 0x0;
pub const DEVICE_IMMERSIVE: i32 = 0x1;
pub const DISP_CHANGE_SUCCESSFUL: i32 = 0x0;
pub const DISP_CHANGE_RESTART: i32 = 0x1;
pub const DISP_CHANGE_FAILED: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
pub const DISP_CHANGE_BADMODE: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE;
pub const DISP_CHANGE_NOTUPDATED: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD;
pub const DISP_CHANGE_BADFLAGS: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC;
pub const DISP_CHANGE_BADPARAM: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB;
pub const DISP_CHANGE_BADDUALVIEW: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA;
pub const DI_MASK: u32 = 0x1;
pub const DI_IMAGE: u32 = 0x2;
pub const DI_NORMAL: u32 = 0x3;
pub const DI_COMPAT: u32 = 0x4;
pub const DI_DEFAULTSIZE: u32 = 0x8;
pub const DI_NOMIRROR: u32 = 0x10;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(2))]
pub struct Dlgitemtemplate {
    pub style: u32,
    pub dw_extended_style: u32,
    pub x: i16,
    pub y: i16,
    pub cx: i16,
    pub cy: i16,
    pub id: u16,
}
impl Dlgitemtemplate {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::DLGITEMTEMPLATE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::DLGITEMTEMPLATE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(2))]
pub struct Dlgtemplate {
    pub style: u32,
    pub dw_extended_style: u32,
    pub cdit: u16,
    pub x: i16,
    pub y: i16,
    pub cx: i16,
    pub cy: i16,
}
impl Dlgtemplate {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::DLGTEMPLATE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::DLGTEMPLATE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const BST_CHECKED: u32 = 0x1;
pub const BST_INDETERMINATE: u32 = 0x2;
pub const BST_UNCHECKED: u32 = 0x0;
pub const DDL_ARCHIVE: u32 = 0x20;
pub const DDL_DIRECTORY: u32 = 0x10;
pub const DDL_DRIVES: u32 = 0x4000;
pub const DDL_EXCLUSIVE: u32 = 0x8000;
pub const DDL_HIDDEN: u32 = 0x2;
pub const DDL_READONLY: u32 = 0x1;
pub const DDL_READWRITE: u32 = 0x0;
pub const DDL_SYSTEM: u32 = 0x4;
pub const DDL_POSTMSGS: u32 = 0x2000;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Dllversioninfo {
    pub cb_size: u32,
    pub dw_major_version: u32,
    pub dw_minor_version: u32,
    pub dw_build_number: u32,
    pub dw_platform_id: u32,
}
impl Dllversioninfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::DLLVERSIONINFO {
        let Self { cb_size, dw_major_version, dw_minor_version, dw_build_number, dw_platform_id } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::DLLVERSIONINFO>() as _;
        let dwMajorVersion = *dw_major_version;
        let dwMinorVersion = *dw_minor_version;
        let dwBuildNumber = *dw_build_number;
        let dwPlatformID = *dw_platform_id;
        windows_sys::Win32::UI::Shell::DLLVERSIONINFO { cbSize, dwMajorVersion, dwMinorVersion, dwBuildNumber, dwPlatformID }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::DLLVERSIONINFO) -> Self {
        let windows_sys::Win32::UI::Shell::DLLVERSIONINFO { cbSize, dwMajorVersion, dwMinorVersion, dwBuildNumber, dwPlatformID } = win32;
        let cb_size = cbSize;
        let dw_major_version = dwMajorVersion;
        let dw_minor_version = dwMinorVersion;
        let dw_build_number = dwBuildNumber;
        let dw_platform_id = dwPlatformID;
        Self { cb_size, dw_major_version, dw_minor_version, dw_build_number, dw_platform_id }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Dllversioninfo2 {
    pub info1: Dllversioninfo,
    pub dw_flags: u32,
    pub ull_version: u64,
}
impl Dllversioninfo2 {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::DLLVERSIONINFO2 {
        let Self { info1, dw_flags, ull_version } = self;
        let info1 = info1.to_win32();
        let dwFlags = *dw_flags;
        let ullVersion = *ull_version;
        windows_sys::Win32::UI::Shell::DLLVERSIONINFO2 { info1, dwFlags, ullVersion }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::DLLVERSIONINFO2) -> Self {
        let windows_sys::Win32::UI::Shell::DLLVERSIONINFO2 { info1, dwFlags, ullVersion } = win32;
        let info1 = unsafe { DLLVERSIONINFO::from_win32(info1) };
        let dw_flags = dwFlags;
        let ull_version = ullVersion;
        Self { info1, dw_flags, ull_version }
    }
}
pub const DPAMM_MERGE: u32 = 0x1;
pub const DPAMM_DELETE: u32 = 0x2;
pub const DPAMM_INSERT: u32 = 0x3;
//  Not generated due to containing a void type
//  #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Dpastreaminfo<'a> {
//      pub i_pos: i32,
//      pub pv_item: &'a mut todo_void,
//  }
//  impl Dpastreaminfo {
//      fn to_win32(&self) -> windows_sys::Win32::UI::Controls::DPASTREAMINFO {
//          let Self { i_pos, pv_item } = self;
//          let iPos = *i_pos;
//          let pvItem = unsafe { &mut *(pv_item as *mut _ as *mut _) };
//          windows_sys::Win32::UI::Controls::DPASTREAMINFO { iPos, pvItem }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::DPASTREAMINFO) -> Self {
//          let windows_sys::Win32::UI::Controls::DPASTREAMINFO { iPos, pvItem } = win32;
//          let i_pos = iPos;
//          let pv_item = unsafe { &mut *(pvItem as *mut _ as *mut _) };
//          Self { i_pos, pv_item }
//      }
//  }
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Draginfoa<'a> {
    pub u_size: u32,
    pub pt: Point,
    pub f_nc: BOOL,
    pub lp_file_list: Cow<'a, CStr>,
    pub grf_key_state: u32,
}
impl Draginfoa {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::DRAGINFOA {
        let Self { u_size, pt, f_nc, lp_file_list, grf_key_state } = self;
        let uSize = mem::size_of::<windows_sys::Win32::UI::Shell::DRAGINFOA>() as _;
        let pt = pt.to_win32();
        let fNC = f_nc;
        let lpFileList = lp_file_list.as_ptr();
        let grfKeyState = *grf_key_state;
        windows_sys::Win32::UI::Shell::DRAGINFOA { uSize, pt, fNC, lpFileList, grfKeyState }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::DRAGINFOA) -> Self {
        let windows_sys::Win32::UI::Shell::DRAGINFOA { uSize, pt, fNC, lpFileList, grfKeyState } = win32;
        let u_size = uSize;
        let pt = unsafe { POINT::from_win32(pt) };
        let f_nc = fNC;
        let lpFileList = unsafe { CStr::from_ptr(lpFileList) };
        let lpFileList = lpFileList.to_bytes_with_nul().to_vec();
        let lp_file_list = Cow::Owned(unsafe { CString::from_vec_unchecked(lpFileList) });
        let grf_key_state = grfKeyState;
        Self { u_size, pt, f_nc, lp_file_list, grf_key_state }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Draginfow<'a> {
    pub u_size: u32,
    pub pt: Point,
    pub f_nc: BOOL,
    pub lp_file_list: Cow<'a, [u16]>,
    pub grf_key_state: u32,
}
impl Draginfow {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::DRAGINFOW {
        let Self { u_size, pt, f_nc, lp_file_list, grf_key_state } = self;
        let uSize = mem::size_of::<windows_sys::Win32::UI::Shell::DRAGINFOW>() as _;
        let pt = pt.to_win32();
        let fNC = f_nc;
        assert_eq!(lp_file_list.last(), Some(0));
        let lpFileList = lp_file_list.as_ptr();
        let grfKeyState = *grf_key_state;
        windows_sys::Win32::UI::Shell::DRAGINFOW { uSize, pt, fNC, lpFileList, grfKeyState }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::DRAGINFOW) -> Self {
        let windows_sys::Win32::UI::Shell::DRAGINFOW { uSize, pt, fNC, lpFileList, grfKeyState } = win32;
        let u_size = uSize;
        let pt = unsafe { POINT::from_win32(pt) };
        let f_nc = fNC;
        let slen = unsafe { wide_strlen(lpFileList as *const u16) };
        let lpFileList = unsafe { slice::from_raw_parts(lpFileList, slen + 1) };
        let lp_file_list = lpFileList.to_vec();
        let grf_key_state = grfKeyState;
        Self { u_size, pt, f_nc, lp_file_list, grf_key_state }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Draglistinfo {
    pub u_notification: u32,
    pub h_wnd: Option<Hwnd>,
    pub pt_cursor: Point,
}
impl Draglistinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::DRAGLISTINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::DRAGLISTINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const DL_BEGINDRAG: u32 = 0x485;
pub const DL_CANCELDRAG: u32 = 0x488;
pub const DL_DRAGGING: u32 = 0x486;
pub const DL_DROPPED: u32 = 0x487;
pub const BDR_RAISEDOUTER: u32 = 0x1;
pub const BDR_SUNKENOUTER: u32 = 0x2;
pub const BDR_RAISEDINNER: u32 = 0x4;
pub const BDR_SUNKENINNER: u32 = 0x8;
pub const BDR_OUTER: u32 = 0x3;
pub const BDR_INNER: u32 = 0xC;
pub const BDR_RAISED: u32 = 0x5;
pub const BDR_SUNKEN: u32 = 0xA;
pub const EDGE_RAISED: u32 = 0x5;
pub const EDGE_SUNKEN: u32 = 0xA;
pub const EDGE_ETCHED: u32 = 0x6;
pub const EDGE_BUMP: u32 = 0x9;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Drawitemstruct {
    pub ctl_type: u32,
    pub ctl_id: u32,
    pub item_id: u32,
    pub item_action: u32,
    pub item_state: u32,
    pub hwnd_item: Option<Hwnd>,
    pub h_dc: Option<Hdc>,
    pub rc_item: Rect,
    pub item_data: usize,
}
impl Drawitemstruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::DRAWITEMSTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::DRAWITEMSTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const ODT_BUTTON: u32 = 0x4;
pub const ODT_COMBOBOX: u32 = 0x3;
pub const ODT_LISTBOX: u32 = 0x2;
pub const ODT_LISTVIEW: u32 = 0x66;
pub const ODT_MENU: u32 = 0x1;
pub const ODT_STATIC: u32 = 0x5;
pub const ODT_TAB: u32 = 0x65;
pub const DST_COMPLEX: u32 = 0x0;
pub const DST_TEXT: u32 = 0x1;
pub const DST_PREFIXTEXT: u32 = 0x2;
pub const DST_ICON: u32 = 0x3;
pub const DST_BITMAP: u32 = 0x4;
pub const DSS_NORMAL: u32 = 0x0;
pub const DSS_UNION: u32 = 0x10;
pub const DSS_DISABLED: u32 = 0x20;
pub const DSS_MONO: u32 = 0x80;
pub const DSS_HIDEPREFIX: u32 = 0x200;
pub const DSS_PREFIXONLY: u32 = 0x400;
pub const DSS_RIGHT: u32 = 0x8000;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Drawtextparams {
    pub cb_size: u32,
    pub i_tab_length: i32,
    pub i_left_margin: i32,
    pub i_right_margin: i32,
    pub ui_length_drawn: u32,
}
impl Drawtextparams {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::DRAWTEXTPARAMS {
        let Self { cb_size, i_tab_length, i_left_margin, i_right_margin, ui_length_drawn } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::DRAWTEXTPARAMS>() as _;
        let iTabLength = *i_tab_length;
        let iLeftMargin = *i_left_margin;
        let iRightMargin = *i_right_margin;
        let uiLengthDrawn = *ui_length_drawn;
        windows_sys::Win32::Graphics::Gdi::DRAWTEXTPARAMS { cbSize, iTabLength, iLeftMargin, iRightMargin, uiLengthDrawn }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::DRAWTEXTPARAMS) -> Self {
        let windows_sys::Win32::Graphics::Gdi::DRAWTEXTPARAMS { cbSize, iTabLength, iLeftMargin, iRightMargin, uiLengthDrawn } = win32;
        let cb_size = cbSize;
        let i_tab_length = iTabLength;
        let i_left_margin = iLeftMargin;
        let i_right_margin = iRightMargin;
        let ui_length_drawn = uiLengthDrawn;
        Self { cb_size, i_tab_length, i_left_margin, i_right_margin, ui_length_drawn }
    }
}
pub const DC_ACTIVE: u32 = 0x1;
pub const DC_BUTTONS: u32 = 0x1000;
pub const DC_GRADIENT: u32 = 0x20;
pub const DC_ICON: u32 = 0x4;
pub const DC_INBUTTON: u32 = 0x10;
pub const DC_SMALLCAP: u32 = 0x2;
pub const DC_TEXT: u32 = 0x8;
pub const BF_ADJUST: u32 = 0x2000;
pub const BF_BOTTOM: u32 = 0x8;
pub const BF_BOTTOMLEFT: u32 = 0x9;
pub const BF_BOTTOMRIGHT: u32 = 0xC;
pub const BF_DIAGONAL: u32 = 0x10;
pub const BF_DIAGONAL_ENDBOTTOMLEFT: u32 = 0x19;
pub const BF_DIAGONAL_ENDBOTTOMRIGHT: u32 = 0x1C;
pub const BF_DIAGONAL_ENDTOPLEFT: u32 = 0x13;
pub const BF_DIAGONAL_ENDTOPRIGHT: u32 = 0x16;
pub const BF_FLAT: u32 = 0x4000;
pub const BF_LEFT: u32 = 0x1;
pub const BF_MIDDLE: u32 = 0x800;
pub const BF_MONO: u32 = 0x8000;
pub const BF_RECT: u32 = 0xF;
pub const BF_RIGHT: u32 = 0x4;
pub const BF_SOFT: u32 = 0x1000;
pub const BF_TOP: u32 = 0x2;
pub const BF_TOPLEFT: u32 = 0x3;
pub const BF_TOPRIGHT: u32 = 0x6;
pub const DT_BOTTOM: u32 = 0x8;
pub const DT_CALCRECT: u32 = 0x400;
pub const DT_CENTER: u32 = 0x1;
pub const DT_EDITCONTROL: u32 = 0x2000;
pub const DT_END_ELLIPSIS: u32 = 0x8000;
pub const DT_EXPANDTABS: u32 = 0x40;
pub const DT_EXTERNALLEADING: u32 = 0x200;
pub const DT_HIDEPREFIX: u32 = 0x100000;
pub const DT_INTERNAL: u32 = 0x1000;
pub const DT_LEFT: u32 = 0x0;
pub const DT_MODIFYSTRING: u32 = 0x10000;
pub const DT_NOCLIP: u32 = 0x100;
pub const DT_NOFULLWIDTHCHARBREAK: u32 = 0x80000;
pub const DT_NOPREFIX: u32 = 0x800;
pub const DT_PATH_ELLIPSIS: u32 = 0x4000;
pub const DT_PREFIXONLY: u32 = 0x200000;
pub const DT_RIGHT: u32 = 0x2;
pub const DT_RTLREADING: u32 = 0x20000;
pub const DT_SINGLELINE: u32 = 0x20;
pub const DT_TABSTOP: u32 = 0x80;
pub const DT_TOP: u32 = 0x0;
pub const DT_VCENTER: u32 = 0x4;
pub const DT_WORDBREAK: u32 = 0x10;
pub const DT_WORD_ELLIPSIS: u32 = 0x40000;
pub const DTPB_WINDOWDC: u32 = 0x1;
pub const DTPB_USECTLCOLORSTATIC: u32 = 0x2;
pub const DTPB_USEERASEBKGND: u32 = 0x4;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Dropdescription {
    pub r#type: i32,
    pub sz_message: [u8; 260],
    pub sz_insert: [u8; 260],
}
impl Dropdescription {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::DROPDESCRIPTION {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::DROPDESCRIPTION) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Dropfiles {
    pub p_files: u32,
    pub pt: Point,
    pub f_nc: BOOL,
    pub f_wide: BOOL,
}
impl Dropfiles {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::DROPFILES {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::DROPFILES) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const DROPIMAGE_INVALID: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
pub const DROPIMAGE_NONE: i32 = 0x0;
pub const DROPIMAGE_COPY: i32 = 0x1;
pub const DROPIMAGE_MOVE: i32 = 0x2;
pub const DROPIMAGE_LINK: i32 = 0x4;
pub const DROPIMAGE_LABEL: i32 = 0x6;
pub const DROPIMAGE_WARNING: i32 = 0x7;
pub const DROPIMAGE_NOIMAGE: i32 = 0x8;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Dropstruct {
    pub hwnd_source: Option<Hwnd>,
    pub hwnd_sink: Option<Hwnd>,
    pub w_fmt: u32,
    pub dw_data: usize,
    pub pt_drop: Point,
    pub dw_control_data: u32,
}
impl Dropstruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::DROPSTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::DROPSTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const DSH_ALLOWDROPDESCRIPTIONTEXT: i32 = 0x1;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Dsktlsystemtime {
    pub w_year: u16,
    pub w_month: u16,
    pub w_day_of_week: u16,
    pub w_day: u16,
    pub w_hour: u16,
    pub w_minute: u16,
    pub w_second: u16,
    pub w_milliseconds: u16,
    pub w_result: u16,
}
impl Dsktlsystemtime {
    fn to_win32(&self) -> windows_sys::Win32::System::Registry::DSKTLSYSTEMTIME {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::System::Registry::DSKTLSYSTEMTIME) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Dtbgopts {
    pub dw_size: u32,
    pub dw_flags: u32,
    pub rc_clip: Rect,
}
impl Dtbgopts {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::DTBGOPTS {
        let Self { dw_size, dw_flags, rc_clip } = self;
        let dwSize = mem::size_of::<windows_sys::Win32::UI::Controls::DTBGOPTS>() as _;
        let dwFlags = *dw_flags;
        let rcClip = rc_clip.to_win32();
        windows_sys::Win32::UI::Controls::DTBGOPTS { dwSize, dwFlags, rcClip }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::DTBGOPTS) -> Self {
        let windows_sys::Win32::UI::Controls::DTBGOPTS { dwSize, dwFlags, rcClip } = win32;
        let dw_size = dwSize;
        let dw_flags = dwFlags;
        let rc_clip = unsafe { RECT::from_win32(rcClip) };
        Self { dw_size, dw_flags, rc_clip }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Dttopts {
    pub dw_size: u32,
    pub dw_flags: u32,
    pub cr_text: u32,
    pub cr_border: u32,
    pub cr_shadow: u32,
    pub i_text_shadow_type: i32,
    pub pt_shadow_offset: Point,
    pub i_border_size: i32,
    pub i_font_prop_id: i32,
    pub i_color_prop_id: i32,
    pub i_state_id: i32,
    pub f_apply_overlay: BOOL,
    pub i_glow_size: i32,
    pub pfn_draw_text_callback: Option<unsafe extern "system" fn(HDC, PWSTR, i32, *mut RECT, u32, LPARAM) -> i32>,
    pub l_param: Lparam,
}
impl Dttopts {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::DTTOPTS {
        let Self { dw_size, dw_flags, cr_text, cr_border, cr_shadow, i_text_shadow_type, pt_shadow_offset, i_border_size, i_font_prop_id, i_color_prop_id, i_state_id, f_apply_overlay, i_glow_size, pfn_draw_text_callback, l_param } = self;
        let dwSize = mem::size_of::<windows_sys::Win32::UI::Controls::DTTOPTS>() as _;
        let dwFlags = *dw_flags;
        let crText = *cr_text;
        let crBorder = *cr_border;
        let crShadow = *cr_shadow;
        let iTextShadowType = *i_text_shadow_type;
        let ptShadowOffset = pt_shadow_offset.to_win32();
        let iBorderSize = *i_border_size;
        let iFontPropId = *i_font_prop_id;
        let iColorPropId = *i_color_prop_id;
        let iStateId = *i_state_id;
        let fApplyOverlay = f_apply_overlay;
        let iGlowSize = *i_glow_size;
        let pfnDrawTextCallback = Some(pfn_draw_text_callback);
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::Controls::DTTOPTS { dwSize, dwFlags, crText, crBorder, crShadow, iTextShadowType, ptShadowOffset, iBorderSize, iFontPropId, iColorPropId, iStateId, fApplyOverlay, iGlowSize, pfnDrawTextCallback, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::DTTOPTS) -> Self {
        let windows_sys::Win32::UI::Controls::DTTOPTS { dwSize, dwFlags, crText, crBorder, crShadow, iTextShadowType, ptShadowOffset, iBorderSize, iFontPropId, iColorPropId, iStateId, fApplyOverlay, iGlowSize, pfnDrawTextCallback, lParam } = win32;
        let dw_size = dwSize;
        let dw_flags = dwFlags;
        let cr_text = crText;
        let cr_border = crBorder;
        let cr_shadow = crShadow;
        let i_text_shadow_type = iTextShadowType;
        let pt_shadow_offset = unsafe { POINT::from_win32(ptShadowOffset) };
        let i_border_size = iBorderSize;
        let i_font_prop_id = iFontPropId;
        let i_color_prop_id = iColorPropId;
        let i_state_id = iStateId;
        let f_apply_overlay = fApplyOverlay;
        let i_glow_size = iGlowSize;
        let pfn_draw_text_callback = pfnDrawTextCallback;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { dw_size, dw_flags, cr_text, cr_border, cr_shadow, i_text_shadow_type, pt_shadow_offset, i_border_size, i_font_prop_id, i_color_prop_id, i_state_id, f_apply_overlay, i_glow_size, pfn_draw_text_callback, l_param }
    }
}
pub const DUPLICATE_CLOSE_SOURCE: u32 = 0x1;
pub const DUPLICATE_SAME_ACCESS: u32 = 0x2;
pub const EC_ENDOFLINE_DETECTFROMCONTENT: i32 = 0x0;
pub const EC_ENDOFLINE_CRLF: i32 = 0x1;
pub const EC_ENDOFLINE_CR: i32 = 0x2;
pub const EC_ENDOFLINE_LF: i32 = 0x3;
pub const ECHUIM_DESKTOP: i32 = 0x0;
pub const ECHUIM_IMMERSIVE: i32 = 0x1;
pub const ECHUIM_SYSTEM_LAUNCHER: i32 = 0x2;
pub const EC_SEARCHWEB_ENTRYPOINT_EXTERNAL: i32 = 0x0;
pub const EC_SEARCHWEB_ENTRYPOINT_CONTEXTMENU: i32 = 0x1;
pub const EGK_TOUCH: i32 = 0x0;
pub const EGK_KEYBOARD: i32 = 0x1;
pub const EGK_MOUSE: i32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Editballoontip<'a> {
    pub cb_struct: u32,
    pub psz_title: Cow<'a, [u16]>,
    pub psz_text: Cow<'a, [u16]>,
    pub tti_icon: u32,
}
impl Editballoontip {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::EDITBALLOONTIP {
        let Self { cb_struct, psz_title, psz_text, tti_icon } = self;
        let cbStruct = *cb_struct;
        assert_eq!(psz_title.last(), Some(0));
        let pszTitle = psz_title.as_ptr();
        assert_eq!(psz_text.last(), Some(0));
        let pszText = psz_text.as_ptr();
        let ttiIcon = tti_icon;
        windows_sys::Win32::UI::Controls::EDITBALLOONTIP { cbStruct, pszTitle, pszText, ttiIcon }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::EDITBALLOONTIP) -> Self {
        let windows_sys::Win32::UI::Controls::EDITBALLOONTIP { cbStruct, pszTitle, pszText, ttiIcon } = win32;
        let cb_struct = cbStruct;
        let slen = unsafe { wide_strlen(pszTitle as *const u16) };
        let pszTitle = unsafe { slice::from_raw_parts(pszTitle, slen + 1) };
        let psz_title = pszTitle.to_vec();
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = pszText.to_vec();
        let tti_icon = ttiIcon;
        Self { cb_struct, psz_title, psz_text, tti_icon }
    }
}
pub const TTI_ERROR: u32 = 0x3;
pub const TTI_INFO: u32 = 0x1;
pub const TTI_NONE: u32 = 0x0;
pub const TTI_WARNING: u32 = 0x2;
pub const TTI_INFO_LARGE: u32 = 0x4;
pub const TTI_WARNING_LARGE: u32 = 0x5;
pub const TTI_ERROR_LARGE: u32 = 0x6;
pub const EDIT_CONTROL_FEATURE_ENTERPRISE_DATA_PROTECTION_PASTE_SUPPORT: i32 = 0x0;
pub const EDIT_CONTROL_FEATURE_PASTE_NOTIFICATIONS: i32 = 0x1;
pub const EMBED_PREVIEWPRINT: u32 = 0x1;
pub const EMBED_EDITABLE: u32 = 0x2;
pub const EMBED_INSTALLABLE: u32 = 0x3;
pub const EMBED_NOEMBEDDING: u32 = 0x4;
pub const CHARSET_UNICODE: u32 = 0x1;
pub const CHARSET_SYMBOL: u32 = 0x2;
pub const EMP_MARKUPTEXT: i32 = 0x1;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emr {
    pub i_type: u32,
    pub n_size: u32,
}
impl Emr {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMR {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMR) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emralphablend {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub x_dest: i32,
    pub y_dest: i32,
    pub cx_dest: i32,
    pub cy_dest: i32,
    pub dw_rop: u32,
    pub x_src: i32,
    pub y_src: i32,
    pub xform_src: Xform,
    pub cr_bk_color_src: u32,
    pub i_usage_src: u32,
    pub off_bmi_src: u32,
    pub cb_bmi_src: u32,
    pub off_bits_src: u32,
    pub cb_bits_src: u32,
    pub cx_src: i32,
    pub cy_src: i32,
}
impl Emralphablend {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRALPHABLEND {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRALPHABLEND) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emranglearc {
    pub emr: Emr,
    pub ptl_center: Pointl,
    pub n_radius: u32,
    pub e_start_angle: f32,
    pub e_sweep_angle: f32,
}
impl Emranglearc {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRANGLEARC {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRANGLEARC) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrarc {
    pub emr: Emr,
    pub rcl_box: Rectl,
    pub ptl_start: Pointl,
    pub ptl_end: Pointl,
}
impl Emrarc {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRARC {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRARC) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrbitblt {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub x_dest: i32,
    pub y_dest: i32,
    pub cx_dest: i32,
    pub cy_dest: i32,
    pub dw_rop: u32,
    pub x_src: i32,
    pub y_src: i32,
    pub xform_src: Xform,
    pub cr_bk_color_src: u32,
    pub i_usage_src: u32,
    pub off_bmi_src: u32,
    pub cb_bmi_src: u32,
    pub off_bits_src: u32,
    pub cb_bits_src: u32,
}
impl Emrbitblt {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRBITBLT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRBITBLT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrcreatebrushindirect {
    pub emr: Emr,
    pub ih_brush: u32,
    pub lb: Logbrush32,
}
impl Emrcreatebrushindirect {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRCREATEBRUSHINDIRECT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRCREATEBRUSHINDIRECT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrcreatedibpatternbrushpt {
    pub emr: Emr,
    pub ih_brush: u32,
    pub i_usage: u32,
    pub off_bmi: u32,
    pub cb_bmi: u32,
    pub off_bits: u32,
    pub cb_bits: u32,
}
impl Emrcreatedibpatternbrushpt {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRCREATEDIBPATTERNBRUSHPT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRCREATEDIBPATTERNBRUSHPT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrcreatemonobrush {
    pub emr: Emr,
    pub ih_brush: u32,
    pub i_usage: u32,
    pub off_bmi: u32,
    pub cb_bmi: u32,
    pub off_bits: u32,
    pub cb_bits: u32,
}
impl Emrcreatemonobrush {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRCREATEMONOBRUSH {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRCREATEMONOBRUSH) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrcreatepalette {
    pub emr: Emr,
    pub ih_pal: u32,
    pub lgpl: Logpalette,
}
impl Emrcreatepalette {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRCREATEPALETTE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRCREATEPALETTE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrcreatepen {
    pub emr: Emr,
    pub ih_pen: u32,
    pub lopn: Logpen,
}
impl Emrcreatepen {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRCREATEPEN {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRCREATEPEN) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrellipse {
    pub emr: Emr,
    pub rcl_box: Rectl,
}
impl Emrellipse {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRELLIPSE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRELLIPSE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emreof {
    pub emr: Emr,
    pub n_pal_entries: u32,
    pub off_pal_entries: u32,
    pub n_size_last: u32,
}
impl Emreof {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMREOF {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMREOF) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrexcludecliprect {
    pub emr: Emr,
    pub rcl_clip: Rectl,
}
impl Emrexcludecliprect {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMREXCLUDECLIPRECT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMREXCLUDECLIPRECT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrextcreatefontindirectw {
    pub emr: Emr,
    pub ih_font: u32,
    pub elfw: Extlogfontw,
}
impl Emrextcreatefontindirectw {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMREXTCREATEFONTINDIRECTW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMREXTCREATEFONTINDIRECTW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrextcreatepen {
    pub emr: Emr,
    pub ih_pen: u32,
    pub off_bmi: u32,
    pub cb_bmi: u32,
    pub off_bits: u32,
    pub cb_bits: u32,
    pub elp: Extlogpen32,
}
impl Emrextcreatepen {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMREXTCREATEPEN {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMREXTCREATEPEN) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrextescape {
    pub emr: Emr,
    pub i_escape: i32,
    pub cb_esc_data: i32,
    pub esc_data: [u8; 1],
}
impl Emrextescape {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMREXTESCAPE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMREXTESCAPE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrextfloodfill {
    pub emr: Emr,
    pub ptl_start: Pointl,
    pub cr_color: u32,
    pub i_mode: u32,
}
impl Emrextfloodfill {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMREXTFLOODFILL {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMREXTFLOODFILL) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrextselectcliprgn {
    pub emr: Emr,
    pub cb_rgn_data: u32,
    pub i_mode: u32,
    pub rgn_data: [u8; 1],
}
impl Emrextselectcliprgn {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMREXTSELECTCLIPRGN {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMREXTSELECTCLIPRGN) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrexttextouta {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub i_graphics_mode: u32,
    pub ex_scale: f32,
    pub ey_scale: f32,
    pub emrtext: Emrtext,
}
impl Emrexttextouta {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMREXTTEXTOUTA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMREXTTEXTOUTA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrfillpath {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
}
impl Emrfillpath {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRFILLPATH {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRFILLPATH) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrfillrgn {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub cb_rgn_data: u32,
    pub ih_brush: u32,
    pub rgn_data: [u8; 1],
}
impl Emrfillrgn {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRFILLRGN {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRFILLRGN) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrformat {
    pub d_signature: u32,
    pub n_version: u32,
    pub cb_data: u32,
    pub off_data: u32,
}
impl Emrformat {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRFORMAT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRFORMAT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrframergn {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub cb_rgn_data: u32,
    pub ih_brush: u32,
    pub szl_stroke: Size,
    pub rgn_data: [u8; 1],
}
impl Emrframergn {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRFRAMERGN {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRFRAMERGN) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrgdicomment {
    pub emr: Emr,
    pub cb_data: u32,
    pub data: [u8; 1],
}
impl Emrgdicomment {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRGDICOMMENT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRGDICOMMENT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrglsboundedrecord {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub cb_data: u32,
    pub data: [u8; 1],
}
impl Emrglsboundedrecord {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRGLSBOUNDEDRECORD {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRGLSBOUNDEDRECORD) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrglsrecord {
    pub emr: Emr,
    pub cb_data: u32,
    pub data: [u8; 1],
}
impl Emrglsrecord {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRGLSRECORD {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRGLSRECORD) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrgradientfill {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub n_ver: u32,
    pub n_tri: u32,
    pub ul_mode: u32,
    pub ver: [Trivertex; 1],
}
impl Emrgradientfill {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRGRADIENTFILL {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRGRADIENTFILL) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrinvertrgn {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub cb_rgn_data: u32,
    pub rgn_data: [u8; 1],
}
impl Emrinvertrgn {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRINVERTRGN {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRINVERTRGN) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrlineto {
    pub emr: Emr,
    pub ptl: Pointl,
}
impl Emrlineto {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRLINETO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRLINETO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrmaskblt {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub x_dest: i32,
    pub y_dest: i32,
    pub cx_dest: i32,
    pub cy_dest: i32,
    pub dw_rop: u32,
    pub x_src: i32,
    pub y_src: i32,
    pub xform_src: Xform,
    pub cr_bk_color_src: u32,
    pub i_usage_src: u32,
    pub off_bmi_src: u32,
    pub cb_bmi_src: u32,
    pub off_bits_src: u32,
    pub cb_bits_src: u32,
    pub x_mask: i32,
    pub y_mask: i32,
    pub i_usage_mask: u32,
    pub off_bmi_mask: u32,
    pub cb_bmi_mask: u32,
    pub off_bits_mask: u32,
    pub cb_bits_mask: u32,
}
impl Emrmaskblt {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRMASKBLT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRMASKBLT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrmodifyworldtransform {
    pub emr: Emr,
    pub xform: Xform,
    pub i_mode: u32,
}
impl Emrmodifyworldtransform {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRMODIFYWORLDTRANSFORM {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRMODIFYWORLDTRANSFORM) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrnamedescape {
    pub emr: Emr,
    pub i_escape: i32,
    pub cb_driver: i32,
    pub cb_esc_data: i32,
    pub esc_data: [u8; 1],
}
impl Emrnamedescape {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRNAMEDESCAPE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRNAMEDESCAPE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emroffsetcliprgn {
    pub emr: Emr,
    pub ptl_offset: Pointl,
}
impl Emroffsetcliprgn {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMROFFSETCLIPRGN {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMROFFSETCLIPRGN) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrpixelformat {
    pub emr: Emr,
    pub pfd: Pixelformatdescriptor,
}
impl Emrpixelformat {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::OpenGL::EMRPIXELFORMAT {
        let Self { emr, pfd } = self;
        let emr = emr.to_win32();
        let pfd = pfd.to_win32();
        windows_sys::Win32::Graphics::OpenGL::EMRPIXELFORMAT { emr, pfd }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::OpenGL::EMRPIXELFORMAT) -> Self {
        let windows_sys::Win32::Graphics::OpenGL::EMRPIXELFORMAT { emr, pfd } = win32;
        let emr = unsafe { EMR::from_win32(emr) };
        let pfd = unsafe { PIXELFORMATDESCRIPTOR::from_win32(pfd) };
        Self { emr, pfd }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrplgblt {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub aptl_dest: [Pointl; 3],
    pub x_src: i32,
    pub y_src: i32,
    pub cx_src: i32,
    pub cy_src: i32,
    pub xform_src: Xform,
    pub cr_bk_color_src: u32,
    pub i_usage_src: u32,
    pub off_bmi_src: u32,
    pub cb_bmi_src: u32,
    pub off_bits_src: u32,
    pub cb_bits_src: u32,
    pub x_mask: i32,
    pub y_mask: i32,
    pub i_usage_mask: u32,
    pub off_bmi_mask: u32,
    pub cb_bmi_mask: u32,
    pub off_bits_mask: u32,
    pub cb_bits_mask: u32,
}
impl Emrplgblt {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRPLGBLT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRPLGBLT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrpolydraw {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub cptl: u32,
    pub aptl: [Pointl; 1],
    pub ab_types: [u8; 1],
}
impl Emrpolydraw {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRPOLYDRAW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRPOLYDRAW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrpolydraw16 {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub cpts: u32,
    pub apts: [Points; 1],
    pub ab_types: [u8; 1],
}
impl Emrpolydraw16 {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRPOLYDRAW16 {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRPOLYDRAW16) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrpolyline {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub cptl: u32,
    pub aptl: [Pointl; 1],
}
impl Emrpolyline {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRPOLYLINE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRPOLYLINE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrpolyline16 {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub cpts: u32,
    pub apts: [Points; 1],
}
impl Emrpolyline16 {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRPOLYLINE16 {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRPOLYLINE16) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrpolypolyline {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub n_polys: u32,
    pub cptl: u32,
    pub a_poly_counts: [u32; 1],
    pub aptl: [Pointl; 1],
}
impl Emrpolypolyline {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRPOLYPOLYLINE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRPOLYPOLYLINE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrpolypolyline16 {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub n_polys: u32,
    pub cpts: u32,
    pub a_poly_counts: [u32; 1],
    pub apts: [Points; 1],
}
impl Emrpolypolyline16 {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRPOLYPOLYLINE16 {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRPOLYPOLYLINE16) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrpolytextouta {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub i_graphics_mode: u32,
    pub ex_scale: f32,
    pub ey_scale: f32,
    pub c_strings: i32,
    pub aemrtext: [Emrtext; 1],
}
impl Emrpolytextouta {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRPOLYTEXTOUTA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRPOLYTEXTOUTA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrresizepalette {
    pub emr: Emr,
    pub ih_pal: u32,
    pub c_entries: u32,
}
impl Emrresizepalette {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRRESIZEPALETTE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRRESIZEPALETTE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrrestoredc {
    pub emr: Emr,
    pub i_relative: i32,
}
impl Emrrestoredc {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRRESTOREDC {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRRESTOREDC) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrroundrect {
    pub emr: Emr,
    pub rcl_box: Rectl,
    pub szl_corner: Size,
}
impl Emrroundrect {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRROUNDRECT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRROUNDRECT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrscaleviewportextex {
    pub emr: Emr,
    pub x_num: i32,
    pub x_denom: i32,
    pub y_num: i32,
    pub y_denom: i32,
}
impl Emrscaleviewportextex {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSCALEVIEWPORTEXTEX {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSCALEVIEWPORTEXTEX) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrselectclippath {
    pub emr: Emr,
    pub i_mode: u32,
}
impl Emrselectclippath {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSELECTCLIPPATH {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSELECTCLIPPATH) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrselectobject {
    pub emr: Emr,
    pub ih_object: u32,
}
impl Emrselectobject {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSELECTOBJECT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSELECTOBJECT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrselectpalette {
    pub emr: Emr,
    pub ih_pal: u32,
}
impl Emrselectpalette {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSELECTPALETTE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSELECTPALETTE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrsetarcdirection {
    pub emr: Emr,
    pub i_arc_direction: u32,
}
impl Emrsetarcdirection {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETARCDIRECTION {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETARCDIRECTION) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrsetcoloradjustment {
    pub emr: Emr,
    pub color_adjustment: Coloradjustment,
}
impl Emrsetcoloradjustment {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETCOLORADJUSTMENT {
        let Self { emr, color_adjustment } = self;
        let emr = emr.to_win32();
        let ColorAdjustment = color_adjustment.to_win32();
        windows_sys::Win32::Graphics::Gdi::EMRSETCOLORADJUSTMENT { emr, ColorAdjustment }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETCOLORADJUSTMENT) -> Self {
        let windows_sys::Win32::Graphics::Gdi::EMRSETCOLORADJUSTMENT { emr, ColorAdjustment } = win32;
        let emr = unsafe { EMR::from_win32(emr) };
        let color_adjustment = unsafe { COLORADJUSTMENT::from_win32(ColorAdjustment) };
        Self { emr, color_adjustment }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrsetcolorspace {
    pub emr: Emr,
    pub ih_cs: u32,
}
impl Emrsetcolorspace {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETCOLORSPACE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETCOLORSPACE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrsetdibitstodevice {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub x_dest: i32,
    pub y_dest: i32,
    pub x_src: i32,
    pub y_src: i32,
    pub cx_src: i32,
    pub cy_src: i32,
    pub off_bmi_src: u32,
    pub cb_bmi_src: u32,
    pub off_bits_src: u32,
    pub cb_bits_src: u32,
    pub i_usage_src: u32,
    pub i_start_scan: u32,
    pub c_scans: u32,
}
impl Emrsetdibitstodevice {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETDIBITSTODEVICE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETDIBITSTODEVICE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrseticmprofile {
    pub emr: Emr,
    pub dw_flags: u32,
    pub cb_name: u32,
    pub cb_data: u32,
    pub data: [u8; 1],
}
impl Emrseticmprofile {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETICMPROFILE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETICMPROFILE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrsetmapperflags {
    pub emr: Emr,
    pub dw_flags: u32,
}
impl Emrsetmapperflags {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETMAPPERFLAGS {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETMAPPERFLAGS) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrsetmiterlimit {
    pub emr: Emr,
    pub e_miter_limit: f32,
}
impl Emrsetmiterlimit {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETMITERLIMIT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETMITERLIMIT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrsetpaletteentries {
    pub emr: Emr,
    pub ih_pal: u32,
    pub i_start: u32,
    pub c_entries: u32,
    pub a_pal_entries: [Paletteentry; 1],
}
impl Emrsetpaletteentries {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETPALETTEENTRIES {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETPALETTEENTRIES) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrsetpixelv {
    pub emr: Emr,
    pub ptl_pixel: Pointl,
    pub cr_color: u32,
}
impl Emrsetpixelv {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETPIXELV {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETPIXELV) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrsettextcolor {
    pub emr: Emr,
    pub cr_color: u32,
}
impl Emrsettextcolor {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETTEXTCOLOR {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETTEXTCOLOR) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrsetviewportextex {
    pub emr: Emr,
    pub szl_extent: Size,
}
impl Emrsetviewportextex {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETVIEWPORTEXTEX {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETVIEWPORTEXTEX) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrsetviewportorgex {
    pub emr: Emr,
    pub ptl_origin: Pointl,
}
impl Emrsetviewportorgex {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETVIEWPORTORGEX {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETVIEWPORTORGEX) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrsetworldtransform {
    pub emr: Emr,
    pub xform: Xform,
}
impl Emrsetworldtransform {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETWORLDTRANSFORM {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETWORLDTRANSFORM) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrstretchblt {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub x_dest: i32,
    pub y_dest: i32,
    pub cx_dest: i32,
    pub cy_dest: i32,
    pub dw_rop: u32,
    pub x_src: i32,
    pub y_src: i32,
    pub xform_src: Xform,
    pub cr_bk_color_src: u32,
    pub i_usage_src: u32,
    pub off_bmi_src: u32,
    pub cb_bmi_src: u32,
    pub off_bits_src: u32,
    pub cb_bits_src: u32,
    pub cx_src: i32,
    pub cy_src: i32,
}
impl Emrstretchblt {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSTRETCHBLT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSTRETCHBLT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrstretchdibits {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub x_dest: i32,
    pub y_dest: i32,
    pub x_src: i32,
    pub y_src: i32,
    pub cx_src: i32,
    pub cy_src: i32,
    pub off_bmi_src: u32,
    pub cb_bmi_src: u32,
    pub off_bits_src: u32,
    pub cb_bits_src: u32,
    pub i_usage_src: u32,
    pub dw_rop: u32,
    pub cx_dest: i32,
    pub cy_dest: i32,
}
impl Emrstretchdibits {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSTRETCHDIBITS {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSTRETCHDIBITS) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrtext {
    pub ptl_reference: Pointl,
    pub n_chars: u32,
    pub off_string: u32,
    pub f_options: u32,
    pub rcl: Rectl,
    pub off_dx: u32,
}
impl Emrtext {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRTEXT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRTEXT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrtransparentblt {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub x_dest: i32,
    pub y_dest: i32,
    pub cx_dest: i32,
    pub cy_dest: i32,
    pub dw_rop: u32,
    pub x_src: i32,
    pub y_src: i32,
    pub xform_src: Xform,
    pub cr_bk_color_src: u32,
    pub i_usage_src: u32,
    pub off_bmi_src: u32,
    pub cb_bmi_src: u32,
    pub off_bits_src: u32,
    pub cb_bits_src: u32,
    pub cx_src: i32,
    pub cy_src: i32,
}
impl Emrtransparentblt {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRTRANSPARENTBLT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRTRANSPARENTBLT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const ESB_DISABLE_BOTH: u32 = 0x3;
pub const ESB_DISABLE_DOWN: u32 = 0x2;
pub const ESB_DISABLE_LEFT: u32 = 0x1;
pub const ESB_DISABLE_LTUP: u32 = 0x1;
pub const ESB_DISABLE_RIGHT: u32 = 0x2;
pub const ESB_DISABLE_RTDN: u32 = 0x2;
pub const ESB_DISABLE_UP: u32 = 0x1;
pub const ESB_ENABLE_BOTH: u32 = 0x0;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Enhmetaheader {
    pub i_type: u32,
    pub n_size: u32,
    pub rcl_bounds: Rectl,
    pub rcl_frame: Rectl,
    pub d_signature: u32,
    pub n_version: u32,
    pub n_bytes: u32,
    pub n_records: u32,
    pub n_handles: u16,
    pub s_reserved: u16,
    pub n_description: u32,
    pub off_description: u32,
    pub n_pal_entries: u32,
    pub szl_device: Size,
    pub szl_millimeters: Size,
    pub cb_pixel_format: u32,
    pub off_pixel_format: u32,
    pub b_open_gl: u32,
    pub szl_micrometers: Size,
}
impl Enhmetaheader {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::ENHMETAHEADER {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::ENHMETAHEADER) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Enhmetarecord {
    pub i_type: u32,
    pub n_size: u32,
    pub d_parm: [u32; 1],
}
impl Enhmetarecord {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::ENHMETARECORD {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::ENHMETARECORD) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Enumlogfonta {
    pub elf_log_font: Logfonta,
    pub elf_full_name: [u8; 64],
    pub elf_style: [u8; 32],
}
impl Enumlogfonta {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::ENUMLOGFONTA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::ENUMLOGFONTA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Enumlogfontexa {
    pub elf_log_font: Logfonta,
    pub elf_full_name: [u8; 64],
    pub elf_style: [u8; 32],
    pub elf_script: [u8; 32],
}
impl Enumlogfontexa {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::ENUMLOGFONTEXA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::ENUMLOGFONTEXA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Enumlogfontexdva {
    pub elf_enum_logfont_ex: Enumlogfontexa,
    pub elf_design_vector: Designvector,
}
impl Enumlogfontexdva {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::ENUMLOGFONTEXDVA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::ENUMLOGFONTEXDVA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Enumlogfontexdvw {
    pub elf_enum_logfont_ex: Enumlogfontexw,
    pub elf_design_vector: Designvector,
}
impl Enumlogfontexdvw {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::ENUMLOGFONTEXDVW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::ENUMLOGFONTEXDVW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Enumlogfontexw {
    pub elf_log_font: Logfontw,
    pub elf_full_name: [u8; 64],
    pub elf_style: [u8; 32],
    pub elf_script: [u8; 32],
}
impl Enumlogfontexw {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::ENUMLOGFONTEXW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::ENUMLOGFONTEXW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Enumlogfontw {
    pub elf_log_font: Logfontw,
    pub elf_full_name: [u8; 64],
    pub elf_style: [u8; 32],
}
impl Enumlogfontw {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::ENUMLOGFONTW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::ENUMLOGFONTW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Enumuilang<'a> {
    pub num_of_enum_ui_lang: u32,
    pub size_of_enum_ui_buffer: u32,
    pub p_enum_ui_buffer: &'a mut u16,
}
impl Enumuilang {
    fn to_win32(&self) -> windows_sys::Win32::System::LibraryLoader::ENUMUILANG {
        let Self { num_of_enum_ui_lang, size_of_enum_ui_buffer, p_enum_ui_buffer } = self;
        let NumOfEnumUILang = *num_of_enum_ui_lang;
        let SizeOfEnumUIBuffer = *size_of_enum_ui_buffer;
        let pEnumUIBuffer = unsafe { &mut *(p_enum_ui_buffer as *mut _ as *mut _) };
        windows_sys::Win32::System::LibraryLoader::ENUMUILANG { NumOfEnumUILang, SizeOfEnumUIBuffer, pEnumUIBuffer }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::System::LibraryLoader::ENUMUILANG) -> Self {
        let windows_sys::Win32::System::LibraryLoader::ENUMUILANG { NumOfEnumUILang, SizeOfEnumUIBuffer, pEnumUIBuffer } = win32;
        let num_of_enum_ui_lang = NumOfEnumUILang;
        let size_of_enum_ui_buffer = SizeOfEnumUIBuffer;
        let p_enum_ui_buffer = unsafe { &mut *(pEnumUIBuffer as *mut _ as *mut _) };
        Self { num_of_enum_ui_lang, size_of_enum_ui_buffer, p_enum_ui_buffer }
    }
}
pub const ENUM_CURRENT_SETTINGS: u32 = 0xFFFFFFFF;
pub const ENUM_REGISTRY_SETTINGS: u32 = 0xFFFFFFFE;
pub const ETO_OPAQUE: u32 = 0x2;
pub const ETO_CLIPPED: u32 = 0x4;
pub const ETO_GLYPH_INDEX: u32 = 0x10;
pub const ETO_RTLREADING: u32 = 0x80;
pub const ETO_NUMERICSLOCAL: u32 = 0x400;
pub const ETO_NUMERICSLATIN: u32 = 0x800;
pub const ETO_IGNORELANGUAGE: u32 = 0x1000;
pub const ETO_PDY: u32 = 0x2000;
pub const ETO_REVERSE_INDEX_MAP: u32 = 0x10000;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Eventmsg {
    pub message: u32,
    pub param_l: u32,
    pub param_h: u32,
    pub time: u32,
    pub hwnd: Option<Hwnd>,
}
impl Eventmsg {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::EVENTMSG {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::EVENTMSG) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct ExpDarwinLink {
    pub dbh: DatablockHeader,
    pub sz_darwin_id: [CHAR; 260],
    pub szw_darwin_id: [u8; 260],
}
impl ExpDarwinLink {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::EXP_DARWIN_LINK {
        let Self { dbh, sz_darwin_id, szw_darwin_id } = self;
        let dbh = dbh.to_win32();
        let szDarwinID = [sz_darwin_id[0],sz_darwin_id[1],sz_darwin_id[2],sz_darwin_id[3],sz_darwin_id[4],sz_darwin_id[5],sz_darwin_id[6],sz_darwin_id[7],sz_darwin_id[8],sz_darwin_id[9],sz_darwin_id[10],sz_darwin_id[11],sz_darwin_id[12],sz_darwin_id[13],sz_darwin_id[14],sz_darwin_id[15],sz_darwin_id[16],sz_darwin_id[17],sz_darwin_id[18],sz_darwin_id[19],sz_darwin_id[20],sz_darwin_id[21],sz_darwin_id[22],sz_darwin_id[23],sz_darwin_id[24],sz_darwin_id[25],sz_darwin_id[26],sz_darwin_id[27],sz_darwin_id[28],sz_darwin_id[29],sz_darwin_id[30],sz_darwin_id[31],sz_darwin_id[32],sz_darwin_id[33],sz_darwin_id[34],sz_darwin_id[35],sz_darwin_id[36],sz_darwin_id[37],sz_darwin_id[38],sz_darwin_id[39],sz_darwin_id[40],sz_darwin_id[41],sz_darwin_id[42],sz_darwin_id[43],sz_darwin_id[44],sz_darwin_id[45],sz_darwin_id[46],sz_darwin_id[47],sz_darwin_id[48],sz_darwin_id[49],sz_darwin_id[50],sz_darwin_id[51],sz_darwin_id[52],sz_darwin_id[53],sz_darwin_id[54],sz_darwin_id[55],sz_darwin_id[56],sz_darwin_id[57],sz_darwin_id[58],sz_darwin_id[59],sz_darwin_id[60],sz_darwin_id[61],sz_darwin_id[62],sz_darwin_id[63],sz_darwin_id[64],sz_darwin_id[65],sz_darwin_id[66],sz_darwin_id[67],sz_darwin_id[68],sz_darwin_id[69],sz_darwin_id[70],sz_darwin_id[71],sz_darwin_id[72],sz_darwin_id[73],sz_darwin_id[74],sz_darwin_id[75],sz_darwin_id[76],sz_darwin_id[77],sz_darwin_id[78],sz_darwin_id[79],sz_darwin_id[80],sz_darwin_id[81],sz_darwin_id[82],sz_darwin_id[83],sz_darwin_id[84],sz_darwin_id[85],sz_darwin_id[86],sz_darwin_id[87],sz_darwin_id[88],sz_darwin_id[89],sz_darwin_id[90],sz_darwin_id[91],sz_darwin_id[92],sz_darwin_id[93],sz_darwin_id[94],sz_darwin_id[95],sz_darwin_id[96],sz_darwin_id[97],sz_darwin_id[98],sz_darwin_id[99],sz_darwin_id[100],sz_darwin_id[101],sz_darwin_id[102],sz_darwin_id[103],sz_darwin_id[104],sz_darwin_id[105],sz_darwin_id[106],sz_darwin_id[107],sz_darwin_id[108],sz_darwin_id[109],sz_darwin_id[110],sz_darwin_id[111],sz_darwin_id[112],sz_darwin_id[113],sz_darwin_id[114],sz_darwin_id[115],sz_darwin_id[116],sz_darwin_id[117],sz_darwin_id[118],sz_darwin_id[119],sz_darwin_id[120],sz_darwin_id[121],sz_darwin_id[122],sz_darwin_id[123],sz_darwin_id[124],sz_darwin_id[125],sz_darwin_id[126],sz_darwin_id[127],sz_darwin_id[128],sz_darwin_id[129],sz_darwin_id[130],sz_darwin_id[131],sz_darwin_id[132],sz_darwin_id[133],sz_darwin_id[134],sz_darwin_id[135],sz_darwin_id[136],sz_darwin_id[137],sz_darwin_id[138],sz_darwin_id[139],sz_darwin_id[140],sz_darwin_id[141],sz_darwin_id[142],sz_darwin_id[143],sz_darwin_id[144],sz_darwin_id[145],sz_darwin_id[146],sz_darwin_id[147],sz_darwin_id[148],sz_darwin_id[149],sz_darwin_id[150],sz_darwin_id[151],sz_darwin_id[152],sz_darwin_id[153],sz_darwin_id[154],sz_darwin_id[155],sz_darwin_id[156],sz_darwin_id[157],sz_darwin_id[158],sz_darwin_id[159],sz_darwin_id[160],sz_darwin_id[161],sz_darwin_id[162],sz_darwin_id[163],sz_darwin_id[164],sz_darwin_id[165],sz_darwin_id[166],sz_darwin_id[167],sz_darwin_id[168],sz_darwin_id[169],sz_darwin_id[170],sz_darwin_id[171],sz_darwin_id[172],sz_darwin_id[173],sz_darwin_id[174],sz_darwin_id[175],sz_darwin_id[176],sz_darwin_id[177],sz_darwin_id[178],sz_darwin_id[179],sz_darwin_id[180],sz_darwin_id[181],sz_darwin_id[182],sz_darwin_id[183],sz_darwin_id[184],sz_darwin_id[185],sz_darwin_id[186],sz_darwin_id[187],sz_darwin_id[188],sz_darwin_id[189],sz_darwin_id[190],sz_darwin_id[191],sz_darwin_id[192],sz_darwin_id[193],sz_darwin_id[194],sz_darwin_id[195],sz_darwin_id[196],sz_darwin_id[197],sz_darwin_id[198],sz_darwin_id[199],sz_darwin_id[200],sz_darwin_id[201],sz_darwin_id[202],sz_darwin_id[203],sz_darwin_id[204],sz_darwin_id[205],sz_darwin_id[206],sz_darwin_id[207],sz_darwin_id[208],sz_darwin_id[209],sz_darwin_id[210],sz_darwin_id[211],sz_darwin_id[212],sz_darwin_id[213],sz_darwin_id[214],sz_darwin_id[215],sz_darwin_id[216],sz_darwin_id[217],sz_darwin_id[218],sz_darwin_id[219],sz_darwin_id[220],sz_darwin_id[221],sz_darwin_id[222],sz_darwin_id[223],sz_darwin_id[224],sz_darwin_id[225],sz_darwin_id[226],sz_darwin_id[227],sz_darwin_id[228],sz_darwin_id[229],sz_darwin_id[230],sz_darwin_id[231],sz_darwin_id[232],sz_darwin_id[233],sz_darwin_id[234],sz_darwin_id[235],sz_darwin_id[236],sz_darwin_id[237],sz_darwin_id[238],sz_darwin_id[239],sz_darwin_id[240],sz_darwin_id[241],sz_darwin_id[242],sz_darwin_id[243],sz_darwin_id[244],sz_darwin_id[245],sz_darwin_id[246],sz_darwin_id[247],sz_darwin_id[248],sz_darwin_id[249],sz_darwin_id[250],sz_darwin_id[251],sz_darwin_id[252],sz_darwin_id[253],sz_darwin_id[254],sz_darwin_id[255],sz_darwin_id[256],sz_darwin_id[257],sz_darwin_id[258],sz_darwin_id[259]];
        let szwDarwinID = [*szw_darwin_id[0],*szw_darwin_id[1],*szw_darwin_id[2],*szw_darwin_id[3],*szw_darwin_id[4],*szw_darwin_id[5],*szw_darwin_id[6],*szw_darwin_id[7],*szw_darwin_id[8],*szw_darwin_id[9],*szw_darwin_id[10],*szw_darwin_id[11],*szw_darwin_id[12],*szw_darwin_id[13],*szw_darwin_id[14],*szw_darwin_id[15],*szw_darwin_id[16],*szw_darwin_id[17],*szw_darwin_id[18],*szw_darwin_id[19],*szw_darwin_id[20],*szw_darwin_id[21],*szw_darwin_id[22],*szw_darwin_id[23],*szw_darwin_id[24],*szw_darwin_id[25],*szw_darwin_id[26],*szw_darwin_id[27],*szw_darwin_id[28],*szw_darwin_id[29],*szw_darwin_id[30],*szw_darwin_id[31],*szw_darwin_id[32],*szw_darwin_id[33],*szw_darwin_id[34],*szw_darwin_id[35],*szw_darwin_id[36],*szw_darwin_id[37],*szw_darwin_id[38],*szw_darwin_id[39],*szw_darwin_id[40],*szw_darwin_id[41],*szw_darwin_id[42],*szw_darwin_id[43],*szw_darwin_id[44],*szw_darwin_id[45],*szw_darwin_id[46],*szw_darwin_id[47],*szw_darwin_id[48],*szw_darwin_id[49],*szw_darwin_id[50],*szw_darwin_id[51],*szw_darwin_id[52],*szw_darwin_id[53],*szw_darwin_id[54],*szw_darwin_id[55],*szw_darwin_id[56],*szw_darwin_id[57],*szw_darwin_id[58],*szw_darwin_id[59],*szw_darwin_id[60],*szw_darwin_id[61],*szw_darwin_id[62],*szw_darwin_id[63],*szw_darwin_id[64],*szw_darwin_id[65],*szw_darwin_id[66],*szw_darwin_id[67],*szw_darwin_id[68],*szw_darwin_id[69],*szw_darwin_id[70],*szw_darwin_id[71],*szw_darwin_id[72],*szw_darwin_id[73],*szw_darwin_id[74],*szw_darwin_id[75],*szw_darwin_id[76],*szw_darwin_id[77],*szw_darwin_id[78],*szw_darwin_id[79],*szw_darwin_id[80],*szw_darwin_id[81],*szw_darwin_id[82],*szw_darwin_id[83],*szw_darwin_id[84],*szw_darwin_id[85],*szw_darwin_id[86],*szw_darwin_id[87],*szw_darwin_id[88],*szw_darwin_id[89],*szw_darwin_id[90],*szw_darwin_id[91],*szw_darwin_id[92],*szw_darwin_id[93],*szw_darwin_id[94],*szw_darwin_id[95],*szw_darwin_id[96],*szw_darwin_id[97],*szw_darwin_id[98],*szw_darwin_id[99],*szw_darwin_id[100],*szw_darwin_id[101],*szw_darwin_id[102],*szw_darwin_id[103],*szw_darwin_id[104],*szw_darwin_id[105],*szw_darwin_id[106],*szw_darwin_id[107],*szw_darwin_id[108],*szw_darwin_id[109],*szw_darwin_id[110],*szw_darwin_id[111],*szw_darwin_id[112],*szw_darwin_id[113],*szw_darwin_id[114],*szw_darwin_id[115],*szw_darwin_id[116],*szw_darwin_id[117],*szw_darwin_id[118],*szw_darwin_id[119],*szw_darwin_id[120],*szw_darwin_id[121],*szw_darwin_id[122],*szw_darwin_id[123],*szw_darwin_id[124],*szw_darwin_id[125],*szw_darwin_id[126],*szw_darwin_id[127],*szw_darwin_id[128],*szw_darwin_id[129],*szw_darwin_id[130],*szw_darwin_id[131],*szw_darwin_id[132],*szw_darwin_id[133],*szw_darwin_id[134],*szw_darwin_id[135],*szw_darwin_id[136],*szw_darwin_id[137],*szw_darwin_id[138],*szw_darwin_id[139],*szw_darwin_id[140],*szw_darwin_id[141],*szw_darwin_id[142],*szw_darwin_id[143],*szw_darwin_id[144],*szw_darwin_id[145],*szw_darwin_id[146],*szw_darwin_id[147],*szw_darwin_id[148],*szw_darwin_id[149],*szw_darwin_id[150],*szw_darwin_id[151],*szw_darwin_id[152],*szw_darwin_id[153],*szw_darwin_id[154],*szw_darwin_id[155],*szw_darwin_id[156],*szw_darwin_id[157],*szw_darwin_id[158],*szw_darwin_id[159],*szw_darwin_id[160],*szw_darwin_id[161],*szw_darwin_id[162],*szw_darwin_id[163],*szw_darwin_id[164],*szw_darwin_id[165],*szw_darwin_id[166],*szw_darwin_id[167],*szw_darwin_id[168],*szw_darwin_id[169],*szw_darwin_id[170],*szw_darwin_id[171],*szw_darwin_id[172],*szw_darwin_id[173],*szw_darwin_id[174],*szw_darwin_id[175],*szw_darwin_id[176],*szw_darwin_id[177],*szw_darwin_id[178],*szw_darwin_id[179],*szw_darwin_id[180],*szw_darwin_id[181],*szw_darwin_id[182],*szw_darwin_id[183],*szw_darwin_id[184],*szw_darwin_id[185],*szw_darwin_id[186],*szw_darwin_id[187],*szw_darwin_id[188],*szw_darwin_id[189],*szw_darwin_id[190],*szw_darwin_id[191],*szw_darwin_id[192],*szw_darwin_id[193],*szw_darwin_id[194],*szw_darwin_id[195],*szw_darwin_id[196],*szw_darwin_id[197],*szw_darwin_id[198],*szw_darwin_id[199],*szw_darwin_id[200],*szw_darwin_id[201],*szw_darwin_id[202],*szw_darwin_id[203],*szw_darwin_id[204],*szw_darwin_id[205],*szw_darwin_id[206],*szw_darwin_id[207],*szw_darwin_id[208],*szw_darwin_id[209],*szw_darwin_id[210],*szw_darwin_id[211],*szw_darwin_id[212],*szw_darwin_id[213],*szw_darwin_id[214],*szw_darwin_id[215],*szw_darwin_id[216],*szw_darwin_id[217],*szw_darwin_id[218],*szw_darwin_id[219],*szw_darwin_id[220],*szw_darwin_id[221],*szw_darwin_id[222],*szw_darwin_id[223],*szw_darwin_id[224],*szw_darwin_id[225],*szw_darwin_id[226],*szw_darwin_id[227],*szw_darwin_id[228],*szw_darwin_id[229],*szw_darwin_id[230],*szw_darwin_id[231],*szw_darwin_id[232],*szw_darwin_id[233],*szw_darwin_id[234],*szw_darwin_id[235],*szw_darwin_id[236],*szw_darwin_id[237],*szw_darwin_id[238],*szw_darwin_id[239],*szw_darwin_id[240],*szw_darwin_id[241],*szw_darwin_id[242],*szw_darwin_id[243],*szw_darwin_id[244],*szw_darwin_id[245],*szw_darwin_id[246],*szw_darwin_id[247],*szw_darwin_id[248],*szw_darwin_id[249],*szw_darwin_id[250],*szw_darwin_id[251],*szw_darwin_id[252],*szw_darwin_id[253],*szw_darwin_id[254],*szw_darwin_id[255],*szw_darwin_id[256],*szw_darwin_id[257],*szw_darwin_id[258],*szw_darwin_id[259]];
        windows_sys::Win32::UI::Shell::EXP_DARWIN_LINK { dbh, szDarwinID, szwDarwinID }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::EXP_DARWIN_LINK) -> Self {
        let windows_sys::Win32::UI::Shell::EXP_DARWIN_LINK { dbh, szDarwinID, szwDarwinID } = win32;
        let dbh = unsafe { DATABLOCK_HEADER::from_win32(dbh) };
        let sz_darwin_id = [szDarwinID[0],szDarwinID[1],szDarwinID[2],szDarwinID[3],szDarwinID[4],szDarwinID[5],szDarwinID[6],szDarwinID[7],szDarwinID[8],szDarwinID[9],szDarwinID[10],szDarwinID[11],szDarwinID[12],szDarwinID[13],szDarwinID[14],szDarwinID[15],szDarwinID[16],szDarwinID[17],szDarwinID[18],szDarwinID[19],szDarwinID[20],szDarwinID[21],szDarwinID[22],szDarwinID[23],szDarwinID[24],szDarwinID[25],szDarwinID[26],szDarwinID[27],szDarwinID[28],szDarwinID[29],szDarwinID[30],szDarwinID[31],szDarwinID[32],szDarwinID[33],szDarwinID[34],szDarwinID[35],szDarwinID[36],szDarwinID[37],szDarwinID[38],szDarwinID[39],szDarwinID[40],szDarwinID[41],szDarwinID[42],szDarwinID[43],szDarwinID[44],szDarwinID[45],szDarwinID[46],szDarwinID[47],szDarwinID[48],szDarwinID[49],szDarwinID[50],szDarwinID[51],szDarwinID[52],szDarwinID[53],szDarwinID[54],szDarwinID[55],szDarwinID[56],szDarwinID[57],szDarwinID[58],szDarwinID[59],szDarwinID[60],szDarwinID[61],szDarwinID[62],szDarwinID[63],szDarwinID[64],szDarwinID[65],szDarwinID[66],szDarwinID[67],szDarwinID[68],szDarwinID[69],szDarwinID[70],szDarwinID[71],szDarwinID[72],szDarwinID[73],szDarwinID[74],szDarwinID[75],szDarwinID[76],szDarwinID[77],szDarwinID[78],szDarwinID[79],szDarwinID[80],szDarwinID[81],szDarwinID[82],szDarwinID[83],szDarwinID[84],szDarwinID[85],szDarwinID[86],szDarwinID[87],szDarwinID[88],szDarwinID[89],szDarwinID[90],szDarwinID[91],szDarwinID[92],szDarwinID[93],szDarwinID[94],szDarwinID[95],szDarwinID[96],szDarwinID[97],szDarwinID[98],szDarwinID[99],szDarwinID[100],szDarwinID[101],szDarwinID[102],szDarwinID[103],szDarwinID[104],szDarwinID[105],szDarwinID[106],szDarwinID[107],szDarwinID[108],szDarwinID[109],szDarwinID[110],szDarwinID[111],szDarwinID[112],szDarwinID[113],szDarwinID[114],szDarwinID[115],szDarwinID[116],szDarwinID[117],szDarwinID[118],szDarwinID[119],szDarwinID[120],szDarwinID[121],szDarwinID[122],szDarwinID[123],szDarwinID[124],szDarwinID[125],szDarwinID[126],szDarwinID[127],szDarwinID[128],szDarwinID[129],szDarwinID[130],szDarwinID[131],szDarwinID[132],szDarwinID[133],szDarwinID[134],szDarwinID[135],szDarwinID[136],szDarwinID[137],szDarwinID[138],szDarwinID[139],szDarwinID[140],szDarwinID[141],szDarwinID[142],szDarwinID[143],szDarwinID[144],szDarwinID[145],szDarwinID[146],szDarwinID[147],szDarwinID[148],szDarwinID[149],szDarwinID[150],szDarwinID[151],szDarwinID[152],szDarwinID[153],szDarwinID[154],szDarwinID[155],szDarwinID[156],szDarwinID[157],szDarwinID[158],szDarwinID[159],szDarwinID[160],szDarwinID[161],szDarwinID[162],szDarwinID[163],szDarwinID[164],szDarwinID[165],szDarwinID[166],szDarwinID[167],szDarwinID[168],szDarwinID[169],szDarwinID[170],szDarwinID[171],szDarwinID[172],szDarwinID[173],szDarwinID[174],szDarwinID[175],szDarwinID[176],szDarwinID[177],szDarwinID[178],szDarwinID[179],szDarwinID[180],szDarwinID[181],szDarwinID[182],szDarwinID[183],szDarwinID[184],szDarwinID[185],szDarwinID[186],szDarwinID[187],szDarwinID[188],szDarwinID[189],szDarwinID[190],szDarwinID[191],szDarwinID[192],szDarwinID[193],szDarwinID[194],szDarwinID[195],szDarwinID[196],szDarwinID[197],szDarwinID[198],szDarwinID[199],szDarwinID[200],szDarwinID[201],szDarwinID[202],szDarwinID[203],szDarwinID[204],szDarwinID[205],szDarwinID[206],szDarwinID[207],szDarwinID[208],szDarwinID[209],szDarwinID[210],szDarwinID[211],szDarwinID[212],szDarwinID[213],szDarwinID[214],szDarwinID[215],szDarwinID[216],szDarwinID[217],szDarwinID[218],szDarwinID[219],szDarwinID[220],szDarwinID[221],szDarwinID[222],szDarwinID[223],szDarwinID[224],szDarwinID[225],szDarwinID[226],szDarwinID[227],szDarwinID[228],szDarwinID[229],szDarwinID[230],szDarwinID[231],szDarwinID[232],szDarwinID[233],szDarwinID[234],szDarwinID[235],szDarwinID[236],szDarwinID[237],szDarwinID[238],szDarwinID[239],szDarwinID[240],szDarwinID[241],szDarwinID[242],szDarwinID[243],szDarwinID[244],szDarwinID[245],szDarwinID[246],szDarwinID[247],szDarwinID[248],szDarwinID[249],szDarwinID[250],szDarwinID[251],szDarwinID[252],szDarwinID[253],szDarwinID[254],szDarwinID[255],szDarwinID[256],szDarwinID[257],szDarwinID[258],szDarwinID[259]];
        let szw_darwin_id = [szwDarwinID[0],szwDarwinID[1],szwDarwinID[2],szwDarwinID[3],szwDarwinID[4],szwDarwinID[5],szwDarwinID[6],szwDarwinID[7],szwDarwinID[8],szwDarwinID[9],szwDarwinID[10],szwDarwinID[11],szwDarwinID[12],szwDarwinID[13],szwDarwinID[14],szwDarwinID[15],szwDarwinID[16],szwDarwinID[17],szwDarwinID[18],szwDarwinID[19],szwDarwinID[20],szwDarwinID[21],szwDarwinID[22],szwDarwinID[23],szwDarwinID[24],szwDarwinID[25],szwDarwinID[26],szwDarwinID[27],szwDarwinID[28],szwDarwinID[29],szwDarwinID[30],szwDarwinID[31],szwDarwinID[32],szwDarwinID[33],szwDarwinID[34],szwDarwinID[35],szwDarwinID[36],szwDarwinID[37],szwDarwinID[38],szwDarwinID[39],szwDarwinID[40],szwDarwinID[41],szwDarwinID[42],szwDarwinID[43],szwDarwinID[44],szwDarwinID[45],szwDarwinID[46],szwDarwinID[47],szwDarwinID[48],szwDarwinID[49],szwDarwinID[50],szwDarwinID[51],szwDarwinID[52],szwDarwinID[53],szwDarwinID[54],szwDarwinID[55],szwDarwinID[56],szwDarwinID[57],szwDarwinID[58],szwDarwinID[59],szwDarwinID[60],szwDarwinID[61],szwDarwinID[62],szwDarwinID[63],szwDarwinID[64],szwDarwinID[65],szwDarwinID[66],szwDarwinID[67],szwDarwinID[68],szwDarwinID[69],szwDarwinID[70],szwDarwinID[71],szwDarwinID[72],szwDarwinID[73],szwDarwinID[74],szwDarwinID[75],szwDarwinID[76],szwDarwinID[77],szwDarwinID[78],szwDarwinID[79],szwDarwinID[80],szwDarwinID[81],szwDarwinID[82],szwDarwinID[83],szwDarwinID[84],szwDarwinID[85],szwDarwinID[86],szwDarwinID[87],szwDarwinID[88],szwDarwinID[89],szwDarwinID[90],szwDarwinID[91],szwDarwinID[92],szwDarwinID[93],szwDarwinID[94],szwDarwinID[95],szwDarwinID[96],szwDarwinID[97],szwDarwinID[98],szwDarwinID[99],szwDarwinID[100],szwDarwinID[101],szwDarwinID[102],szwDarwinID[103],szwDarwinID[104],szwDarwinID[105],szwDarwinID[106],szwDarwinID[107],szwDarwinID[108],szwDarwinID[109],szwDarwinID[110],szwDarwinID[111],szwDarwinID[112],szwDarwinID[113],szwDarwinID[114],szwDarwinID[115],szwDarwinID[116],szwDarwinID[117],szwDarwinID[118],szwDarwinID[119],szwDarwinID[120],szwDarwinID[121],szwDarwinID[122],szwDarwinID[123],szwDarwinID[124],szwDarwinID[125],szwDarwinID[126],szwDarwinID[127],szwDarwinID[128],szwDarwinID[129],szwDarwinID[130],szwDarwinID[131],szwDarwinID[132],szwDarwinID[133],szwDarwinID[134],szwDarwinID[135],szwDarwinID[136],szwDarwinID[137],szwDarwinID[138],szwDarwinID[139],szwDarwinID[140],szwDarwinID[141],szwDarwinID[142],szwDarwinID[143],szwDarwinID[144],szwDarwinID[145],szwDarwinID[146],szwDarwinID[147],szwDarwinID[148],szwDarwinID[149],szwDarwinID[150],szwDarwinID[151],szwDarwinID[152],szwDarwinID[153],szwDarwinID[154],szwDarwinID[155],szwDarwinID[156],szwDarwinID[157],szwDarwinID[158],szwDarwinID[159],szwDarwinID[160],szwDarwinID[161],szwDarwinID[162],szwDarwinID[163],szwDarwinID[164],szwDarwinID[165],szwDarwinID[166],szwDarwinID[167],szwDarwinID[168],szwDarwinID[169],szwDarwinID[170],szwDarwinID[171],szwDarwinID[172],szwDarwinID[173],szwDarwinID[174],szwDarwinID[175],szwDarwinID[176],szwDarwinID[177],szwDarwinID[178],szwDarwinID[179],szwDarwinID[180],szwDarwinID[181],szwDarwinID[182],szwDarwinID[183],szwDarwinID[184],szwDarwinID[185],szwDarwinID[186],szwDarwinID[187],szwDarwinID[188],szwDarwinID[189],szwDarwinID[190],szwDarwinID[191],szwDarwinID[192],szwDarwinID[193],szwDarwinID[194],szwDarwinID[195],szwDarwinID[196],szwDarwinID[197],szwDarwinID[198],szwDarwinID[199],szwDarwinID[200],szwDarwinID[201],szwDarwinID[202],szwDarwinID[203],szwDarwinID[204],szwDarwinID[205],szwDarwinID[206],szwDarwinID[207],szwDarwinID[208],szwDarwinID[209],szwDarwinID[210],szwDarwinID[211],szwDarwinID[212],szwDarwinID[213],szwDarwinID[214],szwDarwinID[215],szwDarwinID[216],szwDarwinID[217],szwDarwinID[218],szwDarwinID[219],szwDarwinID[220],szwDarwinID[221],szwDarwinID[222],szwDarwinID[223],szwDarwinID[224],szwDarwinID[225],szwDarwinID[226],szwDarwinID[227],szwDarwinID[228],szwDarwinID[229],szwDarwinID[230],szwDarwinID[231],szwDarwinID[232],szwDarwinID[233],szwDarwinID[234],szwDarwinID[235],szwDarwinID[236],szwDarwinID[237],szwDarwinID[238],szwDarwinID[239],szwDarwinID[240],szwDarwinID[241],szwDarwinID[242],szwDarwinID[243],szwDarwinID[244],szwDarwinID[245],szwDarwinID[246],szwDarwinID[247],szwDarwinID[248],szwDarwinID[249],szwDarwinID[250],szwDarwinID[251],szwDarwinID[252],szwDarwinID[253],szwDarwinID[254],szwDarwinID[255],szwDarwinID[256],szwDarwinID[257],szwDarwinID[258],szwDarwinID[259]];
        Self { dbh, sz_darwin_id, szw_darwin_id }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct ExpPropertystorage {
    pub cb_size: u32,
    pub dw_signature: u32,
    pub ab_property_storage: [u8; 1],
}
impl ExpPropertystorage {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::EXP_PROPERTYSTORAGE {
        let Self { cb_size, dw_signature, ab_property_storage } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::EXP_PROPERTYSTORAGE>() as _;
        let dwSignature = *dw_signature;
        let abPropertyStorage = [*ab_property_storage[0]];
        windows_sys::Win32::UI::Shell::EXP_PROPERTYSTORAGE { cbSize, dwSignature, abPropertyStorage }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::EXP_PROPERTYSTORAGE) -> Self {
        let windows_sys::Win32::UI::Shell::EXP_PROPERTYSTORAGE { cbSize, dwSignature, abPropertyStorage } = win32;
        let cb_size = cbSize;
        let dw_signature = dwSignature;
        let ab_property_storage = [abPropertyStorage[0]];
        Self { cb_size, dw_signature, ab_property_storage }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct ExpSpecialFolder {
    pub cb_size: u32,
    pub dw_signature: u32,
    pub id_special_folder: u32,
    pub cb_offset: u32,
}
impl ExpSpecialFolder {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::EXP_SPECIAL_FOLDER {
        let Self { cb_size, dw_signature, id_special_folder, cb_offset } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::EXP_SPECIAL_FOLDER>() as _;
        let dwSignature = *dw_signature;
        let idSpecialFolder = *id_special_folder;
        let cbOffset = *cb_offset;
        windows_sys::Win32::UI::Shell::EXP_SPECIAL_FOLDER { cbSize, dwSignature, idSpecialFolder, cbOffset }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::EXP_SPECIAL_FOLDER) -> Self {
        let windows_sys::Win32::UI::Shell::EXP_SPECIAL_FOLDER { cbSize, dwSignature, idSpecialFolder, cbOffset } = win32;
        let cb_size = cbSize;
        let dw_signature = dwSignature;
        let id_special_folder = idSpecialFolder;
        let cb_offset = cbOffset;
        Self { cb_size, dw_signature, id_special_folder, cb_offset }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct ExpSzLink {
    pub cb_size: u32,
    pub dw_signature: u32,
    pub sz_target: [CHAR; 260],
    pub swz_target: [u8; 260],
}
impl ExpSzLink {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::EXP_SZ_LINK {
        let Self { cb_size, dw_signature, sz_target, swz_target } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::EXP_SZ_LINK>() as _;
        let dwSignature = *dw_signature;
        let szTarget = [sz_target[0],sz_target[1],sz_target[2],sz_target[3],sz_target[4],sz_target[5],sz_target[6],sz_target[7],sz_target[8],sz_target[9],sz_target[10],sz_target[11],sz_target[12],sz_target[13],sz_target[14],sz_target[15],sz_target[16],sz_target[17],sz_target[18],sz_target[19],sz_target[20],sz_target[21],sz_target[22],sz_target[23],sz_target[24],sz_target[25],sz_target[26],sz_target[27],sz_target[28],sz_target[29],sz_target[30],sz_target[31],sz_target[32],sz_target[33],sz_target[34],sz_target[35],sz_target[36],sz_target[37],sz_target[38],sz_target[39],sz_target[40],sz_target[41],sz_target[42],sz_target[43],sz_target[44],sz_target[45],sz_target[46],sz_target[47],sz_target[48],sz_target[49],sz_target[50],sz_target[51],sz_target[52],sz_target[53],sz_target[54],sz_target[55],sz_target[56],sz_target[57],sz_target[58],sz_target[59],sz_target[60],sz_target[61],sz_target[62],sz_target[63],sz_target[64],sz_target[65],sz_target[66],sz_target[67],sz_target[68],sz_target[69],sz_target[70],sz_target[71],sz_target[72],sz_target[73],sz_target[74],sz_target[75],sz_target[76],sz_target[77],sz_target[78],sz_target[79],sz_target[80],sz_target[81],sz_target[82],sz_target[83],sz_target[84],sz_target[85],sz_target[86],sz_target[87],sz_target[88],sz_target[89],sz_target[90],sz_target[91],sz_target[92],sz_target[93],sz_target[94],sz_target[95],sz_target[96],sz_target[97],sz_target[98],sz_target[99],sz_target[100],sz_target[101],sz_target[102],sz_target[103],sz_target[104],sz_target[105],sz_target[106],sz_target[107],sz_target[108],sz_target[109],sz_target[110],sz_target[111],sz_target[112],sz_target[113],sz_target[114],sz_target[115],sz_target[116],sz_target[117],sz_target[118],sz_target[119],sz_target[120],sz_target[121],sz_target[122],sz_target[123],sz_target[124],sz_target[125],sz_target[126],sz_target[127],sz_target[128],sz_target[129],sz_target[130],sz_target[131],sz_target[132],sz_target[133],sz_target[134],sz_target[135],sz_target[136],sz_target[137],sz_target[138],sz_target[139],sz_target[140],sz_target[141],sz_target[142],sz_target[143],sz_target[144],sz_target[145],sz_target[146],sz_target[147],sz_target[148],sz_target[149],sz_target[150],sz_target[151],sz_target[152],sz_target[153],sz_target[154],sz_target[155],sz_target[156],sz_target[157],sz_target[158],sz_target[159],sz_target[160],sz_target[161],sz_target[162],sz_target[163],sz_target[164],sz_target[165],sz_target[166],sz_target[167],sz_target[168],sz_target[169],sz_target[170],sz_target[171],sz_target[172],sz_target[173],sz_target[174],sz_target[175],sz_target[176],sz_target[177],sz_target[178],sz_target[179],sz_target[180],sz_target[181],sz_target[182],sz_target[183],sz_target[184],sz_target[185],sz_target[186],sz_target[187],sz_target[188],sz_target[189],sz_target[190],sz_target[191],sz_target[192],sz_target[193],sz_target[194],sz_target[195],sz_target[196],sz_target[197],sz_target[198],sz_target[199],sz_target[200],sz_target[201],sz_target[202],sz_target[203],sz_target[204],sz_target[205],sz_target[206],sz_target[207],sz_target[208],sz_target[209],sz_target[210],sz_target[211],sz_target[212],sz_target[213],sz_target[214],sz_target[215],sz_target[216],sz_target[217],sz_target[218],sz_target[219],sz_target[220],sz_target[221],sz_target[222],sz_target[223],sz_target[224],sz_target[225],sz_target[226],sz_target[227],sz_target[228],sz_target[229],sz_target[230],sz_target[231],sz_target[232],sz_target[233],sz_target[234],sz_target[235],sz_target[236],sz_target[237],sz_target[238],sz_target[239],sz_target[240],sz_target[241],sz_target[242],sz_target[243],sz_target[244],sz_target[245],sz_target[246],sz_target[247],sz_target[248],sz_target[249],sz_target[250],sz_target[251],sz_target[252],sz_target[253],sz_target[254],sz_target[255],sz_target[256],sz_target[257],sz_target[258],sz_target[259]];
        let swzTarget = [*swz_target[0],*swz_target[1],*swz_target[2],*swz_target[3],*swz_target[4],*swz_target[5],*swz_target[6],*swz_target[7],*swz_target[8],*swz_target[9],*swz_target[10],*swz_target[11],*swz_target[12],*swz_target[13],*swz_target[14],*swz_target[15],*swz_target[16],*swz_target[17],*swz_target[18],*swz_target[19],*swz_target[20],*swz_target[21],*swz_target[22],*swz_target[23],*swz_target[24],*swz_target[25],*swz_target[26],*swz_target[27],*swz_target[28],*swz_target[29],*swz_target[30],*swz_target[31],*swz_target[32],*swz_target[33],*swz_target[34],*swz_target[35],*swz_target[36],*swz_target[37],*swz_target[38],*swz_target[39],*swz_target[40],*swz_target[41],*swz_target[42],*swz_target[43],*swz_target[44],*swz_target[45],*swz_target[46],*swz_target[47],*swz_target[48],*swz_target[49],*swz_target[50],*swz_target[51],*swz_target[52],*swz_target[53],*swz_target[54],*swz_target[55],*swz_target[56],*swz_target[57],*swz_target[58],*swz_target[59],*swz_target[60],*swz_target[61],*swz_target[62],*swz_target[63],*swz_target[64],*swz_target[65],*swz_target[66],*swz_target[67],*swz_target[68],*swz_target[69],*swz_target[70],*swz_target[71],*swz_target[72],*swz_target[73],*swz_target[74],*swz_target[75],*swz_target[76],*swz_target[77],*swz_target[78],*swz_target[79],*swz_target[80],*swz_target[81],*swz_target[82],*swz_target[83],*swz_target[84],*swz_target[85],*swz_target[86],*swz_target[87],*swz_target[88],*swz_target[89],*swz_target[90],*swz_target[91],*swz_target[92],*swz_target[93],*swz_target[94],*swz_target[95],*swz_target[96],*swz_target[97],*swz_target[98],*swz_target[99],*swz_target[100],*swz_target[101],*swz_target[102],*swz_target[103],*swz_target[104],*swz_target[105],*swz_target[106],*swz_target[107],*swz_target[108],*swz_target[109],*swz_target[110],*swz_target[111],*swz_target[112],*swz_target[113],*swz_target[114],*swz_target[115],*swz_target[116],*swz_target[117],*swz_target[118],*swz_target[119],*swz_target[120],*swz_target[121],*swz_target[122],*swz_target[123],*swz_target[124],*swz_target[125],*swz_target[126],*swz_target[127],*swz_target[128],*swz_target[129],*swz_target[130],*swz_target[131],*swz_target[132],*swz_target[133],*swz_target[134],*swz_target[135],*swz_target[136],*swz_target[137],*swz_target[138],*swz_target[139],*swz_target[140],*swz_target[141],*swz_target[142],*swz_target[143],*swz_target[144],*swz_target[145],*swz_target[146],*swz_target[147],*swz_target[148],*swz_target[149],*swz_target[150],*swz_target[151],*swz_target[152],*swz_target[153],*swz_target[154],*swz_target[155],*swz_target[156],*swz_target[157],*swz_target[158],*swz_target[159],*swz_target[160],*swz_target[161],*swz_target[162],*swz_target[163],*swz_target[164],*swz_target[165],*swz_target[166],*swz_target[167],*swz_target[168],*swz_target[169],*swz_target[170],*swz_target[171],*swz_target[172],*swz_target[173],*swz_target[174],*swz_target[175],*swz_target[176],*swz_target[177],*swz_target[178],*swz_target[179],*swz_target[180],*swz_target[181],*swz_target[182],*swz_target[183],*swz_target[184],*swz_target[185],*swz_target[186],*swz_target[187],*swz_target[188],*swz_target[189],*swz_target[190],*swz_target[191],*swz_target[192],*swz_target[193],*swz_target[194],*swz_target[195],*swz_target[196],*swz_target[197],*swz_target[198],*swz_target[199],*swz_target[200],*swz_target[201],*swz_target[202],*swz_target[203],*swz_target[204],*swz_target[205],*swz_target[206],*swz_target[207],*swz_target[208],*swz_target[209],*swz_target[210],*swz_target[211],*swz_target[212],*swz_target[213],*swz_target[214],*swz_target[215],*swz_target[216],*swz_target[217],*swz_target[218],*swz_target[219],*swz_target[220],*swz_target[221],*swz_target[222],*swz_target[223],*swz_target[224],*swz_target[225],*swz_target[226],*swz_target[227],*swz_target[228],*swz_target[229],*swz_target[230],*swz_target[231],*swz_target[232],*swz_target[233],*swz_target[234],*swz_target[235],*swz_target[236],*swz_target[237],*swz_target[238],*swz_target[239],*swz_target[240],*swz_target[241],*swz_target[242],*swz_target[243],*swz_target[244],*swz_target[245],*swz_target[246],*swz_target[247],*swz_target[248],*swz_target[249],*swz_target[250],*swz_target[251],*swz_target[252],*swz_target[253],*swz_target[254],*swz_target[255],*swz_target[256],*swz_target[257],*swz_target[258],*swz_target[259]];
        windows_sys::Win32::UI::Shell::EXP_SZ_LINK { cbSize, dwSignature, szTarget, swzTarget }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::EXP_SZ_LINK) -> Self {
        let windows_sys::Win32::UI::Shell::EXP_SZ_LINK { cbSize, dwSignature, szTarget, swzTarget } = win32;
        let cb_size = cbSize;
        let dw_signature = dwSignature;
        let sz_target = [szTarget[0],szTarget[1],szTarget[2],szTarget[3],szTarget[4],szTarget[5],szTarget[6],szTarget[7],szTarget[8],szTarget[9],szTarget[10],szTarget[11],szTarget[12],szTarget[13],szTarget[14],szTarget[15],szTarget[16],szTarget[17],szTarget[18],szTarget[19],szTarget[20],szTarget[21],szTarget[22],szTarget[23],szTarget[24],szTarget[25],szTarget[26],szTarget[27],szTarget[28],szTarget[29],szTarget[30],szTarget[31],szTarget[32],szTarget[33],szTarget[34],szTarget[35],szTarget[36],szTarget[37],szTarget[38],szTarget[39],szTarget[40],szTarget[41],szTarget[42],szTarget[43],szTarget[44],szTarget[45],szTarget[46],szTarget[47],szTarget[48],szTarget[49],szTarget[50],szTarget[51],szTarget[52],szTarget[53],szTarget[54],szTarget[55],szTarget[56],szTarget[57],szTarget[58],szTarget[59],szTarget[60],szTarget[61],szTarget[62],szTarget[63],szTarget[64],szTarget[65],szTarget[66],szTarget[67],szTarget[68],szTarget[69],szTarget[70],szTarget[71],szTarget[72],szTarget[73],szTarget[74],szTarget[75],szTarget[76],szTarget[77],szTarget[78],szTarget[79],szTarget[80],szTarget[81],szTarget[82],szTarget[83],szTarget[84],szTarget[85],szTarget[86],szTarget[87],szTarget[88],szTarget[89],szTarget[90],szTarget[91],szTarget[92],szTarget[93],szTarget[94],szTarget[95],szTarget[96],szTarget[97],szTarget[98],szTarget[99],szTarget[100],szTarget[101],szTarget[102],szTarget[103],szTarget[104],szTarget[105],szTarget[106],szTarget[107],szTarget[108],szTarget[109],szTarget[110],szTarget[111],szTarget[112],szTarget[113],szTarget[114],szTarget[115],szTarget[116],szTarget[117],szTarget[118],szTarget[119],szTarget[120],szTarget[121],szTarget[122],szTarget[123],szTarget[124],szTarget[125],szTarget[126],szTarget[127],szTarget[128],szTarget[129],szTarget[130],szTarget[131],szTarget[132],szTarget[133],szTarget[134],szTarget[135],szTarget[136],szTarget[137],szTarget[138],szTarget[139],szTarget[140],szTarget[141],szTarget[142],szTarget[143],szTarget[144],szTarget[145],szTarget[146],szTarget[147],szTarget[148],szTarget[149],szTarget[150],szTarget[151],szTarget[152],szTarget[153],szTarget[154],szTarget[155],szTarget[156],szTarget[157],szTarget[158],szTarget[159],szTarget[160],szTarget[161],szTarget[162],szTarget[163],szTarget[164],szTarget[165],szTarget[166],szTarget[167],szTarget[168],szTarget[169],szTarget[170],szTarget[171],szTarget[172],szTarget[173],szTarget[174],szTarget[175],szTarget[176],szTarget[177],szTarget[178],szTarget[179],szTarget[180],szTarget[181],szTarget[182],szTarget[183],szTarget[184],szTarget[185],szTarget[186],szTarget[187],szTarget[188],szTarget[189],szTarget[190],szTarget[191],szTarget[192],szTarget[193],szTarget[194],szTarget[195],szTarget[196],szTarget[197],szTarget[198],szTarget[199],szTarget[200],szTarget[201],szTarget[202],szTarget[203],szTarget[204],szTarget[205],szTarget[206],szTarget[207],szTarget[208],szTarget[209],szTarget[210],szTarget[211],szTarget[212],szTarget[213],szTarget[214],szTarget[215],szTarget[216],szTarget[217],szTarget[218],szTarget[219],szTarget[220],szTarget[221],szTarget[222],szTarget[223],szTarget[224],szTarget[225],szTarget[226],szTarget[227],szTarget[228],szTarget[229],szTarget[230],szTarget[231],szTarget[232],szTarget[233],szTarget[234],szTarget[235],szTarget[236],szTarget[237],szTarget[238],szTarget[239],szTarget[240],szTarget[241],szTarget[242],szTarget[243],szTarget[244],szTarget[245],szTarget[246],szTarget[247],szTarget[248],szTarget[249],szTarget[250],szTarget[251],szTarget[252],szTarget[253],szTarget[254],szTarget[255],szTarget[256],szTarget[257],szTarget[258],szTarget[259]];
        let swz_target = [swzTarget[0],swzTarget[1],swzTarget[2],swzTarget[3],swzTarget[4],swzTarget[5],swzTarget[6],swzTarget[7],swzTarget[8],swzTarget[9],swzTarget[10],swzTarget[11],swzTarget[12],swzTarget[13],swzTarget[14],swzTarget[15],swzTarget[16],swzTarget[17],swzTarget[18],swzTarget[19],swzTarget[20],swzTarget[21],swzTarget[22],swzTarget[23],swzTarget[24],swzTarget[25],swzTarget[26],swzTarget[27],swzTarget[28],swzTarget[29],swzTarget[30],swzTarget[31],swzTarget[32],swzTarget[33],swzTarget[34],swzTarget[35],swzTarget[36],swzTarget[37],swzTarget[38],swzTarget[39],swzTarget[40],swzTarget[41],swzTarget[42],swzTarget[43],swzTarget[44],swzTarget[45],swzTarget[46],swzTarget[47],swzTarget[48],swzTarget[49],swzTarget[50],swzTarget[51],swzTarget[52],swzTarget[53],swzTarget[54],swzTarget[55],swzTarget[56],swzTarget[57],swzTarget[58],swzTarget[59],swzTarget[60],swzTarget[61],swzTarget[62],swzTarget[63],swzTarget[64],swzTarget[65],swzTarget[66],swzTarget[67],swzTarget[68],swzTarget[69],swzTarget[70],swzTarget[71],swzTarget[72],swzTarget[73],swzTarget[74],swzTarget[75],swzTarget[76],swzTarget[77],swzTarget[78],swzTarget[79],swzTarget[80],swzTarget[81],swzTarget[82],swzTarget[83],swzTarget[84],swzTarget[85],swzTarget[86],swzTarget[87],swzTarget[88],swzTarget[89],swzTarget[90],swzTarget[91],swzTarget[92],swzTarget[93],swzTarget[94],swzTarget[95],swzTarget[96],swzTarget[97],swzTarget[98],swzTarget[99],swzTarget[100],swzTarget[101],swzTarget[102],swzTarget[103],swzTarget[104],swzTarget[105],swzTarget[106],swzTarget[107],swzTarget[108],swzTarget[109],swzTarget[110],swzTarget[111],swzTarget[112],swzTarget[113],swzTarget[114],swzTarget[115],swzTarget[116],swzTarget[117],swzTarget[118],swzTarget[119],swzTarget[120],swzTarget[121],swzTarget[122],swzTarget[123],swzTarget[124],swzTarget[125],swzTarget[126],swzTarget[127],swzTarget[128],swzTarget[129],swzTarget[130],swzTarget[131],swzTarget[132],swzTarget[133],swzTarget[134],swzTarget[135],swzTarget[136],swzTarget[137],swzTarget[138],swzTarget[139],swzTarget[140],swzTarget[141],swzTarget[142],swzTarget[143],swzTarget[144],swzTarget[145],swzTarget[146],swzTarget[147],swzTarget[148],swzTarget[149],swzTarget[150],swzTarget[151],swzTarget[152],swzTarget[153],swzTarget[154],swzTarget[155],swzTarget[156],swzTarget[157],swzTarget[158],swzTarget[159],swzTarget[160],swzTarget[161],swzTarget[162],swzTarget[163],swzTarget[164],swzTarget[165],swzTarget[166],swzTarget[167],swzTarget[168],swzTarget[169],swzTarget[170],swzTarget[171],swzTarget[172],swzTarget[173],swzTarget[174],swzTarget[175],swzTarget[176],swzTarget[177],swzTarget[178],swzTarget[179],swzTarget[180],swzTarget[181],swzTarget[182],swzTarget[183],swzTarget[184],swzTarget[185],swzTarget[186],swzTarget[187],swzTarget[188],swzTarget[189],swzTarget[190],swzTarget[191],swzTarget[192],swzTarget[193],swzTarget[194],swzTarget[195],swzTarget[196],swzTarget[197],swzTarget[198],swzTarget[199],swzTarget[200],swzTarget[201],swzTarget[202],swzTarget[203],swzTarget[204],swzTarget[205],swzTarget[206],swzTarget[207],swzTarget[208],swzTarget[209],swzTarget[210],swzTarget[211],swzTarget[212],swzTarget[213],swzTarget[214],swzTarget[215],swzTarget[216],swzTarget[217],swzTarget[218],swzTarget[219],swzTarget[220],swzTarget[221],swzTarget[222],swzTarget[223],swzTarget[224],swzTarget[225],swzTarget[226],swzTarget[227],swzTarget[228],swzTarget[229],swzTarget[230],swzTarget[231],swzTarget[232],swzTarget[233],swzTarget[234],swzTarget[235],swzTarget[236],swzTarget[237],swzTarget[238],swzTarget[239],swzTarget[240],swzTarget[241],swzTarget[242],swzTarget[243],swzTarget[244],swzTarget[245],swzTarget[246],swzTarget[247],swzTarget[248],swzTarget[249],swzTarget[250],swzTarget[251],swzTarget[252],swzTarget[253],swzTarget[254],swzTarget[255],swzTarget[256],swzTarget[257],swzTarget[258],swzTarget[259]];
        Self { cb_size, dw_signature, sz_target, swz_target }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Extlogfonta {
    pub elf_log_font: Logfonta,
    pub elf_full_name: [u8; 64],
    pub elf_style: [u8; 32],
    pub elf_version: u32,
    pub elf_style_size: u32,
    pub elf_match: u32,
    pub elf_reserved: u32,
    pub elf_vendor_id: [u8; 4],
    pub elf_culture: u32,
    pub elf_panose: Panose,
}
impl Extlogfonta {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EXTLOGFONTA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EXTLOGFONTA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Extlogfontw {
    pub elf_log_font: Logfontw,
    pub elf_full_name: [u8; 64],
    pub elf_style: [u8; 32],
    pub elf_version: u32,
    pub elf_style_size: u32,
    pub elf_match: u32,
    pub elf_reserved: u32,
    pub elf_vendor_id: [u8; 4],
    pub elf_culture: u32,
    pub elf_panose: Panose,
}
impl Extlogfontw {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EXTLOGFONTW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EXTLOGFONTW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Extlogpen {
    pub elp_pen_style: u32,
    pub elp_width: u32,
    pub elp_brush_style: u32,
    pub elp_color: u32,
    pub elp_hatch: usize,
    pub elp_num_entries: u32,
    pub elp_style_entry: [u32; 1],
}
impl Extlogpen {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EXTLOGPEN {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EXTLOGPEN) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Extlogpen32 {
    pub elp_pen_style: u32,
    pub elp_width: u32,
    pub elp_brush_style: u32,
    pub elp_color: u32,
    pub elp_hatch: u32,
    pub elp_num_entries: u32,
    pub elp_style_entry: [u32; 1],
}
impl Extlogpen32 {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EXTLOGPEN32 {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EXTLOGPEN32) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Extrasearch {
    pub guid_search: GUID,
    pub wsz_friendly_name: [u8; 80],
    pub wsz_url: [u8; 2084],
}
impl Extrasearch {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::EXTRASEARCH {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::EXTRASEARCH) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const FLOODFILLBORDER: u32 = 0x0;
pub const FLOODFILLSURFACE: u32 = 0x1;
pub const FDAP_BOTTOM: i32 = 0x0;
pub const FDAP_TOP: i32 = 0x1;
pub const FDEOR_DEFAULT: i32 = 0x0;
pub const FDEOR_ACCEPT: i32 = 0x1;
pub const FDEOR_REFUSE: i32 = 0x2;
pub const FDESVR_DEFAULT: i32 = 0x0;
pub const FDESVR_ACCEPT: i32 = 0x1;
pub const FDESVR_REFUSE: i32 = 0x2;
pub const FD_CLSID: i32 = 0x1;
pub const FD_SIZEPOINT: i32 = 0x2;
pub const FD_ATTRIBUTES: i32 = 0x4;
pub const FD_CREATETIME: i32 = 0x8;
pub const FD_ACCESSTIME: i32 = 0x10;
pub const FD_WRITESTIME: i32 = 0x20;
pub const FD_FILESIZE: i32 = 0x40;
pub const FD_PROGRESSUI: i32 = 0x4000;
pub const FD_LINKUI: i32 = 0x8000;
pub const FD_UNICODE: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFF80000000;
pub const FEEDBACK_TOUCH_CONTACTVISUALIZATION: i32 = 0x1;
pub const FEEDBACK_PEN_BARRELVISUALIZATION: i32 = 0x2;
pub const FEEDBACK_PEN_TAP: i32 = 0x3;
pub const FEEDBACK_PEN_DOUBLETAP: i32 = 0x4;
pub const FEEDBACK_PEN_PRESSANDHOLD: i32 = 0x5;
pub const FEEDBACK_PEN_RIGHTTAP: i32 = 0x6;
pub const FEEDBACK_TOUCH_TAP: i32 = 0x7;
pub const FEEDBACK_TOUCH_DOUBLETAP: i32 = 0x8;
pub const FEEDBACK_TOUCH_PRESSANDHOLD: i32 = 0x9;
pub const FEEDBACK_TOUCH_RIGHTTAP: i32 = 0xA;
pub const FEEDBACK_GESTURE_PRESSANDTAP: i32 = 0xB;
pub const FEEDBACK_MAX: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
pub const FFFP_EXACTMATCH: i32 = 0x0;
pub const FFFP_NEARESTPARENTMATCH: i32 = 0x1;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Filedescriptora {
    pub dw_flags: u32,
    pub clsid: GUID,
    pub sizel: Size,
    pub pointl: Pointl,
    pub dw_file_attributes: u32,
    pub ft_creation_time: Filetime,
    pub ft_last_access_time: Filetime,
    pub ft_last_write_time: Filetime,
    pub n_file_size_high: u32,
    pub n_file_size_low: u32,
    pub c_file_name: [CHAR; 260],
}
impl Filedescriptora {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::FILEDESCRIPTORA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::FILEDESCRIPTORA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Filedescriptorw {
    pub dw_flags: u32,
    pub clsid: GUID,
    pub sizel: Size,
    pub pointl: Pointl,
    pub dw_file_attributes: u32,
    pub ft_creation_time: Filetime,
    pub ft_last_access_time: Filetime,
    pub ft_last_write_time: Filetime,
    pub n_file_size_high: u32,
    pub n_file_size_low: u32,
    pub c_file_name: [u8; 260],
}
impl Filedescriptorw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::FILEDESCRIPTORW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::FILEDESCRIPTORW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Filegroupdescriptora {
    pub c_items: u32,
    pub fgd: [Filedescriptora; 1],
}
impl Filegroupdescriptora {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::FILEGROUPDESCRIPTORA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::FILEGROUPDESCRIPTORA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Filegroupdescriptorw {
    pub c_items: u32,
    pub fgd: [Filedescriptorw; 1],
}
impl Filegroupdescriptorw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::FILEGROUPDESCRIPTORW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::FILEGROUPDESCRIPTORW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const FOS_OVERWRITEPROMPT: u32 = 0x2;
pub const FOS_STRICTFILETYPES: u32 = 0x4;
pub const FOS_NOCHANGEDIR: u32 = 0x8;
pub const FOS_PICKFOLDERS: u32 = 0x20;
pub const FOS_FORCEFILESYSTEM: u32 = 0x40;
pub const FOS_ALLNONSTORAGEITEMS: u32 = 0x80;
pub const FOS_NOVALIDATE: u32 = 0x100;
pub const FOS_ALLOWMULTISELECT: u32 = 0x200;
pub const FOS_PATHMUSTEXIST: u32 = 0x800;
pub const FOS_FILEMUSTEXIST: u32 = 0x1000;
pub const FOS_CREATEPROMPT: u32 = 0x2000;
pub const FOS_SHAREAWARE: u32 = 0x4000;
pub const FOS_NOREADONLYRETURN: u32 = 0x8000;
pub const FOS_NOTESTFILECREATE: u32 = 0x10000;
pub const FOS_HIDEMRUPLACES: u32 = 0x20000;
pub const FOS_HIDEPINNEDPLACES: u32 = 0x40000;
pub const FOS_NODEREFERENCELINKS: u32 = 0x100000;
pub const FOS_OKBUTTONNEEDSINTERACTION: u32 = 0x200000;
pub const FOS_DONTADDTORECENT: u32 = 0x2000000;
pub const FOS_FORCESHOWHIDDEN: u32 = 0x10000000;
pub const FOS_DEFAULTNOMINIMODE: u32 = 0x20000000;
pub const FOS_FORCEPREVIEWPANEON: u32 = 0x40000000;
pub const FOS_SUPPORTSTREAMABLEITEMS: u32 = 0x80000000;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Filetime {
    pub dw_low_date_time: u32,
    pub dw_high_date_time: u32,
}
impl Filetime {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::FILETIME {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::FILETIME) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const FTA_NONE: i32 = 0x0;
pub const FTA_EXCLUDE: i32 = 0x1;
pub const FTA_SHOW: i32 = 0x2;
pub const FTA_HAS_EXTENSION: i32 = 0x4;
pub const FTA_NO_EDIT: i32 = 0x8;
pub const FTA_NO_REMOVE: i32 = 0x10;
pub const FTA_NO_NEW_VERB: i32 = 0x20;
pub const FTA_NO_EDIT_VERB: i32 = 0x40;
pub const FTA_NO_REMOVE_VERB: i32 = 0x80;
pub const FTA_NO_EDIT_DESC: i32 = 0x100;
pub const FTA_NO_EDIT_ICON: i32 = 0x200;
pub const FTA_NO_EDIT_DFLT: i32 = 0x400;
pub const FTA_NO_EDIT_VERB_CMD: i32 = 0x800;
pub const FTA_NO_EDIT_VERB_EXE: i32 = 0x1000;
pub const FTA_NO_DDE: i32 = 0x2000;
pub const FTA_NO_EDIT_MIME: i32 = 0x8000;
pub const FTA_OPEN_IS_SAFE: i32 = 0x10000;
pub const FTA_ALWAYS_UNSAFE: i32 = 0x20000;
pub const FTA_NO_RECENT_DOCS: i32 = 0x100000;
pub const FTA_SAFE_FOR_ELEVATION: i32 = 0x200000;
pub const FTA_ALWAYS_USE_DIRECT_INVOKE: i32 = 0x400000;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct FileAttributesArray {
    pub c_items: u32,
    pub dw_sum_file_attributes: u32,
    pub dw_product_file_attributes: u32,
    pub rgdw_file_attributes: [u32; 1],
}
impl FileAttributesArray {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::FILE_ATTRIBUTES_ARRAY {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::FILE_ATTRIBUTES_ARRAY) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const FOF2_NONE: i32 = 0x0;
pub const FOF2_MERGEFOLDERSONCOLLISION: i32 = 0x1;
pub const FUT_PLAYING: i32 = 0x0;
pub const FUT_EDITING: i32 = 0x1;
pub const FUT_GENERIC: i32 = 0x2;
pub const FT_SOLID: i32 = 0x0;
pub const FT_VERTGRADIENT: i32 = 0x1;
pub const FT_HORZGRADIENT: i32 = 0x2;
pub const FT_RADIALGRADIENT: i32 = 0x3;
pub const FT_TILEIMAGE: i32 = 0x4;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Fixed {
    pub fract: u16,
    pub value: i16,
}
impl Fixed {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::FIXED {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::FIXED) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Flashwinfo {
    pub cb_size: u32,
    pub hwnd: Option<Hwnd>,
    pub dw_flags: u32,
    pub u_count: u32,
    pub dw_timeout: u32,
}
impl Flashwinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::FLASHWINFO {
        let Self { cb_size, hwnd, dw_flags, u_count, dw_timeout } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::FLASHWINFO>() as _;
        let hwnd = hwnd.map_or(0, Hwnd::into_raw);
        let dwFlags = dw_flags;
        let uCount = *u_count;
        let dwTimeout = *dw_timeout;
        windows_sys::Win32::UI::WindowsAndMessaging::FLASHWINFO { cbSize, hwnd, dwFlags, uCount, dwTimeout }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::FLASHWINFO) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::FLASHWINFO { cbSize, hwnd, dwFlags, uCount, dwTimeout } = win32;
        let cb_size = cbSize;
        let hwnd = unsafe { Hwnd::new_optional(hwnd) };
        let dw_flags = dwFlags;
        let u_count = uCount;
        let dw_timeout = dwTimeout;
        Self { cb_size, hwnd, dw_flags, u_count, dw_timeout }
    }
}
pub const FLASHW_ALL: u32 = 0x3;
pub const FLASHW_CAPTION: u32 = 0x1;
pub const FLASHW_STOP: u32 = 0x0;
pub const FLASHW_TIMER: u32 = 0x4;
pub const FLASHW_TIMERNOFG: u32 = 0xC;
pub const FLASHW_TRAY: u32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Float128 {
    pub low_part: i64,
    pub high_part: i64,
}
impl Float128 {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::FLOAT128 {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::FLOAT128) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const FP_DEFAULT: i32 = 0x0;
pub const FP_ABOVE: i32 = 0x1;
pub const FP_BELOW: i32 = 0x2;
pub const FP_LEFT: i32 = 0x3;
pub const FP_RIGHT: i32 = 0x4;
pub const FWF_NONE: i32 = 0x0;
pub const FWF_AUTOARRANGE: i32 = 0x1;
pub const FWF_ABBREVIATEDNAMES: i32 = 0x2;
pub const FWF_SNAPTOGRID: i32 = 0x4;
pub const FWF_OWNERDATA: i32 = 0x8;
pub const FWF_BESTFITWINDOW: i32 = 0x10;
pub const FWF_DESKTOP: i32 = 0x20;
pub const FWF_SINGLESEL: i32 = 0x40;
pub const FWF_NOSUBFOLDERS: i32 = 0x80;
pub const FWF_TRANSPARENT: i32 = 0x100;
pub const FWF_NOCLIENTEDGE: i32 = 0x200;
pub const FWF_NOSCROLL: i32 = 0x400;
pub const FWF_ALIGNLEFT: i32 = 0x800;
pub const FWF_NOICONS: i32 = 0x1000;
pub const FWF_SHOWSELALWAYS: i32 = 0x2000;
pub const FWF_NOVISIBLE: i32 = 0x4000;
pub const FWF_SINGLECLICKACTIVATE: i32 = 0x8000;
pub const FWF_NOWEBVIEW: i32 = 0x10000;
pub const FWF_HIDEFILENAMES: i32 = 0x20000;
pub const FWF_CHECKSELECT: i32 = 0x40000;
pub const FWF_NOENUMREFRESH: i32 = 0x80000;
pub const FWF_NOGROUPING: i32 = 0x100000;
pub const FWF_FULLROWSELECT: i32 = 0x200000;
pub const FWF_NOFILTERS: i32 = 0x400000;
pub const FWF_NOCOLUMNHEADER: i32 = 0x800000;
pub const FWF_NOHEADERINALLVIEWS: i32 = 0x1000000;
pub const FWF_EXTENDEDTILES: i32 = 0x2000000;
pub const FWF_TRICHECKSELECT: i32 = 0x4000000;
pub const FWF_AUTOCHECKSELECT: i32 = 0x8000000;
pub const FWF_NOBROWSERVIEWSTATE: i32 = 0x10000000;
pub const FWF_SUBSETGROUPS: i32 = 0x20000000;
pub const FWF_USESEARCHFOLDER: i32 = 0x40000000;
pub const FWF_ALLOWRTLREADING: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFF80000000;
pub const FLVM_UNSPECIFIED: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
pub const FLVM_FIRST: i32 = 0x1;
pub const FLVM_DETAILS: i32 = 0x1;
pub const FLVM_TILES: i32 = 0x2;
pub const FLVM_ICONS: i32 = 0x3;
pub const FLVM_LIST: i32 = 0x4;
pub const FLVM_CONTENT: i32 = 0x5;
pub const FLVM_LAST: i32 = 0x5;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Foldersetdata {
    pub fs: Foldersettings,
    pub vid_restore: GUID,
    pub dw_view_priority: u32,
}
impl Foldersetdata {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::FOLDERSETDATA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::FOLDERSETDATA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Foldersettings {
    pub view_mode: u32,
    pub f_flags: u32,
}
impl Foldersettings {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::FOLDERSETTINGS {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::FOLDERSETTINGS) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const FVM_AUTO: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
pub const FVM_FIRST: i32 = 0x1;
pub const FVM_ICON: i32 = 0x1;
pub const FVM_SMALLICON: i32 = 0x2;
pub const FVM_LIST: i32 = 0x3;
pub const FVM_DETAILS: i32 = 0x4;
pub const FVM_THUMBNAIL: i32 = 0x5;
pub const FVM_TILE: i32 = 0x6;
pub const FVM_THUMBSTRIP: i32 = 0x7;
pub const FVM_CONTENT: i32 = 0x8;
pub const FVM_LAST: i32 = 0x8;
pub const FVO_DEFAULT: i32 = 0x0;
pub const FVO_VISTALAYOUT: i32 = 0x1;
pub const FVO_CUSTOMPOSITION: i32 = 0x2;
pub const FVO_CUSTOMORDERING: i32 = 0x4;
pub const FVO_SUPPORTHYPERLINKS: i32 = 0x8;
pub const FVO_NOANIMATIONS: i32 = 0x10;
pub const FVO_NOSCROLLTIPS: i32 = 0x20;
pub const FEM_VIEWRESULT: i32 = 0x0;
pub const FEM_NAVIGATION: i32 = 0x1;
pub const CLIP_CHARACTER_PRECIS: u32 = 0x1;
pub const CLIP_DEFAULT_PRECIS: u32 = 0x0;
pub const CLIP_DFA_DISABLE: u32 = 0x40;
pub const CLIP_EMBEDDED: u32 = 0x80;
pub const CLIP_LH_ANGLES: u32 = 0x10;
pub const CLIP_MASK: u32 = 0xF;
pub const CLIP_STROKE_PRECIS: u32 = 0x2;
pub const CLIP_TT_ALWAYS: u32 = 0x20;
pub const LICENSE_PREVIEWPRINT: u32 = 0x4;
pub const LICENSE_EDITABLE: u32 = 0x8;
pub const LICENSE_INSTALLABLE: u32 = 0x0;
pub const LICENSE_NOEMBEDDING: u32 = 0x2;
pub const LICENSE_DEFAULT: u32 = 0x0;
pub const OUT_CHARACTER_PRECIS: u32 = 0x2;
pub const OUT_DEFAULT_PRECIS: u32 = 0x0;
pub const OUT_DEVICE_PRECIS: u32 = 0x5;
pub const OUT_OUTLINE_PRECIS: u32 = 0x8;
pub const OUT_PS_ONLY_PRECIS: u32 = 0xA;
pub const OUT_RASTER_PRECIS: u32 = 0x6;
pub const OUT_STRING_PRECIS: u32 = 0x1;
pub const OUT_STROKE_PRECIS: u32 = 0x3;
pub const OUT_TT_ONLY_PRECIS: u32 = 0x7;
pub const OUT_TT_PRECIS: u32 = 0x4;
pub const FF_DECORATIVE: u32 = 0x50;
pub const FF_DONTCARE: u32 = 0x0;
pub const FF_MODERN: u32 = 0x30;
pub const FF_ROMAN: u32 = 0x10;
pub const FF_SCRIPT: u32 = 0x40;
pub const FF_SWISS: u32 = 0x20;
pub const ANTIALIASED_QUALITY: u32 = 0x4;
pub const CLEARTYPE_QUALITY: u32 = 0x5;
pub const DEFAULT_QUALITY: u32 = 0x0;
pub const DRAFT_QUALITY: u32 = 0x1;
pub const NONANTIALIASED_QUALITY: u32 = 0x3;
pub const PROOF_QUALITY: u32 = 0x2;
pub const FR_PRIVATE: u32 = 0x10;
pub const FR_NOT_ENUM: u32 = 0x20;
pub const LSFW_LOCK: u32 = 0x1;
pub const LSFW_UNLOCK: u32 = 0x2;
pub const FVST_EMPTYTEXT: i32 = 0x0;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct GcpResultsa<'a> {
    pub l_struct_size: u32,
    pub lp_out_string: Cow<'a, CStr>,
    pub lp_order: &'a mut u32,
    pub lp_dx: &'a mut i32,
    pub lp_caret_pos: &'a mut i32,
    pub lp_class: Cow<'a, CStr>,
    pub lp_glyphs: Cow<'a, [u16]>,
    pub n_glyphs: u32,
    pub n_max_fit: i32,
}
impl GcpResultsa {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::GCP_RESULTSA {
        let Self { l_struct_size, lp_out_string, lp_order, lp_dx, lp_caret_pos, lp_class, lp_glyphs, n_glyphs, n_max_fit } = self;
        let lStructSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::GCP_RESULTSA>() as _;
        let lpOutString = lp_out_string.as_ptr();
        let lpOrder = unsafe { &mut *(lp_order as *mut _ as *mut _) };
        let lpDx = unsafe { &mut *(lp_dx as *mut _ as *mut _) };
        let lpCaretPos = unsafe { &mut *(lp_caret_pos as *mut _ as *mut _) };
        let lpClass = lp_class.as_ptr();
        assert_eq!(lp_glyphs.last(), Some(0));
        let lpGlyphs = lp_glyphs.as_ptr();
        let nGlyphs = *n_glyphs;
        let nMaxFit = *n_max_fit;
        windows_sys::Win32::Graphics::Gdi::GCP_RESULTSA { lStructSize, lpOutString, lpOrder, lpDx, lpCaretPos, lpClass, lpGlyphs, nGlyphs, nMaxFit }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::GCP_RESULTSA) -> Self {
        let windows_sys::Win32::Graphics::Gdi::GCP_RESULTSA { lStructSize, lpOutString, lpOrder, lpDx, lpCaretPos, lpClass, lpGlyphs, nGlyphs, nMaxFit } = win32;
        let l_struct_size = lStructSize;
        let lpOutString = unsafe { CStr::from_ptr(lpOutString) };
        let lpOutString = lpOutString.to_bytes_with_nul().to_vec();
        let lp_out_string = Cow::Owned(unsafe { CString::from_vec_unchecked(lpOutString) });
        let lp_order = unsafe { &mut *(lpOrder as *mut _ as *mut _) };
        let lp_dx = unsafe { &mut *(lpDx as *mut _ as *mut _) };
        let lp_caret_pos = unsafe { &mut *(lpCaretPos as *mut _ as *mut _) };
        let lpClass = unsafe { CStr::from_ptr(lpClass) };
        let lpClass = lpClass.to_bytes_with_nul().to_vec();
        let lp_class = Cow::Owned(unsafe { CString::from_vec_unchecked(lpClass) });
        let slen = unsafe { wide_strlen(lpGlyphs as *const u16) };
        let lpGlyphs = unsafe { slice::from_raw_parts(lpGlyphs, slen + 1) };
        let lp_glyphs = lpGlyphs.to_vec();
        let n_glyphs = nGlyphs;
        let n_max_fit = nMaxFit;
        Self { l_struct_size, lp_out_string, lp_order, lp_dx, lp_caret_pos, lp_class, lp_glyphs, n_glyphs, n_max_fit }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct GcpResultsw<'a> {
    pub l_struct_size: u32,
    pub lp_out_string: Cow<'a, [u16]>,
    pub lp_order: &'a mut u32,
    pub lp_dx: &'a mut i32,
    pub lp_caret_pos: &'a mut i32,
    pub lp_class: Cow<'a, CStr>,
    pub lp_glyphs: Cow<'a, [u16]>,
    pub n_glyphs: u32,
    pub n_max_fit: i32,
}
impl GcpResultsw {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::GCP_RESULTSW {
        let Self { l_struct_size, lp_out_string, lp_order, lp_dx, lp_caret_pos, lp_class, lp_glyphs, n_glyphs, n_max_fit } = self;
        let lStructSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::GCP_RESULTSW>() as _;
        assert_eq!(lp_out_string.last(), Some(0));
        let lpOutString = lp_out_string.as_ptr();
        let lpOrder = unsafe { &mut *(lp_order as *mut _ as *mut _) };
        let lpDx = unsafe { &mut *(lp_dx as *mut _ as *mut _) };
        let lpCaretPos = unsafe { &mut *(lp_caret_pos as *mut _ as *mut _) };
        let lpClass = lp_class.as_ptr();
        assert_eq!(lp_glyphs.last(), Some(0));
        let lpGlyphs = lp_glyphs.as_ptr();
        let nGlyphs = *n_glyphs;
        let nMaxFit = *n_max_fit;
        windows_sys::Win32::Graphics::Gdi::GCP_RESULTSW { lStructSize, lpOutString, lpOrder, lpDx, lpCaretPos, lpClass, lpGlyphs, nGlyphs, nMaxFit }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::GCP_RESULTSW) -> Self {
        let windows_sys::Win32::Graphics::Gdi::GCP_RESULTSW { lStructSize, lpOutString, lpOrder, lpDx, lpCaretPos, lpClass, lpGlyphs, nGlyphs, nMaxFit } = win32;
        let l_struct_size = lStructSize;
        let slen = unsafe { wide_strlen(lpOutString as *const u16) };
        let lpOutString = unsafe { slice::from_raw_parts(lpOutString, slen + 1) };
        let lp_out_string = lpOutString.to_vec();
        let lp_order = unsafe { &mut *(lpOrder as *mut _ as *mut _) };
        let lp_dx = unsafe { &mut *(lpDx as *mut _ as *mut _) };
        let lp_caret_pos = unsafe { &mut *(lpCaretPos as *mut _ as *mut _) };
        let lpClass = unsafe { CStr::from_ptr(lpClass) };
        let lpClass = lpClass.to_bytes_with_nul().to_vec();
        let lp_class = Cow::Owned(unsafe { CString::from_vec_unchecked(lpClass) });
        let slen = unsafe { wide_strlen(lpGlyphs as *const u16) };
        let lpGlyphs = unsafe { slice::from_raw_parts(lpGlyphs, slen + 1) };
        let lp_glyphs = lpGlyphs.to_vec();
        let n_glyphs = nGlyphs;
        let n_max_fit = nMaxFit;
        Self { l_struct_size, lp_out_string, lp_order, lp_dx, lp_caret_pos, lp_class, lp_glyphs, n_glyphs, n_max_fit }
    }
}
pub const IMAGE_BITMAP: u32 = 0x0;
pub const IMAGE_CURSOR: u32 = 0x2;
pub const IMAGE_ICON: u32 = 0x1;
pub const GA_PARENT: u32 = 0x1;
pub const GA_ROOT: u32 = 0x2;
pub const GA_ROOTOWNER: u32 = 0x3;
pub const GCP_CLASSIN: u32 = 0x80000;
pub const GCP_DIACRITIC: u32 = 0x100;
pub const GCP_DISPLAYZWG: u32 = 0x400000;
pub const GCP_GLYPHSHAPE: u32 = 0x10;
pub const GCP_JUSTIFY: u32 = 0x10000;
pub const GCP_KASHIDA: u32 = 0x400;
pub const GCP_LIGATE: u32 = 0x20;
pub const GCP_MAXEXTENT: u32 = 0x100000;
pub const GCP_NEUTRALOVERRIDE: u32 = 0x2000000;
pub const GCP_NUMERICOVERRIDE: u32 = 0x1000000;
pub const GCP_NUMERICSLATIN: u32 = 0x4000000;
pub const GCP_NUMERICSLOCAL: u32 = 0x8000000;
pub const GCP_REORDER: u32 = 0x2;
pub const GCP_SYMSWAPOFF: u32 = 0x800000;
pub const GCP_USEKERNING: u32 = 0x8;
pub const GCW_ATOM: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0;
pub const GCL_CBCLSEXTRA: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEC;
pub const GCL_CBWNDEXTRA: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEE;
pub const GCL_HBRBACKGROUND: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF6;
pub const GCL_HCURSOR: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4;
pub const GCL_HICON: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2;
pub const GCL_HICONSM: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDE;
pub const GCL_HMODULE: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0;
pub const GCL_MENUNAME: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8;
pub const GCL_STYLE: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE6;
pub const GCL_WNDPROC: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE8;
pub const GCLP_HBRBACKGROUND: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF6;
pub const GCLP_HCURSOR: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4;
pub const GCLP_HICON: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2;
pub const GCLP_HICONSM: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDE;
pub const GCLP_HMODULE: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0;
pub const GCLP_MENUNAME: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8;
pub const GCLP_WNDPROC: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE8;
pub const DCX_WINDOW: u32 = 0x1;
pub const DCX_CACHE: u32 = 0x2;
pub const DCX_PARENTCLIP: u32 = 0x20;
pub const DCX_CLIPSIBLINGS: u32 = 0x10;
pub const DCX_CLIPCHILDREN: u32 = 0x8;
pub const DCX_NORESETATTRS: u32 = 0x4;
pub const DCX_LOCKWINDOWUPDATE: u32 = 0x400;
pub const DCX_EXCLUDERGN: u32 = 0x40;
pub const DCX_INTERSECTRGN: u32 = 0x80;
pub const DCX_INTERSECTUPDATE: u32 = 0x200;
pub const DCX_VALIDATE: u32 = 0x200000;
pub const DRIVERVERSION: u32 = 0x0;
pub const TECHNOLOGY: u32 = 0x2;
pub const HORZSIZE: u32 = 0x4;
pub const VERTSIZE: u32 = 0x6;
pub const HORZRES: u32 = 0x8;
pub const VERTRES: u32 = 0xA;
pub const BITSPIXEL: u32 = 0xC;
pub const PLANES: u32 = 0xE;
pub const NUMBRUSHES: u32 = 0x10;
pub const NUMPENS: u32 = 0x12;
pub const NUMMARKERS: u32 = 0x14;
pub const NUMFONTS: u32 = 0x16;
pub const NUMCOLORS: u32 = 0x18;
pub const PDEVICESIZE: u32 = 0x1A;
pub const CURVECAPS: u32 = 0x1C;
pub const LINECAPS: u32 = 0x1E;
pub const POLYGONALCAPS: u32 = 0x20;
pub const TEXTCAPS: u32 = 0x22;
pub const CLIPCAPS: u32 = 0x24;
pub const RASTERCAPS: u32 = 0x26;
pub const ASPECTX: u32 = 0x28;
pub const ASPECTY: u32 = 0x2A;
pub const ASPECTXY: u32 = 0x2C;
pub const LOGPIXELSX: u32 = 0x58;
pub const LOGPIXELSY: u32 = 0x5A;
pub const SIZEPALETTE: u32 = 0x68;
pub const NUMRESERVED: u32 = 0x6A;
pub const COLORRES: u32 = 0x6C;
pub const PHYSICALWIDTH: u32 = 0x6E;
pub const PHYSICALHEIGHT: u32 = 0x6F;
pub const PHYSICALOFFSETX: u32 = 0x70;
pub const PHYSICALOFFSETY: u32 = 0x71;
pub const SCALINGFACTORX: u32 = 0x72;
pub const SCALINGFACTORY: u32 = 0x73;
pub const VREFRESH: u32 = 0x74;
pub const DESKTOPVERTRES: u32 = 0x75;
pub const DESKTOPHORZRES: u32 = 0x76;
pub const BLTALIGNMENT: u32 = 0x77;
pub const SHADEBLENDCAPS: u32 = 0x78;
pub const COLORMGMTCAPS: u32 = 0x79;
pub const GGO_BEZIER: u32 = 0x3;
pub const GGO_BITMAP: u32 = 0x1;
pub const GGO_GLYPH_INDEX: u32 = 0x80;
pub const GGO_GRAY2_BITMAP: u32 = 0x4;
pub const GGO_GRAY4_BITMAP: u32 = 0x5;
pub const GGO_GRAY8_BITMAP: u32 = 0x6;
pub const GGO_METRICS: u32 = 0x0;
pub const GGO_NATIVE: u32 = 0x2;
pub const GGO_UNHINTED: u32 = 0x100;
pub const GMDI_GOINTOPOPUPS: u32 = 0x2;
pub const GMDI_USEDISABLED: u32 = 0x1;
pub const BLACK_BRUSH: u32 = 0x4;
pub const DKGRAY_BRUSH: u32 = 0x3;
pub const DC_BRUSH: u32 = 0x12;
pub const GRAY_BRUSH: u32 = 0x2;
pub const HOLLOW_BRUSH: u32 = 0x5;
pub const LTGRAY_BRUSH: u32 = 0x1;
pub const NULL_BRUSH: u32 = 0x5;
pub const WHITE_BRUSH: u32 = 0x0;
pub const BLACK_PEN: u32 = 0x7;
pub const DC_PEN: u32 = 0x13;
pub const NULL_PEN: u32 = 0x8;
pub const WHITE_PEN: u32 = 0x6;
pub const ANSI_FIXED_FONT: u32 = 0xB;
pub const ANSI_VAR_FONT: u32 = 0xC;
pub const DEVICE_DEFAULT_FONT: u32 = 0xE;
pub const DEFAULT_GUI_FONT: u32 = 0x11;
pub const OEM_FIXED_FONT: u32 = 0xA;
pub const SYSTEM_FONT: u32 = 0xD;
pub const SYSTEM_FIXED_FONT: u32 = 0x10;
pub const DEFAULT_PALETTE: u32 = 0xF;
pub const GBF_DIRECT: u32 = 0x1;
pub const GBF_COPY: u32 = 0x2;
pub const GBF_VALIDBITS: u32 = 0x3;
pub const GW_CHILD: u32 = 0x5;
pub const GW_ENABLEDPOPUP: u32 = 0x6;
pub const GW_HWNDFIRST: u32 = 0x0;
pub const GW_HWNDLAST: u32 = 0x1;
pub const GW_HWNDNEXT: u32 = 0x2;
pub const GW_HWNDPREV: u32 = 0x3;
pub const GW_OWNER: u32 = 0x4;
pub const GFST_NONE: i32 = 0x0;
pub const GFST_SIZE: i32 = 0x1;
pub const GFST_DPI: i32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Glyphmetrics {
    pub gm_black_box_x: u32,
    pub gm_black_box_y: u32,
    pub gmpt_glyph_origin: Point,
    pub gm_cell_inc_x: i16,
    pub gm_cell_inc_y: i16,
}
impl Glyphmetrics {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::GLYPHMETRICS {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::GLYPHMETRICS) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Glyphmetricsfloat {
    pub gmf_black_box_x: f32,
    pub gmf_black_box_y: f32,
    pub gmfpt_glyph_origin: Pointfloat,
    pub gmf_cell_inc_x: f32,
    pub gmf_cell_inc_y: f32,
}
impl Glyphmetricsfloat {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::OpenGL::GLYPHMETRICSFLOAT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::OpenGL::GLYPHMETRICSFLOAT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Glyphset {
    pub cb_this: u32,
    pub fl_accel: u32,
    pub c_glyphs_supported: u32,
    pub c_ranges: u32,
    pub ranges: [Wcrange; 1],
}
impl Glyphset {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::GLYPHSET {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::GLYPHSET) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const GT_NONE: i32 = 0x0;
pub const GT_IMAGEGLYPH: i32 = 0x1;
pub const GT_FONTGLYPH: i32 = 0x2;
pub const GRADIENT_FILL_RECT_H: u32 = 0x0;
pub const GRADIENT_FILL_RECT_V: u32 = 0x1;
pub const GRADIENT_FILL_TRIANGLE: u32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct GradientRect {
    pub upper_left: u32,
    pub lower_right: u32,
}
impl GradientRect {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::GRADIENT_RECT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::GRADIENT_RECT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct GradientTriangle {
    pub vertex1: u32,
    pub vertex2: u32,
    pub vertex3: u32,
}
impl GradientTriangle {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::GRADIENT_TRIANGLE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::GRADIENT_TRIANGLE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const GM_COMPATIBLE: u32 = 0x1;
pub const GM_ADVANCED: u32 = 0x2;
pub const MCGCB_SELECTED: i32 = 0x1;
pub const MCGCB_HOT: i32 = 0x2;
pub const MCGCB_SELECTEDHOT: i32 = 0x3;
pub const MCGCB_SELECTEDNOTFOCUSED: i32 = 0x4;
pub const MCGCB_TODAY: i32 = 0x5;
pub const MCGCB_TODAYSELECTED: i32 = 0x6;
pub const MCGC_HOT: i32 = 0x1;
pub const MCGC_HASSTATE: i32 = 0x2;
pub const MCGC_HASSTATEHOT: i32 = 0x3;
pub const MCGC_TODAY: i32 = 0x4;
pub const MCGC_TODAYSELECTED: i32 = 0x5;
pub const MCGC_SELECTED: i32 = 0x6;
pub const MCGC_SELECTEDHOT: i32 = 0x7;
pub const MCGCU_HOT: i32 = 0x1;
pub const MCGCU_HASSTATE: i32 = 0x2;
pub const MCGCU_HASSTATEHOT: i32 = 0x3;
pub const MCGCU_SELECTED: i32 = 0x4;
pub const MCGCU_SELECTEDHOT: i32 = 0x5;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Guithreadinfo {
    pub cb_size: u32,
    pub flags: u32,
    pub hwnd_active: Option<Hwnd>,
    pub hwnd_focus: Option<Hwnd>,
    pub hwnd_capture: Option<Hwnd>,
    pub hwnd_menu_owner: Option<Hwnd>,
    pub hwnd_move_size: Option<Hwnd>,
    pub hwnd_caret: Option<Hwnd>,
    pub rc_caret: Rect,
}
impl Guithreadinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::GUITHREADINFO {
        let Self { cb_size, flags, hwnd_active, hwnd_focus, hwnd_capture, hwnd_menu_owner, hwnd_move_size, hwnd_caret, rc_caret } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::GUITHREADINFO>() as _;
        let flags = flags;
        let hwndActive = hwnd_active.map_or(0, Hwnd::into_raw);
        let hwndFocus = hwnd_focus.map_or(0, Hwnd::into_raw);
        let hwndCapture = hwnd_capture.map_or(0, Hwnd::into_raw);
        let hwndMenuOwner = hwnd_menu_owner.map_or(0, Hwnd::into_raw);
        let hwndMoveSize = hwnd_move_size.map_or(0, Hwnd::into_raw);
        let hwndCaret = hwnd_caret.map_or(0, Hwnd::into_raw);
        let rcCaret = rc_caret.to_win32();
        windows_sys::Win32::UI::WindowsAndMessaging::GUITHREADINFO { cbSize, flags, hwndActive, hwndFocus, hwndCapture, hwndMenuOwner, hwndMoveSize, hwndCaret, rcCaret }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::GUITHREADINFO) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::GUITHREADINFO { cbSize, flags, hwndActive, hwndFocus, hwndCapture, hwndMenuOwner, hwndMoveSize, hwndCaret, rcCaret } = win32;
        let cb_size = cbSize;
        let flags = flags;
        let hwnd_active = unsafe { Hwnd::new_optional(hwndActive) };
        let hwnd_focus = unsafe { Hwnd::new_optional(hwndFocus) };
        let hwnd_capture = unsafe { Hwnd::new_optional(hwndCapture) };
        let hwnd_menu_owner = unsafe { Hwnd::new_optional(hwndMenuOwner) };
        let hwnd_move_size = unsafe { Hwnd::new_optional(hwndMoveSize) };
        let hwnd_caret = unsafe { Hwnd::new_optional(hwndCaret) };
        let rc_caret = unsafe { RECT::from_win32(rcCaret) };
        Self { cb_size, flags, hwnd_active, hwnd_focus, hwnd_capture, hwnd_menu_owner, hwnd_move_size, hwnd_caret, rc_caret }
    }
}
pub const GUI_CARETBLINKING: u32 = 0x1;
pub const GUI_INMENUMODE: u32 = 0x4;
pub const GUI_INMOVESIZE: u32 = 0x2;
pub const GUI_POPUPMENUMODE: u32 = 0x10;
pub const GUI_SYSTEMMENUMODE: u32 = 0x8;

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Haccel {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Haccel {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Haccel {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Haccel {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    
pub const HA_LEFT: i32 = 0x0;
pub const HA_CENTER: i32 = 0x1;
pub const HA_RIGHT: i32 = 0x2;
pub const HANDEDNESS_LEFT: i32 = 0x0;
pub const HANDEDNESS_RIGHT: i32 = 0x1;

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Handle {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Handle {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Handle {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Handle {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Handletable {
    pub object_handle: [Option<Hgdiobj>; 1],
}
impl Handletable {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::HANDLETABLE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::HANDLETABLE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const HANDLE_FLAG_INHERIT: u32 = 0x1;
pub const HANDLE_FLAG_PROTECT_FROM_CLOSE: u32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Hardwarehookstruct {
    pub hwnd: Option<Hwnd>,
    pub message: u32,
    pub w_param: Wparam,
    pub l_param: Lparam,
}
impl Hardwarehookstruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::HARDWAREHOOKSTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::HARDWAREHOOKSTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const HS_BDIAGONAL: u32 = 0x3;
pub const HS_CROSS: u32 = 0x4;
pub const HS_DIAGCROSS: u32 = 0x5;
pub const HS_FDIAGONAL: u32 = 0x2;
pub const HS_HORIZONTAL: u32 = 0x0;
pub const HS_VERTICAL: u32 = 0x1;

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hbitmap {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hbitmap {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hbitmap {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hbitmap {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hbrush {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hbrush {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hbrush {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hbrush {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hcursor {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hcursor {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hcursor {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hcursor {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hdc {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hdc {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hdc {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hdc {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    
pub const MM_ANISOTROPIC: u32 = 0x8;
pub const MM_HIENGLISH: u32 = 0x5;
pub const MM_HIMETRIC: u32 = 0x3;
pub const MM_ISOTROPIC: u32 = 0x7;
pub const MM_LOENGLISH: u32 = 0x4;
pub const MM_LOMETRIC: u32 = 0x2;
pub const MM_TEXT: u32 = 0x1;
pub const MM_TWIPS: u32 = 0x6;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Hdhittestinfo {
    pub pt: Point,
    pub flags: u32,
    pub i_item: i32,
}
impl Hdhittestinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::HDHITTESTINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::HDHITTESTINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
//  Not generated due to containing a void type
//  #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Hditema<'a> {
//      pub mask: u32,
//      pub cxy: i32,
//      pub psz_text: Cow<'a, CStr>,
//      pub hbm: Option<Hbitmap>,
//      pub cch_text_max: i32,
//      pub fmt: i32,
//      pub l_param: Lparam,
//      pub i_image: i32,
//      pub i_order: i32,
//      pub r#type: u32,
//      pub pv_filter: &'a mut todo_void,
//      pub state: u32,
//  }
//  impl Hditema {
//      fn to_win32(&self) -> windows_sys::Win32::UI::Controls::HDITEMA {
//          let Self { mask, cxy, psz_text, hbm, cch_text_max, fmt, l_param, i_image, i_order, r#type, pv_filter, state } = self;
//          let mask = mask;
//          let cxy = *cxy;
//          let pszText = psz_text.as_ptr();
//          let hbm = hbm.map_or(0, Hbitmap::into_raw);
//          let cchTextMax = *cch_text_max;
//          let fmt = *fmt;
//          let lParam = l_param.into_inner();
//          let iImage = *i_image;
//          let iOrder = *i_order;
//          let r#type = *r#type;
//          let pvFilter = unsafe { &mut *(pv_filter as *mut _ as *mut _) };
//          let state = *state;
//          windows_sys::Win32::UI::Controls::HDITEMA { mask, cxy, pszText, hbm, cchTextMax, fmt, lParam, iImage, iOrder, r#type, pvFilter, state }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::HDITEMA) -> Self {
//          let windows_sys::Win32::UI::Controls::HDITEMA { mask, cxy, pszText, hbm, cchTextMax, fmt, lParam, iImage, iOrder, r#type, pvFilter, state } = win32;
//          let mask = mask;
//          let cxy = cxy;
//          let pszText = unsafe { CStr::from_ptr(pszText) };
//          let pszText = pszText.to_bytes_with_nul().to_vec();
//          let psz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(pszText) });
//          let hbm = unsafe { Hbitmap::new_optional(hbm) };
//          let cch_text_max = cchTextMax;
//          let fmt = fmt;
//          let l_param = unsafe { Lparam::from_inner(lParam) };
//          let i_image = iImage;
//          let i_order = iOrder;
//          let r#type = r#type;
//          let pv_filter = unsafe { &mut *(pvFilter as *mut _ as *mut _) };
//          let state = state;
//          Self { mask, cxy, psz_text, hbm, cch_text_max, fmt, l_param, i_image, i_order, r#type, pv_filter, state }
//      }
//  }
//  Not generated due to containing a void type
//  #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Hditemw<'a> {
//      pub mask: u32,
//      pub cxy: i32,
//      pub psz_text: Cow<'a, [u16]>,
//      pub hbm: Option<Hbitmap>,
//      pub cch_text_max: i32,
//      pub fmt: i32,
//      pub l_param: Lparam,
//      pub i_image: i32,
//      pub i_order: i32,
//      pub r#type: u32,
//      pub pv_filter: &'a mut todo_void,
//      pub state: u32,
//  }
//  impl Hditemw {
//      fn to_win32(&self) -> windows_sys::Win32::UI::Controls::HDITEMW {
//          let Self { mask, cxy, psz_text, hbm, cch_text_max, fmt, l_param, i_image, i_order, r#type, pv_filter, state } = self;
//          let mask = mask;
//          let cxy = *cxy;
//          assert_eq!(psz_text.last(), Some(0));
//          let pszText = psz_text.as_ptr();
//          let hbm = hbm.map_or(0, Hbitmap::into_raw);
//          let cchTextMax = *cch_text_max;
//          let fmt = *fmt;
//          let lParam = l_param.into_inner();
//          let iImage = *i_image;
//          let iOrder = *i_order;
//          let r#type = *r#type;
//          let pvFilter = unsafe { &mut *(pv_filter as *mut _ as *mut _) };
//          let state = *state;
//          windows_sys::Win32::UI::Controls::HDITEMW { mask, cxy, pszText, hbm, cchTextMax, fmt, lParam, iImage, iOrder, r#type, pvFilter, state }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::HDITEMW) -> Self {
//          let windows_sys::Win32::UI::Controls::HDITEMW { mask, cxy, pszText, hbm, cchTextMax, fmt, lParam, iImage, iOrder, r#type, pvFilter, state } = win32;
//          let mask = mask;
//          let cxy = cxy;
//          let slen = unsafe { wide_strlen(pszText as *const u16) };
//          let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
//          let psz_text = pszText.to_vec();
//          let hbm = unsafe { Hbitmap::new_optional(hbm) };
//          let cch_text_max = cchTextMax;
//          let fmt = fmt;
//          let l_param = unsafe { Lparam::from_inner(lParam) };
//          let i_image = iImage;
//          let i_order = iOrder;
//          let r#type = r#type;
//          let pv_filter = unsafe { &mut *(pvFilter as *mut _ as *mut _) };
//          let state = state;
//          Self { mask, cxy, psz_text, hbm, cch_text_max, fmt, l_param, i_image, i_order, r#type, pv_filter, state }
//      }
//  }
pub const HDI_WIDTH: u32 = 0x1;
pub const HDI_HEIGHT: u32 = 0x1;
pub const HDI_TEXT: u32 = 0x2;
pub const HDI_FORMAT: u32 = 0x4;
pub const HDI_LPARAM: u32 = 0x8;
pub const HDI_BITMAP: u32 = 0x10;
pub const HDI_IMAGE: u32 = 0x20;
pub const HDI_DI_SETITEM: u32 = 0x40;
pub const HDI_ORDER: u32 = 0x80;
pub const HDI_FILTER: u32 = 0x100;
pub const HDI_STATE: u32 = 0x200;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Hdlayout<'a> {
    pub prc: &'a mut Rect,
    pub pwpos: &'a mut Windowpos,
}
impl Hdlayout {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::HDLAYOUT {
        let Self { prc, pwpos } = self;
        let prc = unsafe { &mut *(prc as *mut _ as *mut _) };
        let pwpos = unsafe { &mut *(pwpos as *mut _ as *mut _) };
        windows_sys::Win32::UI::Controls::HDLAYOUT { prc, pwpos }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::HDLAYOUT) -> Self {
        let windows_sys::Win32::UI::Controls::HDLAYOUT { prc, pwpos } = win32;
        let prc = unsafe { &mut *(prc as *mut _ as *mut _) };
        let pwpos = unsafe { &mut *(pwpos as *mut _ as *mut _) };
        Self { prc, pwpos }
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hdpa {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hdpa {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hdpa {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hdpa {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hdrop {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hdrop {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hdrop {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hdrop {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hdsa {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hdsa {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hdsa {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hdsa {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct HdTextfiltera<'a> {
    pub psz_text: Cow<'a, CStr>,
    pub cch_text_max: i32,
}
impl HdTextfiltera {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::HD_TEXTFILTERA {
        let Self { psz_text, cch_text_max } = self;
        let pszText = psz_text.as_ptr();
        let cchTextMax = *cch_text_max;
        windows_sys::Win32::UI::Controls::HD_TEXTFILTERA { pszText, cchTextMax }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::HD_TEXTFILTERA) -> Self {
        let windows_sys::Win32::UI::Controls::HD_TEXTFILTERA { pszText, cchTextMax } = win32;
        let pszText = unsafe { CStr::from_ptr(pszText) };
        let pszText = pszText.to_bytes_with_nul().to_vec();
        let psz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(pszText) });
        let cch_text_max = cchTextMax;
        Self { psz_text, cch_text_max }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct HdTextfilterw<'a> {
    pub psz_text: Cow<'a, [u16]>,
    pub cch_text_max: i32,
}
impl HdTextfilterw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::HD_TEXTFILTERW {
        let Self { psz_text, cch_text_max } = self;
        assert_eq!(psz_text.last(), Some(0));
        let pszText = psz_text.as_ptr();
        let cchTextMax = *cch_text_max;
        windows_sys::Win32::UI::Controls::HD_TEXTFILTERW { pszText, cchTextMax }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::HD_TEXTFILTERW) -> Self {
        let windows_sys::Win32::UI::Controls::HD_TEXTFILTERW { pszText, cchTextMax } = win32;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = pszText.to_vec();
        let cch_text_max = cchTextMax;
        Self { psz_text, cch_text_max }
    }
}
pub const HEADER_CONTROL_NOTIFICATION_BUTTON_LEFT: u32 = 0x0;
pub const HEADER_CONTROL_NOTIFICATION_BUTTON_RIGHT: u32 = 0x1;
pub const HEADER_CONTROL_NOTIFICATION_BUTTON_MIDDLE: u32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Helpinfo {
    pub cb_size: u32,
    pub i_context_type: i32,
    pub i_ctrl_id: i32,
    pub h_item_handle: Option<Handle>,
    pub dw_context_id: usize,
    pub mouse_pos: Point,
}
impl Helpinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::HELPINFO {
        let Self { cb_size, i_context_type, i_ctrl_id, h_item_handle, dw_context_id, mouse_pos } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::HELPINFO>() as _;
        let iContextType = *i_context_type;
        let iCtrlId = *i_ctrl_id;
        let hItemHandle = h_item_handle.map_or(0, Handle::into_raw);
        let dwContextId = *dw_context_id;
        let MousePos = mouse_pos.to_win32();
        windows_sys::Win32::UI::Shell::HELPINFO { cbSize, iContextType, iCtrlId, hItemHandle, dwContextId, MousePos }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::HELPINFO) -> Self {
        let windows_sys::Win32::UI::Shell::HELPINFO { cbSize, iContextType, iCtrlId, hItemHandle, dwContextId, MousePos } = win32;
        let cb_size = cbSize;
        let i_context_type = iContextType;
        let i_ctrl_id = iCtrlId;
        let h_item_handle = unsafe { Handle::new_optional(hItemHandle) };
        let dw_context_id = dwContextId;
        let mouse_pos = unsafe { POINT::from_win32(MousePos) };
        Self { cb_size, i_context_type, i_ctrl_id, h_item_handle, dw_context_id, mouse_pos }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Helpwininfoa {
    pub w_struct_size: i32,
    pub x: i32,
    pub y: i32,
    pub dx: i32,
    pub dy: i32,
    pub w_max: i32,
    pub rgch_member: [CHAR; 2],
}
impl Helpwininfoa {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::HELPWININFOA {
        let Self { w_struct_size, x, y, dx, dy, w_max, rgch_member } = self;
        let wStructSize = mem::size_of::<windows_sys::Win32::UI::Shell::HELPWININFOA>() as _;
        let x = *x;
        let y = *y;
        let dx = *dx;
        let dy = *dy;
        let wMax = *w_max;
        let rgchMember = [rgch_member[0],rgch_member[1]];
        windows_sys::Win32::UI::Shell::HELPWININFOA { wStructSize, x, y, dx, dy, wMax, rgchMember }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::HELPWININFOA) -> Self {
        let windows_sys::Win32::UI::Shell::HELPWININFOA { wStructSize, x, y, dx, dy, wMax, rgchMember } = win32;
        let w_struct_size = wStructSize;
        let x = x;
        let y = y;
        let dx = dx;
        let dy = dy;
        let w_max = wMax;
        let rgch_member = [rgchMember[0],rgchMember[1]];
        Self { w_struct_size, x, y, dx, dy, w_max, rgch_member }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Helpwininfow {
    pub w_struct_size: i32,
    pub x: i32,
    pub y: i32,
    pub dx: i32,
    pub dy: i32,
    pub w_max: i32,
    pub rgch_member: [u8; 2],
}
impl Helpwininfow {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::HELPWININFOW {
        let Self { w_struct_size, x, y, dx, dy, w_max, rgch_member } = self;
        let wStructSize = mem::size_of::<windows_sys::Win32::UI::Shell::HELPWININFOW>() as _;
        let x = *x;
        let y = *y;
        let dx = *dx;
        let dy = *dy;
        let wMax = *w_max;
        let rgchMember = [*rgch_member[0],*rgch_member[1]];
        windows_sys::Win32::UI::Shell::HELPWININFOW { wStructSize, x, y, dx, dy, wMax, rgchMember }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::HELPWININFOW) -> Self {
        let windows_sys::Win32::UI::Shell::HELPWININFOW { wStructSize, x, y, dx, dy, wMax, rgchMember } = win32;
        let w_struct_size = wStructSize;
        let x = x;
        let y = y;
        let dx = dx;
        let dy = dy;
        let w_max = wMax;
        let rgch_member = [rgchMember[0],rgchMember[1]];
        Self { w_struct_size, x, y, dx, dy, w_max, rgch_member }
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Henhmetafile {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Henhmetafile {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Henhmetafile {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Henhmetafile {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hfont {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hfont {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hfont {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hfont {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hgdiobj {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hgdiobj {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hgdiobj {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hgdiobj {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hglrc {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hglrc {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hglrc {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hglrc {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hhook {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hhook {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hhook {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hhook {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hicon {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hicon {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hicon {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hicon {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Himagelist {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Himagelist {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Himagelist {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Himagelist {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hinstance {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hinstance {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hinstance {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hinstance {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hkey {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hkey {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hkey {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hkey {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    
pub const HLBWIF_HASFRAMEWNDINFO: u32 = 0x1;
pub const HLBWIF_HASDOCWNDINFO: u32 = 0x2;
pub const HLBWIF_FRAMEWNDMAXIMIZED: u32 = 0x4;
pub const HLBWIF_DOCWNDMAXIMIZED: u32 = 0x8;
pub const HLBWIF_HASWEBTOOLBARINFO: u32 = 0x10;
pub const HLBWIF_WEBTOOLBARHIDDEN: u32 = 0x20;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Hlbwinfo {
    pub cb_size: u32,
    pub grf_hlbwif: u32,
    pub rc_frame_pos: Rect,
    pub rc_doc_pos: Rect,
    pub hltbinfo: Hltbinfo,
}
impl Hlbwinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::HLBWINFO {
        let Self { cb_size, grf_hlbwif, rc_frame_pos, rc_doc_pos, hltbinfo } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::HLBWINFO>() as _;
        let grfHLBWIF = *grf_hlbwif;
        let rcFramePos = rc_frame_pos.to_win32();
        let rcDocPos = rc_doc_pos.to_win32();
        let hltbinfo = hltbinfo.to_win32();
        windows_sys::Win32::UI::Shell::HLBWINFO { cbSize, grfHLBWIF, rcFramePos, rcDocPos, hltbinfo }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::HLBWINFO) -> Self {
        let windows_sys::Win32::UI::Shell::HLBWINFO { cbSize, grfHLBWIF, rcFramePos, rcDocPos, hltbinfo } = win32;
        let cb_size = cbSize;
        let grf_hlbwif = grfHLBWIF;
        let rc_frame_pos = unsafe { RECT::from_win32(rcFramePos) };
        let rc_doc_pos = unsafe { RECT::from_win32(rcDocPos) };
        let hltbinfo = unsafe { HLTBINFO::from_win32(hltbinfo) };
        Self { cb_size, grf_hlbwif, rc_frame_pos, rc_doc_pos, hltbinfo }
    }
}
pub const HLFNAMEF_DEFAULT: u32 = 0x0;
pub const HLFNAMEF_TRYCACHE: u32 = 0x1;
pub const HLFNAMEF_TRYPRETTYTARGET: u32 = 0x2;
pub const HLFNAMEF_TRYFULLTARGET: u32 = 0x4;
pub const HLFNAMEF_TRYWIN95SHORTCUT: u32 = 0x8;
pub const HLID_INVALID: u32 = 0x0;
pub const HLID_PREVIOUS: u32 = 0xFFFFFFFF;
pub const HLID_NEXT: u32 = 0xFFFFFFFE;
pub const HLID_CURRENT: u32 = 0xFFFFFFFD;
pub const HLID_STACKBOTTOM: u32 = 0xFFFFFFFC;
pub const HLID_STACKTOP: u32 = 0xFFFFFFFB;
pub const HLINKGETREF_DEFAULT: i32 = 0x0;
pub const HLINKGETREF_ABSOLUTE: i32 = 0x1;
pub const HLINKGETREF_RELATIVE: i32 = 0x2;
pub const HLINKMISC_RELATIVE: i32 = 0x1;
pub const HLINKSETF_TARGET: i32 = 0x1;
pub const HLINKSETF_LOCATION: i32 = 0x2;
pub const HLINKWHICHMK_CONTAINER: i32 = 0x1;
pub const HLINKWHICHMK_BASE: i32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Hlitem<'a> {
    pub u_hlid: u32,
    pub pwz_friendly_name: Cow<'a, [u16]>,
}
impl Hlitem {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::HLITEM {
        let Self { u_hlid, pwz_friendly_name } = self;
        let uHLID = *u_hlid;
        assert_eq!(pwz_friendly_name.last(), Some(0));
        let pwzFriendlyName = pwz_friendly_name.as_ptr();
        windows_sys::Win32::UI::Shell::HLITEM { uHLID, pwzFriendlyName }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::HLITEM) -> Self {
        let windows_sys::Win32::UI::Shell::HLITEM { uHLID, pwzFriendlyName } = win32;
        let u_hlid = uHLID;
        let slen = unsafe { wide_strlen(pwzFriendlyName as *const u16) };
        let pwzFriendlyName = unsafe { slice::from_raw_parts(pwzFriendlyName, slen + 1) };
        let pwz_friendly_name = pwzFriendlyName.to_vec();
        Self { u_hlid, pwz_friendly_name }
    }
}
pub const HLNF_INTERNALJUMP: u32 = 0x1;
pub const HLNF_OPENINNEWWINDOW: u32 = 0x2;
pub const HLNF_NAVIGATINGBACK: u32 = 0x4;
pub const HLNF_NAVIGATINGFORWARD: u32 = 0x8;
pub const HLNF_NAVIGATINGTOSTACKITEM: u32 = 0x10;
pub const HLNF_CREATENOHISTORY: u32 = 0x20;
pub const HLQF_ISVALID: i32 = 0x1;
pub const HLQF_ISCURRENT: i32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Hlsurf {
    pub unused: i32,
}
impl Hlsurf {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::HLSURF__ {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::HLSURF__) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Hltbinfo {
    pub u_dock_type: u32,
    pub rc_tb_pos: Rect,
}
impl Hltbinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::HLTBINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::HLTBINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const HLTB_DOCKEDLEFT: i32 = 0x0;
pub const HLTB_DOCKEDTOP: i32 = 0x1;
pub const HLTB_DOCKEDRIGHT: i32 = 0x2;
pub const HLTB_DOCKEDBOTTOM: i32 = 0x3;
pub const HLTB_FLOATING: i32 = 0x4;

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hmenu {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hmenu {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hmenu {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hmenu {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hmetafile {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hmetafile {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hmetafile {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hmetafile {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hmonitor {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hmonitor {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hmonitor {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hmonitor {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    
pub const HGSC_NONE: i32 = 0x0;
pub const HGSC_MUSICLIBRARY: i32 = 0x1;
pub const HGSC_PICTURESLIBRARY: i32 = 0x2;
pub const HGSC_VIDEOSLIBRARY: i32 = 0x4;
pub const HGSC_DOCUMENTSLIBRARY: i32 = 0x8;
pub const HGSC_PRINTERS: i32 = 0x10;

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hpalette {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hpalette {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hpalette {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hpalette {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hpen {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hpen {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hpen {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hpen {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hpropsheetpage {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hpropsheetpage {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hpropsheetpage {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hpropsheetpage {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hpsxa {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hpsxa {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hpsxa {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hpsxa {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hrgn {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hrgn {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hrgn {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hrgn {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hrsrc {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hrsrc {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hrsrc {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hrsrc {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Hsprite {
    pub unused: i32,
}
impl Hsprite {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::HSPRITE__ {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::HSPRITE__) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Hstr {
    pub unused: i32,
}
impl Hstr {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::HSTR__ {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::HSTR__) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hsyntheticpointerdevice {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hsyntheticpointerdevice {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hsyntheticpointerdevice {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hsyntheticpointerdevice {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Htreeitem {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Htreeitem {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Htreeitem {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Htreeitem {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Humpd {
    pub unused: i32,
}
impl Humpd {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::HUMPD__ {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::HUMPD__) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hwnd {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hwnd {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hwnd {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hwnd {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    
pub const HLS_NORMALTEXT: i32 = 0x1;
pub const HLS_LINKTEXT: i32 = 0x2;

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct HdcMetdataEnhFileHandle {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl HdcMetdataEnhFileHandle {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for HdcMetdataEnhFileHandle {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for HdcMetdataEnhFileHandle {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct HdcMetdataFileHandle {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl HdcMetdataFileHandle {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for HdcMetdataFileHandle {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for HdcMetdataFileHandle {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    
pub const ICE_NONE: i32 = 0x0;
pub const ICE_GLOW: i32 = 0x1;
pub const ICE_SHADOW: i32 = 0x2;
pub const ICE_PULSE: i32 = 0x3;
pub const ICE_ALPHA: i32 = 0x4;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Iconinfo {
    pub f_icon: BOOL,
    pub x_hotspot: u32,
    pub y_hotspot: u32,
    pub hbm_mask: Option<Hbitmap>,
    pub hbm_color: Option<Hbitmap>,
}
impl Iconinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::ICONINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::ICONINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Iconinfoexa {
    pub cb_size: u32,
    pub f_icon: BOOL,
    pub x_hotspot: u32,
    pub y_hotspot: u32,
    pub hbm_mask: Option<Hbitmap>,
    pub hbm_color: Option<Hbitmap>,
    pub w_res_id: u16,
    pub sz_mod_name: [CHAR; 260],
    pub sz_res_name: [CHAR; 260],
}
impl Iconinfoexa {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::ICONINFOEXA {
        let Self { cb_size, f_icon, x_hotspot, y_hotspot, hbm_mask, hbm_color, w_res_id, sz_mod_name, sz_res_name } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::ICONINFOEXA>() as _;
        let fIcon = f_icon;
        let xHotspot = *x_hotspot;
        let yHotspot = *y_hotspot;
        let hbmMask = hbm_mask.map_or(0, Hbitmap::into_raw);
        let hbmColor = hbm_color.map_or(0, Hbitmap::into_raw);
        let wResID = *w_res_id;
        let szModName = [sz_mod_name[0],sz_mod_name[1],sz_mod_name[2],sz_mod_name[3],sz_mod_name[4],sz_mod_name[5],sz_mod_name[6],sz_mod_name[7],sz_mod_name[8],sz_mod_name[9],sz_mod_name[10],sz_mod_name[11],sz_mod_name[12],sz_mod_name[13],sz_mod_name[14],sz_mod_name[15],sz_mod_name[16],sz_mod_name[17],sz_mod_name[18],sz_mod_name[19],sz_mod_name[20],sz_mod_name[21],sz_mod_name[22],sz_mod_name[23],sz_mod_name[24],sz_mod_name[25],sz_mod_name[26],sz_mod_name[27],sz_mod_name[28],sz_mod_name[29],sz_mod_name[30],sz_mod_name[31],sz_mod_name[32],sz_mod_name[33],sz_mod_name[34],sz_mod_name[35],sz_mod_name[36],sz_mod_name[37],sz_mod_name[38],sz_mod_name[39],sz_mod_name[40],sz_mod_name[41],sz_mod_name[42],sz_mod_name[43],sz_mod_name[44],sz_mod_name[45],sz_mod_name[46],sz_mod_name[47],sz_mod_name[48],sz_mod_name[49],sz_mod_name[50],sz_mod_name[51],sz_mod_name[52],sz_mod_name[53],sz_mod_name[54],sz_mod_name[55],sz_mod_name[56],sz_mod_name[57],sz_mod_name[58],sz_mod_name[59],sz_mod_name[60],sz_mod_name[61],sz_mod_name[62],sz_mod_name[63],sz_mod_name[64],sz_mod_name[65],sz_mod_name[66],sz_mod_name[67],sz_mod_name[68],sz_mod_name[69],sz_mod_name[70],sz_mod_name[71],sz_mod_name[72],sz_mod_name[73],sz_mod_name[74],sz_mod_name[75],sz_mod_name[76],sz_mod_name[77],sz_mod_name[78],sz_mod_name[79],sz_mod_name[80],sz_mod_name[81],sz_mod_name[82],sz_mod_name[83],sz_mod_name[84],sz_mod_name[85],sz_mod_name[86],sz_mod_name[87],sz_mod_name[88],sz_mod_name[89],sz_mod_name[90],sz_mod_name[91],sz_mod_name[92],sz_mod_name[93],sz_mod_name[94],sz_mod_name[95],sz_mod_name[96],sz_mod_name[97],sz_mod_name[98],sz_mod_name[99],sz_mod_name[100],sz_mod_name[101],sz_mod_name[102],sz_mod_name[103],sz_mod_name[104],sz_mod_name[105],sz_mod_name[106],sz_mod_name[107],sz_mod_name[108],sz_mod_name[109],sz_mod_name[110],sz_mod_name[111],sz_mod_name[112],sz_mod_name[113],sz_mod_name[114],sz_mod_name[115],sz_mod_name[116],sz_mod_name[117],sz_mod_name[118],sz_mod_name[119],sz_mod_name[120],sz_mod_name[121],sz_mod_name[122],sz_mod_name[123],sz_mod_name[124],sz_mod_name[125],sz_mod_name[126],sz_mod_name[127],sz_mod_name[128],sz_mod_name[129],sz_mod_name[130],sz_mod_name[131],sz_mod_name[132],sz_mod_name[133],sz_mod_name[134],sz_mod_name[135],sz_mod_name[136],sz_mod_name[137],sz_mod_name[138],sz_mod_name[139],sz_mod_name[140],sz_mod_name[141],sz_mod_name[142],sz_mod_name[143],sz_mod_name[144],sz_mod_name[145],sz_mod_name[146],sz_mod_name[147],sz_mod_name[148],sz_mod_name[149],sz_mod_name[150],sz_mod_name[151],sz_mod_name[152],sz_mod_name[153],sz_mod_name[154],sz_mod_name[155],sz_mod_name[156],sz_mod_name[157],sz_mod_name[158],sz_mod_name[159],sz_mod_name[160],sz_mod_name[161],sz_mod_name[162],sz_mod_name[163],sz_mod_name[164],sz_mod_name[165],sz_mod_name[166],sz_mod_name[167],sz_mod_name[168],sz_mod_name[169],sz_mod_name[170],sz_mod_name[171],sz_mod_name[172],sz_mod_name[173],sz_mod_name[174],sz_mod_name[175],sz_mod_name[176],sz_mod_name[177],sz_mod_name[178],sz_mod_name[179],sz_mod_name[180],sz_mod_name[181],sz_mod_name[182],sz_mod_name[183],sz_mod_name[184],sz_mod_name[185],sz_mod_name[186],sz_mod_name[187],sz_mod_name[188],sz_mod_name[189],sz_mod_name[190],sz_mod_name[191],sz_mod_name[192],sz_mod_name[193],sz_mod_name[194],sz_mod_name[195],sz_mod_name[196],sz_mod_name[197],sz_mod_name[198],sz_mod_name[199],sz_mod_name[200],sz_mod_name[201],sz_mod_name[202],sz_mod_name[203],sz_mod_name[204],sz_mod_name[205],sz_mod_name[206],sz_mod_name[207],sz_mod_name[208],sz_mod_name[209],sz_mod_name[210],sz_mod_name[211],sz_mod_name[212],sz_mod_name[213],sz_mod_name[214],sz_mod_name[215],sz_mod_name[216],sz_mod_name[217],sz_mod_name[218],sz_mod_name[219],sz_mod_name[220],sz_mod_name[221],sz_mod_name[222],sz_mod_name[223],sz_mod_name[224],sz_mod_name[225],sz_mod_name[226],sz_mod_name[227],sz_mod_name[228],sz_mod_name[229],sz_mod_name[230],sz_mod_name[231],sz_mod_name[232],sz_mod_name[233],sz_mod_name[234],sz_mod_name[235],sz_mod_name[236],sz_mod_name[237],sz_mod_name[238],sz_mod_name[239],sz_mod_name[240],sz_mod_name[241],sz_mod_name[242],sz_mod_name[243],sz_mod_name[244],sz_mod_name[245],sz_mod_name[246],sz_mod_name[247],sz_mod_name[248],sz_mod_name[249],sz_mod_name[250],sz_mod_name[251],sz_mod_name[252],sz_mod_name[253],sz_mod_name[254],sz_mod_name[255],sz_mod_name[256],sz_mod_name[257],sz_mod_name[258],sz_mod_name[259]];
        let szResName = [sz_res_name[0],sz_res_name[1],sz_res_name[2],sz_res_name[3],sz_res_name[4],sz_res_name[5],sz_res_name[6],sz_res_name[7],sz_res_name[8],sz_res_name[9],sz_res_name[10],sz_res_name[11],sz_res_name[12],sz_res_name[13],sz_res_name[14],sz_res_name[15],sz_res_name[16],sz_res_name[17],sz_res_name[18],sz_res_name[19],sz_res_name[20],sz_res_name[21],sz_res_name[22],sz_res_name[23],sz_res_name[24],sz_res_name[25],sz_res_name[26],sz_res_name[27],sz_res_name[28],sz_res_name[29],sz_res_name[30],sz_res_name[31],sz_res_name[32],sz_res_name[33],sz_res_name[34],sz_res_name[35],sz_res_name[36],sz_res_name[37],sz_res_name[38],sz_res_name[39],sz_res_name[40],sz_res_name[41],sz_res_name[42],sz_res_name[43],sz_res_name[44],sz_res_name[45],sz_res_name[46],sz_res_name[47],sz_res_name[48],sz_res_name[49],sz_res_name[50],sz_res_name[51],sz_res_name[52],sz_res_name[53],sz_res_name[54],sz_res_name[55],sz_res_name[56],sz_res_name[57],sz_res_name[58],sz_res_name[59],sz_res_name[60],sz_res_name[61],sz_res_name[62],sz_res_name[63],sz_res_name[64],sz_res_name[65],sz_res_name[66],sz_res_name[67],sz_res_name[68],sz_res_name[69],sz_res_name[70],sz_res_name[71],sz_res_name[72],sz_res_name[73],sz_res_name[74],sz_res_name[75],sz_res_name[76],sz_res_name[77],sz_res_name[78],sz_res_name[79],sz_res_name[80],sz_res_name[81],sz_res_name[82],sz_res_name[83],sz_res_name[84],sz_res_name[85],sz_res_name[86],sz_res_name[87],sz_res_name[88],sz_res_name[89],sz_res_name[90],sz_res_name[91],sz_res_name[92],sz_res_name[93],sz_res_name[94],sz_res_name[95],sz_res_name[96],sz_res_name[97],sz_res_name[98],sz_res_name[99],sz_res_name[100],sz_res_name[101],sz_res_name[102],sz_res_name[103],sz_res_name[104],sz_res_name[105],sz_res_name[106],sz_res_name[107],sz_res_name[108],sz_res_name[109],sz_res_name[110],sz_res_name[111],sz_res_name[112],sz_res_name[113],sz_res_name[114],sz_res_name[115],sz_res_name[116],sz_res_name[117],sz_res_name[118],sz_res_name[119],sz_res_name[120],sz_res_name[121],sz_res_name[122],sz_res_name[123],sz_res_name[124],sz_res_name[125],sz_res_name[126],sz_res_name[127],sz_res_name[128],sz_res_name[129],sz_res_name[130],sz_res_name[131],sz_res_name[132],sz_res_name[133],sz_res_name[134],sz_res_name[135],sz_res_name[136],sz_res_name[137],sz_res_name[138],sz_res_name[139],sz_res_name[140],sz_res_name[141],sz_res_name[142],sz_res_name[143],sz_res_name[144],sz_res_name[145],sz_res_name[146],sz_res_name[147],sz_res_name[148],sz_res_name[149],sz_res_name[150],sz_res_name[151],sz_res_name[152],sz_res_name[153],sz_res_name[154],sz_res_name[155],sz_res_name[156],sz_res_name[157],sz_res_name[158],sz_res_name[159],sz_res_name[160],sz_res_name[161],sz_res_name[162],sz_res_name[163],sz_res_name[164],sz_res_name[165],sz_res_name[166],sz_res_name[167],sz_res_name[168],sz_res_name[169],sz_res_name[170],sz_res_name[171],sz_res_name[172],sz_res_name[173],sz_res_name[174],sz_res_name[175],sz_res_name[176],sz_res_name[177],sz_res_name[178],sz_res_name[179],sz_res_name[180],sz_res_name[181],sz_res_name[182],sz_res_name[183],sz_res_name[184],sz_res_name[185],sz_res_name[186],sz_res_name[187],sz_res_name[188],sz_res_name[189],sz_res_name[190],sz_res_name[191],sz_res_name[192],sz_res_name[193],sz_res_name[194],sz_res_name[195],sz_res_name[196],sz_res_name[197],sz_res_name[198],sz_res_name[199],sz_res_name[200],sz_res_name[201],sz_res_name[202],sz_res_name[203],sz_res_name[204],sz_res_name[205],sz_res_name[206],sz_res_name[207],sz_res_name[208],sz_res_name[209],sz_res_name[210],sz_res_name[211],sz_res_name[212],sz_res_name[213],sz_res_name[214],sz_res_name[215],sz_res_name[216],sz_res_name[217],sz_res_name[218],sz_res_name[219],sz_res_name[220],sz_res_name[221],sz_res_name[222],sz_res_name[223],sz_res_name[224],sz_res_name[225],sz_res_name[226],sz_res_name[227],sz_res_name[228],sz_res_name[229],sz_res_name[230],sz_res_name[231],sz_res_name[232],sz_res_name[233],sz_res_name[234],sz_res_name[235],sz_res_name[236],sz_res_name[237],sz_res_name[238],sz_res_name[239],sz_res_name[240],sz_res_name[241],sz_res_name[242],sz_res_name[243],sz_res_name[244],sz_res_name[245],sz_res_name[246],sz_res_name[247],sz_res_name[248],sz_res_name[249],sz_res_name[250],sz_res_name[251],sz_res_name[252],sz_res_name[253],sz_res_name[254],sz_res_name[255],sz_res_name[256],sz_res_name[257],sz_res_name[258],sz_res_name[259]];
        windows_sys::Win32::UI::WindowsAndMessaging::ICONINFOEXA { cbSize, fIcon, xHotspot, yHotspot, hbmMask, hbmColor, wResID, szModName, szResName }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::ICONINFOEXA) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::ICONINFOEXA { cbSize, fIcon, xHotspot, yHotspot, hbmMask, hbmColor, wResID, szModName, szResName } = win32;
        let cb_size = cbSize;
        let f_icon = fIcon;
        let x_hotspot = xHotspot;
        let y_hotspot = yHotspot;
        let hbm_mask = unsafe { Hbitmap::new_optional(hbmMask) };
        let hbm_color = unsafe { Hbitmap::new_optional(hbmColor) };
        let w_res_id = wResID;
        let sz_mod_name = [szModName[0],szModName[1],szModName[2],szModName[3],szModName[4],szModName[5],szModName[6],szModName[7],szModName[8],szModName[9],szModName[10],szModName[11],szModName[12],szModName[13],szModName[14],szModName[15],szModName[16],szModName[17],szModName[18],szModName[19],szModName[20],szModName[21],szModName[22],szModName[23],szModName[24],szModName[25],szModName[26],szModName[27],szModName[28],szModName[29],szModName[30],szModName[31],szModName[32],szModName[33],szModName[34],szModName[35],szModName[36],szModName[37],szModName[38],szModName[39],szModName[40],szModName[41],szModName[42],szModName[43],szModName[44],szModName[45],szModName[46],szModName[47],szModName[48],szModName[49],szModName[50],szModName[51],szModName[52],szModName[53],szModName[54],szModName[55],szModName[56],szModName[57],szModName[58],szModName[59],szModName[60],szModName[61],szModName[62],szModName[63],szModName[64],szModName[65],szModName[66],szModName[67],szModName[68],szModName[69],szModName[70],szModName[71],szModName[72],szModName[73],szModName[74],szModName[75],szModName[76],szModName[77],szModName[78],szModName[79],szModName[80],szModName[81],szModName[82],szModName[83],szModName[84],szModName[85],szModName[86],szModName[87],szModName[88],szModName[89],szModName[90],szModName[91],szModName[92],szModName[93],szModName[94],szModName[95],szModName[96],szModName[97],szModName[98],szModName[99],szModName[100],szModName[101],szModName[102],szModName[103],szModName[104],szModName[105],szModName[106],szModName[107],szModName[108],szModName[109],szModName[110],szModName[111],szModName[112],szModName[113],szModName[114],szModName[115],szModName[116],szModName[117],szModName[118],szModName[119],szModName[120],szModName[121],szModName[122],szModName[123],szModName[124],szModName[125],szModName[126],szModName[127],szModName[128],szModName[129],szModName[130],szModName[131],szModName[132],szModName[133],szModName[134],szModName[135],szModName[136],szModName[137],szModName[138],szModName[139],szModName[140],szModName[141],szModName[142],szModName[143],szModName[144],szModName[145],szModName[146],szModName[147],szModName[148],szModName[149],szModName[150],szModName[151],szModName[152],szModName[153],szModName[154],szModName[155],szModName[156],szModName[157],szModName[158],szModName[159],szModName[160],szModName[161],szModName[162],szModName[163],szModName[164],szModName[165],szModName[166],szModName[167],szModName[168],szModName[169],szModName[170],szModName[171],szModName[172],szModName[173],szModName[174],szModName[175],szModName[176],szModName[177],szModName[178],szModName[179],szModName[180],szModName[181],szModName[182],szModName[183],szModName[184],szModName[185],szModName[186],szModName[187],szModName[188],szModName[189],szModName[190],szModName[191],szModName[192],szModName[193],szModName[194],szModName[195],szModName[196],szModName[197],szModName[198],szModName[199],szModName[200],szModName[201],szModName[202],szModName[203],szModName[204],szModName[205],szModName[206],szModName[207],szModName[208],szModName[209],szModName[210],szModName[211],szModName[212],szModName[213],szModName[214],szModName[215],szModName[216],szModName[217],szModName[218],szModName[219],szModName[220],szModName[221],szModName[222],szModName[223],szModName[224],szModName[225],szModName[226],szModName[227],szModName[228],szModName[229],szModName[230],szModName[231],szModName[232],szModName[233],szModName[234],szModName[235],szModName[236],szModName[237],szModName[238],szModName[239],szModName[240],szModName[241],szModName[242],szModName[243],szModName[244],szModName[245],szModName[246],szModName[247],szModName[248],szModName[249],szModName[250],szModName[251],szModName[252],szModName[253],szModName[254],szModName[255],szModName[256],szModName[257],szModName[258],szModName[259]];
        let sz_res_name = [szResName[0],szResName[1],szResName[2],szResName[3],szResName[4],szResName[5],szResName[6],szResName[7],szResName[8],szResName[9],szResName[10],szResName[11],szResName[12],szResName[13],szResName[14],szResName[15],szResName[16],szResName[17],szResName[18],szResName[19],szResName[20],szResName[21],szResName[22],szResName[23],szResName[24],szResName[25],szResName[26],szResName[27],szResName[28],szResName[29],szResName[30],szResName[31],szResName[32],szResName[33],szResName[34],szResName[35],szResName[36],szResName[37],szResName[38],szResName[39],szResName[40],szResName[41],szResName[42],szResName[43],szResName[44],szResName[45],szResName[46],szResName[47],szResName[48],szResName[49],szResName[50],szResName[51],szResName[52],szResName[53],szResName[54],szResName[55],szResName[56],szResName[57],szResName[58],szResName[59],szResName[60],szResName[61],szResName[62],szResName[63],szResName[64],szResName[65],szResName[66],szResName[67],szResName[68],szResName[69],szResName[70],szResName[71],szResName[72],szResName[73],szResName[74],szResName[75],szResName[76],szResName[77],szResName[78],szResName[79],szResName[80],szResName[81],szResName[82],szResName[83],szResName[84],szResName[85],szResName[86],szResName[87],szResName[88],szResName[89],szResName[90],szResName[91],szResName[92],szResName[93],szResName[94],szResName[95],szResName[96],szResName[97],szResName[98],szResName[99],szResName[100],szResName[101],szResName[102],szResName[103],szResName[104],szResName[105],szResName[106],szResName[107],szResName[108],szResName[109],szResName[110],szResName[111],szResName[112],szResName[113],szResName[114],szResName[115],szResName[116],szResName[117],szResName[118],szResName[119],szResName[120],szResName[121],szResName[122],szResName[123],szResName[124],szResName[125],szResName[126],szResName[127],szResName[128],szResName[129],szResName[130],szResName[131],szResName[132],szResName[133],szResName[134],szResName[135],szResName[136],szResName[137],szResName[138],szResName[139],szResName[140],szResName[141],szResName[142],szResName[143],szResName[144],szResName[145],szResName[146],szResName[147],szResName[148],szResName[149],szResName[150],szResName[151],szResName[152],szResName[153],szResName[154],szResName[155],szResName[156],szResName[157],szResName[158],szResName[159],szResName[160],szResName[161],szResName[162],szResName[163],szResName[164],szResName[165],szResName[166],szResName[167],szResName[168],szResName[169],szResName[170],szResName[171],szResName[172],szResName[173],szResName[174],szResName[175],szResName[176],szResName[177],szResName[178],szResName[179],szResName[180],szResName[181],szResName[182],szResName[183],szResName[184],szResName[185],szResName[186],szResName[187],szResName[188],szResName[189],szResName[190],szResName[191],szResName[192],szResName[193],szResName[194],szResName[195],szResName[196],szResName[197],szResName[198],szResName[199],szResName[200],szResName[201],szResName[202],szResName[203],szResName[204],szResName[205],szResName[206],szResName[207],szResName[208],szResName[209],szResName[210],szResName[211],szResName[212],szResName[213],szResName[214],szResName[215],szResName[216],szResName[217],szResName[218],szResName[219],szResName[220],szResName[221],szResName[222],szResName[223],szResName[224],szResName[225],szResName[226],szResName[227],szResName[228],szResName[229],szResName[230],szResName[231],szResName[232],szResName[233],szResName[234],szResName[235],szResName[236],szResName[237],szResName[238],szResName[239],szResName[240],szResName[241],szResName[242],szResName[243],szResName[244],szResName[245],szResName[246],szResName[247],szResName[248],szResName[249],szResName[250],szResName[251],szResName[252],szResName[253],szResName[254],szResName[255],szResName[256],szResName[257],szResName[258],szResName[259]];
        Self { cb_size, f_icon, x_hotspot, y_hotspot, hbm_mask, hbm_color, w_res_id, sz_mod_name, sz_res_name }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Iconinfoexw {
    pub cb_size: u32,
    pub f_icon: BOOL,
    pub x_hotspot: u32,
    pub y_hotspot: u32,
    pub hbm_mask: Option<Hbitmap>,
    pub hbm_color: Option<Hbitmap>,
    pub w_res_id: u16,
    pub sz_mod_name: [u8; 260],
    pub sz_res_name: [u8; 260],
}
impl Iconinfoexw {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::ICONINFOEXW {
        let Self { cb_size, f_icon, x_hotspot, y_hotspot, hbm_mask, hbm_color, w_res_id, sz_mod_name, sz_res_name } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::ICONINFOEXW>() as _;
        let fIcon = f_icon;
        let xHotspot = *x_hotspot;
        let yHotspot = *y_hotspot;
        let hbmMask = hbm_mask.map_or(0, Hbitmap::into_raw);
        let hbmColor = hbm_color.map_or(0, Hbitmap::into_raw);
        let wResID = *w_res_id;
        let szModName = [*sz_mod_name[0],*sz_mod_name[1],*sz_mod_name[2],*sz_mod_name[3],*sz_mod_name[4],*sz_mod_name[5],*sz_mod_name[6],*sz_mod_name[7],*sz_mod_name[8],*sz_mod_name[9],*sz_mod_name[10],*sz_mod_name[11],*sz_mod_name[12],*sz_mod_name[13],*sz_mod_name[14],*sz_mod_name[15],*sz_mod_name[16],*sz_mod_name[17],*sz_mod_name[18],*sz_mod_name[19],*sz_mod_name[20],*sz_mod_name[21],*sz_mod_name[22],*sz_mod_name[23],*sz_mod_name[24],*sz_mod_name[25],*sz_mod_name[26],*sz_mod_name[27],*sz_mod_name[28],*sz_mod_name[29],*sz_mod_name[30],*sz_mod_name[31],*sz_mod_name[32],*sz_mod_name[33],*sz_mod_name[34],*sz_mod_name[35],*sz_mod_name[36],*sz_mod_name[37],*sz_mod_name[38],*sz_mod_name[39],*sz_mod_name[40],*sz_mod_name[41],*sz_mod_name[42],*sz_mod_name[43],*sz_mod_name[44],*sz_mod_name[45],*sz_mod_name[46],*sz_mod_name[47],*sz_mod_name[48],*sz_mod_name[49],*sz_mod_name[50],*sz_mod_name[51],*sz_mod_name[52],*sz_mod_name[53],*sz_mod_name[54],*sz_mod_name[55],*sz_mod_name[56],*sz_mod_name[57],*sz_mod_name[58],*sz_mod_name[59],*sz_mod_name[60],*sz_mod_name[61],*sz_mod_name[62],*sz_mod_name[63],*sz_mod_name[64],*sz_mod_name[65],*sz_mod_name[66],*sz_mod_name[67],*sz_mod_name[68],*sz_mod_name[69],*sz_mod_name[70],*sz_mod_name[71],*sz_mod_name[72],*sz_mod_name[73],*sz_mod_name[74],*sz_mod_name[75],*sz_mod_name[76],*sz_mod_name[77],*sz_mod_name[78],*sz_mod_name[79],*sz_mod_name[80],*sz_mod_name[81],*sz_mod_name[82],*sz_mod_name[83],*sz_mod_name[84],*sz_mod_name[85],*sz_mod_name[86],*sz_mod_name[87],*sz_mod_name[88],*sz_mod_name[89],*sz_mod_name[90],*sz_mod_name[91],*sz_mod_name[92],*sz_mod_name[93],*sz_mod_name[94],*sz_mod_name[95],*sz_mod_name[96],*sz_mod_name[97],*sz_mod_name[98],*sz_mod_name[99],*sz_mod_name[100],*sz_mod_name[101],*sz_mod_name[102],*sz_mod_name[103],*sz_mod_name[104],*sz_mod_name[105],*sz_mod_name[106],*sz_mod_name[107],*sz_mod_name[108],*sz_mod_name[109],*sz_mod_name[110],*sz_mod_name[111],*sz_mod_name[112],*sz_mod_name[113],*sz_mod_name[114],*sz_mod_name[115],*sz_mod_name[116],*sz_mod_name[117],*sz_mod_name[118],*sz_mod_name[119],*sz_mod_name[120],*sz_mod_name[121],*sz_mod_name[122],*sz_mod_name[123],*sz_mod_name[124],*sz_mod_name[125],*sz_mod_name[126],*sz_mod_name[127],*sz_mod_name[128],*sz_mod_name[129],*sz_mod_name[130],*sz_mod_name[131],*sz_mod_name[132],*sz_mod_name[133],*sz_mod_name[134],*sz_mod_name[135],*sz_mod_name[136],*sz_mod_name[137],*sz_mod_name[138],*sz_mod_name[139],*sz_mod_name[140],*sz_mod_name[141],*sz_mod_name[142],*sz_mod_name[143],*sz_mod_name[144],*sz_mod_name[145],*sz_mod_name[146],*sz_mod_name[147],*sz_mod_name[148],*sz_mod_name[149],*sz_mod_name[150],*sz_mod_name[151],*sz_mod_name[152],*sz_mod_name[153],*sz_mod_name[154],*sz_mod_name[155],*sz_mod_name[156],*sz_mod_name[157],*sz_mod_name[158],*sz_mod_name[159],*sz_mod_name[160],*sz_mod_name[161],*sz_mod_name[162],*sz_mod_name[163],*sz_mod_name[164],*sz_mod_name[165],*sz_mod_name[166],*sz_mod_name[167],*sz_mod_name[168],*sz_mod_name[169],*sz_mod_name[170],*sz_mod_name[171],*sz_mod_name[172],*sz_mod_name[173],*sz_mod_name[174],*sz_mod_name[175],*sz_mod_name[176],*sz_mod_name[177],*sz_mod_name[178],*sz_mod_name[179],*sz_mod_name[180],*sz_mod_name[181],*sz_mod_name[182],*sz_mod_name[183],*sz_mod_name[184],*sz_mod_name[185],*sz_mod_name[186],*sz_mod_name[187],*sz_mod_name[188],*sz_mod_name[189],*sz_mod_name[190],*sz_mod_name[191],*sz_mod_name[192],*sz_mod_name[193],*sz_mod_name[194],*sz_mod_name[195],*sz_mod_name[196],*sz_mod_name[197],*sz_mod_name[198],*sz_mod_name[199],*sz_mod_name[200],*sz_mod_name[201],*sz_mod_name[202],*sz_mod_name[203],*sz_mod_name[204],*sz_mod_name[205],*sz_mod_name[206],*sz_mod_name[207],*sz_mod_name[208],*sz_mod_name[209],*sz_mod_name[210],*sz_mod_name[211],*sz_mod_name[212],*sz_mod_name[213],*sz_mod_name[214],*sz_mod_name[215],*sz_mod_name[216],*sz_mod_name[217],*sz_mod_name[218],*sz_mod_name[219],*sz_mod_name[220],*sz_mod_name[221],*sz_mod_name[222],*sz_mod_name[223],*sz_mod_name[224],*sz_mod_name[225],*sz_mod_name[226],*sz_mod_name[227],*sz_mod_name[228],*sz_mod_name[229],*sz_mod_name[230],*sz_mod_name[231],*sz_mod_name[232],*sz_mod_name[233],*sz_mod_name[234],*sz_mod_name[235],*sz_mod_name[236],*sz_mod_name[237],*sz_mod_name[238],*sz_mod_name[239],*sz_mod_name[240],*sz_mod_name[241],*sz_mod_name[242],*sz_mod_name[243],*sz_mod_name[244],*sz_mod_name[245],*sz_mod_name[246],*sz_mod_name[247],*sz_mod_name[248],*sz_mod_name[249],*sz_mod_name[250],*sz_mod_name[251],*sz_mod_name[252],*sz_mod_name[253],*sz_mod_name[254],*sz_mod_name[255],*sz_mod_name[256],*sz_mod_name[257],*sz_mod_name[258],*sz_mod_name[259]];
        let szResName = [*sz_res_name[0],*sz_res_name[1],*sz_res_name[2],*sz_res_name[3],*sz_res_name[4],*sz_res_name[5],*sz_res_name[6],*sz_res_name[7],*sz_res_name[8],*sz_res_name[9],*sz_res_name[10],*sz_res_name[11],*sz_res_name[12],*sz_res_name[13],*sz_res_name[14],*sz_res_name[15],*sz_res_name[16],*sz_res_name[17],*sz_res_name[18],*sz_res_name[19],*sz_res_name[20],*sz_res_name[21],*sz_res_name[22],*sz_res_name[23],*sz_res_name[24],*sz_res_name[25],*sz_res_name[26],*sz_res_name[27],*sz_res_name[28],*sz_res_name[29],*sz_res_name[30],*sz_res_name[31],*sz_res_name[32],*sz_res_name[33],*sz_res_name[34],*sz_res_name[35],*sz_res_name[36],*sz_res_name[37],*sz_res_name[38],*sz_res_name[39],*sz_res_name[40],*sz_res_name[41],*sz_res_name[42],*sz_res_name[43],*sz_res_name[44],*sz_res_name[45],*sz_res_name[46],*sz_res_name[47],*sz_res_name[48],*sz_res_name[49],*sz_res_name[50],*sz_res_name[51],*sz_res_name[52],*sz_res_name[53],*sz_res_name[54],*sz_res_name[55],*sz_res_name[56],*sz_res_name[57],*sz_res_name[58],*sz_res_name[59],*sz_res_name[60],*sz_res_name[61],*sz_res_name[62],*sz_res_name[63],*sz_res_name[64],*sz_res_name[65],*sz_res_name[66],*sz_res_name[67],*sz_res_name[68],*sz_res_name[69],*sz_res_name[70],*sz_res_name[71],*sz_res_name[72],*sz_res_name[73],*sz_res_name[74],*sz_res_name[75],*sz_res_name[76],*sz_res_name[77],*sz_res_name[78],*sz_res_name[79],*sz_res_name[80],*sz_res_name[81],*sz_res_name[82],*sz_res_name[83],*sz_res_name[84],*sz_res_name[85],*sz_res_name[86],*sz_res_name[87],*sz_res_name[88],*sz_res_name[89],*sz_res_name[90],*sz_res_name[91],*sz_res_name[92],*sz_res_name[93],*sz_res_name[94],*sz_res_name[95],*sz_res_name[96],*sz_res_name[97],*sz_res_name[98],*sz_res_name[99],*sz_res_name[100],*sz_res_name[101],*sz_res_name[102],*sz_res_name[103],*sz_res_name[104],*sz_res_name[105],*sz_res_name[106],*sz_res_name[107],*sz_res_name[108],*sz_res_name[109],*sz_res_name[110],*sz_res_name[111],*sz_res_name[112],*sz_res_name[113],*sz_res_name[114],*sz_res_name[115],*sz_res_name[116],*sz_res_name[117],*sz_res_name[118],*sz_res_name[119],*sz_res_name[120],*sz_res_name[121],*sz_res_name[122],*sz_res_name[123],*sz_res_name[124],*sz_res_name[125],*sz_res_name[126],*sz_res_name[127],*sz_res_name[128],*sz_res_name[129],*sz_res_name[130],*sz_res_name[131],*sz_res_name[132],*sz_res_name[133],*sz_res_name[134],*sz_res_name[135],*sz_res_name[136],*sz_res_name[137],*sz_res_name[138],*sz_res_name[139],*sz_res_name[140],*sz_res_name[141],*sz_res_name[142],*sz_res_name[143],*sz_res_name[144],*sz_res_name[145],*sz_res_name[146],*sz_res_name[147],*sz_res_name[148],*sz_res_name[149],*sz_res_name[150],*sz_res_name[151],*sz_res_name[152],*sz_res_name[153],*sz_res_name[154],*sz_res_name[155],*sz_res_name[156],*sz_res_name[157],*sz_res_name[158],*sz_res_name[159],*sz_res_name[160],*sz_res_name[161],*sz_res_name[162],*sz_res_name[163],*sz_res_name[164],*sz_res_name[165],*sz_res_name[166],*sz_res_name[167],*sz_res_name[168],*sz_res_name[169],*sz_res_name[170],*sz_res_name[171],*sz_res_name[172],*sz_res_name[173],*sz_res_name[174],*sz_res_name[175],*sz_res_name[176],*sz_res_name[177],*sz_res_name[178],*sz_res_name[179],*sz_res_name[180],*sz_res_name[181],*sz_res_name[182],*sz_res_name[183],*sz_res_name[184],*sz_res_name[185],*sz_res_name[186],*sz_res_name[187],*sz_res_name[188],*sz_res_name[189],*sz_res_name[190],*sz_res_name[191],*sz_res_name[192],*sz_res_name[193],*sz_res_name[194],*sz_res_name[195],*sz_res_name[196],*sz_res_name[197],*sz_res_name[198],*sz_res_name[199],*sz_res_name[200],*sz_res_name[201],*sz_res_name[202],*sz_res_name[203],*sz_res_name[204],*sz_res_name[205],*sz_res_name[206],*sz_res_name[207],*sz_res_name[208],*sz_res_name[209],*sz_res_name[210],*sz_res_name[211],*sz_res_name[212],*sz_res_name[213],*sz_res_name[214],*sz_res_name[215],*sz_res_name[216],*sz_res_name[217],*sz_res_name[218],*sz_res_name[219],*sz_res_name[220],*sz_res_name[221],*sz_res_name[222],*sz_res_name[223],*sz_res_name[224],*sz_res_name[225],*sz_res_name[226],*sz_res_name[227],*sz_res_name[228],*sz_res_name[229],*sz_res_name[230],*sz_res_name[231],*sz_res_name[232],*sz_res_name[233],*sz_res_name[234],*sz_res_name[235],*sz_res_name[236],*sz_res_name[237],*sz_res_name[238],*sz_res_name[239],*sz_res_name[240],*sz_res_name[241],*sz_res_name[242],*sz_res_name[243],*sz_res_name[244],*sz_res_name[245],*sz_res_name[246],*sz_res_name[247],*sz_res_name[248],*sz_res_name[249],*sz_res_name[250],*sz_res_name[251],*sz_res_name[252],*sz_res_name[253],*sz_res_name[254],*sz_res_name[255],*sz_res_name[256],*sz_res_name[257],*sz_res_name[258],*sz_res_name[259]];
        windows_sys::Win32::UI::WindowsAndMessaging::ICONINFOEXW { cbSize, fIcon, xHotspot, yHotspot, hbmMask, hbmColor, wResID, szModName, szResName }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::ICONINFOEXW) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::ICONINFOEXW { cbSize, fIcon, xHotspot, yHotspot, hbmMask, hbmColor, wResID, szModName, szResName } = win32;
        let cb_size = cbSize;
        let f_icon = fIcon;
        let x_hotspot = xHotspot;
        let y_hotspot = yHotspot;
        let hbm_mask = unsafe { Hbitmap::new_optional(hbmMask) };
        let hbm_color = unsafe { Hbitmap::new_optional(hbmColor) };
        let w_res_id = wResID;
        let sz_mod_name = [szModName[0],szModName[1],szModName[2],szModName[3],szModName[4],szModName[5],szModName[6],szModName[7],szModName[8],szModName[9],szModName[10],szModName[11],szModName[12],szModName[13],szModName[14],szModName[15],szModName[16],szModName[17],szModName[18],szModName[19],szModName[20],szModName[21],szModName[22],szModName[23],szModName[24],szModName[25],szModName[26],szModName[27],szModName[28],szModName[29],szModName[30],szModName[31],szModName[32],szModName[33],szModName[34],szModName[35],szModName[36],szModName[37],szModName[38],szModName[39],szModName[40],szModName[41],szModName[42],szModName[43],szModName[44],szModName[45],szModName[46],szModName[47],szModName[48],szModName[49],szModName[50],szModName[51],szModName[52],szModName[53],szModName[54],szModName[55],szModName[56],szModName[57],szModName[58],szModName[59],szModName[60],szModName[61],szModName[62],szModName[63],szModName[64],szModName[65],szModName[66],szModName[67],szModName[68],szModName[69],szModName[70],szModName[71],szModName[72],szModName[73],szModName[74],szModName[75],szModName[76],szModName[77],szModName[78],szModName[79],szModName[80],szModName[81],szModName[82],szModName[83],szModName[84],szModName[85],szModName[86],szModName[87],szModName[88],szModName[89],szModName[90],szModName[91],szModName[92],szModName[93],szModName[94],szModName[95],szModName[96],szModName[97],szModName[98],szModName[99],szModName[100],szModName[101],szModName[102],szModName[103],szModName[104],szModName[105],szModName[106],szModName[107],szModName[108],szModName[109],szModName[110],szModName[111],szModName[112],szModName[113],szModName[114],szModName[115],szModName[116],szModName[117],szModName[118],szModName[119],szModName[120],szModName[121],szModName[122],szModName[123],szModName[124],szModName[125],szModName[126],szModName[127],szModName[128],szModName[129],szModName[130],szModName[131],szModName[132],szModName[133],szModName[134],szModName[135],szModName[136],szModName[137],szModName[138],szModName[139],szModName[140],szModName[141],szModName[142],szModName[143],szModName[144],szModName[145],szModName[146],szModName[147],szModName[148],szModName[149],szModName[150],szModName[151],szModName[152],szModName[153],szModName[154],szModName[155],szModName[156],szModName[157],szModName[158],szModName[159],szModName[160],szModName[161],szModName[162],szModName[163],szModName[164],szModName[165],szModName[166],szModName[167],szModName[168],szModName[169],szModName[170],szModName[171],szModName[172],szModName[173],szModName[174],szModName[175],szModName[176],szModName[177],szModName[178],szModName[179],szModName[180],szModName[181],szModName[182],szModName[183],szModName[184],szModName[185],szModName[186],szModName[187],szModName[188],szModName[189],szModName[190],szModName[191],szModName[192],szModName[193],szModName[194],szModName[195],szModName[196],szModName[197],szModName[198],szModName[199],szModName[200],szModName[201],szModName[202],szModName[203],szModName[204],szModName[205],szModName[206],szModName[207],szModName[208],szModName[209],szModName[210],szModName[211],szModName[212],szModName[213],szModName[214],szModName[215],szModName[216],szModName[217],szModName[218],szModName[219],szModName[220],szModName[221],szModName[222],szModName[223],szModName[224],szModName[225],szModName[226],szModName[227],szModName[228],szModName[229],szModName[230],szModName[231],szModName[232],szModName[233],szModName[234],szModName[235],szModName[236],szModName[237],szModName[238],szModName[239],szModName[240],szModName[241],szModName[242],szModName[243],szModName[244],szModName[245],szModName[246],szModName[247],szModName[248],szModName[249],szModName[250],szModName[251],szModName[252],szModName[253],szModName[254],szModName[255],szModName[256],szModName[257],szModName[258],szModName[259]];
        let sz_res_name = [szResName[0],szResName[1],szResName[2],szResName[3],szResName[4],szResName[5],szResName[6],szResName[7],szResName[8],szResName[9],szResName[10],szResName[11],szResName[12],szResName[13],szResName[14],szResName[15],szResName[16],szResName[17],szResName[18],szResName[19],szResName[20],szResName[21],szResName[22],szResName[23],szResName[24],szResName[25],szResName[26],szResName[27],szResName[28],szResName[29],szResName[30],szResName[31],szResName[32],szResName[33],szResName[34],szResName[35],szResName[36],szResName[37],szResName[38],szResName[39],szResName[40],szResName[41],szResName[42],szResName[43],szResName[44],szResName[45],szResName[46],szResName[47],szResName[48],szResName[49],szResName[50],szResName[51],szResName[52],szResName[53],szResName[54],szResName[55],szResName[56],szResName[57],szResName[58],szResName[59],szResName[60],szResName[61],szResName[62],szResName[63],szResName[64],szResName[65],szResName[66],szResName[67],szResName[68],szResName[69],szResName[70],szResName[71],szResName[72],szResName[73],szResName[74],szResName[75],szResName[76],szResName[77],szResName[78],szResName[79],szResName[80],szResName[81],szResName[82],szResName[83],szResName[84],szResName[85],szResName[86],szResName[87],szResName[88],szResName[89],szResName[90],szResName[91],szResName[92],szResName[93],szResName[94],szResName[95],szResName[96],szResName[97],szResName[98],szResName[99],szResName[100],szResName[101],szResName[102],szResName[103],szResName[104],szResName[105],szResName[106],szResName[107],szResName[108],szResName[109],szResName[110],szResName[111],szResName[112],szResName[113],szResName[114],szResName[115],szResName[116],szResName[117],szResName[118],szResName[119],szResName[120],szResName[121],szResName[122],szResName[123],szResName[124],szResName[125],szResName[126],szResName[127],szResName[128],szResName[129],szResName[130],szResName[131],szResName[132],szResName[133],szResName[134],szResName[135],szResName[136],szResName[137],szResName[138],szResName[139],szResName[140],szResName[141],szResName[142],szResName[143],szResName[144],szResName[145],szResName[146],szResName[147],szResName[148],szResName[149],szResName[150],szResName[151],szResName[152],szResName[153],szResName[154],szResName[155],szResName[156],szResName[157],szResName[158],szResName[159],szResName[160],szResName[161],szResName[162],szResName[163],szResName[164],szResName[165],szResName[166],szResName[167],szResName[168],szResName[169],szResName[170],szResName[171],szResName[172],szResName[173],szResName[174],szResName[175],szResName[176],szResName[177],szResName[178],szResName[179],szResName[180],szResName[181],szResName[182],szResName[183],szResName[184],szResName[185],szResName[186],szResName[187],szResName[188],szResName[189],szResName[190],szResName[191],szResName[192],szResName[193],szResName[194],szResName[195],szResName[196],szResName[197],szResName[198],szResName[199],szResName[200],szResName[201],szResName[202],szResName[203],szResName[204],szResName[205],szResName[206],szResName[207],szResName[208],szResName[209],szResName[210],szResName[211],szResName[212],szResName[213],szResName[214],szResName[215],szResName[216],szResName[217],szResName[218],szResName[219],szResName[220],szResName[221],szResName[222],szResName[223],szResName[224],szResName[225],szResName[226],szResName[227],szResName[228],szResName[229],szResName[230],szResName[231],szResName[232],szResName[233],szResName[234],szResName[235],szResName[236],szResName[237],szResName[238],szResName[239],szResName[240],szResName[241],szResName[242],szResName[243],szResName[244],szResName[245],szResName[246],szResName[247],szResName[248],szResName[249],szResName[250],szResName[251],szResName[252],szResName[253],szResName[254],szResName[255],szResName[256],szResName[257],szResName[258],szResName[259]];
        Self { cb_size, f_icon, x_hotspot, y_hotspot, hbm_mask, hbm_color, w_res_id, sz_mod_name, sz_res_name }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Iconmetricsa {
    pub cb_size: u32,
    pub i_horz_spacing: i32,
    pub i_vert_spacing: i32,
    pub i_title_wrap: i32,
    pub lf_font: Logfonta,
}
impl Iconmetricsa {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::ICONMETRICSA {
        let Self { cb_size, i_horz_spacing, i_vert_spacing, i_title_wrap, lf_font } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::ICONMETRICSA>() as _;
        let iHorzSpacing = *i_horz_spacing;
        let iVertSpacing = *i_vert_spacing;
        let iTitleWrap = *i_title_wrap;
        let lfFont = lf_font.to_win32();
        windows_sys::Win32::UI::WindowsAndMessaging::ICONMETRICSA { cbSize, iHorzSpacing, iVertSpacing, iTitleWrap, lfFont }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::ICONMETRICSA) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::ICONMETRICSA { cbSize, iHorzSpacing, iVertSpacing, iTitleWrap, lfFont } = win32;
        let cb_size = cbSize;
        let i_horz_spacing = iHorzSpacing;
        let i_vert_spacing = iVertSpacing;
        let i_title_wrap = iTitleWrap;
        let lf_font = unsafe { LOGFONTA::from_win32(lfFont) };
        Self { cb_size, i_horz_spacing, i_vert_spacing, i_title_wrap, lf_font }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Iconmetricsw {
    pub cb_size: u32,
    pub i_horz_spacing: i32,
    pub i_vert_spacing: i32,
    pub i_title_wrap: i32,
    pub lf_font: Logfontw,
}
impl Iconmetricsw {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::ICONMETRICSW {
        let Self { cb_size, i_horz_spacing, i_vert_spacing, i_title_wrap, lf_font } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::ICONMETRICSW>() as _;
        let iHorzSpacing = *i_horz_spacing;
        let iVertSpacing = *i_vert_spacing;
        let iTitleWrap = *i_title_wrap;
        let lfFont = lf_font.to_win32();
        windows_sys::Win32::UI::WindowsAndMessaging::ICONMETRICSW { cbSize, iHorzSpacing, iVertSpacing, iTitleWrap, lfFont }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::ICONMETRICSW) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::ICONMETRICSW { cbSize, iHorzSpacing, iVertSpacing, iTitleWrap, lfFont } = win32;
        let cb_size = cbSize;
        let i_horz_spacing = iHorzSpacing;
        let i_vert_spacing = iVertSpacing;
        let i_title_wrap = iTitleWrap;
        let lf_font = unsafe { LOGFONTW::from_win32(lfFont) };
        Self { cb_size, i_horz_spacing, i_vert_spacing, i_title_wrap, lf_font }
    }
}
pub const IEPDN_BINDINGUI: i32 = 0x1;
pub const IESHORTCUT_NEWBROWSER: i32 = 0x1;
pub const IESHORTCUT_OPENNEWTAB: i32 = 0x2;
pub const IESHORTCUT_FORCENAVIGATE: i32 = 0x4;
pub const IESHORTCUT_BACKGROUNDTAB: i32 = 0x8;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Imageinfo {
    pub hbm_image: Option<Hbitmap>,
    pub hbm_mask: Option<Hbitmap>,
    pub unused1: i32,
    pub unused2: i32,
    pub rc_image: Rect,
}
impl Imageinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::IMAGEINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::IMAGEINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const IL_VERTICAL: i32 = 0x0;
pub const IL_HORIZONTAL: i32 = 0x1;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Imagelistdrawparams {
    pub cb_size: u32,
    pub himl: Option<Himagelist>,
    pub i: i32,
    pub hdc_dst: Option<Hdc>,
    pub x: i32,
    pub y: i32,
    pub cx: i32,
    pub cy: i32,
    pub x_bitmap: i32,
    pub y_bitmap: i32,
    pub rgb_bk: u32,
    pub rgb_fg: u32,
    pub f_style: u32,
    pub dw_rop: u32,
    pub f_state: u32,
    pub frame: u32,
    pub cr_effect: u32,
}
impl Imagelistdrawparams {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::IMAGELISTDRAWPARAMS {
        let Self { cb_size, himl, i, hdc_dst, x, y, cx, cy, x_bitmap, y_bitmap, rgb_bk, rgb_fg, f_style, dw_rop, f_state, frame, cr_effect } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::IMAGELISTDRAWPARAMS>() as _;
        let himl = himl.map_or(0, Himagelist::into_raw);
        let i = *i;
        let hdcDst = hdc_dst.map_or(0, Hdc::into_raw);
        let x = *x;
        let y = *y;
        let cx = *cx;
        let cy = *cy;
        let xBitmap = *x_bitmap;
        let yBitmap = *y_bitmap;
        let rgbBk = *rgb_bk;
        let rgbFg = *rgb_fg;
        let fStyle = *f_style;
        let dwRop = *dw_rop;
        let fState = *f_state;
        let Frame = *frame;
        let crEffect = *cr_effect;
        windows_sys::Win32::UI::Controls::IMAGELISTDRAWPARAMS { cbSize, himl, i, hdcDst, x, y, cx, cy, xBitmap, yBitmap, rgbBk, rgbFg, fStyle, dwRop, fState, Frame, crEffect }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::IMAGELISTDRAWPARAMS) -> Self {
        let windows_sys::Win32::UI::Controls::IMAGELISTDRAWPARAMS { cbSize, himl, i, hdcDst, x, y, cx, cy, xBitmap, yBitmap, rgbBk, rgbFg, fStyle, dwRop, fState, Frame, crEffect } = win32;
        let cb_size = cbSize;
        let himl = unsafe { Himagelist::new_optional(himl) };
        let i = i;
        let hdc_dst = unsafe { Hdc::new_optional(hdcDst) };
        let x = x;
        let y = y;
        let cx = cx;
        let cy = cy;
        let x_bitmap = xBitmap;
        let y_bitmap = yBitmap;
        let rgb_bk = rgbBk;
        let rgb_fg = rgbFg;
        let f_style = fStyle;
        let dw_rop = dwRop;
        let f_state = fState;
        let frame = Frame;
        let cr_effect = crEffect;
        Self { cb_size, himl, i, hdc_dst, x, y, cx, cy, x_bitmap, y_bitmap, rgb_bk, rgb_fg, f_style, dw_rop, f_state, frame, cr_effect }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Imageliststats {
    pub cb_size: u32,
    pub c_alloc: i32,
    pub c_used: i32,
    pub c_standby: i32,
}
impl Imageliststats {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::IMAGELISTSTATS {
        let Self { cb_size, c_alloc, c_used, c_standby } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::IMAGELISTSTATS>() as _;
        let cAlloc = *c_alloc;
        let cUsed = *c_used;
        let cStandby = *c_standby;
        windows_sys::Win32::UI::Controls::IMAGELISTSTATS { cbSize, cAlloc, cUsed, cStandby }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::IMAGELISTSTATS) -> Self {
        let windows_sys::Win32::UI::Controls::IMAGELISTSTATS { cbSize, cAlloc, cUsed, cStandby } = win32;
        let cb_size = cbSize;
        let c_alloc = cAlloc;
        let c_used = cUsed;
        let c_standby = cStandby;
        Self { cb_size, c_alloc, c_used, c_standby }
    }
}
pub const ILC_MASK: u32 = 0x1;
pub const ILC_COLOR: u32 = 0x0;
pub const ILC_COLORDDB: u32 = 0xFE;
pub const ILC_COLOR4: u32 = 0x4;
pub const ILC_COLOR8: u32 = 0x8;
pub const ILC_COLOR16: u32 = 0x10;
pub const ILC_COLOR24: u32 = 0x18;
pub const ILC_COLOR32: u32 = 0x20;
pub const ILC_PALETTE: u32 = 0x800;
pub const ILC_MIRROR: u32 = 0x2000;
pub const ILC_PERITEMMIRROR: u32 = 0x8000;
pub const ILC_ORIGINALSIZE: u32 = 0x10000;
pub const ILC_HIGHQUALITYSCALE: u32 = 0x20000;
pub const IST_NONE: i32 = 0x0;
pub const IST_SIZE: i32 = 0x1;
pub const IST_DPI: i32 = 0x2;
pub const LR_CREATEDIBSECTION: u32 = 0x2000;
pub const LR_DEFAULTCOLOR: u32 = 0x0;
pub const LR_DEFAULTSIZE: u32 = 0x40;
pub const LR_LOADFROMFILE: u32 = 0x10;
pub const LR_LOADMAP3DCOLORS: u32 = 0x1000;
pub const LR_LOADTRANSPARENT: u32 = 0x20;
pub const LR_MONOCHROME: u32 = 0x1;
pub const LR_SHARED: u32 = 0x8000;
pub const LR_VGACOLOR: u32 = 0x80;
pub const LR_COPYDELETEORG: u32 = 0x8;
pub const LR_COPYFROMRESOURCE: u32 = 0x4000;
pub const LR_COPYRETURNORG: u32 = 0x4;
pub const ILCF_MOVE: u32 = 0x0;
pub const ILCF_SWAP: u32 = 0x1;
pub const ILD_BLEND: u32 = 0x4;
pub const ILD_BLEND50: u32 = 0x4;
pub const ILD_FOCUS: u32 = 0x2;
pub const ILD_MASK: u32 = 0x10;
pub const ILD_NORMAL: u32 = 0x0;
pub const ILD_SELECTED: u32 = 0x4;
pub const ILIF_ALPHA: u32 = 0x1;
pub const ILIF_LOWQUALITY: u32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Initcommoncontrolsex {
    pub dw_size: u32,
    pub dw_icc: u32,
}
impl Initcommoncontrolsex {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::INITCOMMONCONTROLSEX {
        let Self { dw_size, dw_icc } = self;
        let dwSize = mem::size_of::<windows_sys::Win32::UI::Controls::INITCOMMONCONTROLSEX>() as _;
        let dwICC = dw_icc;
        windows_sys::Win32::UI::Controls::INITCOMMONCONTROLSEX { dwSize, dwICC }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::INITCOMMONCONTROLSEX) -> Self {
        let windows_sys::Win32::UI::Controls::INITCOMMONCONTROLSEX { dwSize, dwICC } = win32;
        let dw_size = dwSize;
        let dw_icc = dwICC;
        Self { dw_size, dw_icc }
    }
}
pub const ICC_ANIMATE_CLASS: u32 = 0x80;
pub const ICC_BAR_CLASSES: u32 = 0x4;
pub const ICC_COOL_CLASSES: u32 = 0x400;
pub const ICC_DATE_CLASSES: u32 = 0x100;
pub const ICC_HOTKEY_CLASS: u32 = 0x40;
pub const ICC_INTERNET_CLASSES: u32 = 0x800;
pub const ICC_LINK_CLASS: u32 = 0x8000;
pub const ICC_LISTVIEW_CLASSES: u32 = 0x1;
pub const ICC_NATIVEFNTCTL_CLASS: u32 = 0x2000;
pub const ICC_PAGESCROLLER_CLASS: u32 = 0x1000;
pub const ICC_PROGRESS_CLASS: u32 = 0x20;
pub const ICC_STANDARD_CLASSES: u32 = 0x4000;
pub const ICC_TAB_CLASSES: u32 = 0x8;
pub const ICC_TREEVIEW_CLASSES: u32 = 0x2;
pub const ICC_UPDOWN_CLASS: u32 = 0x10;
pub const ICC_USEREX_CLASSES: u32 = 0x200;
pub const ICC_WIN95_CLASSES: u32 = 0xFF;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct InputInjectionValue {
    pub page: u16,
    pub usage: u16,
    pub value: i32,
    pub index: u16,
}
impl InputInjectionValue {
    fn to_win32(&self) -> windows_sys::Win32::UI::Input::Pointer::INPUT_INJECTION_VALUE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Input::Pointer::INPUT_INJECTION_VALUE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Intlist {
    pub i_value_count: i32,
    pub i_values: [i32; 402],
}
impl Intlist {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::INTLIST {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::INTLIST) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Itemspacing {
    pub cx_small: i32,
    pub cy_small: i32,
    pub cx_large: i32,
    pub cy_large: i32,
}
impl Itemspacing {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::ITEMSPACING {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::ITEMSPACING) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Kbdllhookstruct {
    pub vk_code: u32,
    pub scan_code: u32,
    pub flags: u32,
    pub time: u32,
    pub dw_extra_info: usize,
}
impl Kbdllhookstruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::KBDLLHOOKSTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::KBDLLHOOKSTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const LLKHF_EXTENDED: u32 = 0x1;
pub const LLKHF_ALTDOWN: u32 = 0x20;
pub const LLKHF_UP: u32 = 0x80;
pub const LLKHF_INJECTED: u32 = 0x10;
pub const LLKHF_LOWER_IL_INJECTED: u32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Kerningpair {
    pub w_first: u16,
    pub w_second: u16,
    pub i_kern_amount: i32,
}
impl Kerningpair {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::KERNINGPAIR {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::KERNINGPAIR) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const KF_CATEGORY_VIRTUAL: i32 = 0x1;
pub const KF_CATEGORY_FIXED: i32 = 0x2;
pub const KF_CATEGORY_COMMON: i32 = 0x3;
pub const KF_CATEGORY_PERUSER: i32 = 0x4;
pub const KDC_FREQUENT: i32 = 0x1;
pub const KDC_RECENT: i32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct KnownfolderDefinition<'a> {
    pub category: i32,
    pub psz_name: Cow<'a, [u16]>,
    pub psz_description: Cow<'a, [u16]>,
    pub fid_parent: GUID,
    pub psz_relative_path: Cow<'a, [u16]>,
    pub psz_parsing_name: Cow<'a, [u16]>,
    pub psz_tooltip: Cow<'a, [u16]>,
    pub psz_localized_name: Cow<'a, [u16]>,
    pub psz_icon: Cow<'a, [u16]>,
    pub psz_security: Cow<'a, [u16]>,
    pub dw_attributes: u32,
    pub kfd_flags: u32,
    pub ftid_type: GUID,
}
impl KnownfolderDefinition {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::KNOWNFOLDER_DEFINITION {
        let Self { category, psz_name, psz_description, fid_parent, psz_relative_path, psz_parsing_name, psz_tooltip, psz_localized_name, psz_icon, psz_security, dw_attributes, kfd_flags, ftid_type } = self;
        let category = category;
        assert_eq!(psz_name.last(), Some(0));
        let pszName = psz_name.as_ptr();
        assert_eq!(psz_description.last(), Some(0));
        let pszDescription = psz_description.as_ptr();
        let fidParent = *fid_parent;
        assert_eq!(psz_relative_path.last(), Some(0));
        let pszRelativePath = psz_relative_path.as_ptr();
        assert_eq!(psz_parsing_name.last(), Some(0));
        let pszParsingName = psz_parsing_name.as_ptr();
        assert_eq!(psz_tooltip.last(), Some(0));
        let pszTooltip = psz_tooltip.as_ptr();
        assert_eq!(psz_localized_name.last(), Some(0));
        let pszLocalizedName = psz_localized_name.as_ptr();
        assert_eq!(psz_icon.last(), Some(0));
        let pszIcon = psz_icon.as_ptr();
        assert_eq!(psz_security.last(), Some(0));
        let pszSecurity = psz_security.as_ptr();
        let dwAttributes = *dw_attributes;
        let kfdFlags = *kfd_flags;
        let ftidType = *ftid_type;
        windows_sys::Win32::UI::Shell::KNOWNFOLDER_DEFINITION { category, pszName, pszDescription, fidParent, pszRelativePath, pszParsingName, pszTooltip, pszLocalizedName, pszIcon, pszSecurity, dwAttributes, kfdFlags, ftidType }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::KNOWNFOLDER_DEFINITION) -> Self {
        let windows_sys::Win32::UI::Shell::KNOWNFOLDER_DEFINITION { category, pszName, pszDescription, fidParent, pszRelativePath, pszParsingName, pszTooltip, pszLocalizedName, pszIcon, pszSecurity, dwAttributes, kfdFlags, ftidType } = win32;
        let category = category;
        let slen = unsafe { wide_strlen(pszName as *const u16) };
        let pszName = unsafe { slice::from_raw_parts(pszName, slen + 1) };
        let psz_name = pszName.to_vec();
        let slen = unsafe { wide_strlen(pszDescription as *const u16) };
        let pszDescription = unsafe { slice::from_raw_parts(pszDescription, slen + 1) };
        let psz_description = pszDescription.to_vec();
        let fid_parent = fidParent;
        let slen = unsafe { wide_strlen(pszRelativePath as *const u16) };
        let pszRelativePath = unsafe { slice::from_raw_parts(pszRelativePath, slen + 1) };
        let psz_relative_path = pszRelativePath.to_vec();
        let slen = unsafe { wide_strlen(pszParsingName as *const u16) };
        let pszParsingName = unsafe { slice::from_raw_parts(pszParsingName, slen + 1) };
        let psz_parsing_name = pszParsingName.to_vec();
        let slen = unsafe { wide_strlen(pszTooltip as *const u16) };
        let pszTooltip = unsafe { slice::from_raw_parts(pszTooltip, slen + 1) };
        let psz_tooltip = pszTooltip.to_vec();
        let slen = unsafe { wide_strlen(pszLocalizedName as *const u16) };
        let pszLocalizedName = unsafe { slice::from_raw_parts(pszLocalizedName, slen + 1) };
        let psz_localized_name = pszLocalizedName.to_vec();
        let slen = unsafe { wide_strlen(pszIcon as *const u16) };
        let pszIcon = unsafe { slice::from_raw_parts(pszIcon, slen + 1) };
        let psz_icon = pszIcon.to_vec();
        let slen = unsafe { wide_strlen(pszSecurity as *const u16) };
        let pszSecurity = unsafe { slice::from_raw_parts(pszSecurity, slen + 1) };
        let psz_security = pszSecurity.to_vec();
        let dw_attributes = dwAttributes;
        let kfd_flags = kfdFlags;
        let ftid_type = ftidType;
        Self { category, psz_name, psz_description, fid_parent, psz_relative_path, psz_parsing_name, psz_tooltip, psz_localized_name, psz_icon, psz_security, dw_attributes, kfd_flags, ftid_type }
    }
}
pub const KF_FLAG_DEFAULT: i32 = 0x0;
pub const KF_FLAG_FORCE_APP_DATA_REDIRECTION: i32 = 0x80000;
pub const KF_FLAG_RETURN_FILTER_REDIRECTION_TARGET: i32 = 0x40000;
pub const KF_FLAG_FORCE_PACKAGE_REDIRECTION: i32 = 0x20000;
pub const KF_FLAG_NO_PACKAGE_REDIRECTION: i32 = 0x10000;
pub const KF_FLAG_FORCE_APPCONTAINER_REDIRECTION: i32 = 0x20000;
pub const KF_FLAG_NO_APPCONTAINER_REDIRECTION: i32 = 0x10000;
pub const KF_FLAG_CREATE: i32 = 0x8000;
pub const KF_FLAG_DONT_VERIFY: i32 = 0x4000;
pub const KF_FLAG_DONT_UNEXPAND: i32 = 0x2000;
pub const KF_FLAG_NO_ALIAS: i32 = 0x1000;
pub const KF_FLAG_INIT: i32 = 0x800;
pub const KF_FLAG_DEFAULT_PATH: i32 = 0x400;
pub const KF_FLAG_NOT_PARENT_RELATIVE: i32 = 0x200;
pub const KF_FLAG_SIMPLE_IDLIST: i32 = 0x100;
pub const KF_FLAG_ALIAS_ONLY: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFF80000000;
pub const LWA_ALPHA: u32 = 0x2;
pub const LWA_COLORKEY: u32 = 0x1;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Layerplanedescriptor {
    pub n_size: u16,
    pub n_version: u16,
    pub dw_flags: u32,
    pub i_pixel_type: u8,
    pub c_color_bits: u8,
    pub c_red_bits: u8,
    pub c_red_shift: u8,
    pub c_green_bits: u8,
    pub c_green_shift: u8,
    pub c_blue_bits: u8,
    pub c_blue_shift: u8,
    pub c_alpha_bits: u8,
    pub c_alpha_shift: u8,
    pub c_accum_bits: u8,
    pub c_accum_red_bits: u8,
    pub c_accum_green_bits: u8,
    pub c_accum_blue_bits: u8,
    pub c_accum_alpha_bits: u8,
    pub c_depth_bits: u8,
    pub c_stencil_bits: u8,
    pub c_aux_buffers: u8,
    pub i_layer_plane: u8,
    pub b_reserved: u8,
    pub cr_transparent: u32,
}
impl Layerplanedescriptor {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::OpenGL::LAYERPLANEDESCRIPTOR {
        let Self { n_size, n_version, dw_flags, i_pixel_type, c_color_bits, c_red_bits, c_red_shift, c_green_bits, c_green_shift, c_blue_bits, c_blue_shift, c_alpha_bits, c_alpha_shift, c_accum_bits, c_accum_red_bits, c_accum_green_bits, c_accum_blue_bits, c_accum_alpha_bits, c_depth_bits, c_stencil_bits, c_aux_buffers, i_layer_plane, b_reserved, cr_transparent } = self;
        let nSize = mem::size_of::<windows_sys::Win32::Graphics::OpenGL::LAYERPLANEDESCRIPTOR>() as _;
        let nVersion = *n_version;
        let dwFlags = *dw_flags;
        let iPixelType = *i_pixel_type;
        let cColorBits = *c_color_bits;
        let cRedBits = *c_red_bits;
        let cRedShift = *c_red_shift;
        let cGreenBits = *c_green_bits;
        let cGreenShift = *c_green_shift;
        let cBlueBits = *c_blue_bits;
        let cBlueShift = *c_blue_shift;
        let cAlphaBits = *c_alpha_bits;
        let cAlphaShift = *c_alpha_shift;
        let cAccumBits = *c_accum_bits;
        let cAccumRedBits = *c_accum_red_bits;
        let cAccumGreenBits = *c_accum_green_bits;
        let cAccumBlueBits = *c_accum_blue_bits;
        let cAccumAlphaBits = *c_accum_alpha_bits;
        let cDepthBits = *c_depth_bits;
        let cStencilBits = *c_stencil_bits;
        let cAuxBuffers = *c_aux_buffers;
        let iLayerPlane = *i_layer_plane;
        let bReserved = *b_reserved;
        let crTransparent = *cr_transparent;
        windows_sys::Win32::Graphics::OpenGL::LAYERPLANEDESCRIPTOR { nSize, nVersion, dwFlags, iPixelType, cColorBits, cRedBits, cRedShift, cGreenBits, cGreenShift, cBlueBits, cBlueShift, cAlphaBits, cAlphaShift, cAccumBits, cAccumRedBits, cAccumGreenBits, cAccumBlueBits, cAccumAlphaBits, cDepthBits, cStencilBits, cAuxBuffers, iLayerPlane, bReserved, crTransparent }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::OpenGL::LAYERPLANEDESCRIPTOR) -> Self {
        let windows_sys::Win32::Graphics::OpenGL::LAYERPLANEDESCRIPTOR { nSize, nVersion, dwFlags, iPixelType, cColorBits, cRedBits, cRedShift, cGreenBits, cGreenShift, cBlueBits, cBlueShift, cAlphaBits, cAlphaShift, cAccumBits, cAccumRedBits, cAccumGreenBits, cAccumBlueBits, cAccumAlphaBits, cDepthBits, cStencilBits, cAuxBuffers, iLayerPlane, bReserved, crTransparent } = win32;
        let n_size = nSize;
        let n_version = nVersion;
        let dw_flags = dwFlags;
        let i_pixel_type = iPixelType;
        let c_color_bits = cColorBits;
        let c_red_bits = cRedBits;
        let c_red_shift = cRedShift;
        let c_green_bits = cGreenBits;
        let c_green_shift = cGreenShift;
        let c_blue_bits = cBlueBits;
        let c_blue_shift = cBlueShift;
        let c_alpha_bits = cAlphaBits;
        let c_alpha_shift = cAlphaShift;
        let c_accum_bits = cAccumBits;
        let c_accum_red_bits = cAccumRedBits;
        let c_accum_green_bits = cAccumGreenBits;
        let c_accum_blue_bits = cAccumBlueBits;
        let c_accum_alpha_bits = cAccumAlphaBits;
        let c_depth_bits = cDepthBits;
        let c_stencil_bits = cStencilBits;
        let c_aux_buffers = cAuxBuffers;
        let i_layer_plane = iLayerPlane;
        let b_reserved = bReserved;
        let cr_transparent = crTransparent;
        Self { n_size, n_version, dw_flags, i_pixel_type, c_color_bits, c_red_bits, c_red_shift, c_green_bits, c_green_shift, c_blue_bits, c_blue_shift, c_alpha_bits, c_alpha_shift, c_accum_bits, c_accum_red_bits, c_accum_green_bits, c_accum_blue_bits, c_accum_alpha_bits, c_depth_bits, c_stencil_bits, c_aux_buffers, i_layer_plane, b_reserved, cr_transparent }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lhittestinfo {
    pub pt: Point,
    pub item: Litem,
}
impl Lhittestinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LHITTESTINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LHITTESTINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const LFF_FORCEFILESYSTEM: i32 = 0x1;
pub const LFF_STORAGEITEMS: i32 = 0x2;
pub const LFF_ALLITEMS: i32 = 0x3;
pub const LMD_DEFAULT: i32 = 0x0;
pub const LMD_ALLOWUNINDEXABLENETWORKLOCATIONS: i32 = 0x1;
pub const LOF_DEFAULT: i32 = 0x0;
pub const LOF_PINNEDTONAVPANE: i32 = 0x1;
pub const LOF_MASK_ALL: i32 = 0x1;
pub const LSF_FAILIFTHERE: i32 = 0x0;
pub const LSF_OVERRIDEEXISTING: i32 = 0x1;
pub const LSF_MAKEUNIQUENAME: i32 = 0x2;
pub const LP_HYPERLINK: i32 = 0x1;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Litem {
    pub mask: u32,
    pub i_link: i32,
    pub state: u32,
    pub state_mask: u32,
    pub sz_id: [u8; 48],
    pub sz_url: [u8; 2084],
}
impl Litem {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LITEM {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LITEM) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const DONT_RESOLVE_DLL_REFERENCES: u32 = 0x1;
pub const LOAD_LIBRARY_AS_DATAFILE: u32 = 0x2;
pub const LOAD_WITH_ALTERED_SEARCH_PATH: u32 = 0x8;
pub const LOAD_IGNORE_CODE_AUTHZ_LEVEL: u32 = 0x10;
pub const LOAD_LIBRARY_AS_IMAGE_RESOURCE: u32 = 0x20;
pub const LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE: u32 = 0x40;
pub const LOAD_LIBRARY_REQUIRE_SIGNED_TARGET: u32 = 0x80;
pub const LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR: u32 = 0x100;
pub const LOAD_LIBRARY_SEARCH_APPLICATION_DIR: u32 = 0x200;
pub const LOAD_LIBRARY_SEARCH_USER_DIRS: u32 = 0x400;
pub const LOAD_LIBRARY_SEARCH_SYSTEM32: u32 = 0x800;
pub const LOAD_LIBRARY_SEARCH_DEFAULT_DIRS: u32 = 0x1000;
pub const LOAD_LIBRARY_SAFE_CURRENT_DIRS: u32 = 0x2000;
pub const LOAD_LIBRARY_SEARCH_SYSTEM32_NO_FORWARDER: u32 = 0x4000;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Logbrush {
    pub lb_style: u32,
    pub lb_color: u32,
    pub lb_hatch: usize,
}
impl Logbrush {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::LOGBRUSH {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::LOGBRUSH) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Logbrush32 {
    pub lb_style: u32,
    pub lb_color: u32,
    pub lb_hatch: u32,
}
impl Logbrush32 {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::LOGBRUSH32 {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::LOGBRUSH32) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Logfonta {
    pub lf_height: i32,
    pub lf_width: i32,
    pub lf_escapement: i32,
    pub lf_orientation: i32,
    pub lf_weight: i32,
    pub lf_italic: u8,
    pub lf_underline: u8,
    pub lf_strike_out: u8,
    pub lf_char_set: u8,
    pub lf_out_precision: u8,
    pub lf_clip_precision: u8,
    pub lf_quality: u8,
    pub lf_pitch_and_family: u8,
    pub lf_face_name: [CHAR; 32],
}
impl Logfonta {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::LOGFONTA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::LOGFONTA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Logfontw {
    pub lf_height: i32,
    pub lf_width: i32,
    pub lf_escapement: i32,
    pub lf_orientation: i32,
    pub lf_weight: i32,
    pub lf_italic: u8,
    pub lf_underline: u8,
    pub lf_strike_out: u8,
    pub lf_char_set: u8,
    pub lf_out_precision: u8,
    pub lf_clip_precision: u8,
    pub lf_quality: u8,
    pub lf_pitch_and_family: u8,
    pub lf_face_name: [u8; 32],
}
impl Logfontw {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::LOGFONTW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::LOGFONTW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const SPLS_NORMAL: i32 = 0x1;
pub const SPLS_HOT: i32 = 0x2;
pub const SPLS_PRESSED: i32 = 0x3;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Logpalette {
    pub pal_version: u16,
    pub pal_num_entries: u16,
    pub pal_pal_entry: [Paletteentry; 1],
}
impl Logpalette {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::LOGPALETTE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::LOGPALETTE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Logpen {
    pub lopn_style: u32,
    pub lopn_width: Point,
    pub lopn_color: u32,
}
impl Logpen {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::LOGPEN {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::LOGPEN) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Lresult {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Lresult {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Lresult {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Lresult {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Luid {
    pub low_part: u32,
    pub high_part: i32,
}
impl Luid {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::LUID {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::LUID) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvbkimagea<'a> {
    pub ul_flags: u32,
    pub hbm: Option<Hbitmap>,
    pub psz_image: Cow<'a, CStr>,
    pub cch_image_max: u32,
    pub x_offset_percent: i32,
    pub y_offset_percent: i32,
}
impl Lvbkimagea {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVBKIMAGEA {
        let Self { ul_flags, hbm, psz_image, cch_image_max, x_offset_percent, y_offset_percent } = self;
        let ulFlags = *ul_flags;
        let hbm = hbm.map_or(0, Hbitmap::into_raw);
        let pszImage = psz_image.as_ptr();
        let cchImageMax = *cch_image_max;
        let xOffsetPercent = *x_offset_percent;
        let yOffsetPercent = *y_offset_percent;
        windows_sys::Win32::UI::Controls::LVBKIMAGEA { ulFlags, hbm, pszImage, cchImageMax, xOffsetPercent, yOffsetPercent }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVBKIMAGEA) -> Self {
        let windows_sys::Win32::UI::Controls::LVBKIMAGEA { ulFlags, hbm, pszImage, cchImageMax, xOffsetPercent, yOffsetPercent } = win32;
        let ul_flags = ulFlags;
        let hbm = unsafe { Hbitmap::new_optional(hbm) };
        let pszImage = unsafe { CStr::from_ptr(pszImage) };
        let pszImage = pszImage.to_bytes_with_nul().to_vec();
        let psz_image = Cow::Owned(unsafe { CString::from_vec_unchecked(pszImage) });
        let cch_image_max = cchImageMax;
        let x_offset_percent = xOffsetPercent;
        let y_offset_percent = yOffsetPercent;
        Self { ul_flags, hbm, psz_image, cch_image_max, x_offset_percent, y_offset_percent }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvbkimagew<'a> {
    pub ul_flags: u32,
    pub hbm: Option<Hbitmap>,
    pub psz_image: Cow<'a, [u16]>,
    pub cch_image_max: u32,
    pub x_offset_percent: i32,
    pub y_offset_percent: i32,
}
impl Lvbkimagew {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVBKIMAGEW {
        let Self { ul_flags, hbm, psz_image, cch_image_max, x_offset_percent, y_offset_percent } = self;
        let ulFlags = *ul_flags;
        let hbm = hbm.map_or(0, Hbitmap::into_raw);
        assert_eq!(psz_image.last(), Some(0));
        let pszImage = psz_image.as_ptr();
        let cchImageMax = *cch_image_max;
        let xOffsetPercent = *x_offset_percent;
        let yOffsetPercent = *y_offset_percent;
        windows_sys::Win32::UI::Controls::LVBKIMAGEW { ulFlags, hbm, pszImage, cchImageMax, xOffsetPercent, yOffsetPercent }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVBKIMAGEW) -> Self {
        let windows_sys::Win32::UI::Controls::LVBKIMAGEW { ulFlags, hbm, pszImage, cchImageMax, xOffsetPercent, yOffsetPercent } = win32;
        let ul_flags = ulFlags;
        let hbm = unsafe { Hbitmap::new_optional(hbm) };
        let slen = unsafe { wide_strlen(pszImage as *const u16) };
        let pszImage = unsafe { slice::from_raw_parts(pszImage, slen + 1) };
        let psz_image = pszImage.to_vec();
        let cch_image_max = cchImageMax;
        let x_offset_percent = xOffsetPercent;
        let y_offset_percent = yOffsetPercent;
        Self { ul_flags, hbm, psz_image, cch_image_max, x_offset_percent, y_offset_percent }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvcolumna<'a> {
    pub mask: u32,
    pub fmt: u32,
    pub cx: i32,
    pub psz_text: Cow<'a, CStr>,
    pub cch_text_max: i32,
    pub i_sub_item: i32,
    pub i_image: i32,
    pub i_order: i32,
    pub cx_min: i32,
    pub cx_default: i32,
    pub cx_ideal: i32,
}
impl Lvcolumna {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVCOLUMNA {
        let Self { mask, fmt, cx, psz_text, cch_text_max, i_sub_item, i_image, i_order, cx_min, cx_default, cx_ideal } = self;
        let mask = mask;
        let fmt = fmt;
        let cx = *cx;
        let pszText = psz_text.as_ptr();
        let cchTextMax = *cch_text_max;
        let iSubItem = *i_sub_item;
        let iImage = *i_image;
        let iOrder = *i_order;
        let cxMin = *cx_min;
        let cxDefault = *cx_default;
        let cxIdeal = *cx_ideal;
        windows_sys::Win32::UI::Controls::LVCOLUMNA { mask, fmt, cx, pszText, cchTextMax, iSubItem, iImage, iOrder, cxMin, cxDefault, cxIdeal }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVCOLUMNA) -> Self {
        let windows_sys::Win32::UI::Controls::LVCOLUMNA { mask, fmt, cx, pszText, cchTextMax, iSubItem, iImage, iOrder, cxMin, cxDefault, cxIdeal } = win32;
        let mask = mask;
        let fmt = fmt;
        let cx = cx;
        let pszText = unsafe { CStr::from_ptr(pszText) };
        let pszText = pszText.to_bytes_with_nul().to_vec();
        let psz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(pszText) });
        let cch_text_max = cchTextMax;
        let i_sub_item = iSubItem;
        let i_image = iImage;
        let i_order = iOrder;
        let cx_min = cxMin;
        let cx_default = cxDefault;
        let cx_ideal = cxIdeal;
        Self { mask, fmt, cx, psz_text, cch_text_max, i_sub_item, i_image, i_order, cx_min, cx_default, cx_ideal }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvcolumnw<'a> {
    pub mask: u32,
    pub fmt: u32,
    pub cx: i32,
    pub psz_text: Cow<'a, [u16]>,
    pub cch_text_max: i32,
    pub i_sub_item: i32,
    pub i_image: i32,
    pub i_order: i32,
    pub cx_min: i32,
    pub cx_default: i32,
    pub cx_ideal: i32,
}
impl Lvcolumnw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVCOLUMNW {
        let Self { mask, fmt, cx, psz_text, cch_text_max, i_sub_item, i_image, i_order, cx_min, cx_default, cx_ideal } = self;
        let mask = mask;
        let fmt = fmt;
        let cx = *cx;
        assert_eq!(psz_text.last(), Some(0));
        let pszText = psz_text.as_ptr();
        let cchTextMax = *cch_text_max;
        let iSubItem = *i_sub_item;
        let iImage = *i_image;
        let iOrder = *i_order;
        let cxMin = *cx_min;
        let cxDefault = *cx_default;
        let cxIdeal = *cx_ideal;
        windows_sys::Win32::UI::Controls::LVCOLUMNW { mask, fmt, cx, pszText, cchTextMax, iSubItem, iImage, iOrder, cxMin, cxDefault, cxIdeal }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVCOLUMNW) -> Self {
        let windows_sys::Win32::UI::Controls::LVCOLUMNW { mask, fmt, cx, pszText, cchTextMax, iSubItem, iImage, iOrder, cxMin, cxDefault, cxIdeal } = win32;
        let mask = mask;
        let fmt = fmt;
        let cx = cx;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = pszText.to_vec();
        let cch_text_max = cchTextMax;
        let i_sub_item = iSubItem;
        let i_image = iImage;
        let i_order = iOrder;
        let cx_min = cxMin;
        let cx_default = cxDefault;
        let cx_ideal = cxIdeal;
        Self { mask, fmt, cx, psz_text, cch_text_max, i_sub_item, i_image, i_order, cx_min, cx_default, cx_ideal }
    }
}
pub const LVCFMT_LEFT: u32 = 0x0;
pub const LVCFMT_RIGHT: u32 = 0x1;
pub const LVCFMT_CENTER: u32 = 0x2;
pub const LVCFMT_JUSTIFYMASK: u32 = 0x3;
pub const LVCFMT_IMAGE: u32 = 0x800;
pub const LVCFMT_BITMAP_ON_RIGHT: u32 = 0x1000;
pub const LVCFMT_COL_HAS_IMAGES: u32 = 0x8000;
pub const LVCFMT_FIXED_WIDTH: u32 = 0x100;
pub const LVCFMT_NO_DPI_SCALE: u32 = 0x40000;
pub const LVCFMT_FIXED_RATIO: u32 = 0x80000;
pub const LVCFMT_SPLITBUTTON: u32 = 0x1000000;
pub const LVCF_FMT: u32 = 0x1;
pub const LVCF_WIDTH: u32 = 0x2;
pub const LVCF_TEXT: u32 = 0x4;
pub const LVCF_SUBITEM: u32 = 0x8;
pub const LVCF_IMAGE: u32 = 0x10;
pub const LVCF_ORDER: u32 = 0x20;
pub const LVCF_MINWIDTH: u32 = 0x40;
pub const LVCF_DEFAULTWIDTH: u32 = 0x80;
pub const LVCF_IDEALWIDTH: u32 = 0x100;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvfindinfoa<'a> {
    pub flags: u32,
    pub psz: Cow<'a, CStr>,
    pub l_param: Lparam,
    pub pt: Point,
    pub vk_direction: u32,
}
impl Lvfindinfoa {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVFINDINFOA {
        let Self { flags, psz, l_param, pt, vk_direction } = self;
        let flags = flags;
        let psz = psz.as_ptr();
        let lParam = l_param.into_inner();
        let pt = pt.to_win32();
        let vkDirection = *vk_direction;
        windows_sys::Win32::UI::Controls::LVFINDINFOA { flags, psz, lParam, pt, vkDirection }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVFINDINFOA) -> Self {
        let windows_sys::Win32::UI::Controls::LVFINDINFOA { flags, psz, lParam, pt, vkDirection } = win32;
        let flags = flags;
        let psz = unsafe { CStr::from_ptr(psz) };
        let psz = psz.to_bytes_with_nul().to_vec();
        let psz = Cow::Owned(unsafe { CString::from_vec_unchecked(psz) });
        let l_param = unsafe { Lparam::from_inner(lParam) };
        let pt = unsafe { POINT::from_win32(pt) };
        let vk_direction = vkDirection;
        Self { flags, psz, l_param, pt, vk_direction }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvfindinfow<'a> {
    pub flags: u32,
    pub psz: Cow<'a, [u16]>,
    pub l_param: Lparam,
    pub pt: Point,
    pub vk_direction: u32,
}
impl Lvfindinfow {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVFINDINFOW {
        let Self { flags, psz, l_param, pt, vk_direction } = self;
        let flags = flags;
        assert_eq!(psz.last(), Some(0));
        let psz = psz.as_ptr();
        let lParam = l_param.into_inner();
        let pt = pt.to_win32();
        let vkDirection = *vk_direction;
        windows_sys::Win32::UI::Controls::LVFINDINFOW { flags, psz, lParam, pt, vkDirection }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVFINDINFOW) -> Self {
        let windows_sys::Win32::UI::Controls::LVFINDINFOW { flags, psz, lParam, pt, vkDirection } = win32;
        let flags = flags;
        let slen = unsafe { wide_strlen(psz as *const u16) };
        let psz = unsafe { slice::from_raw_parts(psz, slen + 1) };
        let psz = psz.to_vec();
        let l_param = unsafe { Lparam::from_inner(lParam) };
        let pt = unsafe { POINT::from_win32(pt) };
        let vk_direction = vkDirection;
        Self { flags, psz, l_param, pt, vk_direction }
    }
}
pub const LVFI_PARAM: u32 = 0x1;
pub const LVFI_PARTIAL: u32 = 0x8;
pub const LVFI_STRING: u32 = 0x2;
pub const LVFI_SUBSTRING: u32 = 0x4;
pub const LVFI_WRAP: u32 = 0x20;
pub const LVFI_NEARESTXY: u32 = 0x40;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvfooterinfo<'a> {
    pub mask: u32,
    pub psz_text: Cow<'a, [u16]>,
    pub cch_text_max: i32,
    pub c_items: u32,
}
impl Lvfooterinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVFOOTERINFO {
        let Self { mask, psz_text, cch_text_max, c_items } = self;
        let mask = *mask;
        assert_eq!(psz_text.last(), Some(0));
        let pszText = psz_text.as_ptr();
        let cchTextMax = *cch_text_max;
        let cItems = *c_items;
        windows_sys::Win32::UI::Controls::LVFOOTERINFO { mask, pszText, cchTextMax, cItems }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVFOOTERINFO) -> Self {
        let windows_sys::Win32::UI::Controls::LVFOOTERINFO { mask, pszText, cchTextMax, cItems } = win32;
        let mask = mask;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = pszText.to_vec();
        let cch_text_max = cchTextMax;
        let c_items = cItems;
        Self { mask, psz_text, cch_text_max, c_items }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvfooteritem<'a> {
    pub mask: u32,
    pub i_item: i32,
    pub psz_text: Cow<'a, [u16]>,
    pub cch_text_max: i32,
    pub state: u32,
    pub state_mask: u32,
}
impl Lvfooteritem {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVFOOTERITEM {
        let Self { mask, i_item, psz_text, cch_text_max, state, state_mask } = self;
        let mask = mask;
        let iItem = *i_item;
        assert_eq!(psz_text.last(), Some(0));
        let pszText = psz_text.as_ptr();
        let cchTextMax = *cch_text_max;
        let state = *state;
        let stateMask = *state_mask;
        windows_sys::Win32::UI::Controls::LVFOOTERITEM { mask, iItem, pszText, cchTextMax, state, stateMask }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVFOOTERITEM) -> Self {
        let windows_sys::Win32::UI::Controls::LVFOOTERITEM { mask, iItem, pszText, cchTextMax, state, stateMask } = win32;
        let mask = mask;
        let i_item = iItem;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = pszText.to_vec();
        let cch_text_max = cchTextMax;
        let state = state;
        let state_mask = stateMask;
        Self { mask, i_item, psz_text, cch_text_max, state, state_mask }
    }
}
pub const LVFIF_TEXT: u32 = 0x1;
pub const LVFIF_STATE: u32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvgroup<'a> {
    pub cb_size: u32,
    pub mask: u32,
    pub psz_header: Cow<'a, [u16]>,
    pub cch_header: i32,
    pub psz_footer: Cow<'a, [u16]>,
    pub cch_footer: i32,
    pub i_group_id: i32,
    pub state_mask: u32,
    pub state: u32,
    pub u_align: u32,
    pub psz_subtitle: Cow<'a, [u16]>,
    pub cch_subtitle: u32,
    pub psz_task: Cow<'a, [u16]>,
    pub cch_task: u32,
    pub psz_description_top: Cow<'a, [u16]>,
    pub cch_description_top: u32,
    pub psz_description_bottom: Cow<'a, [u16]>,
    pub cch_description_bottom: u32,
    pub i_title_image: i32,
    pub i_extended_image: i32,
    pub i_first_item: i32,
    pub c_items: u32,
    pub psz_subset_title: Cow<'a, [u16]>,
    pub cch_subset_title: u32,
}
impl Lvgroup {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVGROUP {
        let Self { cb_size, mask, psz_header, cch_header, psz_footer, cch_footer, i_group_id, state_mask, state, u_align, psz_subtitle, cch_subtitle, psz_task, cch_task, psz_description_top, cch_description_top, psz_description_bottom, cch_description_bottom, i_title_image, i_extended_image, i_first_item, c_items, psz_subset_title, cch_subset_title } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::LVGROUP>() as _;
        let mask = mask;
        assert_eq!(psz_header.last(), Some(0));
        let pszHeader = psz_header.as_ptr();
        let cchHeader = *cch_header;
        assert_eq!(psz_footer.last(), Some(0));
        let pszFooter = psz_footer.as_ptr();
        let cchFooter = *cch_footer;
        let iGroupId = *i_group_id;
        let stateMask = *state_mask;
        let state = *state;
        let uAlign = *u_align;
        assert_eq!(psz_subtitle.last(), Some(0));
        let pszSubtitle = psz_subtitle.as_ptr();
        let cchSubtitle = *cch_subtitle;
        assert_eq!(psz_task.last(), Some(0));
        let pszTask = psz_task.as_ptr();
        let cchTask = *cch_task;
        assert_eq!(psz_description_top.last(), Some(0));
        let pszDescriptionTop = psz_description_top.as_ptr();
        let cchDescriptionTop = *cch_description_top;
        assert_eq!(psz_description_bottom.last(), Some(0));
        let pszDescriptionBottom = psz_description_bottom.as_ptr();
        let cchDescriptionBottom = *cch_description_bottom;
        let iTitleImage = *i_title_image;
        let iExtendedImage = *i_extended_image;
        let iFirstItem = *i_first_item;
        let cItems = *c_items;
        assert_eq!(psz_subset_title.last(), Some(0));
        let pszSubsetTitle = psz_subset_title.as_ptr();
        let cchSubsetTitle = *cch_subset_title;
        windows_sys::Win32::UI::Controls::LVGROUP { cbSize, mask, pszHeader, cchHeader, pszFooter, cchFooter, iGroupId, stateMask, state, uAlign, pszSubtitle, cchSubtitle, pszTask, cchTask, pszDescriptionTop, cchDescriptionTop, pszDescriptionBottom, cchDescriptionBottom, iTitleImage, iExtendedImage, iFirstItem, cItems, pszSubsetTitle, cchSubsetTitle }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVGROUP) -> Self {
        let windows_sys::Win32::UI::Controls::LVGROUP { cbSize, mask, pszHeader, cchHeader, pszFooter, cchFooter, iGroupId, stateMask, state, uAlign, pszSubtitle, cchSubtitle, pszTask, cchTask, pszDescriptionTop, cchDescriptionTop, pszDescriptionBottom, cchDescriptionBottom, iTitleImage, iExtendedImage, iFirstItem, cItems, pszSubsetTitle, cchSubsetTitle } = win32;
        let cb_size = cbSize;
        let mask = mask;
        let slen = unsafe { wide_strlen(pszHeader as *const u16) };
        let pszHeader = unsafe { slice::from_raw_parts(pszHeader, slen + 1) };
        let psz_header = pszHeader.to_vec();
        let cch_header = cchHeader;
        let slen = unsafe { wide_strlen(pszFooter as *const u16) };
        let pszFooter = unsafe { slice::from_raw_parts(pszFooter, slen + 1) };
        let psz_footer = pszFooter.to_vec();
        let cch_footer = cchFooter;
        let i_group_id = iGroupId;
        let state_mask = stateMask;
        let state = state;
        let u_align = uAlign;
        let slen = unsafe { wide_strlen(pszSubtitle as *const u16) };
        let pszSubtitle = unsafe { slice::from_raw_parts(pszSubtitle, slen + 1) };
        let psz_subtitle = pszSubtitle.to_vec();
        let cch_subtitle = cchSubtitle;
        let slen = unsafe { wide_strlen(pszTask as *const u16) };
        let pszTask = unsafe { slice::from_raw_parts(pszTask, slen + 1) };
        let psz_task = pszTask.to_vec();
        let cch_task = cchTask;
        let slen = unsafe { wide_strlen(pszDescriptionTop as *const u16) };
        let pszDescriptionTop = unsafe { slice::from_raw_parts(pszDescriptionTop, slen + 1) };
        let psz_description_top = pszDescriptionTop.to_vec();
        let cch_description_top = cchDescriptionTop;
        let slen = unsafe { wide_strlen(pszDescriptionBottom as *const u16) };
        let pszDescriptionBottom = unsafe { slice::from_raw_parts(pszDescriptionBottom, slen + 1) };
        let psz_description_bottom = pszDescriptionBottom.to_vec();
        let cch_description_bottom = cchDescriptionBottom;
        let i_title_image = iTitleImage;
        let i_extended_image = iExtendedImage;
        let i_first_item = iFirstItem;
        let c_items = cItems;
        let slen = unsafe { wide_strlen(pszSubsetTitle as *const u16) };
        let pszSubsetTitle = unsafe { slice::from_raw_parts(pszSubsetTitle, slen + 1) };
        let psz_subset_title = pszSubsetTitle.to_vec();
        let cch_subset_title = cchSubsetTitle;
        Self { cb_size, mask, psz_header, cch_header, psz_footer, cch_footer, i_group_id, state_mask, state, u_align, psz_subtitle, cch_subtitle, psz_task, cch_task, psz_description_top, cch_description_top, psz_description_bottom, cch_description_bottom, i_title_image, i_extended_image, i_first_item, c_items, psz_subset_title, cch_subset_title }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvgroupmetrics {
    pub cb_size: u32,
    pub mask: u32,
    pub left: u32,
    pub top: u32,
    pub right: u32,
    pub bottom: u32,
    pub cr_left: u32,
    pub cr_top: u32,
    pub cr_right: u32,
    pub cr_bottom: u32,
    pub cr_header: u32,
    pub cr_footer: u32,
}
impl Lvgroupmetrics {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVGROUPMETRICS {
        let Self { cb_size, mask, left, top, right, bottom, cr_left, cr_top, cr_right, cr_bottom, cr_header, cr_footer } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::LVGROUPMETRICS>() as _;
        let mask = *mask;
        let Left = *left;
        let Top = *top;
        let Right = *right;
        let Bottom = *bottom;
        let crLeft = *cr_left;
        let crTop = *cr_top;
        let crRight = *cr_right;
        let crBottom = *cr_bottom;
        let crHeader = *cr_header;
        let crFooter = *cr_footer;
        windows_sys::Win32::UI::Controls::LVGROUPMETRICS { cbSize, mask, Left, Top, Right, Bottom, crLeft, crTop, crRight, crBottom, crHeader, crFooter }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVGROUPMETRICS) -> Self {
        let windows_sys::Win32::UI::Controls::LVGROUPMETRICS { cbSize, mask, Left, Top, Right, Bottom, crLeft, crTop, crRight, crBottom, crHeader, crFooter } = win32;
        let cb_size = cbSize;
        let mask = mask;
        let left = Left;
        let top = Top;
        let right = Right;
        let bottom = Bottom;
        let cr_left = crLeft;
        let cr_top = crTop;
        let cr_right = crRight;
        let cr_bottom = crBottom;
        let cr_header = crHeader;
        let cr_footer = crFooter;
        Self { cb_size, mask, left, top, right, bottom, cr_left, cr_top, cr_right, cr_bottom, cr_header, cr_footer }
    }
}
pub const LVGF_NONE: u32 = 0x0;
pub const LVGF_HEADER: u32 = 0x1;
pub const LVGF_FOOTER: u32 = 0x2;
pub const LVGF_STATE: u32 = 0x4;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvhittestinfo {
    pub pt: Point,
    pub flags: u32,
    pub i_item: i32,
    pub i_sub_item: i32,
    pub i_group: i32,
}
impl Lvhittestinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVHITTESTINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVHITTESTINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const LVHT_ABOVE: u32 = 0x8;
pub const LVHT_BELOW: u32 = 0x10;
pub const LVHT_NOWHERE: u32 = 0x1;
pub const LVHT_ONITEMICON: u32 = 0x2;
pub const LVHT_ONITEMLABEL: u32 = 0x4;
pub const LVHT_ONITEMSTATEICON: u32 = 0x8;
pub const LVHT_TOLEFT: u32 = 0x40;
pub const LVHT_TORIGHT: u32 = 0x20;
pub const LVHT_EX_GROUP_HEADER: u32 = 0x10000000;
pub const LVHT_EX_GROUP_FOOTER: u32 = 0x20000000;
pub const LVHT_EX_GROUP_COLLAPSE: u32 = 0x40000000;
pub const LVHT_EX_GROUP_BACKGROUND: u32 = 0x80000000;
pub const LVHT_EX_GROUP_STATEICON: u32 = 0x1000000;
pub const LVHT_EX_GROUP_SUBSETLINK: u32 = 0x2000000;
pub const LVHT_EX_GROUP: u32 = 0xF3000000;
pub const LVHT_EX_ONCONTENTS: u32 = 0x4000000;
pub const LVHT_EX_FOOTER: u32 = 0x8000000;
//  Not generated due to containing a void type
//  #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Lvinsertgroupsorted<'a> {
//      pub pfn_group_compare: Option<unsafe extern "system" fn(i32, i32, *mut c_void) -> i32>,
//      pub pv_data: &'a mut todo_void,
//      pub lv_group: Lvgroup<'a>,
//  }
//  impl Lvinsertgroupsorted {
//      fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVINSERTGROUPSORTED {
//          let Self { pfn_group_compare, pv_data, lv_group } = self;
//          let pfnGroupCompare = Some(pfn_group_compare);
//          let pvData = unsafe { &mut *(pv_data as *mut _ as *mut _) };
//          let lvGroup = lv_group.to_win32();
//          windows_sys::Win32::UI::Controls::LVINSERTGROUPSORTED { pfnGroupCompare, pvData, lvGroup }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVINSERTGROUPSORTED) -> Self {
//          let windows_sys::Win32::UI::Controls::LVINSERTGROUPSORTED { pfnGroupCompare, pvData, lvGroup } = win32;
//          let pfn_group_compare = pfnGroupCompare;
//          let pv_data = unsafe { &mut *(pvData as *mut _ as *mut _) };
//          let lv_group = unsafe { LVGROUP::from_win32(lvGroup) };
//          Self { pfn_group_compare, pv_data, lv_group }
//      }
//  }
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvinsertmark {
    pub cb_size: u32,
    pub dw_flags: u32,
    pub i_item: i32,
    pub dw_reserved: u32,
}
impl Lvinsertmark {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVINSERTMARK {
        let Self { cb_size, dw_flags, i_item, dw_reserved } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::LVINSERTMARK>() as _;
        let dwFlags = *dw_flags;
        let iItem = *i_item;
        let dwReserved = *dw_reserved;
        windows_sys::Win32::UI::Controls::LVINSERTMARK { cbSize, dwFlags, iItem, dwReserved }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVINSERTMARK) -> Self {
        let windows_sys::Win32::UI::Controls::LVINSERTMARK { cbSize, dwFlags, iItem, dwReserved } = win32;
        let cb_size = cbSize;
        let dw_flags = dwFlags;
        let i_item = iItem;
        let dw_reserved = dwReserved;
        Self { cb_size, dw_flags, i_item, dw_reserved }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvitema<'a> {
    pub mask: u32,
    pub i_item: i32,
    pub i_sub_item: i32,
    pub state: u32,
    pub state_mask: u32,
    pub psz_text: Cow<'a, CStr>,
    pub cch_text_max: i32,
    pub i_image: i32,
    pub l_param: Lparam,
    pub i_indent: i32,
    pub i_group_id: i32,
    pub c_columns: u32,
    pub pu_columns: &'a mut u32,
    pub pi_col_fmt: &'a mut i32,
    pub i_group: i32,
}
impl Lvitema {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVITEMA {
        let Self { mask, i_item, i_sub_item, state, state_mask, psz_text, cch_text_max, i_image, l_param, i_indent, i_group_id, c_columns, pu_columns, pi_col_fmt, i_group } = self;
        let mask = *mask;
        let iItem = *i_item;
        let iSubItem = *i_sub_item;
        let state = *state;
        let stateMask = *state_mask;
        let pszText = psz_text.as_ptr();
        let cchTextMax = *cch_text_max;
        let iImage = *i_image;
        let lParam = l_param.into_inner();
        let iIndent = *i_indent;
        let iGroupId = i_group_id;
        let cColumns = *c_columns;
        let puColumns = unsafe { &mut *(pu_columns as *mut _ as *mut _) };
        let piColFmt = unsafe { &mut *(pi_col_fmt as *mut _ as *mut _) };
        let iGroup = *i_group;
        windows_sys::Win32::UI::Controls::LVITEMA { mask, iItem, iSubItem, state, stateMask, pszText, cchTextMax, iImage, lParam, iIndent, iGroupId, cColumns, puColumns, piColFmt, iGroup }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVITEMA) -> Self {
        let windows_sys::Win32::UI::Controls::LVITEMA { mask, iItem, iSubItem, state, stateMask, pszText, cchTextMax, iImage, lParam, iIndent, iGroupId, cColumns, puColumns, piColFmt, iGroup } = win32;
        let mask = mask;
        let i_item = iItem;
        let i_sub_item = iSubItem;
        let state = state;
        let state_mask = stateMask;
        let pszText = unsafe { CStr::from_ptr(pszText) };
        let pszText = pszText.to_bytes_with_nul().to_vec();
        let psz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(pszText) });
        let cch_text_max = cchTextMax;
        let i_image = iImage;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        let i_indent = iIndent;
        let i_group_id = iGroupId;
        let c_columns = cColumns;
        let pu_columns = unsafe { &mut *(puColumns as *mut _ as *mut _) };
        let pi_col_fmt = unsafe { &mut *(piColFmt as *mut _ as *mut _) };
        let i_group = iGroup;
        Self { mask, i_item, i_sub_item, state, state_mask, psz_text, cch_text_max, i_image, l_param, i_indent, i_group_id, c_columns, pu_columns, pi_col_fmt, i_group }
    }
}
pub const I_GROUPIDCALLBACK: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
pub const I_GROUPIDNONE: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvitemindex {
    pub i_item: i32,
    pub i_group: i32,
}
impl Lvitemindex {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVITEMINDEX {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVITEMINDEX) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvitemw<'a> {
    pub mask: u32,
    pub i_item: i32,
    pub i_sub_item: i32,
    pub state: u32,
    pub state_mask: u32,
    pub psz_text: Cow<'a, [u16]>,
    pub cch_text_max: i32,
    pub i_image: i32,
    pub l_param: Lparam,
    pub i_indent: i32,
    pub i_group_id: i32,
    pub c_columns: u32,
    pub pu_columns: &'a mut u32,
    pub pi_col_fmt: &'a mut i32,
    pub i_group: i32,
}
impl Lvitemw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVITEMW {
        let Self { mask, i_item, i_sub_item, state, state_mask, psz_text, cch_text_max, i_image, l_param, i_indent, i_group_id, c_columns, pu_columns, pi_col_fmt, i_group } = self;
        let mask = *mask;
        let iItem = *i_item;
        let iSubItem = *i_sub_item;
        let state = *state;
        let stateMask = *state_mask;
        assert_eq!(psz_text.last(), Some(0));
        let pszText = psz_text.as_ptr();
        let cchTextMax = *cch_text_max;
        let iImage = *i_image;
        let lParam = l_param.into_inner();
        let iIndent = *i_indent;
        let iGroupId = i_group_id;
        let cColumns = *c_columns;
        let puColumns = unsafe { &mut *(pu_columns as *mut _ as *mut _) };
        let piColFmt = unsafe { &mut *(pi_col_fmt as *mut _ as *mut _) };
        let iGroup = *i_group;
        windows_sys::Win32::UI::Controls::LVITEMW { mask, iItem, iSubItem, state, stateMask, pszText, cchTextMax, iImage, lParam, iIndent, iGroupId, cColumns, puColumns, piColFmt, iGroup }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVITEMW) -> Self {
        let windows_sys::Win32::UI::Controls::LVITEMW { mask, iItem, iSubItem, state, stateMask, pszText, cchTextMax, iImage, lParam, iIndent, iGroupId, cColumns, puColumns, piColFmt, iGroup } = win32;
        let mask = mask;
        let i_item = iItem;
        let i_sub_item = iSubItem;
        let state = state;
        let state_mask = stateMask;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = pszText.to_vec();
        let cch_text_max = cchTextMax;
        let i_image = iImage;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        let i_indent = iIndent;
        let i_group_id = iGroupId;
        let c_columns = cColumns;
        let pu_columns = unsafe { &mut *(puColumns as *mut _ as *mut _) };
        let pi_col_fmt = unsafe { &mut *(piColFmt as *mut _ as *mut _) };
        let i_group = iGroup;
        Self { mask, i_item, i_sub_item, state, state_mask, psz_text, cch_text_max, i_image, l_param, i_indent, i_group_id, c_columns, pu_columns, pi_col_fmt, i_group }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvsetinfotip<'a> {
    pub cb_size: u32,
    pub dw_flags: u32,
    pub psz_text: Cow<'a, [u16]>,
    pub i_item: i32,
    pub i_sub_item: i32,
}
impl Lvsetinfotip {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVSETINFOTIP {
        let Self { cb_size, dw_flags, psz_text, i_item, i_sub_item } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::LVSETINFOTIP>() as _;
        let dwFlags = *dw_flags;
        assert_eq!(psz_text.last(), Some(0));
        let pszText = psz_text.as_ptr();
        let iItem = *i_item;
        let iSubItem = *i_sub_item;
        windows_sys::Win32::UI::Controls::LVSETINFOTIP { cbSize, dwFlags, pszText, iItem, iSubItem }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVSETINFOTIP) -> Self {
        let windows_sys::Win32::UI::Controls::LVSETINFOTIP { cbSize, dwFlags, pszText, iItem, iSubItem } = win32;
        let cb_size = cbSize;
        let dw_flags = dwFlags;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = pszText.to_vec();
        let i_item = iItem;
        let i_sub_item = iSubItem;
        Self { cb_size, dw_flags, psz_text, i_item, i_sub_item }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvtileinfo<'a> {
    pub cb_size: u32,
    pub i_item: i32,
    pub c_columns: u32,
    pub pu_columns: &'a mut u32,
    pub pi_col_fmt: &'a mut i32,
}
impl Lvtileinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVTILEINFO {
        let Self { cb_size, i_item, c_columns, pu_columns, pi_col_fmt } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::LVTILEINFO>() as _;
        let iItem = *i_item;
        let cColumns = *c_columns;
        let puColumns = unsafe { &mut *(pu_columns as *mut _ as *mut _) };
        let piColFmt = unsafe { &mut *(pi_col_fmt as *mut _ as *mut _) };
        windows_sys::Win32::UI::Controls::LVTILEINFO { cbSize, iItem, cColumns, puColumns, piColFmt }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVTILEINFO) -> Self {
        let windows_sys::Win32::UI::Controls::LVTILEINFO { cbSize, iItem, cColumns, puColumns, piColFmt } = win32;
        let cb_size = cbSize;
        let i_item = iItem;
        let c_columns = cColumns;
        let pu_columns = unsafe { &mut *(puColumns as *mut _ as *mut _) };
        let pi_col_fmt = unsafe { &mut *(piColFmt as *mut _ as *mut _) };
        Self { cb_size, i_item, c_columns, pu_columns, pi_col_fmt }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvtileviewinfo {
    pub cb_size: u32,
    pub dw_mask: u32,
    pub dw_flags: u32,
    pub size_tile: Size,
    pub c_lines: i32,
    pub rc_label_margin: Rect,
}
impl Lvtileviewinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVTILEVIEWINFO {
        let Self { cb_size, dw_mask, dw_flags, size_tile, c_lines, rc_label_margin } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::LVTILEVIEWINFO>() as _;
        let dwMask = *dw_mask;
        let dwFlags = dw_flags;
        let sizeTile = size_tile.to_win32();
        let cLines = *c_lines;
        let rcLabelMargin = rc_label_margin.to_win32();
        windows_sys::Win32::UI::Controls::LVTILEVIEWINFO { cbSize, dwMask, dwFlags, sizeTile, cLines, rcLabelMargin }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVTILEVIEWINFO) -> Self {
        let windows_sys::Win32::UI::Controls::LVTILEVIEWINFO { cbSize, dwMask, dwFlags, sizeTile, cLines, rcLabelMargin } = win32;
        let cb_size = cbSize;
        let dw_mask = dwMask;
        let dw_flags = dwFlags;
        let size_tile = unsafe { SIZE::from_win32(sizeTile) };
        let c_lines = cLines;
        let rc_label_margin = unsafe { RECT::from_win32(rcLabelMargin) };
        Self { cb_size, dw_mask, dw_flags, size_tile, c_lines, rc_label_margin }
    }
}
pub const LVTVIF_EXTENDED: u32 = 0x4;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Margins {
    pub cx_left_width: i32,
    pub cx_right_width: i32,
    pub cy_top_height: i32,
    pub cy_bottom_height: i32,
}
impl Margins {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::MARGINS {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::MARGINS) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const EMT_NORMALTEXT: i32 = 0x1;
pub const EMT_LINKTEXT: i32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Mat2 {
    pub e_m11: Fixed,
    pub e_m12: Fixed,
    pub e_m21: Fixed,
    pub e_m22: Fixed,
}
impl Mat2 {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::MAT2 {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::MAT2) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Mcgridinfo<'a> {
    pub cb_size: u32,
    pub dw_part: u32,
    pub dw_flags: u32,
    pub i_calendar: i32,
    pub i_row: i32,
    pub i_col: i32,
    pub b_selected: BOOL,
    pub st_start: Systemtime,
    pub st_end: Systemtime,
    pub rc: Rect,
    pub psz_name: Cow<'a, [u16]>,
    pub cch_name: usize,
}
impl Mcgridinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::MCGRIDINFO {
        let Self { cb_size, dw_part, dw_flags, i_calendar, i_row, i_col, b_selected, st_start, st_end, rc, psz_name, cch_name } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::MCGRIDINFO>() as _;
        let dwPart = dw_part;
        let dwFlags = dw_flags;
        let iCalendar = *i_calendar;
        let iRow = *i_row;
        let iCol = *i_col;
        let bSelected = b_selected;
        let stStart = st_start.to_win32();
        let stEnd = st_end.to_win32();
        let rc = rc.to_win32();
        assert_eq!(psz_name.last(), Some(0));
        let pszName = psz_name.as_ptr();
        let cchName = *cch_name;
        windows_sys::Win32::UI::Controls::MCGRIDINFO { cbSize, dwPart, dwFlags, iCalendar, iRow, iCol, bSelected, stStart, stEnd, rc, pszName, cchName }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::MCGRIDINFO) -> Self {
        let windows_sys::Win32::UI::Controls::MCGRIDINFO { cbSize, dwPart, dwFlags, iCalendar, iRow, iCol, bSelected, stStart, stEnd, rc, pszName, cchName } = win32;
        let cb_size = cbSize;
        let dw_part = dwPart;
        let dw_flags = dwFlags;
        let i_calendar = iCalendar;
        let i_row = iRow;
        let i_col = iCol;
        let b_selected = bSelected;
        let st_start = unsafe { SYSTEMTIME::from_win32(stStart) };
        let st_end = unsafe { SYSTEMTIME::from_win32(stEnd) };
        let rc = unsafe { RECT::from_win32(rc) };
        let slen = unsafe { wide_strlen(pszName as *const u16) };
        let pszName = unsafe { slice::from_raw_parts(pszName, slen + 1) };
        let psz_name = pszName.to_vec();
        let cch_name = cchName;
        Self { cb_size, dw_part, dw_flags, i_calendar, i_row, i_col, b_selected, st_start, st_end, rc, psz_name, cch_name }
    }
}
pub const MCGIF_DATE: u32 = 0x1;
pub const MCGIF_RECT: u32 = 0x2;
pub const MCGIF_NAME: u32 = 0x4;
pub const MCGIP_CALENDARCONTROL: u32 = 0x0;
pub const MCGIP_NEXT: u32 = 0x1;
pub const MCGIP_PREV: u32 = 0x2;
pub const MCGIP_FOOTER: u32 = 0x3;
pub const MCGIP_CALENDAR: u32 = 0x4;
pub const MCGIP_CALENDARHEADER: u32 = 0x5;
pub const MCGIP_CALENDARBODY: u32 = 0x6;
pub const MCGIP_CALENDARROW: u32 = 0x7;
pub const MCGIP_CALENDARCELL: u32 = 0x8;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Mchittestinfo {
    pub cb_size: u32,
    pub pt: Point,
    pub u_hit: u32,
    pub st: Systemtime,
    pub rc: Rect,
    pub i_offset: i32,
    pub i_row: i32,
    pub i_col: i32,
}
impl Mchittestinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::MCHITTESTINFO {
        let Self { cb_size, pt, u_hit, st, rc, i_offset, i_row, i_col } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::MCHITTESTINFO>() as _;
        let pt = pt.to_win32();
        let uHit = *u_hit;
        let st = st.to_win32();
        let rc = rc.to_win32();
        let iOffset = *i_offset;
        let iRow = *i_row;
        let iCol = *i_col;
        windows_sys::Win32::UI::Controls::MCHITTESTINFO { cbSize, pt, uHit, st, rc, iOffset, iRow, iCol }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::MCHITTESTINFO) -> Self {
        let windows_sys::Win32::UI::Controls::MCHITTESTINFO { cbSize, pt, uHit, st, rc, iOffset, iRow, iCol } = win32;
        let cb_size = cbSize;
        let pt = unsafe { POINT::from_win32(pt) };
        let u_hit = uHit;
        let st = unsafe { SYSTEMTIME::from_win32(st) };
        let rc = unsafe { RECT::from_win32(rc) };
        let i_offset = iOffset;
        let i_row = iRow;
        let i_col = iCol;
        Self { cb_size, pt, u_hit, st, rc, i_offset, i_row, i_col }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Mdicreatestructa<'a> {
    pub sz_class: Cow<'a, CStr>,
    pub sz_title: Cow<'a, CStr>,
    pub h_owner: Option<Handle>,
    pub x: i32,
    pub y: i32,
    pub cx: i32,
    pub cy: i32,
    pub style: u32,
    pub l_param: Lparam,
}
impl Mdicreatestructa {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MDICREATESTRUCTA {
        let Self { sz_class, sz_title, h_owner, x, y, cx, cy, style, l_param } = self;
        let szClass = sz_class.as_ptr();
        let szTitle = sz_title.as_ptr();
        let hOwner = h_owner.map_or(0, Handle::into_raw);
        let x = *x;
        let y = *y;
        let cx = *cx;
        let cy = *cy;
        let style = style;
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::WindowsAndMessaging::MDICREATESTRUCTA { szClass, szTitle, hOwner, x, y, cx, cy, style, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MDICREATESTRUCTA) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::MDICREATESTRUCTA { szClass, szTitle, hOwner, x, y, cx, cy, style, lParam } = win32;
        let szClass = unsafe { CStr::from_ptr(szClass) };
        let szClass = szClass.to_bytes_with_nul().to_vec();
        let sz_class = Cow::Owned(unsafe { CString::from_vec_unchecked(szClass) });
        let szTitle = unsafe { CStr::from_ptr(szTitle) };
        let szTitle = szTitle.to_bytes_with_nul().to_vec();
        let sz_title = Cow::Owned(unsafe { CString::from_vec_unchecked(szTitle) });
        let h_owner = unsafe { Handle::new_optional(hOwner) };
        let x = x;
        let y = y;
        let cx = cx;
        let cy = cy;
        let style = style;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { sz_class, sz_title, h_owner, x, y, cx, cy, style, l_param }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Mdicreatestructw<'a> {
    pub sz_class: Cow<'a, [u16]>,
    pub sz_title: Cow<'a, [u16]>,
    pub h_owner: Option<Handle>,
    pub x: i32,
    pub y: i32,
    pub cx: i32,
    pub cy: i32,
    pub style: u32,
    pub l_param: Lparam,
}
impl Mdicreatestructw {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MDICREATESTRUCTW {
        let Self { sz_class, sz_title, h_owner, x, y, cx, cy, style, l_param } = self;
        assert_eq!(sz_class.last(), Some(0));
        let szClass = sz_class.as_ptr();
        assert_eq!(sz_title.last(), Some(0));
        let szTitle = sz_title.as_ptr();
        let hOwner = h_owner.map_or(0, Handle::into_raw);
        let x = *x;
        let y = *y;
        let cx = *cx;
        let cy = *cy;
        let style = style;
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::WindowsAndMessaging::MDICREATESTRUCTW { szClass, szTitle, hOwner, x, y, cx, cy, style, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MDICREATESTRUCTW) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::MDICREATESTRUCTW { szClass, szTitle, hOwner, x, y, cx, cy, style, lParam } = win32;
        let slen = unsafe { wide_strlen(szClass as *const u16) };
        let szClass = unsafe { slice::from_raw_parts(szClass, slen + 1) };
        let sz_class = szClass.to_vec();
        let slen = unsafe { wide_strlen(szTitle as *const u16) };
        let szTitle = unsafe { slice::from_raw_parts(szTitle, slen + 1) };
        let sz_title = szTitle.to_vec();
        let h_owner = unsafe { Handle::new_optional(hOwner) };
        let x = x;
        let y = y;
        let cx = cx;
        let cy = cy;
        let style = style;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { sz_class, sz_title, h_owner, x, y, cx, cy, style, l_param }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Mdinextmenu {
    pub hmenu_in: Option<Hmenu>,
    pub hmenu_next: Option<Hmenu>,
    pub hwnd_next: Option<Hwnd>,
}
impl Mdinextmenu {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MDINEXTMENU {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MDINEXTMENU) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Measureitemstruct {
    pub ctl_type: u32,
    pub ctl_id: u32,
    pub item_id: u32,
    pub item_width: u32,
    pub item_height: u32,
    pub item_data: usize,
}
impl Measureitemstruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::MEASUREITEMSTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::MEASUREITEMSTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const MBHANDCID_PIDLSELECT: i32 = 0x0;
pub const MDP_NEWAPPBUTTON: i32 = 0x1;
pub const MDP_SEPERATOR: i32 = 0x2;
pub const MDS_NORMAL: i32 = 0x1;
pub const MDS_HOT: i32 = 0x2;
pub const MDS_PRESSED: i32 = 0x3;
pub const MDS_DISABLED: i32 = 0x4;
pub const MDS_CHECKED: i32 = 0x5;
pub const MDS_HOTCHECKED: i32 = 0x6;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Menubarinfo {
    pub cb_size: u32,
    pub rc_bar: Rect,
    pub h_menu: Option<Hmenu>,
    pub hwnd_menu: Option<Hwnd>,
    pub bitfield: i32,
}
impl Menubarinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MENUBARINFO {
        let Self { cb_size, rc_bar, h_menu, hwnd_menu, bitfield } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::MENUBARINFO>() as _;
        let rcBar = rc_bar.to_win32();
        let hMenu = h_menu.map_or(0, Hmenu::into_raw);
        let hwndMenu = hwnd_menu.map_or(0, Hwnd::into_raw);
        let _bitfield = *bitfield;
        windows_sys::Win32::UI::WindowsAndMessaging::MENUBARINFO { cbSize, rcBar, hMenu, hwndMenu, _bitfield }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MENUBARINFO) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::MENUBARINFO { cbSize, rcBar, hMenu, hwndMenu, _bitfield } = win32;
        let cb_size = cbSize;
        let rc_bar = unsafe { RECT::from_win32(rcBar) };
        let h_menu = unsafe { Hmenu::new_optional(hMenu) };
        let hwnd_menu = unsafe { Hwnd::new_optional(hwndMenu) };
        let bitfield = _bitfield;
        Self { cb_size, rc_bar, h_menu, hwnd_menu, bitfield }
    }
}
//  Not generated due to containing a void type
//  #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Menugetobjectinfo<'a> {
//      pub dw_flags: u32,
//      pub u_pos: u32,
//      pub hmenu: Option<Hmenu>,
//      pub riid: &'a mut todo_void,
//      pub pv_obj: &'a mut todo_void,
//  }
//  impl Menugetobjectinfo {
//      fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MENUGETOBJECTINFO {
//          let Self { dw_flags, u_pos, hmenu, riid, pv_obj } = self;
//          let dwFlags = dw_flags;
//          let uPos = *u_pos;
//          let hmenu = hmenu.map_or(0, Hmenu::into_raw);
//          let riid = unsafe { &mut *(riid as *mut _ as *mut _) };
//          let pvObj = unsafe { &mut *(pv_obj as *mut _ as *mut _) };
//          windows_sys::Win32::UI::WindowsAndMessaging::MENUGETOBJECTINFO { dwFlags, uPos, hmenu, riid, pvObj }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MENUGETOBJECTINFO) -> Self {
//          let windows_sys::Win32::UI::WindowsAndMessaging::MENUGETOBJECTINFO { dwFlags, uPos, hmenu, riid, pvObj } = win32;
//          let dw_flags = dwFlags;
//          let u_pos = uPos;
//          let hmenu = unsafe { Hmenu::new_optional(hmenu) };
//          let riid = unsafe { &mut *(riid as *mut _ as *mut _) };
//          let pv_obj = unsafe { &mut *(pvObj as *mut _ as *mut _) };
//          Self { dw_flags, u_pos, hmenu, riid, pv_obj }
//      }
//  }
pub const MNGOF_BOTTOMGAP: u32 = 0x2;
pub const MNGOF_TOPGAP: u32 = 0x1;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Menuinfo {
    pub cb_size: u32,
    pub f_mask: u32,
    pub dw_style: u32,
    pub cy_max: u32,
    pub hbr_back: Option<Hbrush>,
    pub dw_context_help_id: u32,
    pub dw_menu_data: usize,
}
impl Menuinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MENUINFO {
        let Self { cb_size, f_mask, dw_style, cy_max, hbr_back, dw_context_help_id, dw_menu_data } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::MENUINFO>() as _;
        let fMask = f_mask;
        let dwStyle = dw_style;
        let cyMax = *cy_max;
        let hbrBack = hbr_back.map_or(0, Hbrush::into_raw);
        let dwContextHelpID = *dw_context_help_id;
        let dwMenuData = *dw_menu_data;
        windows_sys::Win32::UI::WindowsAndMessaging::MENUINFO { cbSize, fMask, dwStyle, cyMax, hbrBack, dwContextHelpID, dwMenuData }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MENUINFO) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::MENUINFO { cbSize, fMask, dwStyle, cyMax, hbrBack, dwContextHelpID, dwMenuData } = win32;
        let cb_size = cbSize;
        let f_mask = fMask;
        let dw_style = dwStyle;
        let cy_max = cyMax;
        let hbr_back = unsafe { Hbrush::new_optional(hbrBack) };
        let dw_context_help_id = dwContextHelpID;
        let dw_menu_data = dwMenuData;
        Self { cb_size, f_mask, dw_style, cy_max, hbr_back, dw_context_help_id, dw_menu_data }
    }
}
pub const MIM_APPLYTOSUBMENUS: u32 = 0x80000000;
pub const MIM_BACKGROUND: u32 = 0x2;
pub const MIM_HELPID: u32 = 0x4;
pub const MIM_MAXHEIGHT: u32 = 0x1;
pub const MIM_MENUDATA: u32 = 0x8;
pub const MIM_STYLE: u32 = 0x10;
pub const MNS_AUTODISMISS: u32 = 0x10000000;
pub const MNS_CHECKORBMP: u32 = 0x4000000;
pub const MNS_DRAGDROP: u32 = 0x20000000;
pub const MNS_MODELESS: u32 = 0x40000000;
pub const MNS_NOCHECK: u32 = 0x80000000;
pub const MNS_NOTIFYBYPOS: u32 = 0x8000000;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Menuiteminfoa<'a> {
    pub cb_size: u32,
    pub f_mask: u32,
    pub f_type: u32,
    pub f_state: u32,
    pub w_id: u32,
    pub h_sub_menu: Option<Hmenu>,
    pub hbmp_checked: Option<Hbitmap>,
    pub hbmp_unchecked: Option<Hbitmap>,
    pub dw_item_data: usize,
    pub dw_type_data: Cow<'a, CStr>,
    pub cch: u32,
    pub hbmp_item: Option<Hbitmap>,
}
impl Menuiteminfoa {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMINFOA {
        let Self { cb_size, f_mask, f_type, f_state, w_id, h_sub_menu, hbmp_checked, hbmp_unchecked, dw_item_data, dw_type_data, cch, hbmp_item } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMINFOA>() as _;
        let fMask = f_mask;
        let fType = f_type;
        let fState = f_state;
        let wID = *w_id;
        let hSubMenu = h_sub_menu.map_or(0, Hmenu::into_raw);
        let hbmpChecked = hbmp_checked.map_or(0, Hbitmap::into_raw);
        let hbmpUnchecked = hbmp_unchecked.map_or(0, Hbitmap::into_raw);
        let dwItemData = *dw_item_data;
        let dwTypeData = dw_type_data.as_ptr();
        let cch = *cch;
        let hbmpItem = hbmp_item.map_or(0, Hbitmap::into_raw);
        windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMINFOA { cbSize, fMask, fType, fState, wID, hSubMenu, hbmpChecked, hbmpUnchecked, dwItemData, dwTypeData, cch, hbmpItem }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMINFOA) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMINFOA { cbSize, fMask, fType, fState, wID, hSubMenu, hbmpChecked, hbmpUnchecked, dwItemData, dwTypeData, cch, hbmpItem } = win32;
        let cb_size = cbSize;
        let f_mask = fMask;
        let f_type = fType;
        let f_state = fState;
        let w_id = wID;
        let h_sub_menu = unsafe { Hmenu::new_optional(hSubMenu) };
        let hbmp_checked = unsafe { Hbitmap::new_optional(hbmpChecked) };
        let hbmp_unchecked = unsafe { Hbitmap::new_optional(hbmpUnchecked) };
        let dw_item_data = dwItemData;
        let dwTypeData = unsafe { CStr::from_ptr(dwTypeData) };
        let dwTypeData = dwTypeData.to_bytes_with_nul().to_vec();
        let dw_type_data = Cow::Owned(unsafe { CString::from_vec_unchecked(dwTypeData) });
        let cch = cch;
        let hbmp_item = unsafe { Hbitmap::new_optional(hbmpItem) };
        Self { cb_size, f_mask, f_type, f_state, w_id, h_sub_menu, hbmp_checked, hbmp_unchecked, dw_item_data, dw_type_data, cch, hbmp_item }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Menuiteminfow<'a> {
    pub cb_size: u32,
    pub f_mask: u32,
    pub f_type: u32,
    pub f_state: u32,
    pub w_id: u32,
    pub h_sub_menu: Option<Hmenu>,
    pub hbmp_checked: Option<Hbitmap>,
    pub hbmp_unchecked: Option<Hbitmap>,
    pub dw_item_data: usize,
    pub dw_type_data: Cow<'a, [u16]>,
    pub cch: u32,
    pub hbmp_item: Option<Hbitmap>,
}
impl Menuiteminfow {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMINFOW {
        let Self { cb_size, f_mask, f_type, f_state, w_id, h_sub_menu, hbmp_checked, hbmp_unchecked, dw_item_data, dw_type_data, cch, hbmp_item } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMINFOW>() as _;
        let fMask = f_mask;
        let fType = f_type;
        let fState = f_state;
        let wID = *w_id;
        let hSubMenu = h_sub_menu.map_or(0, Hmenu::into_raw);
        let hbmpChecked = hbmp_checked.map_or(0, Hbitmap::into_raw);
        let hbmpUnchecked = hbmp_unchecked.map_or(0, Hbitmap::into_raw);
        let dwItemData = *dw_item_data;
        assert_eq!(dw_type_data.last(), Some(0));
        let dwTypeData = dw_type_data.as_ptr();
        let cch = *cch;
        let hbmpItem = hbmp_item.map_or(0, Hbitmap::into_raw);
        windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMINFOW { cbSize, fMask, fType, fState, wID, hSubMenu, hbmpChecked, hbmpUnchecked, dwItemData, dwTypeData, cch, hbmpItem }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMINFOW) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMINFOW { cbSize, fMask, fType, fState, wID, hSubMenu, hbmpChecked, hbmpUnchecked, dwItemData, dwTypeData, cch, hbmpItem } = win32;
        let cb_size = cbSize;
        let f_mask = fMask;
        let f_type = fType;
        let f_state = fState;
        let w_id = wID;
        let h_sub_menu = unsafe { Hmenu::new_optional(hSubMenu) };
        let hbmp_checked = unsafe { Hbitmap::new_optional(hbmpChecked) };
        let hbmp_unchecked = unsafe { Hbitmap::new_optional(hbmpUnchecked) };
        let dw_item_data = dwItemData;
        let slen = unsafe { wide_strlen(dwTypeData as *const u16) };
        let dwTypeData = unsafe { slice::from_raw_parts(dwTypeData, slen + 1) };
        let dw_type_data = dwTypeData.to_vec();
        let cch = cch;
        let hbmp_item = unsafe { Hbitmap::new_optional(hbmpItem) };
        Self { cb_size, f_mask, f_type, f_state, w_id, h_sub_menu, hbmp_checked, hbmp_unchecked, dw_item_data, dw_type_data, cch, hbmp_item }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Menuitemtemplate {
    pub mt_option: u16,
    pub mt_id: u16,
    pub mt_string: [u8; 1],
}
impl Menuitemtemplate {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMTEMPLATE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMTEMPLATE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Menuitemtemplateheader {
    pub version_number: u16,
    pub offset: u16,
}
impl Menuitemtemplateheader {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMTEMPLATEHEADER {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMTEMPLATEHEADER) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const MPPF_SETFOCUS: i32 = 0x1;
pub const MPPF_INITIALSELECT: i32 = 0x2;
pub const MPPF_NOANIMATE: i32 = 0x4;
pub const MPPF_KEYBOARD: i32 = 0x10;
pub const MPPF_REPOSITION: i32 = 0x20;
pub const MPPF_FORCEZORDER: i32 = 0x40;
pub const MPPF_FINALSELECT: i32 = 0x80;
pub const MPPF_TOP: i32 = 0x20000000;
pub const MPPF_LEFT: i32 = 0x40000000;
pub const MPPF_RIGHT: i32 = 0x60000000;
pub const MPPF_BOTTOM: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFF80000000;
pub const MPPF_POS_MASK: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFE0000000;
pub const MPPF_ALIGN_LEFT: i32 = 0x2000000;
pub const MPPF_ALIGN_RIGHT: i32 = 0x4000000;
pub const MPOS_EXECUTE: i32 = 0x0;
pub const MPOS_FULLCANCEL: i32 = 0x1;
pub const MPOS_CANCELLEVEL: i32 = 0x2;
pub const MPOS_SELECTLEFT: i32 = 0x3;
pub const MPOS_SELECTRIGHT: i32 = 0x4;
pub const MPOS_CHILDTRACKING: i32 = 0x5;
pub const MF_BYCOMMAND: u32 = 0x0;
pub const MF_BYPOSITION: u32 = 0x400;
pub const MF_BITMAP: u32 = 0x4;
pub const MF_CHECKED: u32 = 0x8;
pub const MF_DISABLED: u32 = 0x2;
pub const MF_ENABLED: u32 = 0x0;
pub const MF_GRAYED: u32 = 0x1;
pub const MF_MENUBARBREAK: u32 = 0x20;
pub const MF_MENUBREAK: u32 = 0x40;
pub const MF_OWNERDRAW: u32 = 0x100;
pub const MF_POPUP: u32 = 0x10;
pub const MF_SEPARATOR: u32 = 0x800;
pub const MF_STRING: u32 = 0x0;
pub const MF_UNCHECKED: u32 = 0x0;
pub const MF_INSERT: u32 = 0x0;
pub const MF_CHANGE: u32 = 0x80;
pub const MF_APPEND: u32 = 0x100;
pub const MF_DELETE: u32 = 0x200;
pub const MF_REMOVE: u32 = 0x1000;
pub const MF_USECHECKBITMAPS: u32 = 0x200;
pub const MF_UNHILITE: u32 = 0x0;
pub const MF_HILITE: u32 = 0x80;
pub const MF_DEFAULT: u32 = 0x1000;
pub const MF_SYSMENU: u32 = 0x2000;
pub const MF_HELP: u32 = 0x4000;
pub const MF_RIGHTJUSTIFY: u32 = 0x4000;
pub const MF_MOUSESELECT: u32 = 0x8000;
pub const MF_END: u32 = 0x80;
pub const MIIM_BITMAP: u32 = 0x80;
pub const MIIM_CHECKMARKS: u32 = 0x8;
pub const MIIM_DATA: u32 = 0x20;
pub const MIIM_FTYPE: u32 = 0x100;
pub const MIIM_ID: u32 = 0x2;
pub const MIIM_STATE: u32 = 0x1;
pub const MIIM_STRING: u32 = 0x40;
pub const MIIM_SUBMENU: u32 = 0x4;
pub const MIIM_TYPE: u32 = 0x10;
pub const MFS_GRAYED: u32 = 0x3;
pub const MFS_DISABLED: u32 = 0x3;
pub const MFS_CHECKED: u32 = 0x8;
pub const MFS_HILITE: u32 = 0x80;
pub const MFS_ENABLED: u32 = 0x0;
pub const MFS_UNCHECKED: u32 = 0x0;
pub const MFS_UNHILITE: u32 = 0x0;
pub const MFS_DEFAULT: u32 = 0x1000;
pub const MFT_BITMAP: u32 = 0x4;
pub const MFT_MENUBARBREAK: u32 = 0x20;
pub const MFT_MENUBREAK: u32 = 0x40;
pub const MFT_OWNERDRAW: u32 = 0x100;
pub const MFT_RADIOCHECK: u32 = 0x200;
pub const MFT_RIGHTJUSTIFY: u32 = 0x4000;
pub const MFT_RIGHTORDER: u32 = 0x2000;
pub const MFT_SEPARATOR: u32 = 0x800;
pub const MFT_STRING: u32 = 0x0;
pub const MUS_COMPLETE: i32 = 0x0;
pub const MUS_USERINPUTNEEDED: i32 = 0x1;
pub const MUS_FAILED: i32 = 0x2;
pub const IDOK: i32 = 0x1;
pub const IDCANCEL: i32 = 0x2;
pub const IDABORT: i32 = 0x3;
pub const IDRETRY: i32 = 0x4;
pub const IDIGNORE: i32 = 0x5;
pub const IDYES: i32 = 0x6;
pub const IDNO: i32 = 0x7;
pub const IDCLOSE: i32 = 0x8;
pub const IDHELP: i32 = 0x9;
pub const IDTRYAGAIN: i32 = 0xA;
pub const IDCONTINUE: i32 = 0xB;
pub const IDASYNC: i32 = 0x7D01;
pub const IDTIMEOUT: i32 = 0x7D00;
pub const MB_ABORTRETRYIGNORE: u32 = 0x2;
pub const MB_CANCELTRYCONTINUE: u32 = 0x6;
pub const MB_HELP: u32 = 0x4000;
pub const MB_OK: u32 = 0x0;
pub const MB_OKCANCEL: u32 = 0x1;
pub const MB_RETRYCANCEL: u32 = 0x5;
pub const MB_YESNO: u32 = 0x4;
pub const MB_YESNOCANCEL: u32 = 0x3;
pub const MB_ICONHAND: u32 = 0x10;
pub const MB_ICONQUESTION: u32 = 0x20;
pub const MB_ICONEXCLAMATION: u32 = 0x30;
pub const MB_ICONASTERISK: u32 = 0x40;
pub const MB_USERICON: u32 = 0x80;
pub const MB_ICONWARNING: u32 = 0x30;
pub const MB_ICONERROR: u32 = 0x10;
pub const MB_ICONINFORMATION: u32 = 0x40;
pub const MB_ICONSTOP: u32 = 0x10;
pub const MB_DEFBUTTON1: u32 = 0x0;
pub const MB_DEFBUTTON2: u32 = 0x100;
pub const MB_DEFBUTTON3: u32 = 0x200;
pub const MB_DEFBUTTON4: u32 = 0x300;
pub const MB_APPLMODAL: u32 = 0x0;
pub const MB_SYSTEMMODAL: u32 = 0x1000;
pub const MB_TASKMODAL: u32 = 0x2000;
pub const MB_NOFOCUS: u32 = 0x8000;
pub const MB_SETFOREGROUND: u32 = 0x10000;
pub const MB_DEFAULT_DESKTOP_ONLY: u32 = 0x20000;
pub const MB_TOPMOST: u32 = 0x40000;
pub const MB_RIGHT: u32 = 0x80000;
pub const MB_RTLREADING: u32 = 0x100000;
pub const MB_SERVICE_NOTIFICATION: u32 = 0x200000;
pub const MB_SERVICE_NOTIFICATION_NT3X: u32 = 0x40000;
pub const MB_TYPEMASK: u32 = 0xF;
pub const MB_ICONMASK: u32 = 0xF0;
pub const MB_DEFMASK: u32 = 0xF00;
pub const MB_MODEMASK: u32 = 0x3000;
pub const MB_MISCMASK: u32 = 0xC000;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct MessageResourceBlock {
    pub low_id: u32,
    pub high_id: u32,
    pub offset_to_entries: u32,
}
impl MessageResourceBlock {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MESSAGE_RESOURCE_BLOCK {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MESSAGE_RESOURCE_BLOCK) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct MessageResourceData {
    pub number_of_blocks: u32,
    pub blocks: [MessageResourceBlock; 1],
}
impl MessageResourceData {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MESSAGE_RESOURCE_DATA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MESSAGE_RESOURCE_DATA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct MessageResourceEntry {
    pub length: u16,
    pub flags: u16,
    pub text: [u8; 1],
}
impl MessageResourceEntry {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MESSAGE_RESOURCE_ENTRY {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MESSAGE_RESOURCE_ENTRY) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(2))]
pub struct Metaheader {
    pub mt_type: u16,
    pub mt_header_size: u16,
    pub mt_version: u16,
    pub mt_size: u32,
    pub mt_no_objects: u16,
    pub mt_max_record: u32,
    pub mt_no_parameters: u16,
}
impl Metaheader {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::METAHEADER {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::METAHEADER) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Metarecord {
    pub rd_size: u32,
    pub rd_function: u16,
    pub rd_parm: [u16; 1],
}
impl Metarecord {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::METARECORD {
        let Self { rd_size, rd_function, rd_parm } = self;
        let rdSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::METARECORD>() as _;
        let rdFunction = *rd_function;
        let rdParm = [*rd_parm[0]];
        windows_sys::Win32::Graphics::Gdi::METARECORD { rdSize, rdFunction, rdParm }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::METARECORD) -> Self {
        let windows_sys::Win32::Graphics::Gdi::METARECORD { rdSize, rdFunction, rdParm } = win32;
        let rd_size = rdSize;
        let rd_function = rdFunction;
        let rd_parm = [rdParm[0]];
        Self { rd_size, rd_function, rd_parm }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Minimizedmetrics {
    pub cb_size: u32,
    pub i_width: i32,
    pub i_horz_gap: i32,
    pub i_vert_gap: i32,
    pub i_arrange: i32,
}
impl Minimizedmetrics {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MINIMIZEDMETRICS {
        let Self { cb_size, i_width, i_horz_gap, i_vert_gap, i_arrange } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::MINIMIZEDMETRICS>() as _;
        let iWidth = *i_width;
        let iHorzGap = *i_horz_gap;
        let iVertGap = *i_vert_gap;
        let iArrange = i_arrange;
        windows_sys::Win32::UI::WindowsAndMessaging::MINIMIZEDMETRICS { cbSize, iWidth, iHorzGap, iVertGap, iArrange }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MINIMIZEDMETRICS) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::MINIMIZEDMETRICS { cbSize, iWidth, iHorzGap, iVertGap, iArrange } = win32;
        let cb_size = cbSize;
        let i_width = iWidth;
        let i_horz_gap = iHorzGap;
        let i_vert_gap = iVertGap;
        let i_arrange = iArrange;
        Self { cb_size, i_width, i_horz_gap, i_vert_gap, i_arrange }
    }
}
pub const ARW_BOTTOMLEFT: i32 = 0x0;
pub const ARW_BOTTOMRIGHT: i32 = 0x1;
pub const ARW_TOPLEFT: i32 = 0x2;
pub const ARW_TOPRIGHT: i32 = 0x3;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Minmaxinfo {
    pub pt_reserved: Point,
    pub pt_max_size: Point,
    pub pt_max_position: Point,
    pub pt_min_track_size: Point,
    pub pt_max_track_size: Point,
}
impl Minmaxinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MINMAXINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MINMAXINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const MM_ADDSEPARATOR: u32 = 0x1;
pub const MM_SUBMENUSHAVEIDS: u32 = 0x2;
pub const MM_DONTREMOVESEPS: u32 = 0x4;
pub const MWT_IDENTITY: u32 = 0x1;
pub const MWT_LEFTMULTIPLY: u32 = 0x2;
pub const MWT_RIGHTMULTIPLY: u32 = 0x3;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Monitorinfo {
    pub cb_size: u32,
    pub rc_monitor: Rect,
    pub rc_work: Rect,
    pub dw_flags: u32,
}
impl Monitorinfo {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::MONITORINFO {
        let Self { cb_size, rc_monitor, rc_work, dw_flags } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::MONITORINFO>() as _;
        let rcMonitor = rc_monitor.to_win32();
        let rcWork = rc_work.to_win32();
        let dwFlags = *dw_flags;
        windows_sys::Win32::Graphics::Gdi::MONITORINFO { cbSize, rcMonitor, rcWork, dwFlags }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::MONITORINFO) -> Self {
        let windows_sys::Win32::Graphics::Gdi::MONITORINFO { cbSize, rcMonitor, rcWork, dwFlags } = win32;
        let cb_size = cbSize;
        let rc_monitor = unsafe { RECT::from_win32(rcMonitor) };
        let rc_work = unsafe { RECT::from_win32(rcWork) };
        let dw_flags = dwFlags;
        Self { cb_size, rc_monitor, rc_work, dw_flags }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Monitorinfoexa {
    pub monitor_info: Monitorinfo,
    pub sz_device: [CHAR; 32],
}
impl Monitorinfoexa {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::MONITORINFOEXA {
        let Self { monitor_info, sz_device } = self;
        let monitorInfo = monitor_info.to_win32();
        let szDevice = [sz_device[0],sz_device[1],sz_device[2],sz_device[3],sz_device[4],sz_device[5],sz_device[6],sz_device[7],sz_device[8],sz_device[9],sz_device[10],sz_device[11],sz_device[12],sz_device[13],sz_device[14],sz_device[15],sz_device[16],sz_device[17],sz_device[18],sz_device[19],sz_device[20],sz_device[21],sz_device[22],sz_device[23],sz_device[24],sz_device[25],sz_device[26],sz_device[27],sz_device[28],sz_device[29],sz_device[30],sz_device[31]];
        windows_sys::Win32::Graphics::Gdi::MONITORINFOEXA { monitorInfo, szDevice }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::MONITORINFOEXA) -> Self {
        let windows_sys::Win32::Graphics::Gdi::MONITORINFOEXA { monitorInfo, szDevice } = win32;
        let monitor_info = unsafe { MONITORINFO::from_win32(monitorInfo) };
        let sz_device = [szDevice[0],szDevice[1],szDevice[2],szDevice[3],szDevice[4],szDevice[5],szDevice[6],szDevice[7],szDevice[8],szDevice[9],szDevice[10],szDevice[11],szDevice[12],szDevice[13],szDevice[14],szDevice[15],szDevice[16],szDevice[17],szDevice[18],szDevice[19],szDevice[20],szDevice[21],szDevice[22],szDevice[23],szDevice[24],szDevice[25],szDevice[26],szDevice[27],szDevice[28],szDevice[29],szDevice[30],szDevice[31]];
        Self { monitor_info, sz_device }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Monitorinfoexw {
    pub monitor_info: Monitorinfo,
    pub sz_device: [u8; 32],
}
impl Monitorinfoexw {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::MONITORINFOEXW {
        let Self { monitor_info, sz_device } = self;
        let monitorInfo = monitor_info.to_win32();
        let szDevice = [*sz_device[0],*sz_device[1],*sz_device[2],*sz_device[3],*sz_device[4],*sz_device[5],*sz_device[6],*sz_device[7],*sz_device[8],*sz_device[9],*sz_device[10],*sz_device[11],*sz_device[12],*sz_device[13],*sz_device[14],*sz_device[15],*sz_device[16],*sz_device[17],*sz_device[18],*sz_device[19],*sz_device[20],*sz_device[21],*sz_device[22],*sz_device[23],*sz_device[24],*sz_device[25],*sz_device[26],*sz_device[27],*sz_device[28],*sz_device[29],*sz_device[30],*sz_device[31]];
        windows_sys::Win32::Graphics::Gdi::MONITORINFOEXW { monitorInfo, szDevice }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::MONITORINFOEXW) -> Self {
        let windows_sys::Win32::Graphics::Gdi::MONITORINFOEXW { monitorInfo, szDevice } = win32;
        let monitor_info = unsafe { MONITORINFO::from_win32(monitorInfo) };
        let sz_device = [szDevice[0],szDevice[1],szDevice[2],szDevice[3],szDevice[4],szDevice[5],szDevice[6],szDevice[7],szDevice[8],szDevice[9],szDevice[10],szDevice[11],szDevice[12],szDevice[13],szDevice[14],szDevice[15],szDevice[16],szDevice[17],szDevice[18],szDevice[19],szDevice[20],szDevice[21],szDevice[22],szDevice[23],szDevice[24],szDevice[25],szDevice[26],szDevice[27],szDevice[28],szDevice[29],szDevice[30],szDevice[31]];
        Self { monitor_info, sz_device }
    }
}
pub const MAV_UNKNOWN: i32 = 0x0;
pub const MAV_NO_APP_VISIBLE: i32 = 0x1;
pub const MAV_APP_VISIBLE: i32 = 0x2;
pub const MONITOR_DEFAULTTONEAREST: u32 = 0x2;
pub const MONITOR_DEFAULTTONULL: u32 = 0x0;
pub const MONITOR_DEFAULTTOPRIMARY: u32 = 0x1;
pub const MC_BACKGROUND: i32 = 0x1;
pub const MC_BORDERS: i32 = 0x2;
pub const MC_GRIDBACKGROUND: i32 = 0x3;
pub const MC_COLHEADERSPLITTER: i32 = 0x4;
pub const MC_GRIDCELLBACKGROUND: i32 = 0x5;
pub const MC_GRIDCELL: i32 = 0x6;
pub const MC_GRIDCELLUPPER: i32 = 0x7;
pub const MC_TRAILINGGRIDCELL: i32 = 0x8;
pub const MC_TRAILINGGRIDCELLUPPER: i32 = 0x9;
pub const MC_NAVNEXT: i32 = 0xA;
pub const MC_NAVPREV: i32 = 0xB;
pub const SPSB_NORMAL: i32 = 0x1;
pub const SPSB_HOT: i32 = 0x2;
pub const SPSB_PRESSED: i32 = 0x3;
pub const SPS_NORMAL: i32 = 0x1;
pub const SPS_HOT: i32 = 0x2;
pub const SPS_PRESSED: i32 = 0x3;
pub const SPMPT_NORMAL: i32 = 0x1;
pub const SPMPT_HOT: i32 = 0x2;
pub const SPMPT_SELECTED: i32 = 0x3;
pub const SPMPT_DISABLED: i32 = 0x4;
pub const SPMPT_FOCUSED: i32 = 0x5;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Mousehookstruct {
    pub pt: Point,
    pub hwnd: Option<Hwnd>,
    pub w_hit_test_code: u32,
    pub dw_extra_info: usize,
}
impl Mousehookstruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MOUSEHOOKSTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MOUSEHOOKSTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Mousehookstructex {
    pub anonymous_base_winuser_l1166_c46: Mousehookstruct,
    pub mouse_data: u32,
}
impl Mousehookstructex {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MOUSEHOOKSTRUCTEX {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MOUSEHOOKSTRUCTEX) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const XBUTTON1: u32 = 0x1;
pub const XBUTTON2: u32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Msg {
    pub hwnd: Option<Hwnd>,
    pub message: u32,
    pub w_param: Wparam,
    pub l_param: Lparam,
    pub time: u32,
    pub pt: Point,
}
impl Msg {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MSG {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MSG) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Msgboxparamsa<'a> {
    pub cb_size: u32,
    pub hwnd_owner: Option<Hwnd>,
    pub h_instance: Option<Hinstance>,
    pub lpsz_text: Cow<'a, CStr>,
    pub lpsz_caption: Cow<'a, CStr>,
    pub dw_style: u32,
    pub lpsz_icon: Cow<'a, CStr>,
    pub dw_context_help_id: usize,
    pub lpfn_msg_box_callback: Option<unsafe extern "system" fn(*mut HELPINFO)>,
    pub dw_language_id: u32,
}
impl Msgboxparamsa {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MSGBOXPARAMSA {
        let Self { cb_size, hwnd_owner, h_instance, lpsz_text, lpsz_caption, dw_style, lpsz_icon, dw_context_help_id, lpfn_msg_box_callback, dw_language_id } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::MSGBOXPARAMSA>() as _;
        let hwndOwner = hwnd_owner.map_or(0, Hwnd::into_raw);
        let hInstance = h_instance.map_or(0, Hinstance::into_raw);
        let lpszText = lpsz_text.as_ptr();
        let lpszCaption = lpsz_caption.as_ptr();
        let dwStyle = dw_style;
        let lpszIcon = lpsz_icon.as_ptr();
        let dwContextHelpId = *dw_context_help_id;
        let lpfnMsgBoxCallback = Some(lpfn_msg_box_callback);
        let dwLanguageId = *dw_language_id;
        windows_sys::Win32::UI::WindowsAndMessaging::MSGBOXPARAMSA { cbSize, hwndOwner, hInstance, lpszText, lpszCaption, dwStyle, lpszIcon, dwContextHelpId, lpfnMsgBoxCallback, dwLanguageId }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MSGBOXPARAMSA) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::MSGBOXPARAMSA { cbSize, hwndOwner, hInstance, lpszText, lpszCaption, dwStyle, lpszIcon, dwContextHelpId, lpfnMsgBoxCallback, dwLanguageId } = win32;
        let cb_size = cbSize;
        let hwnd_owner = unsafe { Hwnd::new_optional(hwndOwner) };
        let h_instance = unsafe { Hinstance::new_optional(hInstance) };
        let lpszText = unsafe { CStr::from_ptr(lpszText) };
        let lpszText = lpszText.to_bytes_with_nul().to_vec();
        let lpsz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(lpszText) });
        let lpszCaption = unsafe { CStr::from_ptr(lpszCaption) };
        let lpszCaption = lpszCaption.to_bytes_with_nul().to_vec();
        let lpsz_caption = Cow::Owned(unsafe { CString::from_vec_unchecked(lpszCaption) });
        let dw_style = dwStyle;
        let lpszIcon = unsafe { CStr::from_ptr(lpszIcon) };
        let lpszIcon = lpszIcon.to_bytes_with_nul().to_vec();
        let lpsz_icon = Cow::Owned(unsafe { CString::from_vec_unchecked(lpszIcon) });
        let dw_context_help_id = dwContextHelpId;
        let lpfn_msg_box_callback = lpfnMsgBoxCallback;
        let dw_language_id = dwLanguageId;
        Self { cb_size, hwnd_owner, h_instance, lpsz_text, lpsz_caption, dw_style, lpsz_icon, dw_context_help_id, lpfn_msg_box_callback, dw_language_id }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Msgboxparamsw<'a> {
    pub cb_size: u32,
    pub hwnd_owner: Option<Hwnd>,
    pub h_instance: Option<Hinstance>,
    pub lpsz_text: Cow<'a, [u16]>,
    pub lpsz_caption: Cow<'a, [u16]>,
    pub dw_style: u32,
    pub lpsz_icon: Cow<'a, [u16]>,
    pub dw_context_help_id: usize,
    pub lpfn_msg_box_callback: Option<unsafe extern "system" fn(*mut HELPINFO)>,
    pub dw_language_id: u32,
}
impl Msgboxparamsw {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MSGBOXPARAMSW {
        let Self { cb_size, hwnd_owner, h_instance, lpsz_text, lpsz_caption, dw_style, lpsz_icon, dw_context_help_id, lpfn_msg_box_callback, dw_language_id } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::MSGBOXPARAMSW>() as _;
        let hwndOwner = hwnd_owner.map_or(0, Hwnd::into_raw);
        let hInstance = h_instance.map_or(0, Hinstance::into_raw);
        assert_eq!(lpsz_text.last(), Some(0));
        let lpszText = lpsz_text.as_ptr();
        assert_eq!(lpsz_caption.last(), Some(0));
        let lpszCaption = lpsz_caption.as_ptr();
        let dwStyle = dw_style;
        assert_eq!(lpsz_icon.last(), Some(0));
        let lpszIcon = lpsz_icon.as_ptr();
        let dwContextHelpId = *dw_context_help_id;
        let lpfnMsgBoxCallback = Some(lpfn_msg_box_callback);
        let dwLanguageId = *dw_language_id;
        windows_sys::Win32::UI::WindowsAndMessaging::MSGBOXPARAMSW { cbSize, hwndOwner, hInstance, lpszText, lpszCaption, dwStyle, lpszIcon, dwContextHelpId, lpfnMsgBoxCallback, dwLanguageId }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MSGBOXPARAMSW) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::MSGBOXPARAMSW { cbSize, hwndOwner, hInstance, lpszText, lpszCaption, dwStyle, lpszIcon, dwContextHelpId, lpfnMsgBoxCallback, dwLanguageId } = win32;
        let cb_size = cbSize;
        let hwnd_owner = unsafe { Hwnd::new_optional(hwndOwner) };
        let h_instance = unsafe { Hinstance::new_optional(hInstance) };
        let slen = unsafe { wide_strlen(lpszText as *const u16) };
        let lpszText = unsafe { slice::from_raw_parts(lpszText, slen + 1) };
        let lpsz_text = lpszText.to_vec();
        let slen = unsafe { wide_strlen(lpszCaption as *const u16) };
        let lpszCaption = unsafe { slice::from_raw_parts(lpszCaption, slen + 1) };
        let lpsz_caption = lpszCaption.to_vec();
        let dw_style = dwStyle;
        let slen = unsafe { wide_strlen(lpszIcon as *const u16) };
        let lpszIcon = unsafe { slice::from_raw_parts(lpszIcon, slen + 1) };
        let lpsz_icon = lpszIcon.to_vec();
        let dw_context_help_id = dwContextHelpId;
        let lpfn_msg_box_callback = lpfnMsgBoxCallback;
        let dw_language_id = dwLanguageId;
        Self { cb_size, hwnd_owner, h_instance, lpsz_text, lpsz_caption, dw_style, lpsz_icon, dw_context_help_id, lpfn_msg_box_callback, dw_language_id }
    }
}
pub const MSGFLTINFO_NONE: u32 = 0x0;
pub const MSGFLTINFO_ALLOWED_HIGHER: u32 = 0x3;
pub const MSGFLTINFO_ALREADYALLOWED_FORWND: u32 = 0x1;
pub const MSGFLTINFO_ALREADYDISALLOWED_FORWND: u32 = 0x2;
pub const MWMO_NONE: u32 = 0x0;
pub const MWMO_ALERTABLE: u32 = 0x2;
pub const MWMO_INPUTAVAILABLE: u32 = 0x4;
pub const MWMO_WAITALL: u32 = 0x1;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Msllhookstruct {
    pub pt: Point,
    pub mouse_data: u32,
    pub flags: u32,
    pub time: u32,
    pub dw_extra_info: usize,
}
impl Msllhookstruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MSLLHOOKSTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MSLLHOOKSTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Multikeyhelpa {
    pub mk_size: u32,
    pub mk_keylist: CHAR,
    pub sz_keyphrase: [CHAR; 1],
}
impl Multikeyhelpa {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::MULTIKEYHELPA {
        let Self { mk_size, mk_keylist, sz_keyphrase } = self;
        let mkSize = mem::size_of::<windows_sys::Win32::UI::Shell::MULTIKEYHELPA>() as _;
        let mkKeylist = mk_keylist;
        let szKeyphrase = [sz_keyphrase[0]];
        windows_sys::Win32::UI::Shell::MULTIKEYHELPA { mkSize, mkKeylist, szKeyphrase }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::MULTIKEYHELPA) -> Self {
        let windows_sys::Win32::UI::Shell::MULTIKEYHELPA { mkSize, mkKeylist, szKeyphrase } = win32;
        let mk_size = mkSize;
        let mk_keylist = mkKeylist;
        let sz_keyphrase = [szKeyphrase[0]];
        Self { mk_size, mk_keylist, sz_keyphrase }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Multikeyhelpw {
    pub mk_size: u32,
    pub mk_keylist: u8,
    pub sz_keyphrase: [u8; 1],
}
impl Multikeyhelpw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::MULTIKEYHELPW {
        let Self { mk_size, mk_keylist, sz_keyphrase } = self;
        let mkSize = mem::size_of::<windows_sys::Win32::UI::Shell::MULTIKEYHELPW>() as _;
        let mkKeylist = *mk_keylist;
        let szKeyphrase = [*sz_keyphrase[0]];
        windows_sys::Win32::UI::Shell::MULTIKEYHELPW { mkSize, mkKeylist, szKeyphrase }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::MULTIKEYHELPW) -> Self {
        let windows_sys::Win32::UI::Shell::MULTIKEYHELPW { mkSize, mkKeylist, szKeyphrase } = win32;
        let mk_size = mkSize;
        let mk_keylist = mkKeylist;
        let sz_keyphrase = [szKeyphrase[0]];
        Self { mk_size, mk_keylist, sz_keyphrase }
    }
}
pub const NSWF_DEFAULT: i32 = 0x0;
pub const NSWF_NONE_IMPLIES_ALL: i32 = 0x1;
pub const NSWF_ONE_IMPLIES_ALL: i32 = 0x2;
pub const NSWF_DONT_TRAVERSE_LINKS: i32 = 0x4;
pub const NSWF_DONT_ACCUMULATE_RESULT: i32 = 0x8;
pub const NSWF_TRAVERSE_STREAM_JUNCTIONS: i32 = 0x10;
pub const NSWF_FILESYSTEM_ONLY: i32 = 0x20;
pub const NSWF_SHOW_PROGRESS: i32 = 0x40;
pub const NSWF_FLAG_VIEWORDER: i32 = 0x80;
pub const NSWF_IGNORE_AUTOPLAY_HIDA: i32 = 0x100;
pub const NSWF_ASYNC: i32 = 0x200;
pub const NSWF_DONT_RESOLVE_LINKS: i32 = 0x400;
pub const NSWF_ACCUMULATE_FOLDERS: i32 = 0x800;
pub const NSWF_DONT_SORT: i32 = 0x1000;
pub const NSWF_USE_TRANSFER_MEDIUM: i32 = 0x2000;
pub const NSWF_DONT_TRAVERSE_STREAM_JUNCTIONS: i32 = 0x4000;
pub const NSWF_ANY_IMPLIES_ALL: i32 = 0x8000;
pub const NDO_LANDSCAPE: i32 = 0x0;
pub const NDO_PORTRAIT: i32 = 0x1;
pub const MCNN_NORMAL: i32 = 0x1;
pub const MCNN_HOT: i32 = 0x2;
pub const MCNN_PRESSED: i32 = 0x3;
pub const MCNN_DISABLED: i32 = 0x4;
pub const MCNP_NORMAL: i32 = 0x1;
pub const MCNP_HOT: i32 = 0x2;
pub const MCNP_PRESSED: i32 = 0x3;
pub const MCNP_DISABLED: i32 = 0x4;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct NccalcsizeParams<'a> {
    pub rgrc: [Rect; 3],
    pub lppos: &'a mut Windowpos,
}
impl NccalcsizeParams {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::NCCALCSIZE_PARAMS {
        let Self { rgrc, lppos } = self;
        let rgrc = [rgrc[0].to_win32(),rgrc[1].to_win32(),rgrc[2].to_win32()];
        let lppos = unsafe { &mut *(lppos as *mut _ as *mut _) };
        windows_sys::Win32::UI::WindowsAndMessaging::NCCALCSIZE_PARAMS { rgrc, lppos }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::NCCALCSIZE_PARAMS) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::NCCALCSIZE_PARAMS { rgrc, lppos } = win32;
        let rgrc = [unsafe { RECT::from_win32(rgrc[0]) },unsafe { RECT::from_win32(rgrc[1]) },unsafe { RECT::from_win32(rgrc[2]) }];
        let lppos = unsafe { &mut *(lppos as *mut _ as *mut _) };
        Self { rgrc, lppos }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Newcplinfoa {
    pub dw_size: u32,
    pub dw_flags: u32,
    pub dw_help_context: u32,
    pub l_data: isize,
    pub h_icon: Option<Hicon>,
    pub sz_name: [CHAR; 32],
    pub sz_info: [CHAR; 64],
    pub sz_help_file: [CHAR; 128],
}
impl Newcplinfoa {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::NEWCPLINFOA {
        let Self { dw_size, dw_flags, dw_help_context, l_data, h_icon, sz_name, sz_info, sz_help_file } = self;
        let dwSize = mem::size_of::<windows_sys::Win32::UI::Shell::NEWCPLINFOA>() as _;
        let dwFlags = *dw_flags;
        let dwHelpContext = *dw_help_context;
        let lData = *l_data;
        let hIcon = h_icon.map_or(0, Hicon::into_raw);
        let szName = [sz_name[0],sz_name[1],sz_name[2],sz_name[3],sz_name[4],sz_name[5],sz_name[6],sz_name[7],sz_name[8],sz_name[9],sz_name[10],sz_name[11],sz_name[12],sz_name[13],sz_name[14],sz_name[15],sz_name[16],sz_name[17],sz_name[18],sz_name[19],sz_name[20],sz_name[21],sz_name[22],sz_name[23],sz_name[24],sz_name[25],sz_name[26],sz_name[27],sz_name[28],sz_name[29],sz_name[30],sz_name[31]];
        let szInfo = [sz_info[0],sz_info[1],sz_info[2],sz_info[3],sz_info[4],sz_info[5],sz_info[6],sz_info[7],sz_info[8],sz_info[9],sz_info[10],sz_info[11],sz_info[12],sz_info[13],sz_info[14],sz_info[15],sz_info[16],sz_info[17],sz_info[18],sz_info[19],sz_info[20],sz_info[21],sz_info[22],sz_info[23],sz_info[24],sz_info[25],sz_info[26],sz_info[27],sz_info[28],sz_info[29],sz_info[30],sz_info[31],sz_info[32],sz_info[33],sz_info[34],sz_info[35],sz_info[36],sz_info[37],sz_info[38],sz_info[39],sz_info[40],sz_info[41],sz_info[42],sz_info[43],sz_info[44],sz_info[45],sz_info[46],sz_info[47],sz_info[48],sz_info[49],sz_info[50],sz_info[51],sz_info[52],sz_info[53],sz_info[54],sz_info[55],sz_info[56],sz_info[57],sz_info[58],sz_info[59],sz_info[60],sz_info[61],sz_info[62],sz_info[63]];
        let szHelpFile = [sz_help_file[0],sz_help_file[1],sz_help_file[2],sz_help_file[3],sz_help_file[4],sz_help_file[5],sz_help_file[6],sz_help_file[7],sz_help_file[8],sz_help_file[9],sz_help_file[10],sz_help_file[11],sz_help_file[12],sz_help_file[13],sz_help_file[14],sz_help_file[15],sz_help_file[16],sz_help_file[17],sz_help_file[18],sz_help_file[19],sz_help_file[20],sz_help_file[21],sz_help_file[22],sz_help_file[23],sz_help_file[24],sz_help_file[25],sz_help_file[26],sz_help_file[27],sz_help_file[28],sz_help_file[29],sz_help_file[30],sz_help_file[31],sz_help_file[32],sz_help_file[33],sz_help_file[34],sz_help_file[35],sz_help_file[36],sz_help_file[37],sz_help_file[38],sz_help_file[39],sz_help_file[40],sz_help_file[41],sz_help_file[42],sz_help_file[43],sz_help_file[44],sz_help_file[45],sz_help_file[46],sz_help_file[47],sz_help_file[48],sz_help_file[49],sz_help_file[50],sz_help_file[51],sz_help_file[52],sz_help_file[53],sz_help_file[54],sz_help_file[55],sz_help_file[56],sz_help_file[57],sz_help_file[58],sz_help_file[59],sz_help_file[60],sz_help_file[61],sz_help_file[62],sz_help_file[63],sz_help_file[64],sz_help_file[65],sz_help_file[66],sz_help_file[67],sz_help_file[68],sz_help_file[69],sz_help_file[70],sz_help_file[71],sz_help_file[72],sz_help_file[73],sz_help_file[74],sz_help_file[75],sz_help_file[76],sz_help_file[77],sz_help_file[78],sz_help_file[79],sz_help_file[80],sz_help_file[81],sz_help_file[82],sz_help_file[83],sz_help_file[84],sz_help_file[85],sz_help_file[86],sz_help_file[87],sz_help_file[88],sz_help_file[89],sz_help_file[90],sz_help_file[91],sz_help_file[92],sz_help_file[93],sz_help_file[94],sz_help_file[95],sz_help_file[96],sz_help_file[97],sz_help_file[98],sz_help_file[99],sz_help_file[100],sz_help_file[101],sz_help_file[102],sz_help_file[103],sz_help_file[104],sz_help_file[105],sz_help_file[106],sz_help_file[107],sz_help_file[108],sz_help_file[109],sz_help_file[110],sz_help_file[111],sz_help_file[112],sz_help_file[113],sz_help_file[114],sz_help_file[115],sz_help_file[116],sz_help_file[117],sz_help_file[118],sz_help_file[119],sz_help_file[120],sz_help_file[121],sz_help_file[122],sz_help_file[123],sz_help_file[124],sz_help_file[125],sz_help_file[126],sz_help_file[127]];
        windows_sys::Win32::UI::Shell::NEWCPLINFOA { dwSize, dwFlags, dwHelpContext, lData, hIcon, szName, szInfo, szHelpFile }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::NEWCPLINFOA) -> Self {
        let windows_sys::Win32::UI::Shell::NEWCPLINFOA { dwSize, dwFlags, dwHelpContext, lData, hIcon, szName, szInfo, szHelpFile } = win32;
        let dw_size = dwSize;
        let dw_flags = dwFlags;
        let dw_help_context = dwHelpContext;
        let l_data = lData;
        let h_icon = unsafe { Hicon::new_optional(hIcon) };
        let sz_name = [szName[0],szName[1],szName[2],szName[3],szName[4],szName[5],szName[6],szName[7],szName[8],szName[9],szName[10],szName[11],szName[12],szName[13],szName[14],szName[15],szName[16],szName[17],szName[18],szName[19],szName[20],szName[21],szName[22],szName[23],szName[24],szName[25],szName[26],szName[27],szName[28],szName[29],szName[30],szName[31]];
        let sz_info = [szInfo[0],szInfo[1],szInfo[2],szInfo[3],szInfo[4],szInfo[5],szInfo[6],szInfo[7],szInfo[8],szInfo[9],szInfo[10],szInfo[11],szInfo[12],szInfo[13],szInfo[14],szInfo[15],szInfo[16],szInfo[17],szInfo[18],szInfo[19],szInfo[20],szInfo[21],szInfo[22],szInfo[23],szInfo[24],szInfo[25],szInfo[26],szInfo[27],szInfo[28],szInfo[29],szInfo[30],szInfo[31],szInfo[32],szInfo[33],szInfo[34],szInfo[35],szInfo[36],szInfo[37],szInfo[38],szInfo[39],szInfo[40],szInfo[41],szInfo[42],szInfo[43],szInfo[44],szInfo[45],szInfo[46],szInfo[47],szInfo[48],szInfo[49],szInfo[50],szInfo[51],szInfo[52],szInfo[53],szInfo[54],szInfo[55],szInfo[56],szInfo[57],szInfo[58],szInfo[59],szInfo[60],szInfo[61],szInfo[62],szInfo[63]];
        let sz_help_file = [szHelpFile[0],szHelpFile[1],szHelpFile[2],szHelpFile[3],szHelpFile[4],szHelpFile[5],szHelpFile[6],szHelpFile[7],szHelpFile[8],szHelpFile[9],szHelpFile[10],szHelpFile[11],szHelpFile[12],szHelpFile[13],szHelpFile[14],szHelpFile[15],szHelpFile[16],szHelpFile[17],szHelpFile[18],szHelpFile[19],szHelpFile[20],szHelpFile[21],szHelpFile[22],szHelpFile[23],szHelpFile[24],szHelpFile[25],szHelpFile[26],szHelpFile[27],szHelpFile[28],szHelpFile[29],szHelpFile[30],szHelpFile[31],szHelpFile[32],szHelpFile[33],szHelpFile[34],szHelpFile[35],szHelpFile[36],szHelpFile[37],szHelpFile[38],szHelpFile[39],szHelpFile[40],szHelpFile[41],szHelpFile[42],szHelpFile[43],szHelpFile[44],szHelpFile[45],szHelpFile[46],szHelpFile[47],szHelpFile[48],szHelpFile[49],szHelpFile[50],szHelpFile[51],szHelpFile[52],szHelpFile[53],szHelpFile[54],szHelpFile[55],szHelpFile[56],szHelpFile[57],szHelpFile[58],szHelpFile[59],szHelpFile[60],szHelpFile[61],szHelpFile[62],szHelpFile[63],szHelpFile[64],szHelpFile[65],szHelpFile[66],szHelpFile[67],szHelpFile[68],szHelpFile[69],szHelpFile[70],szHelpFile[71],szHelpFile[72],szHelpFile[73],szHelpFile[74],szHelpFile[75],szHelpFile[76],szHelpFile[77],szHelpFile[78],szHelpFile[79],szHelpFile[80],szHelpFile[81],szHelpFile[82],szHelpFile[83],szHelpFile[84],szHelpFile[85],szHelpFile[86],szHelpFile[87],szHelpFile[88],szHelpFile[89],szHelpFile[90],szHelpFile[91],szHelpFile[92],szHelpFile[93],szHelpFile[94],szHelpFile[95],szHelpFile[96],szHelpFile[97],szHelpFile[98],szHelpFile[99],szHelpFile[100],szHelpFile[101],szHelpFile[102],szHelpFile[103],szHelpFile[104],szHelpFile[105],szHelpFile[106],szHelpFile[107],szHelpFile[108],szHelpFile[109],szHelpFile[110],szHelpFile[111],szHelpFile[112],szHelpFile[113],szHelpFile[114],szHelpFile[115],szHelpFile[116],szHelpFile[117],szHelpFile[118],szHelpFile[119],szHelpFile[120],szHelpFile[121],szHelpFile[122],szHelpFile[123],szHelpFile[124],szHelpFile[125],szHelpFile[126],szHelpFile[127]];
        Self { dw_size, dw_flags, dw_help_context, l_data, h_icon, sz_name, sz_info, sz_help_file }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Newcplinfow {
    pub dw_size: u32,
    pub dw_flags: u32,
    pub dw_help_context: u32,
    pub l_data: isize,
    pub h_icon: Option<Hicon>,
    pub sz_name: [u8; 32],
    pub sz_info: [u8; 64],
    pub sz_help_file: [u8; 128],
}
impl Newcplinfow {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::NEWCPLINFOW {
        let Self { dw_size, dw_flags, dw_help_context, l_data, h_icon, sz_name, sz_info, sz_help_file } = self;
        let dwSize = mem::size_of::<windows_sys::Win32::UI::Shell::NEWCPLINFOW>() as _;
        let dwFlags = *dw_flags;
        let dwHelpContext = *dw_help_context;
        let lData = *l_data;
        let hIcon = h_icon.map_or(0, Hicon::into_raw);
        let szName = [*sz_name[0],*sz_name[1],*sz_name[2],*sz_name[3],*sz_name[4],*sz_name[5],*sz_name[6],*sz_name[7],*sz_name[8],*sz_name[9],*sz_name[10],*sz_name[11],*sz_name[12],*sz_name[13],*sz_name[14],*sz_name[15],*sz_name[16],*sz_name[17],*sz_name[18],*sz_name[19],*sz_name[20],*sz_name[21],*sz_name[22],*sz_name[23],*sz_name[24],*sz_name[25],*sz_name[26],*sz_name[27],*sz_name[28],*sz_name[29],*sz_name[30],*sz_name[31]];
        let szInfo = [*sz_info[0],*sz_info[1],*sz_info[2],*sz_info[3],*sz_info[4],*sz_info[5],*sz_info[6],*sz_info[7],*sz_info[8],*sz_info[9],*sz_info[10],*sz_info[11],*sz_info[12],*sz_info[13],*sz_info[14],*sz_info[15],*sz_info[16],*sz_info[17],*sz_info[18],*sz_info[19],*sz_info[20],*sz_info[21],*sz_info[22],*sz_info[23],*sz_info[24],*sz_info[25],*sz_info[26],*sz_info[27],*sz_info[28],*sz_info[29],*sz_info[30],*sz_info[31],*sz_info[32],*sz_info[33],*sz_info[34],*sz_info[35],*sz_info[36],*sz_info[37],*sz_info[38],*sz_info[39],*sz_info[40],*sz_info[41],*sz_info[42],*sz_info[43],*sz_info[44],*sz_info[45],*sz_info[46],*sz_info[47],*sz_info[48],*sz_info[49],*sz_info[50],*sz_info[51],*sz_info[52],*sz_info[53],*sz_info[54],*sz_info[55],*sz_info[56],*sz_info[57],*sz_info[58],*sz_info[59],*sz_info[60],*sz_info[61],*sz_info[62],*sz_info[63]];
        let szHelpFile = [*sz_help_file[0],*sz_help_file[1],*sz_help_file[2],*sz_help_file[3],*sz_help_file[4],*sz_help_file[5],*sz_help_file[6],*sz_help_file[7],*sz_help_file[8],*sz_help_file[9],*sz_help_file[10],*sz_help_file[11],*sz_help_file[12],*sz_help_file[13],*sz_help_file[14],*sz_help_file[15],*sz_help_file[16],*sz_help_file[17],*sz_help_file[18],*sz_help_file[19],*sz_help_file[20],*sz_help_file[21],*sz_help_file[22],*sz_help_file[23],*sz_help_file[24],*sz_help_file[25],*sz_help_file[26],*sz_help_file[27],*sz_help_file[28],*sz_help_file[29],*sz_help_file[30],*sz_help_file[31],*sz_help_file[32],*sz_help_file[33],*sz_help_file[34],*sz_help_file[35],*sz_help_file[36],*sz_help_file[37],*sz_help_file[38],*sz_help_file[39],*sz_help_file[40],*sz_help_file[41],*sz_help_file[42],*sz_help_file[43],*sz_help_file[44],*sz_help_file[45],*sz_help_file[46],*sz_help_file[47],*sz_help_file[48],*sz_help_file[49],*sz_help_file[50],*sz_help_file[51],*sz_help_file[52],*sz_help_file[53],*sz_help_file[54],*sz_help_file[55],*sz_help_file[56],*sz_help_file[57],*sz_help_file[58],*sz_help_file[59],*sz_help_file[60],*sz_help_file[61],*sz_help_file[62],*sz_help_file[63],*sz_help_file[64],*sz_help_file[65],*sz_help_file[66],*sz_help_file[67],*sz_help_file[68],*sz_help_file[69],*sz_help_file[70],*sz_help_file[71],*sz_help_file[72],*sz_help_file[73],*sz_help_file[74],*sz_help_file[75],*sz_help_file[76],*sz_help_file[77],*sz_help_file[78],*sz_help_file[79],*sz_help_file[80],*sz_help_file[81],*sz_help_file[82],*sz_help_file[83],*sz_help_file[84],*sz_help_file[85],*sz_help_file[86],*sz_help_file[87],*sz_help_file[88],*sz_help_file[89],*sz_help_file[90],*sz_help_file[91],*sz_help_file[92],*sz_help_file[93],*sz_help_file[94],*sz_help_file[95],*sz_help_file[96],*sz_help_file[97],*sz_help_file[98],*sz_help_file[99],*sz_help_file[100],*sz_help_file[101],*sz_help_file[102],*sz_help_file[103],*sz_help_file[104],*sz_help_file[105],*sz_help_file[106],*sz_help_file[107],*sz_help_file[108],*sz_help_file[109],*sz_help_file[110],*sz_help_file[111],*sz_help_file[112],*sz_help_file[113],*sz_help_file[114],*sz_help_file[115],*sz_help_file[116],*sz_help_file[117],*sz_help_file[118],*sz_help_file[119],*sz_help_file[120],*sz_help_file[121],*sz_help_file[122],*sz_help_file[123],*sz_help_file[124],*sz_help_file[125],*sz_help_file[126],*sz_help_file[127]];
        windows_sys::Win32::UI::Shell::NEWCPLINFOW { dwSize, dwFlags, dwHelpContext, lData, hIcon, szName, szInfo, szHelpFile }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::NEWCPLINFOW) -> Self {
        let windows_sys::Win32::UI::Shell::NEWCPLINFOW { dwSize, dwFlags, dwHelpContext, lData, hIcon, szName, szInfo, szHelpFile } = win32;
        let dw_size = dwSize;
        let dw_flags = dwFlags;
        let dw_help_context = dwHelpContext;
        let l_data = lData;
        let h_icon = unsafe { Hicon::new_optional(hIcon) };
        let sz_name = [szName[0],szName[1],szName[2],szName[3],szName[4],szName[5],szName[6],szName[7],szName[8],szName[9],szName[10],szName[11],szName[12],szName[13],szName[14],szName[15],szName[16],szName[17],szName[18],szName[19],szName[20],szName[21],szName[22],szName[23],szName[24],szName[25],szName[26],szName[27],szName[28],szName[29],szName[30],szName[31]];
        let sz_info = [szInfo[0],szInfo[1],szInfo[2],szInfo[3],szInfo[4],szInfo[5],szInfo[6],szInfo[7],szInfo[8],szInfo[9],szInfo[10],szInfo[11],szInfo[12],szInfo[13],szInfo[14],szInfo[15],szInfo[16],szInfo[17],szInfo[18],szInfo[19],szInfo[20],szInfo[21],szInfo[22],szInfo[23],szInfo[24],szInfo[25],szInfo[26],szInfo[27],szInfo[28],szInfo[29],szInfo[30],szInfo[31],szInfo[32],szInfo[33],szInfo[34],szInfo[35],szInfo[36],szInfo[37],szInfo[38],szInfo[39],szInfo[40],szInfo[41],szInfo[42],szInfo[43],szInfo[44],szInfo[45],szInfo[46],szInfo[47],szInfo[48],szInfo[49],szInfo[50],szInfo[51],szInfo[52],szInfo[53],szInfo[54],szInfo[55],szInfo[56],szInfo[57],szInfo[58],szInfo[59],szInfo[60],szInfo[61],szInfo[62],szInfo[63]];
        let sz_help_file = [szHelpFile[0],szHelpFile[1],szHelpFile[2],szHelpFile[3],szHelpFile[4],szHelpFile[5],szHelpFile[6],szHelpFile[7],szHelpFile[8],szHelpFile[9],szHelpFile[10],szHelpFile[11],szHelpFile[12],szHelpFile[13],szHelpFile[14],szHelpFile[15],szHelpFile[16],szHelpFile[17],szHelpFile[18],szHelpFile[19],szHelpFile[20],szHelpFile[21],szHelpFile[22],szHelpFile[23],szHelpFile[24],szHelpFile[25],szHelpFile[26],szHelpFile[27],szHelpFile[28],szHelpFile[29],szHelpFile[30],szHelpFile[31],szHelpFile[32],szHelpFile[33],szHelpFile[34],szHelpFile[35],szHelpFile[36],szHelpFile[37],szHelpFile[38],szHelpFile[39],szHelpFile[40],szHelpFile[41],szHelpFile[42],szHelpFile[43],szHelpFile[44],szHelpFile[45],szHelpFile[46],szHelpFile[47],szHelpFile[48],szHelpFile[49],szHelpFile[50],szHelpFile[51],szHelpFile[52],szHelpFile[53],szHelpFile[54],szHelpFile[55],szHelpFile[56],szHelpFile[57],szHelpFile[58],szHelpFile[59],szHelpFile[60],szHelpFile[61],szHelpFile[62],szHelpFile[63],szHelpFile[64],szHelpFile[65],szHelpFile[66],szHelpFile[67],szHelpFile[68],szHelpFile[69],szHelpFile[70],szHelpFile[71],szHelpFile[72],szHelpFile[73],szHelpFile[74],szHelpFile[75],szHelpFile[76],szHelpFile[77],szHelpFile[78],szHelpFile[79],szHelpFile[80],szHelpFile[81],szHelpFile[82],szHelpFile[83],szHelpFile[84],szHelpFile[85],szHelpFile[86],szHelpFile[87],szHelpFile[88],szHelpFile[89],szHelpFile[90],szHelpFile[91],szHelpFile[92],szHelpFile[93],szHelpFile[94],szHelpFile[95],szHelpFile[96],szHelpFile[97],szHelpFile[98],szHelpFile[99],szHelpFile[100],szHelpFile[101],szHelpFile[102],szHelpFile[103],szHelpFile[104],szHelpFile[105],szHelpFile[106],szHelpFile[107],szHelpFile[108],szHelpFile[109],szHelpFile[110],szHelpFile[111],szHelpFile[112],szHelpFile[113],szHelpFile[114],szHelpFile[115],szHelpFile[116],szHelpFile[117],szHelpFile[118],szHelpFile[119],szHelpFile[120],szHelpFile[121],szHelpFile[122],szHelpFile[123],szHelpFile[124],szHelpFile[125],szHelpFile[126],szHelpFile[127]];
        Self { dw_size, dw_flags, dw_help_context, l_data, h_icon, sz_name, sz_info, sz_help_file }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Newtextmetrica {
    pub tm_height: i32,
    pub tm_ascent: i32,
    pub tm_descent: i32,
    pub tm_internal_leading: i32,
    pub tm_external_leading: i32,
    pub tm_ave_char_width: i32,
    pub tm_max_char_width: i32,
    pub tm_weight: i32,
    pub tm_overhang: i32,
    pub tm_digitized_aspect_x: i32,
    pub tm_digitized_aspect_y: i32,
    pub tm_first_char: u8,
    pub tm_last_char: u8,
    pub tm_default_char: u8,
    pub tm_break_char: u8,
    pub tm_italic: u8,
    pub tm_underlined: u8,
    pub tm_struck_out: u8,
    pub tm_pitch_and_family: u8,
    pub tm_char_set: u8,
    pub ntm_flags: u32,
    pub ntm_size_em: u32,
    pub ntm_cell_height: u32,
    pub ntm_avg_width: u32,
}
impl Newtextmetrica {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::NEWTEXTMETRICA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::NEWTEXTMETRICA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Newtextmetricw {
    pub tm_height: i32,
    pub tm_ascent: i32,
    pub tm_descent: i32,
    pub tm_internal_leading: i32,
    pub tm_external_leading: i32,
    pub tm_ave_char_width: i32,
    pub tm_max_char_width: i32,
    pub tm_weight: i32,
    pub tm_overhang: i32,
    pub tm_digitized_aspect_x: i32,
    pub tm_digitized_aspect_y: i32,
    pub tm_first_char: u8,
    pub tm_last_char: u8,
    pub tm_default_char: u8,
    pub tm_break_char: u8,
    pub tm_italic: u8,
    pub tm_underlined: u8,
    pub tm_struck_out: u8,
    pub tm_pitch_and_family: u8,
    pub tm_char_set: u8,
    pub ntm_flags: u32,
    pub ntm_size_em: u32,
    pub ntm_cell_height: u32,
    pub ntm_avg_width: u32,
}
impl Newtextmetricw {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::NEWTEXTMETRICW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::NEWTEXTMETRICW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmcbedragbegina {
    pub hdr: Nmhdr,
    pub i_itemid: i32,
    pub sz_text: [CHAR; 260],
}
impl Nmcbedragbegina {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMCBEDRAGBEGINA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMCBEDRAGBEGINA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmcbedragbeginw {
    pub hdr: Nmhdr,
    pub i_itemid: i32,
    pub sz_text: [u8; 260],
}
impl Nmcbedragbeginw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMCBEDRAGBEGINW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMCBEDRAGBEGINW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmcbeendedita {
    pub hdr: Nmhdr,
    pub f_changed: BOOL,
    pub i_new_selection: i32,
    pub sz_text: [CHAR; 260],
    pub i_why: i32,
}
impl Nmcbeendedita {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMCBEENDEDITA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMCBEENDEDITA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmcbeendeditw {
    pub hdr: Nmhdr,
    pub f_changed: BOOL,
    pub i_new_selection: i32,
    pub sz_text: [u8; 260],
    pub i_why: i32,
}
impl Nmcbeendeditw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMCBEENDEDITW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMCBEENDEDITW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmchar {
    pub hdr: Nmhdr,
    pub ch: u32,
    pub dw_item_prev: u32,
    pub dw_item_next: u32,
}
impl Nmchar {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMCHAR {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMCHAR) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmcustomdraw {
    pub hdr: Nmhdr,
    pub dw_draw_stage: u32,
    pub hdc: Option<Hdc>,
    pub rc: Rect,
    pub dw_item_spec: usize,
    pub u_item_state: u32,
    pub l_iteml_param: Lparam,
}
impl Nmcustomdraw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMCUSTOMDRAW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMCUSTOMDRAW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const CDDS_POSTPAINT: u32 = 0x2;
pub const CDDS_PREERASE: u32 = 0x3;
pub const CDDS_PREPAINT: u32 = 0x1;
pub const CDDS_ITEMPOSTERASE: u32 = 0x10004;
pub const CDDS_ITEMPOSTPAINT: u32 = 0x10002;
pub const CDDS_ITEMPREERASE: u32 = 0x10003;
pub const CDDS_ITEMPREPAINT: u32 = 0x10001;
pub const CDDS_SUBITEM: u32 = 0x20000;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmcustomsplitrectinfo {
    pub hdr: Nmhdr,
    pub rc_client: Rect,
    pub rc_button: Rect,
    pub rc_split: Rect,
}
impl Nmcustomsplitrectinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMCUSTOMSPLITRECTINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMCUSTOMSPLITRECTINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmcustomtext<'a> {
    pub hdr: Nmhdr,
    pub h_dc: Option<Hdc>,
    pub lp_string: Cow<'a, [u16]>,
    pub n_count: i32,
    pub lp_rect: &'a mut Rect,
    pub u_format: u32,
    pub f_link: BOOL,
}
impl Nmcustomtext {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMCUSTOMTEXT {
        let Self { hdr, h_dc, lp_string, n_count, lp_rect, u_format, f_link } = self;
        let hdr = hdr.to_win32();
        let hDC = h_dc.map_or(0, Hdc::into_raw);
        assert_eq!(lp_string.last(), Some(0));
        let lpString = lp_string.as_ptr();
        let nCount = *n_count;
        let lpRect = unsafe { &mut *(lp_rect as *mut _ as *mut _) };
        let uFormat = *u_format;
        let fLink = f_link;
        windows_sys::Win32::UI::Controls::NMCUSTOMTEXT { hdr, hDC, lpString, nCount, lpRect, uFormat, fLink }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMCUSTOMTEXT) -> Self {
        let windows_sys::Win32::UI::Controls::NMCUSTOMTEXT { hdr, hDC, lpString, nCount, lpRect, uFormat, fLink } = win32;
        let hdr = unsafe { NMHDR::from_win32(hdr) };
        let h_dc = unsafe { Hdc::new_optional(hDC) };
        let slen = unsafe { wide_strlen(lpString as *const u16) };
        let lpString = unsafe { slice::from_raw_parts(lpString, slen + 1) };
        let lp_string = lpString.to_vec();
        let n_count = nCount;
        let lp_rect = unsafe { &mut *(lpRect as *mut _ as *mut _) };
        let u_format = uFormat;
        let f_link = fLink;
        Self { hdr, h_dc, lp_string, n_count, lp_rect, u_format, f_link }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmdatetimechange {
    pub nmhdr: Nmhdr,
    pub dw_flags: u32,
    pub st: Systemtime,
}
impl Nmdatetimechange {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMDATETIMECHANGE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMDATETIMECHANGE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmdatetimeformata<'a> {
    pub nmhdr: Nmhdr,
    pub psz_format: Cow<'a, CStr>,
    pub st: Systemtime,
    pub psz_display: Cow<'a, CStr>,
    pub sz_display: [CHAR; 64],
}
impl Nmdatetimeformata {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMDATETIMEFORMATA {
        let Self { nmhdr, psz_format, st, psz_display, sz_display } = self;
        let nmhdr = nmhdr.to_win32();
        let pszFormat = psz_format.as_ptr();
        let st = st.to_win32();
        let pszDisplay = psz_display.as_ptr();
        let szDisplay = [sz_display[0],sz_display[1],sz_display[2],sz_display[3],sz_display[4],sz_display[5],sz_display[6],sz_display[7],sz_display[8],sz_display[9],sz_display[10],sz_display[11],sz_display[12],sz_display[13],sz_display[14],sz_display[15],sz_display[16],sz_display[17],sz_display[18],sz_display[19],sz_display[20],sz_display[21],sz_display[22],sz_display[23],sz_display[24],sz_display[25],sz_display[26],sz_display[27],sz_display[28],sz_display[29],sz_display[30],sz_display[31],sz_display[32],sz_display[33],sz_display[34],sz_display[35],sz_display[36],sz_display[37],sz_display[38],sz_display[39],sz_display[40],sz_display[41],sz_display[42],sz_display[43],sz_display[44],sz_display[45],sz_display[46],sz_display[47],sz_display[48],sz_display[49],sz_display[50],sz_display[51],sz_display[52],sz_display[53],sz_display[54],sz_display[55],sz_display[56],sz_display[57],sz_display[58],sz_display[59],sz_display[60],sz_display[61],sz_display[62],sz_display[63]];
        windows_sys::Win32::UI::Controls::NMDATETIMEFORMATA { nmhdr, pszFormat, st, pszDisplay, szDisplay }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMDATETIMEFORMATA) -> Self {
        let windows_sys::Win32::UI::Controls::NMDATETIMEFORMATA { nmhdr, pszFormat, st, pszDisplay, szDisplay } = win32;
        let nmhdr = unsafe { NMHDR::from_win32(nmhdr) };
        let pszFormat = unsafe { CStr::from_ptr(pszFormat) };
        let pszFormat = pszFormat.to_bytes_with_nul().to_vec();
        let psz_format = Cow::Owned(unsafe { CString::from_vec_unchecked(pszFormat) });
        let st = unsafe { SYSTEMTIME::from_win32(st) };
        let pszDisplay = unsafe { CStr::from_ptr(pszDisplay) };
        let pszDisplay = pszDisplay.to_bytes_with_nul().to_vec();
        let psz_display = Cow::Owned(unsafe { CString::from_vec_unchecked(pszDisplay) });
        let sz_display = [szDisplay[0],szDisplay[1],szDisplay[2],szDisplay[3],szDisplay[4],szDisplay[5],szDisplay[6],szDisplay[7],szDisplay[8],szDisplay[9],szDisplay[10],szDisplay[11],szDisplay[12],szDisplay[13],szDisplay[14],szDisplay[15],szDisplay[16],szDisplay[17],szDisplay[18],szDisplay[19],szDisplay[20],szDisplay[21],szDisplay[22],szDisplay[23],szDisplay[24],szDisplay[25],szDisplay[26],szDisplay[27],szDisplay[28],szDisplay[29],szDisplay[30],szDisplay[31],szDisplay[32],szDisplay[33],szDisplay[34],szDisplay[35],szDisplay[36],szDisplay[37],szDisplay[38],szDisplay[39],szDisplay[40],szDisplay[41],szDisplay[42],szDisplay[43],szDisplay[44],szDisplay[45],szDisplay[46],szDisplay[47],szDisplay[48],szDisplay[49],szDisplay[50],szDisplay[51],szDisplay[52],szDisplay[53],szDisplay[54],szDisplay[55],szDisplay[56],szDisplay[57],szDisplay[58],szDisplay[59],szDisplay[60],szDisplay[61],szDisplay[62],szDisplay[63]];
        Self { nmhdr, psz_format, st, psz_display, sz_display }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmdatetimeformatquerya<'a> {
    pub nmhdr: Nmhdr,
    pub psz_format: Cow<'a, CStr>,
    pub sz_max: Size,
}
impl Nmdatetimeformatquerya {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMDATETIMEFORMATQUERYA {
        let Self { nmhdr, psz_format, sz_max } = self;
        let nmhdr = nmhdr.to_win32();
        let pszFormat = psz_format.as_ptr();
        let szMax = sz_max.to_win32();
        windows_sys::Win32::UI::Controls::NMDATETIMEFORMATQUERYA { nmhdr, pszFormat, szMax }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMDATETIMEFORMATQUERYA) -> Self {
        let windows_sys::Win32::UI::Controls::NMDATETIMEFORMATQUERYA { nmhdr, pszFormat, szMax } = win32;
        let nmhdr = unsafe { NMHDR::from_win32(nmhdr) };
        let pszFormat = unsafe { CStr::from_ptr(pszFormat) };
        let pszFormat = pszFormat.to_bytes_with_nul().to_vec();
        let psz_format = Cow::Owned(unsafe { CString::from_vec_unchecked(pszFormat) });
        let sz_max = unsafe { SIZE::from_win32(szMax) };
        Self { nmhdr, psz_format, sz_max }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmdatetimeformatqueryw<'a> {
    pub nmhdr: Nmhdr,
    pub psz_format: Cow<'a, [u16]>,
    pub sz_max: Size,
}
impl Nmdatetimeformatqueryw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMDATETIMEFORMATQUERYW {
        let Self { nmhdr, psz_format, sz_max } = self;
        let nmhdr = nmhdr.to_win32();
        assert_eq!(psz_format.last(), Some(0));
        let pszFormat = psz_format.as_ptr();
        let szMax = sz_max.to_win32();
        windows_sys::Win32::UI::Controls::NMDATETIMEFORMATQUERYW { nmhdr, pszFormat, szMax }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMDATETIMEFORMATQUERYW) -> Self {
        let windows_sys::Win32::UI::Controls::NMDATETIMEFORMATQUERYW { nmhdr, pszFormat, szMax } = win32;
        let nmhdr = unsafe { NMHDR::from_win32(nmhdr) };
        let slen = unsafe { wide_strlen(pszFormat as *const u16) };
        let pszFormat = unsafe { slice::from_raw_parts(pszFormat, slen + 1) };
        let psz_format = pszFormat.to_vec();
        let sz_max = unsafe { SIZE::from_win32(szMax) };
        Self { nmhdr, psz_format, sz_max }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmdatetimeformatw<'a> {
    pub nmhdr: Nmhdr,
    pub psz_format: Cow<'a, [u16]>,
    pub st: Systemtime,
    pub psz_display: Cow<'a, [u16]>,
    pub sz_display: [u8; 64],
}
impl Nmdatetimeformatw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMDATETIMEFORMATW {
        let Self { nmhdr, psz_format, st, psz_display, sz_display } = self;
        let nmhdr = nmhdr.to_win32();
        assert_eq!(psz_format.last(), Some(0));
        let pszFormat = psz_format.as_ptr();
        let st = st.to_win32();
        assert_eq!(psz_display.last(), Some(0));
        let pszDisplay = psz_display.as_ptr();
        let szDisplay = [*sz_display[0],*sz_display[1],*sz_display[2],*sz_display[3],*sz_display[4],*sz_display[5],*sz_display[6],*sz_display[7],*sz_display[8],*sz_display[9],*sz_display[10],*sz_display[11],*sz_display[12],*sz_display[13],*sz_display[14],*sz_display[15],*sz_display[16],*sz_display[17],*sz_display[18],*sz_display[19],*sz_display[20],*sz_display[21],*sz_display[22],*sz_display[23],*sz_display[24],*sz_display[25],*sz_display[26],*sz_display[27],*sz_display[28],*sz_display[29],*sz_display[30],*sz_display[31],*sz_display[32],*sz_display[33],*sz_display[34],*sz_display[35],*sz_display[36],*sz_display[37],*sz_display[38],*sz_display[39],*sz_display[40],*sz_display[41],*sz_display[42],*sz_display[43],*sz_display[44],*sz_display[45],*sz_display[46],*sz_display[47],*sz_display[48],*sz_display[49],*sz_display[50],*sz_display[51],*sz_display[52],*sz_display[53],*sz_display[54],*sz_display[55],*sz_display[56],*sz_display[57],*sz_display[58],*sz_display[59],*sz_display[60],*sz_display[61],*sz_display[62],*sz_display[63]];
        windows_sys::Win32::UI::Controls::NMDATETIMEFORMATW { nmhdr, pszFormat, st, pszDisplay, szDisplay }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMDATETIMEFORMATW) -> Self {
        let windows_sys::Win32::UI::Controls::NMDATETIMEFORMATW { nmhdr, pszFormat, st, pszDisplay, szDisplay } = win32;
        let nmhdr = unsafe { NMHDR::from_win32(nmhdr) };
        let slen = unsafe { wide_strlen(pszFormat as *const u16) };
        let pszFormat = unsafe { slice::from_raw_parts(pszFormat, slen + 1) };
        let psz_format = pszFormat.to_vec();
        let st = unsafe { SYSTEMTIME::from_win32(st) };
        let slen = unsafe { wide_strlen(pszDisplay as *const u16) };
        let pszDisplay = unsafe { slice::from_raw_parts(pszDisplay, slen + 1) };
        let psz_display = pszDisplay.to_vec();
        let sz_display = [szDisplay[0],szDisplay[1],szDisplay[2],szDisplay[3],szDisplay[4],szDisplay[5],szDisplay[6],szDisplay[7],szDisplay[8],szDisplay[9],szDisplay[10],szDisplay[11],szDisplay[12],szDisplay[13],szDisplay[14],szDisplay[15],szDisplay[16],szDisplay[17],szDisplay[18],szDisplay[19],szDisplay[20],szDisplay[21],szDisplay[22],szDisplay[23],szDisplay[24],szDisplay[25],szDisplay[26],szDisplay[27],szDisplay[28],szDisplay[29],szDisplay[30],szDisplay[31],szDisplay[32],szDisplay[33],szDisplay[34],szDisplay[35],szDisplay[36],szDisplay[37],szDisplay[38],szDisplay[39],szDisplay[40],szDisplay[41],szDisplay[42],szDisplay[43],szDisplay[44],szDisplay[45],szDisplay[46],szDisplay[47],szDisplay[48],szDisplay[49],szDisplay[50],szDisplay[51],szDisplay[52],szDisplay[53],szDisplay[54],szDisplay[55],szDisplay[56],szDisplay[57],szDisplay[58],szDisplay[59],szDisplay[60],szDisplay[61],szDisplay[62],szDisplay[63]];
        Self { nmhdr, psz_format, st, psz_display, sz_display }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmdatetimestringa<'a> {
    pub nmhdr: Nmhdr,
    pub psz_user_string: Cow<'a, CStr>,
    pub st: Systemtime,
    pub dw_flags: u32,
}
impl Nmdatetimestringa {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMDATETIMESTRINGA {
        let Self { nmhdr, psz_user_string, st, dw_flags } = self;
        let nmhdr = nmhdr.to_win32();
        let pszUserString = psz_user_string.as_ptr();
        let st = st.to_win32();
        let dwFlags = *dw_flags;
        windows_sys::Win32::UI::Controls::NMDATETIMESTRINGA { nmhdr, pszUserString, st, dwFlags }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMDATETIMESTRINGA) -> Self {
        let windows_sys::Win32::UI::Controls::NMDATETIMESTRINGA { nmhdr, pszUserString, st, dwFlags } = win32;
        let nmhdr = unsafe { NMHDR::from_win32(nmhdr) };
        let pszUserString = unsafe { CStr::from_ptr(pszUserString) };
        let pszUserString = pszUserString.to_bytes_with_nul().to_vec();
        let psz_user_string = Cow::Owned(unsafe { CString::from_vec_unchecked(pszUserString) });
        let st = unsafe { SYSTEMTIME::from_win32(st) };
        let dw_flags = dwFlags;
        Self { nmhdr, psz_user_string, st, dw_flags }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmdatetimestringw<'a> {
    pub nmhdr: Nmhdr,
    pub psz_user_string: Cow<'a, [u16]>,
    pub st: Systemtime,
    pub dw_flags: u32,
}
impl Nmdatetimestringw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMDATETIMESTRINGW {
        let Self { nmhdr, psz_user_string, st, dw_flags } = self;
        let nmhdr = nmhdr.to_win32();
        assert_eq!(psz_user_string.last(), Some(0));
        let pszUserString = psz_user_string.as_ptr();
        let st = st.to_win32();
        let dwFlags = *dw_flags;
        windows_sys::Win32::UI::Controls::NMDATETIMESTRINGW { nmhdr, pszUserString, st, dwFlags }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMDATETIMESTRINGW) -> Self {
        let windows_sys::Win32::UI::Controls::NMDATETIMESTRINGW { nmhdr, pszUserString, st, dwFlags } = win32;
        let nmhdr = unsafe { NMHDR::from_win32(nmhdr) };
        let slen = unsafe { wide_strlen(pszUserString as *const u16) };
        let pszUserString = unsafe { slice::from_raw_parts(pszUserString, slen + 1) };
        let psz_user_string = pszUserString.to_vec();
        let st = unsafe { SYSTEMTIME::from_win32(st) };
        let dw_flags = dwFlags;
        Self { nmhdr, psz_user_string, st, dw_flags }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmdatetimewmkeydowna<'a> {
    pub nmhdr: Nmhdr,
    pub n_virt_key: i32,
    pub psz_format: Cow<'a, CStr>,
    pub st: Systemtime,
}
impl Nmdatetimewmkeydowna {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMDATETIMEWMKEYDOWNA {
        let Self { nmhdr, n_virt_key, psz_format, st } = self;
        let nmhdr = nmhdr.to_win32();
        let nVirtKey = *n_virt_key;
        let pszFormat = psz_format.as_ptr();
        let st = st.to_win32();
        windows_sys::Win32::UI::Controls::NMDATETIMEWMKEYDOWNA { nmhdr, nVirtKey, pszFormat, st }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMDATETIMEWMKEYDOWNA) -> Self {
        let windows_sys::Win32::UI::Controls::NMDATETIMEWMKEYDOWNA { nmhdr, nVirtKey, pszFormat, st } = win32;
        let nmhdr = unsafe { NMHDR::from_win32(nmhdr) };
        let n_virt_key = nVirtKey;
        let pszFormat = unsafe { CStr::from_ptr(pszFormat) };
        let pszFormat = pszFormat.to_bytes_with_nul().to_vec();
        let psz_format = Cow::Owned(unsafe { CString::from_vec_unchecked(pszFormat) });
        let st = unsafe { SYSTEMTIME::from_win32(st) };
        Self { nmhdr, n_virt_key, psz_format, st }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmdatetimewmkeydownw<'a> {
    pub nmhdr: Nmhdr,
    pub n_virt_key: i32,
    pub psz_format: Cow<'a, [u16]>,
    pub st: Systemtime,
}
impl Nmdatetimewmkeydownw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMDATETIMEWMKEYDOWNW {
        let Self { nmhdr, n_virt_key, psz_format, st } = self;
        let nmhdr = nmhdr.to_win32();
        let nVirtKey = *n_virt_key;
        assert_eq!(psz_format.last(), Some(0));
        let pszFormat = psz_format.as_ptr();
        let st = st.to_win32();
        windows_sys::Win32::UI::Controls::NMDATETIMEWMKEYDOWNW { nmhdr, nVirtKey, pszFormat, st }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMDATETIMEWMKEYDOWNW) -> Self {
        let windows_sys::Win32::UI::Controls::NMDATETIMEWMKEYDOWNW { nmhdr, nVirtKey, pszFormat, st } = win32;
        let nmhdr = unsafe { NMHDR::from_win32(nmhdr) };
        let n_virt_key = nVirtKey;
        let slen = unsafe { wide_strlen(pszFormat as *const u16) };
        let pszFormat = unsafe { slice::from_raw_parts(pszFormat, slen + 1) };
        let psz_format = pszFormat.to_vec();
        let st = unsafe { SYSTEMTIME::from_win32(st) };
        Self { nmhdr, n_virt_key, psz_format, st }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmdaystate<'a> {
    pub nmhdr: Nmhdr,
    pub st_start: Systemtime,
    pub c_day_state: i32,
    pub prg_day_state: &'a mut u32,
}
impl Nmdaystate {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMDAYSTATE {
        let Self { nmhdr, st_start, c_day_state, prg_day_state } = self;
        let nmhdr = nmhdr.to_win32();
        let stStart = st_start.to_win32();
        let cDayState = *c_day_state;
        let prgDayState = unsafe { &mut *(prg_day_state as *mut _ as *mut _) };
        windows_sys::Win32::UI::Controls::NMDAYSTATE { nmhdr, stStart, cDayState, prgDayState }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMDAYSTATE) -> Self {
        let windows_sys::Win32::UI::Controls::NMDAYSTATE { nmhdr, stStart, cDayState, prgDayState } = win32;
        let nmhdr = unsafe { NMHDR::from_win32(nmhdr) };
        let st_start = unsafe { SYSTEMTIME::from_win32(stStart) };
        let c_day_state = cDayState;
        let prg_day_state = unsafe { &mut *(prgDayState as *mut _ as *mut _) };
        Self { nmhdr, st_start, c_day_state, prg_day_state }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmhddispinfoa<'a> {
    pub hdr: Nmhdr,
    pub i_item: i32,
    pub mask: u32,
    pub psz_text: Cow<'a, CStr>,
    pub cch_text_max: i32,
    pub i_image: i32,
    pub l_param: Lparam,
}
impl Nmhddispinfoa {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMHDDISPINFOA {
        let Self { hdr, i_item, mask, psz_text, cch_text_max, i_image, l_param } = self;
        let hdr = hdr.to_win32();
        let iItem = *i_item;
        let mask = mask;
        let pszText = psz_text.as_ptr();
        let cchTextMax = *cch_text_max;
        let iImage = *i_image;
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::Controls::NMHDDISPINFOA { hdr, iItem, mask, pszText, cchTextMax, iImage, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMHDDISPINFOA) -> Self {
        let windows_sys::Win32::UI::Controls::NMHDDISPINFOA { hdr, iItem, mask, pszText, cchTextMax, iImage, lParam } = win32;
        let hdr = unsafe { NMHDR::from_win32(hdr) };
        let i_item = iItem;
        let mask = mask;
        let pszText = unsafe { CStr::from_ptr(pszText) };
        let pszText = pszText.to_bytes_with_nul().to_vec();
        let psz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(pszText) });
        let cch_text_max = cchTextMax;
        let i_image = iImage;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { hdr, i_item, mask, psz_text, cch_text_max, i_image, l_param }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmhddispinfow<'a> {
    pub hdr: Nmhdr,
    pub i_item: i32,
    pub mask: u32,
    pub psz_text: Cow<'a, [u16]>,
    pub cch_text_max: i32,
    pub i_image: i32,
    pub l_param: Lparam,
}
impl Nmhddispinfow {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMHDDISPINFOW {
        let Self { hdr, i_item, mask, psz_text, cch_text_max, i_image, l_param } = self;
        let hdr = hdr.to_win32();
        let iItem = *i_item;
        let mask = mask;
        assert_eq!(psz_text.last(), Some(0));
        let pszText = psz_text.as_ptr();
        let cchTextMax = *cch_text_max;
        let iImage = *i_image;
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::Controls::NMHDDISPINFOW { hdr, iItem, mask, pszText, cchTextMax, iImage, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMHDDISPINFOW) -> Self {
        let windows_sys::Win32::UI::Controls::NMHDDISPINFOW { hdr, iItem, mask, pszText, cchTextMax, iImage, lParam } = win32;
        let hdr = unsafe { NMHDR::from_win32(hdr) };
        let i_item = iItem;
        let mask = mask;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = pszText.to_vec();
        let cch_text_max = cchTextMax;
        let i_image = iImage;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { hdr, i_item, mask, psz_text, cch_text_max, i_image, l_param }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmhdfilterbtnclick {
    pub hdr: Nmhdr,
    pub i_item: i32,
    pub rc: Rect,
}
impl Nmhdfilterbtnclick {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMHDFILTERBTNCLICK {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMHDFILTERBTNCLICK) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmhdr {
    pub hwnd_from: Option<Hwnd>,
    pub id_from: usize,
    pub code: u32,
}
impl Nmhdr {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMHDR {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMHDR) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmipaddress {
    pub hdr: Nmhdr,
    pub i_field: i32,
    pub i_value: i32,
}
impl Nmipaddress {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMIPADDRESS {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMIPADDRESS) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmitemactivate {
    pub hdr: Nmhdr,
    pub i_item: i32,
    pub i_sub_item: i32,
    pub u_new_state: u32,
    pub u_old_state: u32,
    pub u_changed: u32,
    pub pt_action: Point,
    pub l_param: Lparam,
    pub u_key_flags: u32,
}
impl Nmitemactivate {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMITEMACTIVATE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMITEMACTIVATE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmkey {
    pub hdr: Nmhdr,
    pub n_v_key: u32,
    pub u_flags: u32,
}
impl Nmkey {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMKEY {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMKEY) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlink {
    pub hdr: Nmhdr,
    pub item: Litem,
}
impl Nmlink {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLINK {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLINK) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlistview {
    pub hdr: Nmhdr,
    pub i_item: i32,
    pub i_sub_item: i32,
    pub u_new_state: u32,
    pub u_old_state: u32,
    pub u_changed: u32,
    pub pt_action: Point,
    pub l_param: Lparam,
}
impl Nmlistview {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLISTVIEW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLISTVIEW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlvcachehint {
    pub hdr: Nmhdr,
    pub i_from: i32,
    pub i_to: i32,
}
impl Nmlvcachehint {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVCACHEHINT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVCACHEHINT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlvcustomdraw {
    pub nmcd: Nmcustomdraw,
    pub clr_text: u32,
    pub clr_text_bk: u32,
    pub i_sub_item: i32,
    pub dw_item_type: u32,
    pub clr_face: u32,
    pub i_icon_effect: i32,
    pub i_icon_phase: i32,
    pub i_part_id: i32,
    pub i_state_id: i32,
    pub rc_text: Rect,
    pub u_align: u32,
}
impl Nmlvcustomdraw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVCUSTOMDRAW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVCUSTOMDRAW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const LVGA_HEADER_CENTER: u32 = 0x2;
pub const LVGA_HEADER_LEFT: u32 = 0x1;
pub const LVGA_HEADER_RIGHT: u32 = 0x4;
pub const LVCDI_ITEM: u32 = 0x0;
pub const LVCDI_GROUP: u32 = 0x1;
pub const LVCDI_ITEMSLIST: u32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlvdispinfoa<'a> {
    pub hdr: Nmhdr,
    pub item: Lvitema<'a>,
}
impl Nmlvdispinfoa {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVDISPINFOA {
        let Self { hdr, item } = self;
        let hdr = hdr.to_win32();
        let item = item.to_win32();
        windows_sys::Win32::UI::Controls::NMLVDISPINFOA { hdr, item }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVDISPINFOA) -> Self {
        let windows_sys::Win32::UI::Controls::NMLVDISPINFOA { hdr, item } = win32;
        let hdr = unsafe { NMHDR::from_win32(hdr) };
        let item = unsafe { LVITEMA::from_win32(item) };
        Self { hdr, item }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlvdispinfow<'a> {
    pub hdr: Nmhdr,
    pub item: Lvitemw<'a>,
}
impl Nmlvdispinfow {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVDISPINFOW {
        let Self { hdr, item } = self;
        let hdr = hdr.to_win32();
        let item = item.to_win32();
        windows_sys::Win32::UI::Controls::NMLVDISPINFOW { hdr, item }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVDISPINFOW) -> Self {
        let windows_sys::Win32::UI::Controls::NMLVDISPINFOW { hdr, item } = win32;
        let hdr = unsafe { NMHDR::from_win32(hdr) };
        let item = unsafe { LVITEMW::from_win32(item) };
        Self { hdr, item }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlvemptymarkup {
    pub hdr: Nmhdr,
    pub dw_flags: u32,
    pub sz_markup: [u8; 2084],
}
impl Nmlvemptymarkup {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVEMPTYMARKUP {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVEMPTYMARKUP) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const EMF_CENTERED: u32 = 0x1;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlvfinditema<'a> {
    pub hdr: Nmhdr,
    pub i_start: i32,
    pub lvfi: Lvfindinfoa<'a>,
}
impl Nmlvfinditema {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVFINDITEMA {
        let Self { hdr, i_start, lvfi } = self;
        let hdr = hdr.to_win32();
        let iStart = *i_start;
        let lvfi = lvfi.to_win32();
        windows_sys::Win32::UI::Controls::NMLVFINDITEMA { hdr, iStart, lvfi }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVFINDITEMA) -> Self {
        let windows_sys::Win32::UI::Controls::NMLVFINDITEMA { hdr, iStart, lvfi } = win32;
        let hdr = unsafe { NMHDR::from_win32(hdr) };
        let i_start = iStart;
        let lvfi = unsafe { LVFINDINFOA::from_win32(lvfi) };
        Self { hdr, i_start, lvfi }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlvfinditemw<'a> {
    pub hdr: Nmhdr,
    pub i_start: i32,
    pub lvfi: Lvfindinfow<'a>,
}
impl Nmlvfinditemw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVFINDITEMW {
        let Self { hdr, i_start, lvfi } = self;
        let hdr = hdr.to_win32();
        let iStart = *i_start;
        let lvfi = lvfi.to_win32();
        windows_sys::Win32::UI::Controls::NMLVFINDITEMW { hdr, iStart, lvfi }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVFINDITEMW) -> Self {
        let windows_sys::Win32::UI::Controls::NMLVFINDITEMW { hdr, iStart, lvfi } = win32;
        let hdr = unsafe { NMHDR::from_win32(hdr) };
        let i_start = iStart;
        let lvfi = unsafe { LVFINDINFOW::from_win32(lvfi) };
        Self { hdr, i_start, lvfi }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlvgetinfotipa<'a> {
    pub hdr: Nmhdr,
    pub dw_flags: u32,
    pub psz_text: Cow<'a, CStr>,
    pub cch_text_max: i32,
    pub i_item: i32,
    pub i_sub_item: i32,
    pub l_param: Lparam,
}
impl Nmlvgetinfotipa {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVGETINFOTIPA {
        let Self { hdr, dw_flags, psz_text, cch_text_max, i_item, i_sub_item, l_param } = self;
        let hdr = hdr.to_win32();
        let dwFlags = *dw_flags;
        let pszText = psz_text.as_ptr();
        let cchTextMax = *cch_text_max;
        let iItem = *i_item;
        let iSubItem = *i_sub_item;
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::Controls::NMLVGETINFOTIPA { hdr, dwFlags, pszText, cchTextMax, iItem, iSubItem, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVGETINFOTIPA) -> Self {
        let windows_sys::Win32::UI::Controls::NMLVGETINFOTIPA { hdr, dwFlags, pszText, cchTextMax, iItem, iSubItem, lParam } = win32;
        let hdr = unsafe { NMHDR::from_win32(hdr) };
        let dw_flags = dwFlags;
        let pszText = unsafe { CStr::from_ptr(pszText) };
        let pszText = pszText.to_bytes_with_nul().to_vec();
        let psz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(pszText) });
        let cch_text_max = cchTextMax;
        let i_item = iItem;
        let i_sub_item = iSubItem;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { hdr, dw_flags, psz_text, cch_text_max, i_item, i_sub_item, l_param }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlvgetinfotipw<'a> {
    pub hdr: Nmhdr,
    pub dw_flags: u32,
    pub psz_text: Cow<'a, [u16]>,
    pub cch_text_max: i32,
    pub i_item: i32,
    pub i_sub_item: i32,
    pub l_param: Lparam,
}
impl Nmlvgetinfotipw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVGETINFOTIPW {
        let Self { hdr, dw_flags, psz_text, cch_text_max, i_item, i_sub_item, l_param } = self;
        let hdr = hdr.to_win32();
        let dwFlags = *dw_flags;
        assert_eq!(psz_text.last(), Some(0));
        let pszText = psz_text.as_ptr();
        let cchTextMax = *cch_text_max;
        let iItem = *i_item;
        let iSubItem = *i_sub_item;
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::Controls::NMLVGETINFOTIPW { hdr, dwFlags, pszText, cchTextMax, iItem, iSubItem, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVGETINFOTIPW) -> Self {
        let windows_sys::Win32::UI::Controls::NMLVGETINFOTIPW { hdr, dwFlags, pszText, cchTextMax, iItem, iSubItem, lParam } = win32;
        let hdr = unsafe { NMHDR::from_win32(hdr) };
        let dw_flags = dwFlags;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = pszText.to_vec();
        let cch_text_max = cchTextMax;
        let i_item = iItem;
        let i_sub_item = iSubItem;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { hdr, dw_flags, psz_text, cch_text_max, i_item, i_sub_item, l_param }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Nmlvkeydown {
    pub hdr: Nmhdr,
    pub w_v_key: u16,
    pub flags: u32,
}
impl Nmlvkeydown {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVKEYDOWN {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVKEYDOWN) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlvlink {
    pub hdr: Nmhdr,
    pub link: Litem,
    pub i_item: i32,
    pub i_sub_item: i32,
}
impl Nmlvlink {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVLINK {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVLINK) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlvodstatechange {
    pub hdr: Nmhdr,
    pub i_from: i32,
    pub i_to: i32,
    pub u_new_state: u32,
    pub u_old_state: u32,
}
impl Nmlvodstatechange {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVODSTATECHANGE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVODSTATECHANGE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlvscroll {
    pub hdr: Nmhdr,
    pub dx: i32,
    pub dy: i32,
}
impl Nmlvscroll {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVSCROLL {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVSCROLL) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmmouse {
    pub hdr: Nmhdr,
    pub dw_item_spec: usize,
    pub dw_item_data: usize,
    pub pt: Point,
    pub dw_hit_info: Lparam,
}
impl Nmmouse {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMMOUSE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMMOUSE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
//  Not generated due to containing a void type
//  #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Nmobjectnotify<'a> {
//      pub hdr: Nmhdr,
//      pub i_item: i32,
//      pub piid: Cow<'a, GUID>,
//      pub p_object: &'a mut todo_void,
//      pub h_result: HRESULT,
//      pub dw_flags: u32,
//  }
//  impl Nmobjectnotify {
//      fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMOBJECTNOTIFY {
//          let Self { hdr, i_item, piid, p_object, h_result, dw_flags } = self;
//          let hdr = hdr.to_win32();
//          let iItem = *i_item;
//          let piid = unsafe { &*(&**piid as *const _ as *const _) };
//          let pObject = unsafe { &mut *(p_object as *mut _ as *mut _) };
//          let hResult = *h_result;
//          let dwFlags = *dw_flags;
//          windows_sys::Win32::UI::Controls::NMOBJECTNOTIFY { hdr, iItem, piid, pObject, hResult, dwFlags }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMOBJECTNOTIFY) -> Self {
//          let windows_sys::Win32::UI::Controls::NMOBJECTNOTIFY { hdr, iItem, piid, pObject, hResult, dwFlags } = win32;
//          let hdr = unsafe { NMHDR::from_win32(hdr) };
//          let i_item = iItem;
//          let piid = Cow::Borrowed(unsafe { &*(piid as *const _ as *const _) });
//          let p_object = unsafe { &mut *(pObject as *mut _ as *mut _) };
//          let h_result = hResult;
//          let dw_flags = dwFlags;
//          Self { hdr, i_item, piid, p_object, h_result, dw_flags }
//      }
//  }
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmpgcalcsize {
    pub hdr: Nmhdr,
    pub dw_flag: u32,
    pub i_width: i32,
    pub i_height: i32,
}
impl Nmpgcalcsize {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMPGCALCSIZE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMPGCALCSIZE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const PGF_CALCHEIGHT: u32 = 0x2;
pub const PGF_CALCWIDTH: u32 = 0x1;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmpghotitem {
    pub hdr: Nmhdr,
    pub id_old: i32,
    pub id_new: i32,
    pub dw_flags: u32,
}
impl Nmpghotitem {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMPGHOTITEM {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMPGHOTITEM) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Nmpgscroll {
    pub hdr: Nmhdr,
    pub fw_keys: u16,
    pub rc_parent: Rect,
    pub i_dir: u32,
    pub i_xpos: i32,
    pub i_ypos: i32,
    pub i_scroll: i32,
}
impl Nmpgscroll {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMPGSCROLL {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMPGSCROLL) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const PGF_SCROLLDOWN: u32 = 0x2;
pub const PGF_SCROLLLEFT: u32 = 0x4;
pub const PGF_SCROLLRIGHT: u32 = 0x8;
pub const PGF_SCROLLUP: u32 = 0x1;
pub const PGK_NONE: u16 = 0x0;
pub const PGK_SHIFT: u16 = 0x1;
pub const PGK_CONTROL: u16 = 0x2;
pub const PGK_MENU: u16 = 0x4;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmrbautosize {
    pub hdr: Nmhdr,
    pub f_changed: BOOL,
    pub rc_target: Rect,
    pub rc_actual: Rect,
}
impl Nmrbautosize {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMRBAUTOSIZE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMRBAUTOSIZE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmrebar {
    pub hdr: Nmhdr,
    pub dw_mask: u32,
    pub u_band: u32,
    pub f_style: u32,
    pub w_id: u32,
    pub l_param: Lparam,
}
impl Nmrebar {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMREBAR {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMREBAR) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmrebarautobreak {
    pub hdr: Nmhdr,
    pub u_band: u32,
    pub w_id: u32,
    pub l_param: Lparam,
    pub u_msg: u32,
    pub f_style_current: u32,
    pub f_auto_break: BOOL,
}
impl Nmrebarautobreak {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMREBARAUTOBREAK {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMREBARAUTOBREAK) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmrebarchevron {
    pub hdr: Nmhdr,
    pub u_band: u32,
    pub w_id: u32,
    pub l_param: Lparam,
    pub rc: Rect,
    pub l_param_nm: Lparam,
}
impl Nmrebarchevron {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMREBARCHEVRON {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMREBARCHEVRON) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmrebarchildsize {
    pub hdr: Nmhdr,
    pub u_band: u32,
    pub w_id: u32,
    pub rc_child: Rect,
    pub rc_band: Rect,
}
impl Nmrebarchildsize {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMREBARCHILDSIZE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMREBARCHILDSIZE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmrebarsplitter {
    pub hdr: Nmhdr,
    pub rc_sizing: Rect,
}
impl Nmrebarsplitter {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMREBARSPLITTER {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMREBARSPLITTER) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const RBNM_ID: u32 = 0x1;
pub const RBNM_LPARAM: u32 = 0x4;
pub const RBNM_STYLE: u32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmsearchweb {
    pub hdr: Nmhdr,
    pub entrypoint: i32,
    pub has_query_text: BOOL,
    pub invoke_succeeded: BOOL,
}
impl Nmsearchweb {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMSEARCHWEB {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMSEARCHWEB) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmselchange {
    pub nmhdr: Nmhdr,
    pub st_sel_start: Systemtime,
    pub st_sel_end: Systemtime,
}
impl Nmselchange {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMSELCHANGE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMSELCHANGE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmupdown {
    pub hdr: Nmhdr,
    pub i_pos: i32,
    pub i_delta: i32,
}
impl Nmupdown {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMUPDOWN {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMUPDOWN) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmviewchange {
    pub nmhdr: Nmhdr,
    pub dw_old_view: u32,
    pub dw_new_view: u32,
}
impl Nmviewchange {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMVIEWCHANGE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMVIEWCHANGE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nonclientmetricsa {
    pub cb_size: u32,
    pub i_border_width: i32,
    pub i_scroll_width: i32,
    pub i_scroll_height: i32,
    pub i_caption_width: i32,
    pub i_caption_height: i32,
    pub lf_caption_font: Logfonta,
    pub i_sm_caption_width: i32,
    pub i_sm_caption_height: i32,
    pub lf_sm_caption_font: Logfonta,
    pub i_menu_width: i32,
    pub i_menu_height: i32,
    pub lf_menu_font: Logfonta,
    pub lf_status_font: Logfonta,
    pub lf_message_font: Logfonta,
    pub i_padded_border_width: i32,
}
impl Nonclientmetricsa {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::NONCLIENTMETRICSA {
        let Self { cb_size, i_border_width, i_scroll_width, i_scroll_height, i_caption_width, i_caption_height, lf_caption_font, i_sm_caption_width, i_sm_caption_height, lf_sm_caption_font, i_menu_width, i_menu_height, lf_menu_font, lf_status_font, lf_message_font, i_padded_border_width } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::NONCLIENTMETRICSA>() as _;
        let iBorderWidth = *i_border_width;
        let iScrollWidth = *i_scroll_width;
        let iScrollHeight = *i_scroll_height;
        let iCaptionWidth = *i_caption_width;
        let iCaptionHeight = *i_caption_height;
        let lfCaptionFont = lf_caption_font.to_win32();
        let iSmCaptionWidth = *i_sm_caption_width;
        let iSmCaptionHeight = *i_sm_caption_height;
        let lfSmCaptionFont = lf_sm_caption_font.to_win32();
        let iMenuWidth = *i_menu_width;
        let iMenuHeight = *i_menu_height;
        let lfMenuFont = lf_menu_font.to_win32();
        let lfStatusFont = lf_status_font.to_win32();
        let lfMessageFont = lf_message_font.to_win32();
        let iPaddedBorderWidth = *i_padded_border_width;
        windows_sys::Win32::UI::WindowsAndMessaging::NONCLIENTMETRICSA { cbSize, iBorderWidth, iScrollWidth, iScrollHeight, iCaptionWidth, iCaptionHeight, lfCaptionFont, iSmCaptionWidth, iSmCaptionHeight, lfSmCaptionFont, iMenuWidth, iMenuHeight, lfMenuFont, lfStatusFont, lfMessageFont, iPaddedBorderWidth }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::NONCLIENTMETRICSA) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::NONCLIENTMETRICSA { cbSize, iBorderWidth, iScrollWidth, iScrollHeight, iCaptionWidth, iCaptionHeight, lfCaptionFont, iSmCaptionWidth, iSmCaptionHeight, lfSmCaptionFont, iMenuWidth, iMenuHeight, lfMenuFont, lfStatusFont, lfMessageFont, iPaddedBorderWidth } = win32;
        let cb_size = cbSize;
        let i_border_width = iBorderWidth;
        let i_scroll_width = iScrollWidth;
        let i_scroll_height = iScrollHeight;
        let i_caption_width = iCaptionWidth;
        let i_caption_height = iCaptionHeight;
        let lf_caption_font = unsafe { LOGFONTA::from_win32(lfCaptionFont) };
        let i_sm_caption_width = iSmCaptionWidth;
        let i_sm_caption_height = iSmCaptionHeight;
        let lf_sm_caption_font = unsafe { LOGFONTA::from_win32(lfSmCaptionFont) };
        let i_menu_width = iMenuWidth;
        let i_menu_height = iMenuHeight;
        let lf_menu_font = unsafe { LOGFONTA::from_win32(lfMenuFont) };
        let lf_status_font = unsafe { LOGFONTA::from_win32(lfStatusFont) };
        let lf_message_font = unsafe { LOGFONTA::from_win32(lfMessageFont) };
        let i_padded_border_width = iPaddedBorderWidth;
        Self { cb_size, i_border_width, i_scroll_width, i_scroll_height, i_caption_width, i_caption_height, lf_caption_font, i_sm_caption_width, i_sm_caption_height, lf_sm_caption_font, i_menu_width, i_menu_height, lf_menu_font, lf_status_font, lf_message_font, i_padded_border_width }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nonclientmetricsw {
    pub cb_size: u32,
    pub i_border_width: i32,
    pub i_scroll_width: i32,
    pub i_scroll_height: i32,
    pub i_caption_width: i32,
    pub i_caption_height: i32,
    pub lf_caption_font: Logfontw,
    pub i_sm_caption_width: i32,
    pub i_sm_caption_height: i32,
    pub lf_sm_caption_font: Logfontw,
    pub i_menu_width: i32,
    pub i_menu_height: i32,
    pub lf_menu_font: Logfontw,
    pub lf_status_font: Logfontw,
    pub lf_message_font: Logfontw,
    pub i_padded_border_width: i32,
}
impl Nonclientmetricsw {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::NONCLIENTMETRICSW {
        let Self { cb_size, i_border_width, i_scroll_width, i_scroll_height, i_caption_width, i_caption_height, lf_caption_font, i_sm_caption_width, i_sm_caption_height, lf_sm_caption_font, i_menu_width, i_menu_height, lf_menu_font, lf_status_font, lf_message_font, i_padded_border_width } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::NONCLIENTMETRICSW>() as _;
        let iBorderWidth = *i_border_width;
        let iScrollWidth = *i_scroll_width;
        let iScrollHeight = *i_scroll_height;
        let iCaptionWidth = *i_caption_width;
        let iCaptionHeight = *i_caption_height;
        let lfCaptionFont = lf_caption_font.to_win32();
        let iSmCaptionWidth = *i_sm_caption_width;
        let iSmCaptionHeight = *i_sm_caption_height;
        let lfSmCaptionFont = lf_sm_caption_font.to_win32();
        let iMenuWidth = *i_menu_width;
        let iMenuHeight = *i_menu_height;
        let lfMenuFont = lf_menu_font.to_win32();
        let lfStatusFont = lf_status_font.to_win32();
        let lfMessageFont = lf_message_font.to_win32();
        let iPaddedBorderWidth = *i_padded_border_width;
        windows_sys::Win32::UI::WindowsAndMessaging::NONCLIENTMETRICSW { cbSize, iBorderWidth, iScrollWidth, iScrollHeight, iCaptionWidth, iCaptionHeight, lfCaptionFont, iSmCaptionWidth, iSmCaptionHeight, lfSmCaptionFont, iMenuWidth, iMenuHeight, lfMenuFont, lfStatusFont, lfMessageFont, iPaddedBorderWidth }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::NONCLIENTMETRICSW) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::NONCLIENTMETRICSW { cbSize, iBorderWidth, iScrollWidth, iScrollHeight, iCaptionWidth, iCaptionHeight, lfCaptionFont, iSmCaptionWidth, iSmCaptionHeight, lfSmCaptionFont, iMenuWidth, iMenuHeight, lfMenuFont, lfStatusFont, lfMessageFont, iPaddedBorderWidth } = win32;
        let cb_size = cbSize;
        let i_border_width = iBorderWidth;
        let i_scroll_width = iScrollWidth;
        let i_scroll_height = iScrollHeight;
        let i_caption_width = iCaptionWidth;
        let i_caption_height = iCaptionHeight;
        let lf_caption_font = unsafe { LOGFONTW::from_win32(lfCaptionFont) };
        let i_sm_caption_width = iSmCaptionWidth;
        let i_sm_caption_height = iSmCaptionHeight;
        let lf_sm_caption_font = unsafe { LOGFONTW::from_win32(lfSmCaptionFont) };
        let i_menu_width = iMenuWidth;
        let i_menu_height = iMenuHeight;
        let lf_menu_font = unsafe { LOGFONTW::from_win32(lfMenuFont) };
        let lf_status_font = unsafe { LOGFONTW::from_win32(lfStatusFont) };
        let lf_message_font = unsafe { LOGFONTW::from_win32(lfMessageFont) };
        let i_padded_border_width = iPaddedBorderWidth;
        Self { cb_size, i_border_width, i_scroll_width, i_scroll_height, i_caption_width, i_caption_height, lf_caption_font, i_sm_caption_width, i_sm_caption_height, lf_sm_caption_font, i_menu_width, i_menu_height, lf_menu_font, lf_status_font, lf_message_font, i_padded_border_width }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Notifyicondataa {
    pub cb_size: u32,
    pub h_wnd: Option<Hwnd>,
    pub u_id: u32,
    pub u_flags: u32,
    pub u_callback_message: u32,
    pub h_icon: Option<Hicon>,
    pub sz_tip: [CHAR; 128],
    pub dw_state: u32,
    pub dw_state_mask: u32,
    pub sz_info: [CHAR; 256],
    pub anonymous: Notifyicondataa8,
    pub sz_info_title: [CHAR; 64],
    pub dw_info_flags: u32,
    pub guid_item: GUID,
    pub h_balloon_icon: Option<Hicon>,
}
impl Notifyicondataa {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::NOTIFYICONDATAA {
        let Self { cb_size, h_wnd, u_id, u_flags, u_callback_message, h_icon, sz_tip, dw_state, dw_state_mask, sz_info, anonymous, sz_info_title, dw_info_flags, guid_item, h_balloon_icon } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::NOTIFYICONDATAA>() as _;
        let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
        let uID = *u_id;
        let uFlags = u_flags;
        let uCallbackMessage = *u_callback_message;
        let hIcon = h_icon.map_or(0, Hicon::into_raw);
        let szTip = [sz_tip[0],sz_tip[1],sz_tip[2],sz_tip[3],sz_tip[4],sz_tip[5],sz_tip[6],sz_tip[7],sz_tip[8],sz_tip[9],sz_tip[10],sz_tip[11],sz_tip[12],sz_tip[13],sz_tip[14],sz_tip[15],sz_tip[16],sz_tip[17],sz_tip[18],sz_tip[19],sz_tip[20],sz_tip[21],sz_tip[22],sz_tip[23],sz_tip[24],sz_tip[25],sz_tip[26],sz_tip[27],sz_tip[28],sz_tip[29],sz_tip[30],sz_tip[31],sz_tip[32],sz_tip[33],sz_tip[34],sz_tip[35],sz_tip[36],sz_tip[37],sz_tip[38],sz_tip[39],sz_tip[40],sz_tip[41],sz_tip[42],sz_tip[43],sz_tip[44],sz_tip[45],sz_tip[46],sz_tip[47],sz_tip[48],sz_tip[49],sz_tip[50],sz_tip[51],sz_tip[52],sz_tip[53],sz_tip[54],sz_tip[55],sz_tip[56],sz_tip[57],sz_tip[58],sz_tip[59],sz_tip[60],sz_tip[61],sz_tip[62],sz_tip[63],sz_tip[64],sz_tip[65],sz_tip[66],sz_tip[67],sz_tip[68],sz_tip[69],sz_tip[70],sz_tip[71],sz_tip[72],sz_tip[73],sz_tip[74],sz_tip[75],sz_tip[76],sz_tip[77],sz_tip[78],sz_tip[79],sz_tip[80],sz_tip[81],sz_tip[82],sz_tip[83],sz_tip[84],sz_tip[85],sz_tip[86],sz_tip[87],sz_tip[88],sz_tip[89],sz_tip[90],sz_tip[91],sz_tip[92],sz_tip[93],sz_tip[94],sz_tip[95],sz_tip[96],sz_tip[97],sz_tip[98],sz_tip[99],sz_tip[100],sz_tip[101],sz_tip[102],sz_tip[103],sz_tip[104],sz_tip[105],sz_tip[106],sz_tip[107],sz_tip[108],sz_tip[109],sz_tip[110],sz_tip[111],sz_tip[112],sz_tip[113],sz_tip[114],sz_tip[115],sz_tip[116],sz_tip[117],sz_tip[118],sz_tip[119],sz_tip[120],sz_tip[121],sz_tip[122],sz_tip[123],sz_tip[124],sz_tip[125],sz_tip[126],sz_tip[127]];
        let dwState = *dw_state;
        let dwStateMask = *dw_state_mask;
        let szInfo = [sz_info[0],sz_info[1],sz_info[2],sz_info[3],sz_info[4],sz_info[5],sz_info[6],sz_info[7],sz_info[8],sz_info[9],sz_info[10],sz_info[11],sz_info[12],sz_info[13],sz_info[14],sz_info[15],sz_info[16],sz_info[17],sz_info[18],sz_info[19],sz_info[20],sz_info[21],sz_info[22],sz_info[23],sz_info[24],sz_info[25],sz_info[26],sz_info[27],sz_info[28],sz_info[29],sz_info[30],sz_info[31],sz_info[32],sz_info[33],sz_info[34],sz_info[35],sz_info[36],sz_info[37],sz_info[38],sz_info[39],sz_info[40],sz_info[41],sz_info[42],sz_info[43],sz_info[44],sz_info[45],sz_info[46],sz_info[47],sz_info[48],sz_info[49],sz_info[50],sz_info[51],sz_info[52],sz_info[53],sz_info[54],sz_info[55],sz_info[56],sz_info[57],sz_info[58],sz_info[59],sz_info[60],sz_info[61],sz_info[62],sz_info[63],sz_info[64],sz_info[65],sz_info[66],sz_info[67],sz_info[68],sz_info[69],sz_info[70],sz_info[71],sz_info[72],sz_info[73],sz_info[74],sz_info[75],sz_info[76],sz_info[77],sz_info[78],sz_info[79],sz_info[80],sz_info[81],sz_info[82],sz_info[83],sz_info[84],sz_info[85],sz_info[86],sz_info[87],sz_info[88],sz_info[89],sz_info[90],sz_info[91],sz_info[92],sz_info[93],sz_info[94],sz_info[95],sz_info[96],sz_info[97],sz_info[98],sz_info[99],sz_info[100],sz_info[101],sz_info[102],sz_info[103],sz_info[104],sz_info[105],sz_info[106],sz_info[107],sz_info[108],sz_info[109],sz_info[110],sz_info[111],sz_info[112],sz_info[113],sz_info[114],sz_info[115],sz_info[116],sz_info[117],sz_info[118],sz_info[119],sz_info[120],sz_info[121],sz_info[122],sz_info[123],sz_info[124],sz_info[125],sz_info[126],sz_info[127],sz_info[128],sz_info[129],sz_info[130],sz_info[131],sz_info[132],sz_info[133],sz_info[134],sz_info[135],sz_info[136],sz_info[137],sz_info[138],sz_info[139],sz_info[140],sz_info[141],sz_info[142],sz_info[143],sz_info[144],sz_info[145],sz_info[146],sz_info[147],sz_info[148],sz_info[149],sz_info[150],sz_info[151],sz_info[152],sz_info[153],sz_info[154],sz_info[155],sz_info[156],sz_info[157],sz_info[158],sz_info[159],sz_info[160],sz_info[161],sz_info[162],sz_info[163],sz_info[164],sz_info[165],sz_info[166],sz_info[167],sz_info[168],sz_info[169],sz_info[170],sz_info[171],sz_info[172],sz_info[173],sz_info[174],sz_info[175],sz_info[176],sz_info[177],sz_info[178],sz_info[179],sz_info[180],sz_info[181],sz_info[182],sz_info[183],sz_info[184],sz_info[185],sz_info[186],sz_info[187],sz_info[188],sz_info[189],sz_info[190],sz_info[191],sz_info[192],sz_info[193],sz_info[194],sz_info[195],sz_info[196],sz_info[197],sz_info[198],sz_info[199],sz_info[200],sz_info[201],sz_info[202],sz_info[203],sz_info[204],sz_info[205],sz_info[206],sz_info[207],sz_info[208],sz_info[209],sz_info[210],sz_info[211],sz_info[212],sz_info[213],sz_info[214],sz_info[215],sz_info[216],sz_info[217],sz_info[218],sz_info[219],sz_info[220],sz_info[221],sz_info[222],sz_info[223],sz_info[224],sz_info[225],sz_info[226],sz_info[227],sz_info[228],sz_info[229],sz_info[230],sz_info[231],sz_info[232],sz_info[233],sz_info[234],sz_info[235],sz_info[236],sz_info[237],sz_info[238],sz_info[239],sz_info[240],sz_info[241],sz_info[242],sz_info[243],sz_info[244],sz_info[245],sz_info[246],sz_info[247],sz_info[248],sz_info[249],sz_info[250],sz_info[251],sz_info[252],sz_info[253],sz_info[254],sz_info[255]];
        let Anonymous = anonymous.to_win32();
        let szInfoTitle = [sz_info_title[0],sz_info_title[1],sz_info_title[2],sz_info_title[3],sz_info_title[4],sz_info_title[5],sz_info_title[6],sz_info_title[7],sz_info_title[8],sz_info_title[9],sz_info_title[10],sz_info_title[11],sz_info_title[12],sz_info_title[13],sz_info_title[14],sz_info_title[15],sz_info_title[16],sz_info_title[17],sz_info_title[18],sz_info_title[19],sz_info_title[20],sz_info_title[21],sz_info_title[22],sz_info_title[23],sz_info_title[24],sz_info_title[25],sz_info_title[26],sz_info_title[27],sz_info_title[28],sz_info_title[29],sz_info_title[30],sz_info_title[31],sz_info_title[32],sz_info_title[33],sz_info_title[34],sz_info_title[35],sz_info_title[36],sz_info_title[37],sz_info_title[38],sz_info_title[39],sz_info_title[40],sz_info_title[41],sz_info_title[42],sz_info_title[43],sz_info_title[44],sz_info_title[45],sz_info_title[46],sz_info_title[47],sz_info_title[48],sz_info_title[49],sz_info_title[50],sz_info_title[51],sz_info_title[52],sz_info_title[53],sz_info_title[54],sz_info_title[55],sz_info_title[56],sz_info_title[57],sz_info_title[58],sz_info_title[59],sz_info_title[60],sz_info_title[61],sz_info_title[62],sz_info_title[63]];
        let dwInfoFlags = *dw_info_flags;
        let guidItem = *guid_item;
        let hBalloonIcon = h_balloon_icon.map_or(0, Hicon::into_raw);
        windows_sys::Win32::UI::Shell::NOTIFYICONDATAA { cbSize, hWnd, uID, uFlags, uCallbackMessage, hIcon, szTip, dwState, dwStateMask, szInfo, Anonymous, szInfoTitle, dwInfoFlags, guidItem, hBalloonIcon }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::NOTIFYICONDATAA) -> Self {
        let windows_sys::Win32::UI::Shell::NOTIFYICONDATAA { cbSize, hWnd, uID, uFlags, uCallbackMessage, hIcon, szTip, dwState, dwStateMask, szInfo, Anonymous, szInfoTitle, dwInfoFlags, guidItem, hBalloonIcon } = win32;
        let cb_size = cbSize;
        let h_wnd = unsafe { Hwnd::new_optional(hWnd) };
        let u_id = uID;
        let u_flags = uFlags;
        let u_callback_message = uCallbackMessage;
        let h_icon = unsafe { Hicon::new_optional(hIcon) };
        let sz_tip = [szTip[0],szTip[1],szTip[2],szTip[3],szTip[4],szTip[5],szTip[6],szTip[7],szTip[8],szTip[9],szTip[10],szTip[11],szTip[12],szTip[13],szTip[14],szTip[15],szTip[16],szTip[17],szTip[18],szTip[19],szTip[20],szTip[21],szTip[22],szTip[23],szTip[24],szTip[25],szTip[26],szTip[27],szTip[28],szTip[29],szTip[30],szTip[31],szTip[32],szTip[33],szTip[34],szTip[35],szTip[36],szTip[37],szTip[38],szTip[39],szTip[40],szTip[41],szTip[42],szTip[43],szTip[44],szTip[45],szTip[46],szTip[47],szTip[48],szTip[49],szTip[50],szTip[51],szTip[52],szTip[53],szTip[54],szTip[55],szTip[56],szTip[57],szTip[58],szTip[59],szTip[60],szTip[61],szTip[62],szTip[63],szTip[64],szTip[65],szTip[66],szTip[67],szTip[68],szTip[69],szTip[70],szTip[71],szTip[72],szTip[73],szTip[74],szTip[75],szTip[76],szTip[77],szTip[78],szTip[79],szTip[80],szTip[81],szTip[82],szTip[83],szTip[84],szTip[85],szTip[86],szTip[87],szTip[88],szTip[89],szTip[90],szTip[91],szTip[92],szTip[93],szTip[94],szTip[95],szTip[96],szTip[97],szTip[98],szTip[99],szTip[100],szTip[101],szTip[102],szTip[103],szTip[104],szTip[105],szTip[106],szTip[107],szTip[108],szTip[109],szTip[110],szTip[111],szTip[112],szTip[113],szTip[114],szTip[115],szTip[116],szTip[117],szTip[118],szTip[119],szTip[120],szTip[121],szTip[122],szTip[123],szTip[124],szTip[125],szTip[126],szTip[127]];
        let dw_state = dwState;
        let dw_state_mask = dwStateMask;
        let sz_info = [szInfo[0],szInfo[1],szInfo[2],szInfo[3],szInfo[4],szInfo[5],szInfo[6],szInfo[7],szInfo[8],szInfo[9],szInfo[10],szInfo[11],szInfo[12],szInfo[13],szInfo[14],szInfo[15],szInfo[16],szInfo[17],szInfo[18],szInfo[19],szInfo[20],szInfo[21],szInfo[22],szInfo[23],szInfo[24],szInfo[25],szInfo[26],szInfo[27],szInfo[28],szInfo[29],szInfo[30],szInfo[31],szInfo[32],szInfo[33],szInfo[34],szInfo[35],szInfo[36],szInfo[37],szInfo[38],szInfo[39],szInfo[40],szInfo[41],szInfo[42],szInfo[43],szInfo[44],szInfo[45],szInfo[46],szInfo[47],szInfo[48],szInfo[49],szInfo[50],szInfo[51],szInfo[52],szInfo[53],szInfo[54],szInfo[55],szInfo[56],szInfo[57],szInfo[58],szInfo[59],szInfo[60],szInfo[61],szInfo[62],szInfo[63],szInfo[64],szInfo[65],szInfo[66],szInfo[67],szInfo[68],szInfo[69],szInfo[70],szInfo[71],szInfo[72],szInfo[73],szInfo[74],szInfo[75],szInfo[76],szInfo[77],szInfo[78],szInfo[79],szInfo[80],szInfo[81],szInfo[82],szInfo[83],szInfo[84],szInfo[85],szInfo[86],szInfo[87],szInfo[88],szInfo[89],szInfo[90],szInfo[91],szInfo[92],szInfo[93],szInfo[94],szInfo[95],szInfo[96],szInfo[97],szInfo[98],szInfo[99],szInfo[100],szInfo[101],szInfo[102],szInfo[103],szInfo[104],szInfo[105],szInfo[106],szInfo[107],szInfo[108],szInfo[109],szInfo[110],szInfo[111],szInfo[112],szInfo[113],szInfo[114],szInfo[115],szInfo[116],szInfo[117],szInfo[118],szInfo[119],szInfo[120],szInfo[121],szInfo[122],szInfo[123],szInfo[124],szInfo[125],szInfo[126],szInfo[127],szInfo[128],szInfo[129],szInfo[130],szInfo[131],szInfo[132],szInfo[133],szInfo[134],szInfo[135],szInfo[136],szInfo[137],szInfo[138],szInfo[139],szInfo[140],szInfo[141],szInfo[142],szInfo[143],szInfo[144],szInfo[145],szInfo[146],szInfo[147],szInfo[148],szInfo[149],szInfo[150],szInfo[151],szInfo[152],szInfo[153],szInfo[154],szInfo[155],szInfo[156],szInfo[157],szInfo[158],szInfo[159],szInfo[160],szInfo[161],szInfo[162],szInfo[163],szInfo[164],szInfo[165],szInfo[166],szInfo[167],szInfo[168],szInfo[169],szInfo[170],szInfo[171],szInfo[172],szInfo[173],szInfo[174],szInfo[175],szInfo[176],szInfo[177],szInfo[178],szInfo[179],szInfo[180],szInfo[181],szInfo[182],szInfo[183],szInfo[184],szInfo[185],szInfo[186],szInfo[187],szInfo[188],szInfo[189],szInfo[190],szInfo[191],szInfo[192],szInfo[193],szInfo[194],szInfo[195],szInfo[196],szInfo[197],szInfo[198],szInfo[199],szInfo[200],szInfo[201],szInfo[202],szInfo[203],szInfo[204],szInfo[205],szInfo[206],szInfo[207],szInfo[208],szInfo[209],szInfo[210],szInfo[211],szInfo[212],szInfo[213],szInfo[214],szInfo[215],szInfo[216],szInfo[217],szInfo[218],szInfo[219],szInfo[220],szInfo[221],szInfo[222],szInfo[223],szInfo[224],szInfo[225],szInfo[226],szInfo[227],szInfo[228],szInfo[229],szInfo[230],szInfo[231],szInfo[232],szInfo[233],szInfo[234],szInfo[235],szInfo[236],szInfo[237],szInfo[238],szInfo[239],szInfo[240],szInfo[241],szInfo[242],szInfo[243],szInfo[244],szInfo[245],szInfo[246],szInfo[247],szInfo[248],szInfo[249],szInfo[250],szInfo[251],szInfo[252],szInfo[253],szInfo[254],szInfo[255]];
        let anonymous = unsafe { NOTIFYICONDATAA_8::from_win32(Anonymous) };
        let sz_info_title = [szInfoTitle[0],szInfoTitle[1],szInfoTitle[2],szInfoTitle[3],szInfoTitle[4],szInfoTitle[5],szInfoTitle[6],szInfoTitle[7],szInfoTitle[8],szInfoTitle[9],szInfoTitle[10],szInfoTitle[11],szInfoTitle[12],szInfoTitle[13],szInfoTitle[14],szInfoTitle[15],szInfoTitle[16],szInfoTitle[17],szInfoTitle[18],szInfoTitle[19],szInfoTitle[20],szInfoTitle[21],szInfoTitle[22],szInfoTitle[23],szInfoTitle[24],szInfoTitle[25],szInfoTitle[26],szInfoTitle[27],szInfoTitle[28],szInfoTitle[29],szInfoTitle[30],szInfoTitle[31],szInfoTitle[32],szInfoTitle[33],szInfoTitle[34],szInfoTitle[35],szInfoTitle[36],szInfoTitle[37],szInfoTitle[38],szInfoTitle[39],szInfoTitle[40],szInfoTitle[41],szInfoTitle[42],szInfoTitle[43],szInfoTitle[44],szInfoTitle[45],szInfoTitle[46],szInfoTitle[47],szInfoTitle[48],szInfoTitle[49],szInfoTitle[50],szInfoTitle[51],szInfoTitle[52],szInfoTitle[53],szInfoTitle[54],szInfoTitle[55],szInfoTitle[56],szInfoTitle[57],szInfoTitle[58],szInfoTitle[59],szInfoTitle[60],szInfoTitle[61],szInfoTitle[62],szInfoTitle[63]];
        let dw_info_flags = dwInfoFlags;
        let guid_item = guidItem;
        let h_balloon_icon = unsafe { Hicon::new_optional(hBalloonIcon) };
        Self { cb_size, h_wnd, u_id, u_flags, u_callback_message, h_icon, sz_tip, dw_state, dw_state_mask, sz_info, anonymous, sz_info_title, dw_info_flags, guid_item, h_balloon_icon }
    }
}
#[repr(C)]
pub union Notifyicondataa7 {
    pub field0: u32,
    pub field1: u32,
}
impl Notifyicondataa7 {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::NOTIFYICONDATAA_7 {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::NOTIFYICONDATAA_7) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[repr(C)]
pub union Notifyicondataa8 {
    pub field0: u32,
    pub field1: u32,
}
impl Notifyicondataa8 {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::NOTIFYICONDATAA_8 {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::NOTIFYICONDATAA_8) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Notifyicondataw {
    pub cb_size: u32,
    pub h_wnd: Option<Hwnd>,
    pub u_id: u32,
    pub u_flags: u32,
    pub u_callback_message: u32,
    pub h_icon: Option<Hicon>,
    pub sz_tip: [u8; 128],
    pub dw_state: u32,
    pub dw_state_mask: u32,
    pub sz_info: [u8; 256],
    pub anonymous: Notifyicondataw10,
    pub sz_info_title: [u8; 64],
    pub dw_info_flags: u32,
    pub guid_item: GUID,
    pub h_balloon_icon: Option<Hicon>,
}
impl Notifyicondataw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::NOTIFYICONDATAW {
        let Self { cb_size, h_wnd, u_id, u_flags, u_callback_message, h_icon, sz_tip, dw_state, dw_state_mask, sz_info, anonymous, sz_info_title, dw_info_flags, guid_item, h_balloon_icon } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::NOTIFYICONDATAW>() as _;
        let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
        let uID = *u_id;
        let uFlags = u_flags;
        let uCallbackMessage = *u_callback_message;
        let hIcon = h_icon.map_or(0, Hicon::into_raw);
        let szTip = [*sz_tip[0],*sz_tip[1],*sz_tip[2],*sz_tip[3],*sz_tip[4],*sz_tip[5],*sz_tip[6],*sz_tip[7],*sz_tip[8],*sz_tip[9],*sz_tip[10],*sz_tip[11],*sz_tip[12],*sz_tip[13],*sz_tip[14],*sz_tip[15],*sz_tip[16],*sz_tip[17],*sz_tip[18],*sz_tip[19],*sz_tip[20],*sz_tip[21],*sz_tip[22],*sz_tip[23],*sz_tip[24],*sz_tip[25],*sz_tip[26],*sz_tip[27],*sz_tip[28],*sz_tip[29],*sz_tip[30],*sz_tip[31],*sz_tip[32],*sz_tip[33],*sz_tip[34],*sz_tip[35],*sz_tip[36],*sz_tip[37],*sz_tip[38],*sz_tip[39],*sz_tip[40],*sz_tip[41],*sz_tip[42],*sz_tip[43],*sz_tip[44],*sz_tip[45],*sz_tip[46],*sz_tip[47],*sz_tip[48],*sz_tip[49],*sz_tip[50],*sz_tip[51],*sz_tip[52],*sz_tip[53],*sz_tip[54],*sz_tip[55],*sz_tip[56],*sz_tip[57],*sz_tip[58],*sz_tip[59],*sz_tip[60],*sz_tip[61],*sz_tip[62],*sz_tip[63],*sz_tip[64],*sz_tip[65],*sz_tip[66],*sz_tip[67],*sz_tip[68],*sz_tip[69],*sz_tip[70],*sz_tip[71],*sz_tip[72],*sz_tip[73],*sz_tip[74],*sz_tip[75],*sz_tip[76],*sz_tip[77],*sz_tip[78],*sz_tip[79],*sz_tip[80],*sz_tip[81],*sz_tip[82],*sz_tip[83],*sz_tip[84],*sz_tip[85],*sz_tip[86],*sz_tip[87],*sz_tip[88],*sz_tip[89],*sz_tip[90],*sz_tip[91],*sz_tip[92],*sz_tip[93],*sz_tip[94],*sz_tip[95],*sz_tip[96],*sz_tip[97],*sz_tip[98],*sz_tip[99],*sz_tip[100],*sz_tip[101],*sz_tip[102],*sz_tip[103],*sz_tip[104],*sz_tip[105],*sz_tip[106],*sz_tip[107],*sz_tip[108],*sz_tip[109],*sz_tip[110],*sz_tip[111],*sz_tip[112],*sz_tip[113],*sz_tip[114],*sz_tip[115],*sz_tip[116],*sz_tip[117],*sz_tip[118],*sz_tip[119],*sz_tip[120],*sz_tip[121],*sz_tip[122],*sz_tip[123],*sz_tip[124],*sz_tip[125],*sz_tip[126],*sz_tip[127]];
        let dwState = *dw_state;
        let dwStateMask = *dw_state_mask;
        let szInfo = [*sz_info[0],*sz_info[1],*sz_info[2],*sz_info[3],*sz_info[4],*sz_info[5],*sz_info[6],*sz_info[7],*sz_info[8],*sz_info[9],*sz_info[10],*sz_info[11],*sz_info[12],*sz_info[13],*sz_info[14],*sz_info[15],*sz_info[16],*sz_info[17],*sz_info[18],*sz_info[19],*sz_info[20],*sz_info[21],*sz_info[22],*sz_info[23],*sz_info[24],*sz_info[25],*sz_info[26],*sz_info[27],*sz_info[28],*sz_info[29],*sz_info[30],*sz_info[31],*sz_info[32],*sz_info[33],*sz_info[34],*sz_info[35],*sz_info[36],*sz_info[37],*sz_info[38],*sz_info[39],*sz_info[40],*sz_info[41],*sz_info[42],*sz_info[43],*sz_info[44],*sz_info[45],*sz_info[46],*sz_info[47],*sz_info[48],*sz_info[49],*sz_info[50],*sz_info[51],*sz_info[52],*sz_info[53],*sz_info[54],*sz_info[55],*sz_info[56],*sz_info[57],*sz_info[58],*sz_info[59],*sz_info[60],*sz_info[61],*sz_info[62],*sz_info[63],*sz_info[64],*sz_info[65],*sz_info[66],*sz_info[67],*sz_info[68],*sz_info[69],*sz_info[70],*sz_info[71],*sz_info[72],*sz_info[73],*sz_info[74],*sz_info[75],*sz_info[76],*sz_info[77],*sz_info[78],*sz_info[79],*sz_info[80],*sz_info[81],*sz_info[82],*sz_info[83],*sz_info[84],*sz_info[85],*sz_info[86],*sz_info[87],*sz_info[88],*sz_info[89],*sz_info[90],*sz_info[91],*sz_info[92],*sz_info[93],*sz_info[94],*sz_info[95],*sz_info[96],*sz_info[97],*sz_info[98],*sz_info[99],*sz_info[100],*sz_info[101],*sz_info[102],*sz_info[103],*sz_info[104],*sz_info[105],*sz_info[106],*sz_info[107],*sz_info[108],*sz_info[109],*sz_info[110],*sz_info[111],*sz_info[112],*sz_info[113],*sz_info[114],*sz_info[115],*sz_info[116],*sz_info[117],*sz_info[118],*sz_info[119],*sz_info[120],*sz_info[121],*sz_info[122],*sz_info[123],*sz_info[124],*sz_info[125],*sz_info[126],*sz_info[127],*sz_info[128],*sz_info[129],*sz_info[130],*sz_info[131],*sz_info[132],*sz_info[133],*sz_info[134],*sz_info[135],*sz_info[136],*sz_info[137],*sz_info[138],*sz_info[139],*sz_info[140],*sz_info[141],*sz_info[142],*sz_info[143],*sz_info[144],*sz_info[145],*sz_info[146],*sz_info[147],*sz_info[148],*sz_info[149],*sz_info[150],*sz_info[151],*sz_info[152],*sz_info[153],*sz_info[154],*sz_info[155],*sz_info[156],*sz_info[157],*sz_info[158],*sz_info[159],*sz_info[160],*sz_info[161],*sz_info[162],*sz_info[163],*sz_info[164],*sz_info[165],*sz_info[166],*sz_info[167],*sz_info[168],*sz_info[169],*sz_info[170],*sz_info[171],*sz_info[172],*sz_info[173],*sz_info[174],*sz_info[175],*sz_info[176],*sz_info[177],*sz_info[178],*sz_info[179],*sz_info[180],*sz_info[181],*sz_info[182],*sz_info[183],*sz_info[184],*sz_info[185],*sz_info[186],*sz_info[187],*sz_info[188],*sz_info[189],*sz_info[190],*sz_info[191],*sz_info[192],*sz_info[193],*sz_info[194],*sz_info[195],*sz_info[196],*sz_info[197],*sz_info[198],*sz_info[199],*sz_info[200],*sz_info[201],*sz_info[202],*sz_info[203],*sz_info[204],*sz_info[205],*sz_info[206],*sz_info[207],*sz_info[208],*sz_info[209],*sz_info[210],*sz_info[211],*sz_info[212],*sz_info[213],*sz_info[214],*sz_info[215],*sz_info[216],*sz_info[217],*sz_info[218],*sz_info[219],*sz_info[220],*sz_info[221],*sz_info[222],*sz_info[223],*sz_info[224],*sz_info[225],*sz_info[226],*sz_info[227],*sz_info[228],*sz_info[229],*sz_info[230],*sz_info[231],*sz_info[232],*sz_info[233],*sz_info[234],*sz_info[235],*sz_info[236],*sz_info[237],*sz_info[238],*sz_info[239],*sz_info[240],*sz_info[241],*sz_info[242],*sz_info[243],*sz_info[244],*sz_info[245],*sz_info[246],*sz_info[247],*sz_info[248],*sz_info[249],*sz_info[250],*sz_info[251],*sz_info[252],*sz_info[253],*sz_info[254],*sz_info[255]];
        let Anonymous = anonymous.to_win32();
        let szInfoTitle = [*sz_info_title[0],*sz_info_title[1],*sz_info_title[2],*sz_info_title[3],*sz_info_title[4],*sz_info_title[5],*sz_info_title[6],*sz_info_title[7],*sz_info_title[8],*sz_info_title[9],*sz_info_title[10],*sz_info_title[11],*sz_info_title[12],*sz_info_title[13],*sz_info_title[14],*sz_info_title[15],*sz_info_title[16],*sz_info_title[17],*sz_info_title[18],*sz_info_title[19],*sz_info_title[20],*sz_info_title[21],*sz_info_title[22],*sz_info_title[23],*sz_info_title[24],*sz_info_title[25],*sz_info_title[26],*sz_info_title[27],*sz_info_title[28],*sz_info_title[29],*sz_info_title[30],*sz_info_title[31],*sz_info_title[32],*sz_info_title[33],*sz_info_title[34],*sz_info_title[35],*sz_info_title[36],*sz_info_title[37],*sz_info_title[38],*sz_info_title[39],*sz_info_title[40],*sz_info_title[41],*sz_info_title[42],*sz_info_title[43],*sz_info_title[44],*sz_info_title[45],*sz_info_title[46],*sz_info_title[47],*sz_info_title[48],*sz_info_title[49],*sz_info_title[50],*sz_info_title[51],*sz_info_title[52],*sz_info_title[53],*sz_info_title[54],*sz_info_title[55],*sz_info_title[56],*sz_info_title[57],*sz_info_title[58],*sz_info_title[59],*sz_info_title[60],*sz_info_title[61],*sz_info_title[62],*sz_info_title[63]];
        let dwInfoFlags = *dw_info_flags;
        let guidItem = *guid_item;
        let hBalloonIcon = h_balloon_icon.map_or(0, Hicon::into_raw);
        windows_sys::Win32::UI::Shell::NOTIFYICONDATAW { cbSize, hWnd, uID, uFlags, uCallbackMessage, hIcon, szTip, dwState, dwStateMask, szInfo, Anonymous, szInfoTitle, dwInfoFlags, guidItem, hBalloonIcon }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::NOTIFYICONDATAW) -> Self {
        let windows_sys::Win32::UI::Shell::NOTIFYICONDATAW { cbSize, hWnd, uID, uFlags, uCallbackMessage, hIcon, szTip, dwState, dwStateMask, szInfo, Anonymous, szInfoTitle, dwInfoFlags, guidItem, hBalloonIcon } = win32;
        let cb_size = cbSize;
        let h_wnd = unsafe { Hwnd::new_optional(hWnd) };
        let u_id = uID;
        let u_flags = uFlags;
        let u_callback_message = uCallbackMessage;
        let h_icon = unsafe { Hicon::new_optional(hIcon) };
        let sz_tip = [szTip[0],szTip[1],szTip[2],szTip[3],szTip[4],szTip[5],szTip[6],szTip[7],szTip[8],szTip[9],szTip[10],szTip[11],szTip[12],szTip[13],szTip[14],szTip[15],szTip[16],szTip[17],szTip[18],szTip[19],szTip[20],szTip[21],szTip[22],szTip[23],szTip[24],szTip[25],szTip[26],szTip[27],szTip[28],szTip[29],szTip[30],szTip[31],szTip[32],szTip[33],szTip[34],szTip[35],szTip[36],szTip[37],szTip[38],szTip[39],szTip[40],szTip[41],szTip[42],szTip[43],szTip[44],szTip[45],szTip[46],szTip[47],szTip[48],szTip[49],szTip[50],szTip[51],szTip[52],szTip[53],szTip[54],szTip[55],szTip[56],szTip[57],szTip[58],szTip[59],szTip[60],szTip[61],szTip[62],szTip[63],szTip[64],szTip[65],szTip[66],szTip[67],szTip[68],szTip[69],szTip[70],szTip[71],szTip[72],szTip[73],szTip[74],szTip[75],szTip[76],szTip[77],szTip[78],szTip[79],szTip[80],szTip[81],szTip[82],szTip[83],szTip[84],szTip[85],szTip[86],szTip[87],szTip[88],szTip[89],szTip[90],szTip[91],szTip[92],szTip[93],szTip[94],szTip[95],szTip[96],szTip[97],szTip[98],szTip[99],szTip[100],szTip[101],szTip[102],szTip[103],szTip[104],szTip[105],szTip[106],szTip[107],szTip[108],szTip[109],szTip[110],szTip[111],szTip[112],szTip[113],szTip[114],szTip[115],szTip[116],szTip[117],szTip[118],szTip[119],szTip[120],szTip[121],szTip[122],szTip[123],szTip[124],szTip[125],szTip[126],szTip[127]];
        let dw_state = dwState;
        let dw_state_mask = dwStateMask;
        let sz_info = [szInfo[0],szInfo[1],szInfo[2],szInfo[3],szInfo[4],szInfo[5],szInfo[6],szInfo[7],szInfo[8],szInfo[9],szInfo[10],szInfo[11],szInfo[12],szInfo[13],szInfo[14],szInfo[15],szInfo[16],szInfo[17],szInfo[18],szInfo[19],szInfo[20],szInfo[21],szInfo[22],szInfo[23],szInfo[24],szInfo[25],szInfo[26],szInfo[27],szInfo[28],szInfo[29],szInfo[30],szInfo[31],szInfo[32],szInfo[33],szInfo[34],szInfo[35],szInfo[36],szInfo[37],szInfo[38],szInfo[39],szInfo[40],szInfo[41],szInfo[42],szInfo[43],szInfo[44],szInfo[45],szInfo[46],szInfo[47],szInfo[48],szInfo[49],szInfo[50],szInfo[51],szInfo[52],szInfo[53],szInfo[54],szInfo[55],szInfo[56],szInfo[57],szInfo[58],szInfo[59],szInfo[60],szInfo[61],szInfo[62],szInfo[63],szInfo[64],szInfo[65],szInfo[66],szInfo[67],szInfo[68],szInfo[69],szInfo[70],szInfo[71],szInfo[72],szInfo[73],szInfo[74],szInfo[75],szInfo[76],szInfo[77],szInfo[78],szInfo[79],szInfo[80],szInfo[81],szInfo[82],szInfo[83],szInfo[84],szInfo[85],szInfo[86],szInfo[87],szInfo[88],szInfo[89],szInfo[90],szInfo[91],szInfo[92],szInfo[93],szInfo[94],szInfo[95],szInfo[96],szInfo[97],szInfo[98],szInfo[99],szInfo[100],szInfo[101],szInfo[102],szInfo[103],szInfo[104],szInfo[105],szInfo[106],szInfo[107],szInfo[108],szInfo[109],szInfo[110],szInfo[111],szInfo[112],szInfo[113],szInfo[114],szInfo[115],szInfo[116],szInfo[117],szInfo[118],szInfo[119],szInfo[120],szInfo[121],szInfo[122],szInfo[123],szInfo[124],szInfo[125],szInfo[126],szInfo[127],szInfo[128],szInfo[129],szInfo[130],szInfo[131],szInfo[132],szInfo[133],szInfo[134],szInfo[135],szInfo[136],szInfo[137],szInfo[138],szInfo[139],szInfo[140],szInfo[141],szInfo[142],szInfo[143],szInfo[144],szInfo[145],szInfo[146],szInfo[147],szInfo[148],szInfo[149],szInfo[150],szInfo[151],szInfo[152],szInfo[153],szInfo[154],szInfo[155],szInfo[156],szInfo[157],szInfo[158],szInfo[159],szInfo[160],szInfo[161],szInfo[162],szInfo[163],szInfo[164],szInfo[165],szInfo[166],szInfo[167],szInfo[168],szInfo[169],szInfo[170],szInfo[171],szInfo[172],szInfo[173],szInfo[174],szInfo[175],szInfo[176],szInfo[177],szInfo[178],szInfo[179],szInfo[180],szInfo[181],szInfo[182],szInfo[183],szInfo[184],szInfo[185],szInfo[186],szInfo[187],szInfo[188],szInfo[189],szInfo[190],szInfo[191],szInfo[192],szInfo[193],szInfo[194],szInfo[195],szInfo[196],szInfo[197],szInfo[198],szInfo[199],szInfo[200],szInfo[201],szInfo[202],szInfo[203],szInfo[204],szInfo[205],szInfo[206],szInfo[207],szInfo[208],szInfo[209],szInfo[210],szInfo[211],szInfo[212],szInfo[213],szInfo[214],szInfo[215],szInfo[216],szInfo[217],szInfo[218],szInfo[219],szInfo[220],szInfo[221],szInfo[222],szInfo[223],szInfo[224],szInfo[225],szInfo[226],szInfo[227],szInfo[228],szInfo[229],szInfo[230],szInfo[231],szInfo[232],szInfo[233],szInfo[234],szInfo[235],szInfo[236],szInfo[237],szInfo[238],szInfo[239],szInfo[240],szInfo[241],szInfo[242],szInfo[243],szInfo[244],szInfo[245],szInfo[246],szInfo[247],szInfo[248],szInfo[249],szInfo[250],szInfo[251],szInfo[252],szInfo[253],szInfo[254],szInfo[255]];
        let anonymous = unsafe { NOTIFYICONDATAW_10::from_win32(Anonymous) };
        let sz_info_title = [szInfoTitle[0],szInfoTitle[1],szInfoTitle[2],szInfoTitle[3],szInfoTitle[4],szInfoTitle[5],szInfoTitle[6],szInfoTitle[7],szInfoTitle[8],szInfoTitle[9],szInfoTitle[10],szInfoTitle[11],szInfoTitle[12],szInfoTitle[13],szInfoTitle[14],szInfoTitle[15],szInfoTitle[16],szInfoTitle[17],szInfoTitle[18],szInfoTitle[19],szInfoTitle[20],szInfoTitle[21],szInfoTitle[22],szInfoTitle[23],szInfoTitle[24],szInfoTitle[25],szInfoTitle[26],szInfoTitle[27],szInfoTitle[28],szInfoTitle[29],szInfoTitle[30],szInfoTitle[31],szInfoTitle[32],szInfoTitle[33],szInfoTitle[34],szInfoTitle[35],szInfoTitle[36],szInfoTitle[37],szInfoTitle[38],szInfoTitle[39],szInfoTitle[40],szInfoTitle[41],szInfoTitle[42],szInfoTitle[43],szInfoTitle[44],szInfoTitle[45],szInfoTitle[46],szInfoTitle[47],szInfoTitle[48],szInfoTitle[49],szInfoTitle[50],szInfoTitle[51],szInfoTitle[52],szInfoTitle[53],szInfoTitle[54],szInfoTitle[55],szInfoTitle[56],szInfoTitle[57],szInfoTitle[58],szInfoTitle[59],szInfoTitle[60],szInfoTitle[61],szInfoTitle[62],szInfoTitle[63]];
        let dw_info_flags = dwInfoFlags;
        let guid_item = guidItem;
        let h_balloon_icon = unsafe { Hicon::new_optional(hBalloonIcon) };
        Self { cb_size, h_wnd, u_id, u_flags, u_callback_message, h_icon, sz_tip, dw_state, dw_state_mask, sz_info, anonymous, sz_info_title, dw_info_flags, guid_item, h_balloon_icon }
    }
}
#[repr(C)]
pub union Notifyicondataw10 {
    pub field0: u32,
    pub field1: u32,
}
impl Notifyicondataw10 {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::NOTIFYICONDATAW_10 {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::NOTIFYICONDATAW_10) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[repr(C)]
pub union Notifyicondataw9 {
    pub field0: u32,
    pub field1: u32,
}
impl Notifyicondataw9 {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::NOTIFYICONDATAW_9 {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::NOTIFYICONDATAW_9) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Notifyiconidentifier {
    pub cb_size: u32,
    pub h_wnd: Option<Hwnd>,
    pub u_id: u32,
    pub guid_item: GUID,
}
impl Notifyiconidentifier {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::NOTIFYICONIDENTIFIER {
        let Self { cb_size, h_wnd, u_id, guid_item } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::NOTIFYICONIDENTIFIER>() as _;
        let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
        let uID = *u_id;
        let guidItem = *guid_item;
        windows_sys::Win32::UI::Shell::NOTIFYICONIDENTIFIER { cbSize, hWnd, uID, guidItem }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::NOTIFYICONIDENTIFIER) -> Self {
        let windows_sys::Win32::UI::Shell::NOTIFYICONIDENTIFIER { cbSize, hWnd, uID, guidItem } = win32;
        let cb_size = cbSize;
        let h_wnd = unsafe { Hwnd::new_optional(hWnd) };
        let u_id = uID;
        let guid_item = guidItem;
        Self { cb_size, h_wnd, u_id, guid_item }
    }
}
pub const NIF_MESSAGE: u32 = 0x1;
pub const NIF_ICON: u32 = 0x2;
pub const NIF_TIP: u32 = 0x4;
pub const NIF_STATE: u32 = 0x8;
pub const NIF_INFO: u32 = 0x10;
pub const NIF_GUID: u32 = 0x20;
pub const NIF_REALTIME: u32 = 0x40;
pub const NIF_SHOWTIP: u32 = 0x80;
pub const NIM_ADD: u32 = 0x0;
pub const NIM_MODIFY: u32 = 0x1;
pub const NIM_DELETE: u32 = 0x2;
pub const NIM_SETFOCUS: u32 = 0x3;
pub const NIM_SETVERSION: u32 = 0x4;
pub const NSTCFC_NONE: i32 = 0x0;
pub const NSTCFC_PINNEDITEMFILTERING: i32 = 0x1;
pub const NSTCFC_DELAY_REGISTER_NOTIFY: i32 = 0x2;
pub const NSTCGNI_NEXT: i32 = 0x0;
pub const NSTCGNI_NEXTVISIBLE: i32 = 0x1;
pub const NSTCGNI_PREV: i32 = 0x2;
pub const NSTCGNI_PREVVISIBLE: i32 = 0x3;
pub const NSTCGNI_PARENT: i32 = 0x4;
pub const NSTCGNI_CHILD: i32 = 0x5;
pub const NSTCGNI_FIRSTVISIBLE: i32 = 0x6;
pub const NSTCGNI_LASTVISIBLE: i32 = 0x7;
pub const NSTCS2_DEFAULT: i32 = 0x0;
pub const NSTCS2_INTERRUPTNOTIFICATIONS: i32 = 0x1;
pub const NSTCS2_SHOWNULLSPACEMENU: i32 = 0x2;
pub const NSTCS2_DISPLAYPADDING: i32 = 0x4;
pub const NSTCS2_DISPLAYPINNEDONLY: i32 = 0x8;
pub const NTSCS2_NOSINGLETONAUTOEXPAND: i32 = 0x10;
pub const NTSCS2_NEVERINSERTNONENUMERATED: i32 = 0x20;
pub const FACILITY_DEBUGGER: u32 = 0x1;
pub const FACILITY_RPC_RUNTIME: u32 = 0x2;
pub const FACILITY_RPC_STUBS: u32 = 0x3;
pub const FACILITY_IO_ERROR_CODE: u32 = 0x4;
pub const FACILITY_CODCLASS_ERROR_CODE: u32 = 0x6;
pub const FACILITY_NTWIN32: u32 = 0x7;
pub const FACILITY_NTCERT: u32 = 0x8;
pub const FACILITY_NTSSPI: u32 = 0x9;
pub const FACILITY_TERMINAL_SERVER: u32 = 0xA;
pub const FACILITY_USB_ERROR_CODE: u32 = 0x10;
pub const FACILITY_HID_ERROR_CODE: u32 = 0x11;
pub const FACILITY_FIREWIRE_ERROR_CODE: u32 = 0x12;
pub const FACILITY_CLUSTER_ERROR_CODE: u32 = 0x13;
pub const FACILITY_ACPI_ERROR_CODE: u32 = 0x14;
pub const FACILITY_SXS_ERROR_CODE: u32 = 0x15;
pub const FACILITY_TRANSACTION: u32 = 0x19;
pub const FACILITY_COMMONLOG: u32 = 0x1A;
pub const FACILITY_VIDEO: u32 = 0x1B;
pub const FACILITY_FILTER_MANAGER: u32 = 0x1C;
pub const FACILITY_MONITOR: u32 = 0x1D;
pub const FACILITY_GRAPHICS_KERNEL: u32 = 0x1E;
pub const FACILITY_DRIVER_FRAMEWORK: u32 = 0x20;
pub const FACILITY_FVE_ERROR_CODE: u32 = 0x21;
pub const FACILITY_FWP_ERROR_CODE: u32 = 0x22;
pub const FACILITY_NDIS_ERROR_CODE: u32 = 0x23;
pub const FACILITY_QUIC_ERROR_CODE: u32 = 0x24;
pub const FACILITY_TPM: u32 = 0x29;
pub const FACILITY_RTPM: u32 = 0x2A;
pub const FACILITY_HYPERVISOR: u32 = 0x35;
pub const FACILITY_IPSEC: u32 = 0x36;
pub const FACILITY_VIRTUALIZATION: u32 = 0x37;
pub const FACILITY_VOLMGR: u32 = 0x38;
pub const FACILITY_BCD_ERROR_CODE: u32 = 0x39;
pub const FACILITY_WIN32K_NTUSER: u32 = 0x3E;
pub const FACILITY_WIN32K_NTGDI: u32 = 0x3F;
pub const FACILITY_RESUME_KEY_FILTER: u32 = 0x40;
pub const FACILITY_RDBSS: u32 = 0x41;
pub const FACILITY_BTH_ATT: u32 = 0x42;
pub const FACILITY_SECUREBOOT: u32 = 0x43;
pub const FACILITY_AUDIO_KERNEL: u32 = 0x44;
pub const FACILITY_VSM: u32 = 0x45;
pub const FACILITY_NT_IORING: u32 = 0x46;
pub const FACILITY_VOLSNAP: u32 = 0x50;
pub const FACILITY_SDBUS: u32 = 0x51;
pub const FACILITY_SHARED_VHDX: u32 = 0x5C;
pub const FACILITY_SMB: u32 = 0x5D;
pub const FACILITY_XVS: u32 = 0x5E;
pub const FACILITY_INTERIX: u32 = 0x99;
pub const FACILITY_SPACES: u32 = 0xE7;
pub const FACILITY_SECURITY_CORE: u32 = 0xE8;
pub const FACILITY_SYSTEM_INTEGRITY: u32 = 0xE9;
pub const FACILITY_LICENSING: u32 = 0xEA;
pub const FACILITY_PLATFORM_MANIFEST: u32 = 0xEB;
pub const FACILITY_APP_EXEC: u32 = 0xEC;
pub const FACILITY_MAXIMUM_VALUE: u32 = 0xED;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct NtFeConsoleProps {
    pub dbh: DatablockHeader,
    pub u_code_page: u32,
}
impl NtFeConsoleProps {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::NT_FE_CONSOLE_PROPS {
        let Self { dbh, u_code_page } = self;
        let dbh = dbh.to_win32();
        let uCodePage = *u_code_page;
        windows_sys::Win32::UI::Shell::NT_FE_CONSOLE_PROPS { dbh, uCodePage }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::NT_FE_CONSOLE_PROPS) -> Self {
        let windows_sys::Win32::UI::Shell::NT_FE_CONSOLE_PROPS { dbh, uCodePage } = win32;
        let dbh = unsafe { DATABLOCK_HEADER::from_win32(dbh) };
        let u_code_page = uCodePage;
        Self { dbh, u_code_page }
    }
}
pub const NWMF_UNLOADING: i32 = 0x1;
pub const NWMF_USERINITED: i32 = 0x2;
pub const NWMF_FIRST: i32 = 0x4;
pub const NWMF_OVERRIDEKEY: i32 = 0x8;
pub const NWMF_SHOWHELP: i32 = 0x10;
pub const NWMF_HTMLDIALOG: i32 = 0x20;
pub const NWMF_FROMDIALOGCHILD: i32 = 0x40;
pub const NWMF_USERREQUESTED: i32 = 0x80;
pub const NWMF_USERALLOWED: i32 = 0x100;
pub const NWMF_FORCEWINDOW: i32 = 0x10000;
pub const NWMF_FORCETAB: i32 = 0x20000;
pub const NWMF_SUGGESTWINDOW: i32 = 0x40000;
pub const NWMF_SUGGESTTAB: i32 = 0x80000;
pub const NWMF_INACTIVETAB: i32 = 0x100000;
pub const PROTECTED_MODE_REDIRECT: i32 = 0x1;
pub const OBJID_WINDOW: i32 = 0x0;
pub const OBJID_SYSMENU: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
pub const OBJID_TITLEBAR: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE;
pub const OBJID_MENU: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD;
pub const OBJID_CLIENT: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC;
pub const OBJID_VSCROLL: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB;
pub const OBJID_HSCROLL: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA;
pub const OBJID_SIZEGRIP: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF9;
pub const OBJID_CARET: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8;
pub const OBJID_CURSOR: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7;
pub const OBJID_ALERT: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF6;
pub const OBJID_SOUND: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5;
pub const OBJID_QUERYCLASSNAMEIDX: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4;
pub const OBJID_NATIVEOM: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0;
pub const OBJ_PEN: i32 = 0x1;
pub const OBJ_BRUSH: i32 = 0x2;
pub const OBJ_DC: i32 = 0x3;
pub const OBJ_METADC: i32 = 0x4;
pub const OBJ_PAL: i32 = 0x5;
pub const OBJ_FONT: i32 = 0x6;
pub const OBJ_BITMAP: i32 = 0x7;
pub const OBJ_REGION: i32 = 0x8;
pub const OBJ_METAFILE: i32 = 0x9;
pub const OBJ_MEMDC: i32 = 0xA;
pub const OBJ_EXTPEN: i32 = 0xB;
pub const OBJ_ENHMETADC: i32 = 0xC;
pub const OBJ_ENHMETAFILE: i32 = 0xD;
pub const OBJ_COLORSPACE: i32 = 0xE;
pub const OT_TOPLEFT: i32 = 0x0;
pub const OT_TOPRIGHT: i32 = 0x1;
pub const OT_TOPMIDDLE: i32 = 0x2;
pub const OT_BOTTOMLEFT: i32 = 0x3;
pub const OT_BOTTOMRIGHT: i32 = 0x4;
pub const OT_BOTTOMMIDDLE: i32 = 0x5;
pub const OT_MIDDLELEFT: i32 = 0x6;
pub const OT_MIDDLERIGHT: i32 = 0x7;
pub const OT_LEFTOFCAPTION: i32 = 0x8;
pub const OT_RIGHTOFCAPTION: i32 = 0x9;
pub const OT_LEFTOFLASTBUTTON: i32 = 0xA;
pub const OT_RIGHTOFLASTBUTTON: i32 = 0xB;
pub const OT_ABOVELASTBUTTON: i32 = 0xC;
pub const OT_BELOWLASTBUTTON: i32 = 0xD;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Openasinfo<'a> {
    pub pcsz_file: Cow<'a, [u16]>,
    pub pcsz_class: Cow<'a, [u16]>,
    pub oaif_in_flags: u32,
}
impl Openasinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::OPENASINFO {
        let Self { pcsz_file, pcsz_class, oaif_in_flags } = self;
        assert_eq!(pcsz_file.last(), Some(0));
        let pcszFile = pcsz_file.as_ptr();
        assert_eq!(pcsz_class.last(), Some(0));
        let pcszClass = pcsz_class.as_ptr();
        let oaifInFlags = oaif_in_flags;
        windows_sys::Win32::UI::Shell::OPENASINFO { pcszFile, pcszClass, oaifInFlags }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::OPENASINFO) -> Self {
        let windows_sys::Win32::UI::Shell::OPENASINFO { pcszFile, pcszClass, oaifInFlags } = win32;
        let slen = unsafe { wide_strlen(pcszFile as *const u16) };
        let pcszFile = unsafe { slice::from_raw_parts(pcszFile, slen + 1) };
        let pcsz_file = pcszFile.to_vec();
        let slen = unsafe { wide_strlen(pcszClass as *const u16) };
        let pcszClass = unsafe { slice::from_raw_parts(pcszClass, slen + 1) };
        let pcsz_class = pcszClass.to_vec();
        let oaif_in_flags = oaifInFlags;
        Self { pcsz_file, pcsz_class, oaif_in_flags }
    }
}
pub const SPOB_NORMAL: i32 = 0x1;
pub const SPOB_HOT: i32 = 0x2;
pub const SPOB_SELECTED: i32 = 0x3;
pub const SPOB_DISABLED: i32 = 0x4;
pub const SPOB_FOCUSED: i32 = 0x5;
pub const OAIF_ALLOW_REGISTRATION: u32 = 0x1;
pub const OAIF_REGISTER_EXT: u32 = 0x2;
pub const OAIF_EXEC: u32 = 0x4;
pub const OAIF_FORCE_REGISTRATION: u32 = 0x8;
pub const OAIF_HIDE_REGISTRATION: u32 = 0x20;
pub const OAIF_URL_PROTOCOL: u32 = 0x40;
pub const OAIF_FILE_IS_URI: u32 = 0x80;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct OpenPrinterPropsInfoa<'a> {
    pub dw_size: u32,
    pub psz_sheet_name: Cow<'a, CStr>,
    pub u_sheet_index: u32,
    pub dw_flags: u32,
    pub b_modal: BOOL,
}
impl OpenPrinterPropsInfoa {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::OPEN_PRINTER_PROPS_INFOA {
        let Self { dw_size, psz_sheet_name, u_sheet_index, dw_flags, b_modal } = self;
        let dwSize = mem::size_of::<windows_sys::Win32::UI::Shell::OPEN_PRINTER_PROPS_INFOA>() as _;
        let pszSheetName = psz_sheet_name.as_ptr();
        let uSheetIndex = *u_sheet_index;
        let dwFlags = *dw_flags;
        let bModal = b_modal;
        windows_sys::Win32::UI::Shell::OPEN_PRINTER_PROPS_INFOA { dwSize, pszSheetName, uSheetIndex, dwFlags, bModal }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::OPEN_PRINTER_PROPS_INFOA) -> Self {
        let windows_sys::Win32::UI::Shell::OPEN_PRINTER_PROPS_INFOA { dwSize, pszSheetName, uSheetIndex, dwFlags, bModal } = win32;
        let dw_size = dwSize;
        let pszSheetName = unsafe { CStr::from_ptr(pszSheetName) };
        let pszSheetName = pszSheetName.to_bytes_with_nul().to_vec();
        let psz_sheet_name = Cow::Owned(unsafe { CString::from_vec_unchecked(pszSheetName) });
        let u_sheet_index = uSheetIndex;
        let dw_flags = dwFlags;
        let b_modal = bModal;
        Self { dw_size, psz_sheet_name, u_sheet_index, dw_flags, b_modal }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct OpenPrinterPropsInfow<'a> {
    pub dw_size: u32,
    pub psz_sheet_name: Cow<'a, [u16]>,
    pub u_sheet_index: u32,
    pub dw_flags: u32,
    pub b_modal: BOOL,
}
impl OpenPrinterPropsInfow {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::OPEN_PRINTER_PROPS_INFOW {
        let Self { dw_size, psz_sheet_name, u_sheet_index, dw_flags, b_modal } = self;
        let dwSize = mem::size_of::<windows_sys::Win32::UI::Shell::OPEN_PRINTER_PROPS_INFOW>() as _;
        assert_eq!(psz_sheet_name.last(), Some(0));
        let pszSheetName = psz_sheet_name.as_ptr();
        let uSheetIndex = *u_sheet_index;
        let dwFlags = *dw_flags;
        let bModal = b_modal;
        windows_sys::Win32::UI::Shell::OPEN_PRINTER_PROPS_INFOW { dwSize, pszSheetName, uSheetIndex, dwFlags, bModal }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::OPEN_PRINTER_PROPS_INFOW) -> Self {
        let windows_sys::Win32::UI::Shell::OPEN_PRINTER_PROPS_INFOW { dwSize, pszSheetName, uSheetIndex, dwFlags, bModal } = win32;
        let dw_size = dwSize;
        let slen = unsafe { wide_strlen(pszSheetName as *const u16) };
        let pszSheetName = unsafe { slice::from_raw_parts(pszSheetName, slen + 1) };
        let psz_sheet_name = pszSheetName.to_vec();
        let u_sheet_index = uSheetIndex;
        let dw_flags = dwFlags;
        let b_modal = bModal;
        Self { dw_size, psz_sheet_name, u_sheet_index, dw_flags, b_modal }
    }
}
pub const OTD_FORCE_RECT_SIZING: u32 = 0x1;
pub const OTD_NONCLIENT: u32 = 0x2;
pub const OS_WINDOWS: u32 = 0x0;
pub const OS_NT: u32 = 0x1;
pub const OS_WIN95ORGREATER: u32 = 0x2;
pub const OS_NT4ORGREATER: u32 = 0x3;
pub const OS_WIN98ORGREATER: u32 = 0x5;
pub const OS_WIN98_GOLD: u32 = 0x6;
pub const OS_WIN2000ORGREATER: u32 = 0x7;
pub const OS_WIN2000PRO: u32 = 0x8;
pub const OS_WIN2000SERVER: u32 = 0x9;
pub const OS_WIN2000ADVSERVER: u32 = 0xA;
pub const OS_WIN2000DATACENTER: u32 = 0xB;
pub const OS_WIN2000TERMINAL: u32 = 0xC;
pub const OS_EMBEDDED: u32 = 0xD;
pub const OS_TERMINALCLIENT: u32 = 0xE;
pub const OS_TERMINALREMOTEADMIN: u32 = 0xF;
pub const OS_WIN95_GOLD: u32 = 0x10;
pub const OS_MEORGREATER: u32 = 0x11;
pub const OS_XPORGREATER: u32 = 0x12;
pub const OS_HOME: u32 = 0x13;
pub const OS_PROFESSIONAL: u32 = 0x14;
pub const OS_DATACENTER: u32 = 0x15;
pub const OS_ADVSERVER: u32 = 0x16;
pub const OS_SERVER: u32 = 0x17;
pub const OS_TERMINALSERVER: u32 = 0x18;
pub const OS_PERSONALTERMINALSERVER: u32 = 0x19;
pub const OS_FASTUSERSWITCHING: u32 = 0x1A;
pub const OS_WELCOMELOGONUI: u32 = 0x1B;
pub const OS_DOMAINMEMBER: u32 = 0x1C;
pub const OS_ANYSERVER: u32 = 0x1D;
pub const OS_WOW6432: u32 = 0x1E;
pub const OS_WEBSERVER: u32 = 0x1F;
pub const OS_SMALLBUSINESSSERVER: u32 = 0x20;
pub const OS_TABLETPC: u32 = 0x21;
pub const OS_SERVERADMINUI: u32 = 0x22;
pub const OS_MEDIACENTER: u32 = 0x23;
pub const OS_APPLIANCE: u32 = 0x24;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Outlinetextmetrica<'a> {
    pub otm_size: u32,
    pub otm_text_metrics: Textmetrica,
    pub otm_filler: u8,
    pub otm_panose_number: Panose,
    pub otmfs_selection: u32,
    pub otmfs_type: u32,
    pub otms_char_slope_rise: i32,
    pub otms_char_slope_run: i32,
    pub otm_italic_angle: i32,
    pub otm_em_square: u32,
    pub otm_ascent: i32,
    pub otm_descent: i32,
    pub otm_line_gap: u32,
    pub otms_cap_em_height: u32,
    pub otms_x_height: u32,
    pub otmrc_font_box: Rect,
    pub otm_mac_ascent: i32,
    pub otm_mac_descent: i32,
    pub otm_mac_line_gap: u32,
    pub otmus_minimum_ppem: u32,
    pub otmpt_subscript_size: Point,
    pub otmpt_subscript_offset: Point,
    pub otmpt_superscript_size: Point,
    pub otmpt_superscript_offset: Point,
    pub otms_strikeout_size: u32,
    pub otms_strikeout_position: i32,
    pub otms_underscore_size: i32,
    pub otms_underscore_position: i32,
    pub otmp_family_name: Cow<'a, CStr>,
    pub otmp_face_name: Cow<'a, CStr>,
    pub otmp_style_name: Cow<'a, CStr>,
    pub otmp_full_name: Cow<'a, CStr>,
}
impl Outlinetextmetrica {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::OUTLINETEXTMETRICA {
        let Self { otm_size, otm_text_metrics, otm_filler, otm_panose_number, otmfs_selection, otmfs_type, otms_char_slope_rise, otms_char_slope_run, otm_italic_angle, otm_em_square, otm_ascent, otm_descent, otm_line_gap, otms_cap_em_height, otms_x_height, otmrc_font_box, otm_mac_ascent, otm_mac_descent, otm_mac_line_gap, otmus_minimum_ppem, otmpt_subscript_size, otmpt_subscript_offset, otmpt_superscript_size, otmpt_superscript_offset, otms_strikeout_size, otms_strikeout_position, otms_underscore_size, otms_underscore_position, otmp_family_name, otmp_face_name, otmp_style_name, otmp_full_name } = self;
        let otmSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::OUTLINETEXTMETRICA>() as _;
        let otmTextMetrics = otm_text_metrics.to_win32();
        let otmFiller = *otm_filler;
        let otmPanoseNumber = otm_panose_number.to_win32();
        let otmfsSelection = *otmfs_selection;
        let otmfsType = *otmfs_type;
        let otmsCharSlopeRise = *otms_char_slope_rise;
        let otmsCharSlopeRun = *otms_char_slope_run;
        let otmItalicAngle = *otm_italic_angle;
        let otmEMSquare = *otm_em_square;
        let otmAscent = *otm_ascent;
        let otmDescent = *otm_descent;
        let otmLineGap = *otm_line_gap;
        let otmsCapEmHeight = *otms_cap_em_height;
        let otmsXHeight = *otms_x_height;
        let otmrcFontBox = otmrc_font_box.to_win32();
        let otmMacAscent = *otm_mac_ascent;
        let otmMacDescent = *otm_mac_descent;
        let otmMacLineGap = *otm_mac_line_gap;
        let otmusMinimumPPEM = *otmus_minimum_ppem;
        let otmptSubscriptSize = otmpt_subscript_size.to_win32();
        let otmptSubscriptOffset = otmpt_subscript_offset.to_win32();
        let otmptSuperscriptSize = otmpt_superscript_size.to_win32();
        let otmptSuperscriptOffset = otmpt_superscript_offset.to_win32();
        let otmsStrikeoutSize = *otms_strikeout_size;
        let otmsStrikeoutPosition = *otms_strikeout_position;
        let otmsUnderscoreSize = *otms_underscore_size;
        let otmsUnderscorePosition = *otms_underscore_position;
        let otmpFamilyName = otmp_family_name.as_ptr();
        let otmpFaceName = otmp_face_name.as_ptr();
        let otmpStyleName = otmp_style_name.as_ptr();
        let otmpFullName = otmp_full_name.as_ptr();
        windows_sys::Win32::Graphics::Gdi::OUTLINETEXTMETRICA { otmSize, otmTextMetrics, otmFiller, otmPanoseNumber, otmfsSelection, otmfsType, otmsCharSlopeRise, otmsCharSlopeRun, otmItalicAngle, otmEMSquare, otmAscent, otmDescent, otmLineGap, otmsCapEmHeight, otmsXHeight, otmrcFontBox, otmMacAscent, otmMacDescent, otmMacLineGap, otmusMinimumPPEM, otmptSubscriptSize, otmptSubscriptOffset, otmptSuperscriptSize, otmptSuperscriptOffset, otmsStrikeoutSize, otmsStrikeoutPosition, otmsUnderscoreSize, otmsUnderscorePosition, otmpFamilyName, otmpFaceName, otmpStyleName, otmpFullName }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::OUTLINETEXTMETRICA) -> Self {
        let windows_sys::Win32::Graphics::Gdi::OUTLINETEXTMETRICA { otmSize, otmTextMetrics, otmFiller, otmPanoseNumber, otmfsSelection, otmfsType, otmsCharSlopeRise, otmsCharSlopeRun, otmItalicAngle, otmEMSquare, otmAscent, otmDescent, otmLineGap, otmsCapEmHeight, otmsXHeight, otmrcFontBox, otmMacAscent, otmMacDescent, otmMacLineGap, otmusMinimumPPEM, otmptSubscriptSize, otmptSubscriptOffset, otmptSuperscriptSize, otmptSuperscriptOffset, otmsStrikeoutSize, otmsStrikeoutPosition, otmsUnderscoreSize, otmsUnderscorePosition, otmpFamilyName, otmpFaceName, otmpStyleName, otmpFullName } = win32;
        let otm_size = otmSize;
        let otm_text_metrics = unsafe { TEXTMETRICA::from_win32(otmTextMetrics) };
        let otm_filler = otmFiller;
        let otm_panose_number = unsafe { PANOSE::from_win32(otmPanoseNumber) };
        let otmfs_selection = otmfsSelection;
        let otmfs_type = otmfsType;
        let otms_char_slope_rise = otmsCharSlopeRise;
        let otms_char_slope_run = otmsCharSlopeRun;
        let otm_italic_angle = otmItalicAngle;
        let otm_em_square = otmEMSquare;
        let otm_ascent = otmAscent;
        let otm_descent = otmDescent;
        let otm_line_gap = otmLineGap;
        let otms_cap_em_height = otmsCapEmHeight;
        let otms_x_height = otmsXHeight;
        let otmrc_font_box = unsafe { RECT::from_win32(otmrcFontBox) };
        let otm_mac_ascent = otmMacAscent;
        let otm_mac_descent = otmMacDescent;
        let otm_mac_line_gap = otmMacLineGap;
        let otmus_minimum_ppem = otmusMinimumPPEM;
        let otmpt_subscript_size = unsafe { POINT::from_win32(otmptSubscriptSize) };
        let otmpt_subscript_offset = unsafe { POINT::from_win32(otmptSubscriptOffset) };
        let otmpt_superscript_size = unsafe { POINT::from_win32(otmptSuperscriptSize) };
        let otmpt_superscript_offset = unsafe { POINT::from_win32(otmptSuperscriptOffset) };
        let otms_strikeout_size = otmsStrikeoutSize;
        let otms_strikeout_position = otmsStrikeoutPosition;
        let otms_underscore_size = otmsUnderscoreSize;
        let otms_underscore_position = otmsUnderscorePosition;
        let otmpFamilyName = unsafe { CStr::from_ptr(otmpFamilyName) };
        let otmpFamilyName = otmpFamilyName.to_bytes_with_nul().to_vec();
        let otmp_family_name = Cow::Owned(unsafe { CString::from_vec_unchecked(otmpFamilyName) });
        let otmpFaceName = unsafe { CStr::from_ptr(otmpFaceName) };
        let otmpFaceName = otmpFaceName.to_bytes_with_nul().to_vec();
        let otmp_face_name = Cow::Owned(unsafe { CString::from_vec_unchecked(otmpFaceName) });
        let otmpStyleName = unsafe { CStr::from_ptr(otmpStyleName) };
        let otmpStyleName = otmpStyleName.to_bytes_with_nul().to_vec();
        let otmp_style_name = Cow::Owned(unsafe { CString::from_vec_unchecked(otmpStyleName) });
        let otmpFullName = unsafe { CStr::from_ptr(otmpFullName) };
        let otmpFullName = otmpFullName.to_bytes_with_nul().to_vec();
        let otmp_full_name = Cow::Owned(unsafe { CString::from_vec_unchecked(otmpFullName) });
        Self { otm_size, otm_text_metrics, otm_filler, otm_panose_number, otmfs_selection, otmfs_type, otms_char_slope_rise, otms_char_slope_run, otm_italic_angle, otm_em_square, otm_ascent, otm_descent, otm_line_gap, otms_cap_em_height, otms_x_height, otmrc_font_box, otm_mac_ascent, otm_mac_descent, otm_mac_line_gap, otmus_minimum_ppem, otmpt_subscript_size, otmpt_subscript_offset, otmpt_superscript_size, otmpt_superscript_offset, otms_strikeout_size, otms_strikeout_position, otms_underscore_size, otms_underscore_position, otmp_family_name, otmp_face_name, otmp_style_name, otmp_full_name }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Outlinetextmetricw<'a> {
    pub otm_size: u32,
    pub otm_text_metrics: Textmetricw,
    pub otm_filler: u8,
    pub otm_panose_number: Panose,
    pub otmfs_selection: u32,
    pub otmfs_type: u32,
    pub otms_char_slope_rise: i32,
    pub otms_char_slope_run: i32,
    pub otm_italic_angle: i32,
    pub otm_em_square: u32,
    pub otm_ascent: i32,
    pub otm_descent: i32,
    pub otm_line_gap: u32,
    pub otms_cap_em_height: u32,
    pub otms_x_height: u32,
    pub otmrc_font_box: Rect,
    pub otm_mac_ascent: i32,
    pub otm_mac_descent: i32,
    pub otm_mac_line_gap: u32,
    pub otmus_minimum_ppem: u32,
    pub otmpt_subscript_size: Point,
    pub otmpt_subscript_offset: Point,
    pub otmpt_superscript_size: Point,
    pub otmpt_superscript_offset: Point,
    pub otms_strikeout_size: u32,
    pub otms_strikeout_position: i32,
    pub otms_underscore_size: i32,
    pub otms_underscore_position: i32,
    pub otmp_family_name: Cow<'a, CStr>,
    pub otmp_face_name: Cow<'a, CStr>,
    pub otmp_style_name: Cow<'a, CStr>,
    pub otmp_full_name: Cow<'a, CStr>,
}
impl Outlinetextmetricw {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::OUTLINETEXTMETRICW {
        let Self { otm_size, otm_text_metrics, otm_filler, otm_panose_number, otmfs_selection, otmfs_type, otms_char_slope_rise, otms_char_slope_run, otm_italic_angle, otm_em_square, otm_ascent, otm_descent, otm_line_gap, otms_cap_em_height, otms_x_height, otmrc_font_box, otm_mac_ascent, otm_mac_descent, otm_mac_line_gap, otmus_minimum_ppem, otmpt_subscript_size, otmpt_subscript_offset, otmpt_superscript_size, otmpt_superscript_offset, otms_strikeout_size, otms_strikeout_position, otms_underscore_size, otms_underscore_position, otmp_family_name, otmp_face_name, otmp_style_name, otmp_full_name } = self;
        let otmSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::OUTLINETEXTMETRICW>() as _;
        let otmTextMetrics = otm_text_metrics.to_win32();
        let otmFiller = *otm_filler;
        let otmPanoseNumber = otm_panose_number.to_win32();
        let otmfsSelection = *otmfs_selection;
        let otmfsType = *otmfs_type;
        let otmsCharSlopeRise = *otms_char_slope_rise;
        let otmsCharSlopeRun = *otms_char_slope_run;
        let otmItalicAngle = *otm_italic_angle;
        let otmEMSquare = *otm_em_square;
        let otmAscent = *otm_ascent;
        let otmDescent = *otm_descent;
        let otmLineGap = *otm_line_gap;
        let otmsCapEmHeight = *otms_cap_em_height;
        let otmsXHeight = *otms_x_height;
        let otmrcFontBox = otmrc_font_box.to_win32();
        let otmMacAscent = *otm_mac_ascent;
        let otmMacDescent = *otm_mac_descent;
        let otmMacLineGap = *otm_mac_line_gap;
        let otmusMinimumPPEM = *otmus_minimum_ppem;
        let otmptSubscriptSize = otmpt_subscript_size.to_win32();
        let otmptSubscriptOffset = otmpt_subscript_offset.to_win32();
        let otmptSuperscriptSize = otmpt_superscript_size.to_win32();
        let otmptSuperscriptOffset = otmpt_superscript_offset.to_win32();
        let otmsStrikeoutSize = *otms_strikeout_size;
        let otmsStrikeoutPosition = *otms_strikeout_position;
        let otmsUnderscoreSize = *otms_underscore_size;
        let otmsUnderscorePosition = *otms_underscore_position;
        let otmpFamilyName = otmp_family_name.as_ptr();
        let otmpFaceName = otmp_face_name.as_ptr();
        let otmpStyleName = otmp_style_name.as_ptr();
        let otmpFullName = otmp_full_name.as_ptr();
        windows_sys::Win32::Graphics::Gdi::OUTLINETEXTMETRICW { otmSize, otmTextMetrics, otmFiller, otmPanoseNumber, otmfsSelection, otmfsType, otmsCharSlopeRise, otmsCharSlopeRun, otmItalicAngle, otmEMSquare, otmAscent, otmDescent, otmLineGap, otmsCapEmHeight, otmsXHeight, otmrcFontBox, otmMacAscent, otmMacDescent, otmMacLineGap, otmusMinimumPPEM, otmptSubscriptSize, otmptSubscriptOffset, otmptSuperscriptSize, otmptSuperscriptOffset, otmsStrikeoutSize, otmsStrikeoutPosition, otmsUnderscoreSize, otmsUnderscorePosition, otmpFamilyName, otmpFaceName, otmpStyleName, otmpFullName }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::OUTLINETEXTMETRICW) -> Self {
        let windows_sys::Win32::Graphics::Gdi::OUTLINETEXTMETRICW { otmSize, otmTextMetrics, otmFiller, otmPanoseNumber, otmfsSelection, otmfsType, otmsCharSlopeRise, otmsCharSlopeRun, otmItalicAngle, otmEMSquare, otmAscent, otmDescent, otmLineGap, otmsCapEmHeight, otmsXHeight, otmrcFontBox, otmMacAscent, otmMacDescent, otmMacLineGap, otmusMinimumPPEM, otmptSubscriptSize, otmptSubscriptOffset, otmptSuperscriptSize, otmptSuperscriptOffset, otmsStrikeoutSize, otmsStrikeoutPosition, otmsUnderscoreSize, otmsUnderscorePosition, otmpFamilyName, otmpFaceName, otmpStyleName, otmpFullName } = win32;
        let otm_size = otmSize;
        let otm_text_metrics = unsafe { TEXTMETRICW::from_win32(otmTextMetrics) };
        let otm_filler = otmFiller;
        let otm_panose_number = unsafe { PANOSE::from_win32(otmPanoseNumber) };
        let otmfs_selection = otmfsSelection;
        let otmfs_type = otmfsType;
        let otms_char_slope_rise = otmsCharSlopeRise;
        let otms_char_slope_run = otmsCharSlopeRun;
        let otm_italic_angle = otmItalicAngle;
        let otm_em_square = otmEMSquare;
        let otm_ascent = otmAscent;
        let otm_descent = otmDescent;
        let otm_line_gap = otmLineGap;
        let otms_cap_em_height = otmsCapEmHeight;
        let otms_x_height = otmsXHeight;
        let otmrc_font_box = unsafe { RECT::from_win32(otmrcFontBox) };
        let otm_mac_ascent = otmMacAscent;
        let otm_mac_descent = otmMacDescent;
        let otm_mac_line_gap = otmMacLineGap;
        let otmus_minimum_ppem = otmusMinimumPPEM;
        let otmpt_subscript_size = unsafe { POINT::from_win32(otmptSubscriptSize) };
        let otmpt_subscript_offset = unsafe { POINT::from_win32(otmptSubscriptOffset) };
        let otmpt_superscript_size = unsafe { POINT::from_win32(otmptSuperscriptSize) };
        let otmpt_superscript_offset = unsafe { POINT::from_win32(otmptSuperscriptOffset) };
        let otms_strikeout_size = otmsStrikeoutSize;
        let otms_strikeout_position = otmsStrikeoutPosition;
        let otms_underscore_size = otmsUnderscoreSize;
        let otms_underscore_position = otmsUnderscorePosition;
        let otmpFamilyName = unsafe { CStr::from_ptr(otmpFamilyName) };
        let otmpFamilyName = otmpFamilyName.to_bytes_with_nul().to_vec();
        let otmp_family_name = Cow::Owned(unsafe { CString::from_vec_unchecked(otmpFamilyName) });
        let otmpFaceName = unsafe { CStr::from_ptr(otmpFaceName) };
        let otmpFaceName = otmpFaceName.to_bytes_with_nul().to_vec();
        let otmp_face_name = Cow::Owned(unsafe { CString::from_vec_unchecked(otmpFaceName) });
        let otmpStyleName = unsafe { CStr::from_ptr(otmpStyleName) };
        let otmpStyleName = otmpStyleName.to_bytes_with_nul().to_vec();
        let otmp_style_name = Cow::Owned(unsafe { CString::from_vec_unchecked(otmpStyleName) });
        let otmpFullName = unsafe { CStr::from_ptr(otmpFullName) };
        let otmpFullName = otmpFullName.to_bytes_with_nul().to_vec();
        let otmp_full_name = Cow::Owned(unsafe { CString::from_vec_unchecked(otmpFullName) });
        Self { otm_size, otm_text_metrics, otm_filler, otm_panose_number, otmfs_selection, otmfs_type, otms_char_slope_rise, otms_char_slope_run, otm_italic_angle, otm_em_square, otm_ascent, otm_descent, otm_line_gap, otms_cap_em_height, otms_x_height, otmrc_font_box, otm_mac_ascent, otm_mac_descent, otm_mac_line_gap, otmus_minimum_ppem, otmpt_subscript_size, otmpt_subscript_offset, otmpt_superscript_size, otmpt_superscript_offset, otms_strikeout_size, otms_strikeout_position, otms_underscore_size, otms_underscore_position, otmp_family_name, otmp_face_name, otmp_style_name, otmp_full_name }
    }
}
pub const OFS_INACTIVE: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
pub const OFS_ONLINE: i32 = 0x0;
pub const OFS_OFFLINE: i32 = 0x1;
pub const OFS_SERVERBACK: i32 = 0x2;
pub const OFS_DIRTYCACHE: i32 = 0x3;
pub const PES_UNKNOWN: i32 = 0x0;
pub const PES_RUNNING: i32 = 0x1;
pub const PES_SUSPENDING: i32 = 0x2;
pub const PES_SUSPENDED: i32 = 0x3;
pub const PES_TERMINATED: i32 = 0x4;
pub const PGRP_UP: i32 = 0x1;
pub const PGRP_DOWN: i32 = 0x2;
pub const PGRP_UPHORZ: i32 = 0x3;
pub const PGRP_DOWNHORZ: i32 = 0x4;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Paintstruct {
    pub hdc: Option<Hdc>,
    pub f_erase: BOOL,
    pub rc_paint: Rect,
    pub f_restore: BOOL,
    pub f_inc_update: BOOL,
    pub rgb_reserved: [u8; 32],
}
impl Paintstruct {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::PAINTSTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::PAINTSTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Paletteentry {
    pub pe_red: u8,
    pub pe_green: u8,
    pub pe_blue: u8,
    pub pe_flags: u8,
}
impl Paletteentry {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::PALETTEENTRY {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::PALETTEENTRY) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Panose {
    pub b_family_type: u8,
    pub b_serif_style: u8,
    pub b_weight: u8,
    pub b_proportion: u8,
    pub b_contrast: u8,
    pub b_stroke_variation: u8,
    pub b_arm_style: u8,
    pub b_letterform: u8,
    pub b_midline: u8,
    pub b_x_height: u8,
}
impl Panose {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::PANOSE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::PANOSE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Parsedurla<'a> {
    pub cb_size: u32,
    pub psz_protocol: Cow<'a, CStr>,
    pub cch_protocol: u32,
    pub psz_suffix: Cow<'a, CStr>,
    pub cch_suffix: u32,
    pub n_scheme: u32,
}
impl Parsedurla {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::PARSEDURLA {
        let Self { cb_size, psz_protocol, cch_protocol, psz_suffix, cch_suffix, n_scheme } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::PARSEDURLA>() as _;
        let pszProtocol = psz_protocol.as_ptr();
        let cchProtocol = *cch_protocol;
        let pszSuffix = psz_suffix.as_ptr();
        let cchSuffix = *cch_suffix;
        let nScheme = *n_scheme;
        windows_sys::Win32::UI::Shell::PARSEDURLA { cbSize, pszProtocol, cchProtocol, pszSuffix, cchSuffix, nScheme }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::PARSEDURLA) -> Self {
        let windows_sys::Win32::UI::Shell::PARSEDURLA { cbSize, pszProtocol, cchProtocol, pszSuffix, cchSuffix, nScheme } = win32;
        let cb_size = cbSize;
        let pszProtocol = unsafe { CStr::from_ptr(pszProtocol) };
        let pszProtocol = pszProtocol.to_bytes_with_nul().to_vec();
        let psz_protocol = Cow::Owned(unsafe { CString::from_vec_unchecked(pszProtocol) });
        let cch_protocol = cchProtocol;
        let pszSuffix = unsafe { CStr::from_ptr(pszSuffix) };
        let pszSuffix = pszSuffix.to_bytes_with_nul().to_vec();
        let psz_suffix = Cow::Owned(unsafe { CString::from_vec_unchecked(pszSuffix) });
        let cch_suffix = cchSuffix;
        let n_scheme = nScheme;
        Self { cb_size, psz_protocol, cch_protocol, psz_suffix, cch_suffix, n_scheme }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Parsedurlw<'a> {
    pub cb_size: u32,
    pub psz_protocol: Cow<'a, [u16]>,
    pub cch_protocol: u32,
    pub psz_suffix: Cow<'a, [u16]>,
    pub cch_suffix: u32,
    pub n_scheme: u32,
}
impl Parsedurlw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::PARSEDURLW {
        let Self { cb_size, psz_protocol, cch_protocol, psz_suffix, cch_suffix, n_scheme } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::PARSEDURLW>() as _;
        assert_eq!(psz_protocol.last(), Some(0));
        let pszProtocol = psz_protocol.as_ptr();
        let cchProtocol = *cch_protocol;
        assert_eq!(psz_suffix.last(), Some(0));
        let pszSuffix = psz_suffix.as_ptr();
        let cchSuffix = *cch_suffix;
        let nScheme = *n_scheme;
        windows_sys::Win32::UI::Shell::PARSEDURLW { cbSize, pszProtocol, cchProtocol, pszSuffix, cchSuffix, nScheme }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::PARSEDURLW) -> Self {
        let windows_sys::Win32::UI::Shell::PARSEDURLW { cbSize, pszProtocol, cchProtocol, pszSuffix, cchSuffix, nScheme } = win32;
        let cb_size = cbSize;
        let slen = unsafe { wide_strlen(pszProtocol as *const u16) };
        let pszProtocol = unsafe { slice::from_raw_parts(pszProtocol, slen + 1) };
        let psz_protocol = pszProtocol.to_vec();
        let cch_protocol = cchProtocol;
        let slen = unsafe { wide_strlen(pszSuffix as *const u16) };
        let pszSuffix = unsafe { slice::from_raw_parts(pszSuffix, slen + 1) };
        let psz_suffix = pszSuffix.to_vec();
        let cch_suffix = cchSuffix;
        let n_scheme = nScheme;
        Self { cb_size, psz_protocol, cch_protocol, psz_suffix, cch_suffix, n_scheme }
    }
}
pub const PATHCCH_NONE: i32 = 0x0;
pub const PATHCCH_ALLOW_LONG_PATHS: i32 = 0x1;
pub const PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS: i32 = 0x2;
pub const PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS: i32 = 0x4;
pub const PATHCCH_DO_NOT_NORMALIZE_SEGMENTS: i32 = 0x8;
pub const PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH: i32 = 0x10;
pub const PATHCCH_ENSURE_TRAILING_SLASH: i32 = 0x20;
pub const PATHCCH_CANONICALIZE_SLASHES: i32 = 0x40;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Pbrange {
    pub i_low: i32,
    pub i_high: i32,
}
impl Pbrange {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::PBRANGE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::PBRANGE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const PCS_FATAL: u32 = 0x80000000;
pub const PCS_REPLACEDCHAR: u32 = 0x1;
pub const PCS_REMOVEDCHAR: u32 = 0x2;
pub const PCS_TRUNCATED: u32 = 0x4;
pub const PCS_PATHTOOLONG: u32 = 0x8;
pub const PM_NOREMOVE: u32 = 0x0;
pub const PM_REMOVE: u32 = 0x1;
pub const PM_NOYIELD: u32 = 0x2;
pub const PM_QS_INPUT: u32 = 0x4070000;
pub const PM_QS_POSTMESSAGE: u32 = 0x980000;
pub const PM_QS_PAINT: u32 = 0x200000;
pub const PM_QS_SENDMESSAGE: u32 = 0x400000;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Pelarray {
    pub pa_x_count: i32,
    pub pa_y_count: i32,
    pub pa_x_ext: i32,
    pub pa_y_ext: i32,
    pub pa_rg_bs: u8,
}
impl Pelarray {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::PELARRAY {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::PELARRAY) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const PS_GEOMETRIC: u32 = 0x10000;
pub const PS_COSMETIC: u32 = 0x0;
pub const PS_SOLID: u32 = 0x0;
pub const PS_DASH: u32 = 0x1;
pub const PS_DOT: u32 = 0x2;
pub const PS_DASHDOT: u32 = 0x3;
pub const PS_DASHDOTDOT: u32 = 0x4;
pub const PS_NULL: u32 = 0x5;
pub const PS_INSIDEFRAME: u32 = 0x6;
pub const PS_USERSTYLE: u32 = 0x7;
pub const PS_ALTERNATE: u32 = 0x8;
pub const PS_STYLE_MASK: u32 = 0xF;
pub const PS_ENDCAP_ROUND: u32 = 0x0;
pub const PS_ENDCAP_SQUARE: u32 = 0x100;
pub const PS_ENDCAP_FLAT: u32 = 0x200;
pub const PS_ENDCAP_MASK: u32 = 0xF00;
pub const PS_JOIN_ROUND: u32 = 0x0;
pub const PS_JOIN_BEVEL: u32 = 0x1000;
pub const PS_JOIN_MITER: u32 = 0x2000;
pub const PS_JOIN_MASK: u32 = 0xF000;
pub const PS_TYPE_MASK: u32 = 0xF0000;
pub const PFD_DOUBLEBUFFER: u32 = 0x1;
pub const PFD_STEREO: u32 = 0x2;
pub const PFD_DRAW_TO_WINDOW: u32 = 0x4;
pub const PFD_DRAW_TO_BITMAP: u32 = 0x8;
pub const PFD_SUPPORT_GDI: u32 = 0x10;
pub const PFD_SUPPORT_OPENGL: u32 = 0x20;
pub const PFD_GENERIC_FORMAT: u32 = 0x40;
pub const PFD_NEED_PALETTE: u32 = 0x80;
pub const PFD_NEED_SYSTEM_PALETTE: u32 = 0x100;
pub const PFD_SWAP_EXCHANGE: u32 = 0x200;
pub const PFD_SWAP_COPY: u32 = 0x400;
pub const PFD_SWAP_LAYER_BUFFERS: u32 = 0x800;
pub const PFD_GENERIC_ACCELERATED: u32 = 0x1000;
pub const PFD_SUPPORT_DIRECTDRAW: u32 = 0x2000;
pub const PFD_DIRECT3D_ACCELERATED: u32 = 0x4000;
pub const PFD_SUPPORT_COMPOSITION: u32 = 0x8000;
pub const PFD_DEPTH_DONTCARE: u32 = 0x20000000;
pub const PFD_DOUBLEBUFFER_DONTCARE: u32 = 0x40000000;
pub const PFD_STEREO_DONTCARE: u32 = 0x80000000;
pub const PFD_UNDERLAY_PLANE: i8 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
pub const PFD_MAIN_PLANE: i8 = 0x0;
pub const PFD_OVERLAY_PLANE: i8 = 0x1;
pub const PFD_TYPE_RGBA: i8 = 0x0;
pub const PFD_TYPE_COLORINDEX: i8 = 0x1;
pub const PIDISF_RECENTLYCHANGED: i32 = 0x1;
pub const PIDISF_CACHEDSTICKY: i32 = 0x2;
pub const PIDISF_CACHEIMAGES: i32 = 0x10;
pub const PIDISF_FOLLOWALLLINKS: i32 = 0x20;
pub const PIDISM_GLOBAL: i32 = 0x0;
pub const PIDISM_WATCH: i32 = 0x1;
pub const PIDISM_DONTWATCH: i32 = 0x2;
pub const PIDISR_UP_TO_DATE: i32 = 0x0;
pub const PIDISR_NEEDS_ADD: i32 = 0x1;
pub const PIDISR_NEEDS_UPDATE: i32 = 0x2;
pub const PIDISR_NEEDS_DELETE: i32 = 0x3;
pub const PID_INTSITE_WHATSNEW: i32 = 0x2;
pub const PID_INTSITE_AUTHOR: i32 = 0x3;
pub const PID_INTSITE_LASTVISIT: i32 = 0x4;
pub const PID_INTSITE_LASTMOD: i32 = 0x5;
pub const PID_INTSITE_VISITCOUNT: i32 = 0x6;
pub const PID_INTSITE_DESCRIPTION: i32 = 0x7;
pub const PID_INTSITE_COMMENT: i32 = 0x8;
pub const PID_INTSITE_FLAGS: i32 = 0x9;
pub const PID_INTSITE_CONTENTLEN: i32 = 0xA;
pub const PID_INTSITE_CONTENTCODE: i32 = 0xB;
pub const PID_INTSITE_RECURSE: i32 = 0xC;
pub const PID_INTSITE_WATCH: i32 = 0xD;
pub const PID_INTSITE_SUBSCRIPTION: i32 = 0xE;
pub const PID_INTSITE_URL: i32 = 0xF;
pub const PID_INTSITE_TITLE: i32 = 0x10;
pub const PID_INTSITE_CODEPAGE: i32 = 0x12;
pub const PID_INTSITE_TRACKING: i32 = 0x13;
pub const PID_INTSITE_ICONINDEX: i32 = 0x14;
pub const PID_INTSITE_ICONFILE: i32 = 0x15;
pub const PID_INTSITE_ROAMED: i32 = 0x22;
pub const PID_IS_URL: i32 = 0x2;
pub const PID_IS_NAME: i32 = 0x4;
pub const PID_IS_WORKINGDIR: i32 = 0x5;
pub const PID_IS_HOTKEY: i32 = 0x6;
pub const PID_IS_SHOWCMD: i32 = 0x7;
pub const PID_IS_ICONINDEX: i32 = 0x8;
pub const PID_IS_ICONFILE: i32 = 0x9;
pub const PID_IS_WHATSNEW: i32 = 0xA;
pub const PID_IS_AUTHOR: i32 = 0xB;
pub const PID_IS_DESCRIPTION: i32 = 0xC;
pub const PID_IS_COMMENT: i32 = 0xD;
pub const PID_IS_ROAMED: i32 = 0xF;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Pixelformatdescriptor {
    pub n_size: u16,
    pub n_version: u16,
    pub dw_flags: u32,
    pub i_pixel_type: i8,
    pub c_color_bits: u8,
    pub c_red_bits: u8,
    pub c_red_shift: u8,
    pub c_green_bits: u8,
    pub c_green_shift: u8,
    pub c_blue_bits: u8,
    pub c_blue_shift: u8,
    pub c_alpha_bits: u8,
    pub c_alpha_shift: u8,
    pub c_accum_bits: u8,
    pub c_accum_red_bits: u8,
    pub c_accum_green_bits: u8,
    pub c_accum_blue_bits: u8,
    pub c_accum_alpha_bits: u8,
    pub c_depth_bits: u8,
    pub c_stencil_bits: u8,
    pub c_aux_buffers: u8,
    pub i_layer_type: i8,
    pub b_reserved: u8,
    pub dw_layer_mask: u32,
    pub dw_visible_mask: u32,
    pub dw_damage_mask: u32,
}
impl Pixelformatdescriptor {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::OpenGL::PIXELFORMATDESCRIPTOR {
        let Self { n_size, n_version, dw_flags, i_pixel_type, c_color_bits, c_red_bits, c_red_shift, c_green_bits, c_green_shift, c_blue_bits, c_blue_shift, c_alpha_bits, c_alpha_shift, c_accum_bits, c_accum_red_bits, c_accum_green_bits, c_accum_blue_bits, c_accum_alpha_bits, c_depth_bits, c_stencil_bits, c_aux_buffers, i_layer_type, b_reserved, dw_layer_mask, dw_visible_mask, dw_damage_mask } = self;
        let nSize = mem::size_of::<windows_sys::Win32::Graphics::OpenGL::PIXELFORMATDESCRIPTOR>() as _;
        let nVersion = *n_version;
        let dwFlags = dw_flags;
        let iPixelType = i_pixel_type;
        let cColorBits = *c_color_bits;
        let cRedBits = *c_red_bits;
        let cRedShift = *c_red_shift;
        let cGreenBits = *c_green_bits;
        let cGreenShift = *c_green_shift;
        let cBlueBits = *c_blue_bits;
        let cBlueShift = *c_blue_shift;
        let cAlphaBits = *c_alpha_bits;
        let cAlphaShift = *c_alpha_shift;
        let cAccumBits = *c_accum_bits;
        let cAccumRedBits = *c_accum_red_bits;
        let cAccumGreenBits = *c_accum_green_bits;
        let cAccumBlueBits = *c_accum_blue_bits;
        let cAccumAlphaBits = *c_accum_alpha_bits;
        let cDepthBits = *c_depth_bits;
        let cStencilBits = *c_stencil_bits;
        let cAuxBuffers = *c_aux_buffers;
        let iLayerType = i_layer_type;
        let bReserved = *b_reserved;
        let dwLayerMask = *dw_layer_mask;
        let dwVisibleMask = *dw_visible_mask;
        let dwDamageMask = *dw_damage_mask;
        windows_sys::Win32::Graphics::OpenGL::PIXELFORMATDESCRIPTOR { nSize, nVersion, dwFlags, iPixelType, cColorBits, cRedBits, cRedShift, cGreenBits, cGreenShift, cBlueBits, cBlueShift, cAlphaBits, cAlphaShift, cAccumBits, cAccumRedBits, cAccumGreenBits, cAccumBlueBits, cAccumAlphaBits, cDepthBits, cStencilBits, cAuxBuffers, iLayerType, bReserved, dwLayerMask, dwVisibleMask, dwDamageMask }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::OpenGL::PIXELFORMATDESCRIPTOR) -> Self {
        let windows_sys::Win32::Graphics::OpenGL::PIXELFORMATDESCRIPTOR { nSize, nVersion, dwFlags, iPixelType, cColorBits, cRedBits, cRedShift, cGreenBits, cGreenShift, cBlueBits, cBlueShift, cAlphaBits, cAlphaShift, cAccumBits, cAccumRedBits, cAccumGreenBits, cAccumBlueBits, cAccumAlphaBits, cDepthBits, cStencilBits, cAuxBuffers, iLayerType, bReserved, dwLayerMask, dwVisibleMask, dwDamageMask } = win32;
        let n_size = nSize;
        let n_version = nVersion;
        let dw_flags = dwFlags;
        let i_pixel_type = iPixelType;
        let c_color_bits = cColorBits;
        let c_red_bits = cRedBits;
        let c_red_shift = cRedShift;
        let c_green_bits = cGreenBits;
        let c_green_shift = cGreenShift;
        let c_blue_bits = cBlueBits;
        let c_blue_shift = cBlueShift;
        let c_alpha_bits = cAlphaBits;
        let c_alpha_shift = cAlphaShift;
        let c_accum_bits = cAccumBits;
        let c_accum_red_bits = cAccumRedBits;
        let c_accum_green_bits = cAccumGreenBits;
        let c_accum_blue_bits = cAccumBlueBits;
        let c_accum_alpha_bits = cAccumAlphaBits;
        let c_depth_bits = cDepthBits;
        let c_stencil_bits = cStencilBits;
        let c_aux_buffers = cAuxBuffers;
        let i_layer_type = iLayerType;
        let b_reserved = bReserved;
        let dw_layer_mask = dwLayerMask;
        let dw_visible_mask = dwVisibleMask;
        let dw_damage_mask = dwDamageMask;
        Self { n_size, n_version, dw_flags, i_pixel_type, c_color_bits, c_red_bits, c_red_shift, c_green_bits, c_green_shift, c_blue_bits, c_blue_shift, c_alpha_bits, c_alpha_shift, c_accum_bits, c_accum_red_bits, c_accum_green_bits, c_accum_blue_bits, c_accum_alpha_bits, c_depth_bits, c_stencil_bits, c_aux_buffers, i_layer_type, b_reserved, dw_layer_mask, dw_visible_mask, dw_damage_mask }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Point {
    pub x: i32,
    pub y: i32,
}
impl Point {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::POINT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::POINT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const POINTER_CHANGE_NONE: i32 = 0x0;
pub const POINTER_CHANGE_FIRSTBUTTON_DOWN: i32 = 0x1;
pub const POINTER_CHANGE_FIRSTBUTTON_UP: i32 = 0x2;
pub const POINTER_CHANGE_SECONDBUTTON_DOWN: i32 = 0x3;
pub const POINTER_CHANGE_SECONDBUTTON_UP: i32 = 0x4;
pub const POINTER_CHANGE_THIRDBUTTON_DOWN: i32 = 0x5;
pub const POINTER_CHANGE_THIRDBUTTON_UP: i32 = 0x6;
pub const POINTER_CHANGE_FOURTHBUTTON_DOWN: i32 = 0x7;
pub const POINTER_CHANGE_FOURTHBUTTON_UP: i32 = 0x8;
pub const POINTER_CHANGE_FIFTHBUTTON_DOWN: i32 = 0x9;
pub const POINTER_CHANGE_FIFTHBUTTON_UP: i32 = 0xA;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct PointerDeviceCursorInfo {
    pub cursor_id: u32,
    pub cursor: i32,
}
impl PointerDeviceCursorInfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::POINTER_DEVICE_CURSOR_INFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::POINTER_DEVICE_CURSOR_INFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const POINTER_DEVICE_CURSOR_TYPE_UNKNOWN: i32 = 0x0;
pub const POINTER_DEVICE_CURSOR_TYPE_TIP: i32 = 0x1;
pub const POINTER_DEVICE_CURSOR_TYPE_ERASER: i32 = 0x2;
pub const POINTER_DEVICE_CURSOR_TYPE_MAX: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct PointerDeviceInfo {
    pub display_orientation: u32,
    pub device: Option<Handle>,
    pub pointer_device_type: i32,
    pub monitor: Option<Hmonitor>,
    pub starting_cursor_id: u32,
    pub max_active_contacts: u16,
    pub product_string: [u8; 520],
}
impl PointerDeviceInfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::POINTER_DEVICE_INFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::POINTER_DEVICE_INFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct PointerDeviceProperty {
    pub logical_min: i32,
    pub logical_max: i32,
    pub physical_min: i32,
    pub physical_max: i32,
    pub unit: u32,
    pub unit_exponent: u32,
    pub usage_page_id: u16,
    pub usage_id: u16,
}
impl PointerDeviceProperty {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::POINTER_DEVICE_PROPERTY {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::POINTER_DEVICE_PROPERTY) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const POINTER_DEVICE_TYPE_INTEGRATED_PEN: i32 = 0x1;
pub const POINTER_DEVICE_TYPE_EXTERNAL_PEN: i32 = 0x2;
pub const POINTER_DEVICE_TYPE_TOUCH: i32 = 0x3;
pub const POINTER_DEVICE_TYPE_TOUCH_PAD: i32 = 0x4;
pub const POINTER_DEVICE_TYPE_MAX: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
pub const POINTER_FEEDBACK_DEFAULT: i32 = 0x1;
pub const POINTER_FEEDBACK_INDIRECT: i32 = 0x2;
pub const POINTER_FEEDBACK_NONE: i32 = 0x3;
pub const POINTER_FLAG_NONE: u32 = 0x0;
pub const POINTER_FLAG_NEW: u32 = 0x1;
pub const POINTER_FLAG_INRANGE: u32 = 0x2;
pub const POINTER_FLAG_INCONTACT: u32 = 0x4;
pub const POINTER_FLAG_FIRSTBUTTON: u32 = 0x10;
pub const POINTER_FLAG_SECONDBUTTON: u32 = 0x20;
pub const POINTER_FLAG_THIRDBUTTON: u32 = 0x40;
pub const POINTER_FLAG_FOURTHBUTTON: u32 = 0x80;
pub const POINTER_FLAG_FIFTHBUTTON: u32 = 0x100;
pub const POINTER_FLAG_PRIMARY: u32 = 0x2000;
pub const POINTER_FLAG_CONFIDENCE: u32 = 0x4000;
pub const POINTER_FLAG_CANCELED: u32 = 0x8000;
pub const POINTER_FLAG_DOWN: u32 = 0x10000;
pub const POINTER_FLAG_UPDATE: u32 = 0x20000;
pub const POINTER_FLAG_UP: u32 = 0x40000;
pub const POINTER_FLAG_WHEEL: u32 = 0x80000;
pub const POINTER_FLAG_HWHEEL: u32 = 0x100000;
pub const POINTER_FLAG_CAPTURECHANGED: u32 = 0x200000;
pub const POINTER_FLAG_HASTRANSFORM: u32 = 0x400000;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct PointerInfo {
    pub pointer_type: i32,
    pub pointer_id: u32,
    pub frame_id: u32,
    pub pointer_flags: u32,
    pub source_device: Option<Handle>,
    pub hwnd_target: Option<Hwnd>,
    pub pt_pixel_location: Point,
    pub pt_himetric_location: Point,
    pub pt_pixel_location_raw: Point,
    pub pt_himetric_location_raw: Point,
    pub dw_time: u32,
    pub history_count: u32,
    pub input_data: i32,
    pub dw_key_states: u32,
    pub performance_count: u64,
    pub button_change_type: i32,
}
impl PointerInfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Input::Pointer::POINTER_INFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Input::Pointer::POINTER_INFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const PT_POINTER: i32 = 0x1;
pub const PT_TOUCH: i32 = 0x2;
pub const PT_PEN: i32 = 0x3;
pub const PT_MOUSE: i32 = 0x4;
pub const PT_TOUCHPAD: i32 = 0x5;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct PointerPenInfo {
    pub pointer_info: PointerInfo,
    pub pen_flags: u32,
    pub pen_mask: u32,
    pub pressure: u32,
    pub rotation: u32,
    pub tilt_x: i32,
    pub tilt_y: i32,
}
impl PointerPenInfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Input::Pointer::POINTER_PEN_INFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Input::Pointer::POINTER_PEN_INFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct PointerTouchInfo {
    pub pointer_info: PointerInfo,
    pub touch_flags: u32,
    pub touch_mask: u32,
    pub rc_contact: Rect,
    pub rc_contact_raw: Rect,
    pub orientation: u32,
    pub pressure: u32,
}
impl PointerTouchInfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Input::Pointer::POINTER_TOUCH_INFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Input::Pointer::POINTER_TOUCH_INFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct PointerTypeInfo {
    pub r#type: i32,
    pub anonymous: PointerTypeInfo4,
}
impl PointerTypeInfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::POINTER_TYPE_INFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::POINTER_TYPE_INFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[repr(C)]
pub union PointerTypeInfo4 {
    pub field0: PointerTouchInfo,
    pub field1: PointerPenInfo,
}
impl PointerTypeInfo4 {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::POINTER_TYPE_INFO_4 {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::POINTER_TYPE_INFO_4) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Pointfloat {
    pub x: f32,
    pub y: f32,
}
impl Pointfloat {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::OpenGL::POINTFLOAT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::OpenGL::POINTFLOAT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Pointfx {
    pub x: Fixed,
    pub y: Fixed,
}
impl Pointfx {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::POINTFX {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::POINTFX) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Pointl {
    pub x: i32,
    pub y: i32,
}
impl Pointl {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::POINTL {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::POINTL) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Points {
    pub x: i16,
    pub y: i16,
}
impl Points {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::POINTS {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::POINTS) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Polytexta<'a> {
    pub x: i32,
    pub y: i32,
    pub n: u32,
    pub lpstr: Cow<'a, CStr>,
    pub ui_flags: u32,
    pub rcl: Rect,
    pub pdx: &'a mut i32,
}
impl Polytexta {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::POLYTEXTA {
        let Self { x, y, n, lpstr, ui_flags, rcl, pdx } = self;
        let x = *x;
        let y = *y;
        let n = *n;
        let lpstr = lpstr.as_ptr();
        let uiFlags = *ui_flags;
        let rcl = rcl.to_win32();
        let pdx = unsafe { &mut *(pdx as *mut _ as *mut _) };
        windows_sys::Win32::Graphics::Gdi::POLYTEXTA { x, y, n, lpstr, uiFlags, rcl, pdx }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::POLYTEXTA) -> Self {
        let windows_sys::Win32::Graphics::Gdi::POLYTEXTA { x, y, n, lpstr, uiFlags, rcl, pdx } = win32;
        let x = x;
        let y = y;
        let n = n;
        let lpstr = unsafe { CStr::from_ptr(lpstr) };
        let lpstr = lpstr.to_bytes_with_nul().to_vec();
        let lpstr = Cow::Owned(unsafe { CString::from_vec_unchecked(lpstr) });
        let ui_flags = uiFlags;
        let rcl = unsafe { RECT::from_win32(rcl) };
        let pdx = unsafe { &mut *(pdx as *mut _ as *mut _) };
        Self { x, y, n, lpstr, ui_flags, rcl, pdx }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Polytextw<'a> {
    pub x: i32,
    pub y: i32,
    pub n: u32,
    pub lpstr: Cow<'a, [u16]>,
    pub ui_flags: u32,
    pub rcl: Rect,
    pub pdx: &'a mut i32,
}
impl Polytextw {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::POLYTEXTW {
        let Self { x, y, n, lpstr, ui_flags, rcl, pdx } = self;
        let x = *x;
        let y = *y;
        let n = *n;
        assert_eq!(lpstr.last(), Some(0));
        let lpstr = lpstr.as_ptr();
        let uiFlags = *ui_flags;
        let rcl = rcl.to_win32();
        let pdx = unsafe { &mut *(pdx as *mut _ as *mut _) };
        windows_sys::Win32::Graphics::Gdi::POLYTEXTW { x, y, n, lpstr, uiFlags, rcl, pdx }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::POLYTEXTW) -> Self {
        let windows_sys::Win32::Graphics::Gdi::POLYTEXTW { x, y, n, lpstr, uiFlags, rcl, pdx } = win32;
        let x = x;
        let y = y;
        let n = n;
        let slen = unsafe { wide_strlen(lpstr as *const u16) };
        let lpstr = unsafe { slice::from_raw_parts(lpstr, slen + 1) };
        let lpstr = lpstr.to_vec();
        let ui_flags = uiFlags;
        let rcl = unsafe { RECT::from_win32(rcl) };
        let pdx = unsafe { &mut *(pdx as *mut _ as *mut _) };
        Self { x, y, n, lpstr, ui_flags, rcl, pdx }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Previewhandlerframeinfo {
    pub haccel: Option<Haccel>,
    pub c_accel_entries: u32,
}
impl Previewhandlerframeinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::PREVIEWHANDLERFRAMEINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::PREVIEWHANDLERFRAMEINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const PRF_VERIFYEXISTS: i32 = 0x1;
pub const PRF_TRYPROGRAMEXTENSIONS: i32 = 0x3;
pub const PRF_FIRSTDIRDEF: i32 = 0x4;
pub const PRF_DONTFINDLNK: i32 = 0x8;
pub const PRF_REQUIREABSOLUTE: i32 = 0x10;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Profileinfoa<'a> {
    pub dw_size: u32,
    pub dw_flags: u32,
    pub lp_user_name: Cow<'a, CStr>,
    pub lp_profile_path: Cow<'a, CStr>,
    pub lp_default_path: Cow<'a, CStr>,
    pub lp_server_name: Cow<'a, CStr>,
    pub lp_policy_path: Cow<'a, CStr>,
    pub h_profile: Option<Handle>,
}
impl Profileinfoa {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::PROFILEINFOA {
        let Self { dw_size, dw_flags, lp_user_name, lp_profile_path, lp_default_path, lp_server_name, lp_policy_path, h_profile } = self;
        let dwSize = mem::size_of::<windows_sys::Win32::UI::Shell::PROFILEINFOA>() as _;
        let dwFlags = *dw_flags;
        let lpUserName = lp_user_name.as_ptr();
        let lpProfilePath = lp_profile_path.as_ptr();
        let lpDefaultPath = lp_default_path.as_ptr();
        let lpServerName = lp_server_name.as_ptr();
        let lpPolicyPath = lp_policy_path.as_ptr();
        let hProfile = h_profile.map_or(0, Handle::into_raw);
        windows_sys::Win32::UI::Shell::PROFILEINFOA { dwSize, dwFlags, lpUserName, lpProfilePath, lpDefaultPath, lpServerName, lpPolicyPath, hProfile }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::PROFILEINFOA) -> Self {
        let windows_sys::Win32::UI::Shell::PROFILEINFOA { dwSize, dwFlags, lpUserName, lpProfilePath, lpDefaultPath, lpServerName, lpPolicyPath, hProfile } = win32;
        let dw_size = dwSize;
        let dw_flags = dwFlags;
        let lpUserName = unsafe { CStr::from_ptr(lpUserName) };
        let lpUserName = lpUserName.to_bytes_with_nul().to_vec();
        let lp_user_name = Cow::Owned(unsafe { CString::from_vec_unchecked(lpUserName) });
        let lpProfilePath = unsafe { CStr::from_ptr(lpProfilePath) };
        let lpProfilePath = lpProfilePath.to_bytes_with_nul().to_vec();
        let lp_profile_path = Cow::Owned(unsafe { CString::from_vec_unchecked(lpProfilePath) });
        let lpDefaultPath = unsafe { CStr::from_ptr(lpDefaultPath) };
        let lpDefaultPath = lpDefaultPath.to_bytes_with_nul().to_vec();
        let lp_default_path = Cow::Owned(unsafe { CString::from_vec_unchecked(lpDefaultPath) });
        let lpServerName = unsafe { CStr::from_ptr(lpServerName) };
        let lpServerName = lpServerName.to_bytes_with_nul().to_vec();
        let lp_server_name = Cow::Owned(unsafe { CString::from_vec_unchecked(lpServerName) });
        let lpPolicyPath = unsafe { CStr::from_ptr(lpPolicyPath) };
        let lpPolicyPath = lpPolicyPath.to_bytes_with_nul().to_vec();
        let lp_policy_path = Cow::Owned(unsafe { CString::from_vec_unchecked(lpPolicyPath) });
        let h_profile = unsafe { Handle::new_optional(hProfile) };
        Self { dw_size, dw_flags, lp_user_name, lp_profile_path, lp_default_path, lp_server_name, lp_policy_path, h_profile }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Profileinfow<'a> {
    pub dw_size: u32,
    pub dw_flags: u32,
    pub lp_user_name: Cow<'a, [u16]>,
    pub lp_profile_path: Cow<'a, [u16]>,
    pub lp_default_path: Cow<'a, [u16]>,
    pub lp_server_name: Cow<'a, [u16]>,
    pub lp_policy_path: Cow<'a, [u16]>,
    pub h_profile: Option<Handle>,
}
impl Profileinfow {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::PROFILEINFOW {
        let Self { dw_size, dw_flags, lp_user_name, lp_profile_path, lp_default_path, lp_server_name, lp_policy_path, h_profile } = self;
        let dwSize = mem::size_of::<windows_sys::Win32::UI::Shell::PROFILEINFOW>() as _;
        let dwFlags = *dw_flags;
        assert_eq!(lp_user_name.last(), Some(0));
        let lpUserName = lp_user_name.as_ptr();
        assert_eq!(lp_profile_path.last(), Some(0));
        let lpProfilePath = lp_profile_path.as_ptr();
        assert_eq!(lp_default_path.last(), Some(0));
        let lpDefaultPath = lp_default_path.as_ptr();
        assert_eq!(lp_server_name.last(), Some(0));
        let lpServerName = lp_server_name.as_ptr();
        assert_eq!(lp_policy_path.last(), Some(0));
        let lpPolicyPath = lp_policy_path.as_ptr();
        let hProfile = h_profile.map_or(0, Handle::into_raw);
        windows_sys::Win32::UI::Shell::PROFILEINFOW { dwSize, dwFlags, lpUserName, lpProfilePath, lpDefaultPath, lpServerName, lpPolicyPath, hProfile }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::PROFILEINFOW) -> Self {
        let windows_sys::Win32::UI::Shell::PROFILEINFOW { dwSize, dwFlags, lpUserName, lpProfilePath, lpDefaultPath, lpServerName, lpPolicyPath, hProfile } = win32;
        let dw_size = dwSize;
        let dw_flags = dwFlags;
        let slen = unsafe { wide_strlen(lpUserName as *const u16) };
        let lpUserName = unsafe { slice::from_raw_parts(lpUserName, slen + 1) };
        let lp_user_name = lpUserName.to_vec();
        let slen = unsafe { wide_strlen(lpProfilePath as *const u16) };
        let lpProfilePath = unsafe { slice::from_raw_parts(lpProfilePath, slen + 1) };
        let lp_profile_path = lpProfilePath.to_vec();
        let slen = unsafe { wide_strlen(lpDefaultPath as *const u16) };
        let lpDefaultPath = unsafe { slice::from_raw_parts(lpDefaultPath, slen + 1) };
        let lp_default_path = lpDefaultPath.to_vec();
        let slen = unsafe { wide_strlen(lpServerName as *const u16) };
        let lpServerName = unsafe { slice::from_raw_parts(lpServerName, slen + 1) };
        let lp_server_name = lpServerName.to_vec();
        let slen = unsafe { wide_strlen(lpPolicyPath as *const u16) };
        let lpPolicyPath = unsafe { slice::from_raw_parts(lpPolicyPath, slen + 1) };
        let lp_policy_path = lpPolicyPath.to_vec();
        let h_profile = unsafe { Handle::new_optional(hProfile) };
        Self { dw_size, dw_flags, lp_user_name, lp_profile_path, lp_default_path, lp_server_name, lp_policy_path, h_profile }
    }
}
pub const PO_STATE: i32 = 0x0;
pub const PO_PART: i32 = 0x1;
pub const PO_CLASS: i32 = 0x2;
pub const PO_GLOBAL: i32 = 0x3;
pub const PO_NOTFOUND: i32 = 0x4;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Pshnotify {
    pub hdr: Nmhdr,
    pub l_param: Lparam,
}
impl Pshnotify {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::PSHNOTIFY {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::PSHNOTIFY) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const PSPCB_ADDREF: u32 = 0x0;
pub const PSPCB_CREATE: u32 = 0x2;
pub const PSPCB_RELEASE: u32 = 0x1;
pub const PSPCB_SI_INITDIALOG: u32 = 0x401;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Pubappinfo<'a> {
    pub cb_size: u32,
    pub dw_mask: u32,
    pub psz_source: Cow<'a, [u16]>,
    pub st_assigned: Systemtime,
    pub st_published: Systemtime,
    pub st_scheduled: Systemtime,
    pub st_expire: Systemtime,
}
impl Pubappinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::PUBAPPINFO {
        let Self { cb_size, dw_mask, psz_source, st_assigned, st_published, st_scheduled, st_expire } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::PUBAPPINFO>() as _;
        let dwMask = *dw_mask;
        assert_eq!(psz_source.last(), Some(0));
        let pszSource = psz_source.as_ptr();
        let stAssigned = st_assigned.to_win32();
        let stPublished = st_published.to_win32();
        let stScheduled = st_scheduled.to_win32();
        let stExpire = st_expire.to_win32();
        windows_sys::Win32::UI::Shell::PUBAPPINFO { cbSize, dwMask, pszSource, stAssigned, stPublished, stScheduled, stExpire }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::PUBAPPINFO) -> Self {
        let windows_sys::Win32::UI::Shell::PUBAPPINFO { cbSize, dwMask, pszSource, stAssigned, stPublished, stScheduled, stExpire } = win32;
        let cb_size = cbSize;
        let dw_mask = dwMask;
        let slen = unsafe { wide_strlen(pszSource as *const u16) };
        let pszSource = unsafe { slice::from_raw_parts(pszSource, slen + 1) };
        let psz_source = pszSource.to_vec();
        let st_assigned = unsafe { SYSTEMTIME::from_win32(stAssigned) };
        let st_published = unsafe { SYSTEMTIME::from_win32(stPublished) };
        let st_scheduled = unsafe { SYSTEMTIME::from_win32(stScheduled) };
        let st_expire = unsafe { SYSTEMTIME::from_win32(stExpire) };
        Self { cb_size, dw_mask, psz_source, st_assigned, st_published, st_scheduled, st_expire }
    }
}
pub const PAI_SOURCE: i32 = 0x1;
pub const PAI_ASSIGNEDTIME: i32 = 0x2;
pub const PAI_PUBLISHEDTIME: i32 = 0x4;
pub const PAI_SCHEDULEDTIME: i32 = 0x8;
pub const PAI_EXPIRETIME: i32 = 0x10;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Qcminfo<'a> {
    pub hmenu: Option<Hmenu>,
    pub index_menu: u32,
    pub id_cmd_first: u32,
    pub id_cmd_last: u32,
    pub p_id_map: Cow<'a, QcminfoIdmap>,
}
impl Qcminfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::QCMINFO {
        let Self { hmenu, index_menu, id_cmd_first, id_cmd_last, p_id_map } = self;
        let hmenu = hmenu.map_or(0, Hmenu::into_raw);
        let indexMenu = *index_menu;
        let idCmdFirst = *id_cmd_first;
        let idCmdLast = *id_cmd_last;
        let pIdMap = unsafe { &*(&**p_id_map as *const _ as *const _) };
        windows_sys::Win32::UI::Shell::QCMINFO { hmenu, indexMenu, idCmdFirst, idCmdLast, pIdMap }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::QCMINFO) -> Self {
        let windows_sys::Win32::UI::Shell::QCMINFO { hmenu, indexMenu, idCmdFirst, idCmdLast, pIdMap } = win32;
        let hmenu = unsafe { Hmenu::new_optional(hmenu) };
        let index_menu = indexMenu;
        let id_cmd_first = idCmdFirst;
        let id_cmd_last = idCmdLast;
        let p_id_map = Cow::Borrowed(unsafe { &*(pIdMap as *const _ as *const _) });
        Self { hmenu, index_menu, id_cmd_first, id_cmd_last, p_id_map }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct QcminfoIdmap {
    pub n_max_ids: u32,
    pub p_id_list: [QcminfoIdmapPlacement; 1],
}
impl QcminfoIdmap {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::QCMINFO_IDMAP {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::QCMINFO_IDMAP) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct QcminfoIdmapPlacement {
    pub id: u32,
    pub f_flags: u32,
}
impl QcminfoIdmapPlacement {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::QCMINFO_IDMAP_PLACEMENT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::QCMINFO_IDMAP_PLACEMENT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Qitab<'a> {
    pub piid: Cow<'a, GUID>,
    pub dw_offset: u32,
}
impl Qitab {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::QITAB {
        let Self { piid, dw_offset } = self;
        let piid = unsafe { &*(&**piid as *const _ as *const _) };
        let dwOffset = *dw_offset;
        windows_sys::Win32::UI::Shell::QITAB { piid, dwOffset }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::QITAB) -> Self {
        let windows_sys::Win32::UI::Shell::QITAB { piid, dwOffset } = win32;
        let piid = Cow::Borrowed(unsafe { &*(piid as *const _ as *const _) });
        let dw_offset = dwOffset;
        Self { piid, dw_offset }
    }
}
pub const QITIPF_DEFAULT: i32 = 0x0;
pub const QITIPF_USENAME: i32 = 0x1;
pub const QITIPF_LINKNOTARGET: i32 = 0x2;
pub const QITIPF_LINKUSETARGET: i32 = 0x4;
pub const QITIPF_USESLOWTIP: i32 = 0x8;
pub const QITIPF_SINGLELINE: i32 = 0x10;
pub const QIF_CACHED: i32 = 0x1;
pub const QIF_DONTEXPANDFOLDER: i32 = 0x2;
pub const QUNS_NOT_PRESENT: i32 = 0x1;
pub const QUNS_BUSY: i32 = 0x2;
pub const QUNS_RUNNING_D3D_FULL_SCREEN: i32 = 0x3;
pub const QUNS_PRESENTATION_MODE: i32 = 0x4;
pub const QUNS_ACCEPTS_NOTIFICATIONS: i32 = 0x5;
pub const QUNS_QUIET_TIME: i32 = 0x6;
pub const QUNS_APP: i32 = 0x7;
pub const QS_ALLEVENTS: u32 = 0x4BF;
pub const QS_ALLINPUT: u32 = 0x4FF;
pub const QS_ALLPOSTMESSAGE: u32 = 0x100;
pub const QS_HOTKEY: u32 = 0x80;
pub const QS_INPUT: u32 = 0x407;
pub const QS_KEY: u32 = 0x1;
pub const QS_MOUSE: u32 = 0x6;
pub const QS_MOUSEBUTTON: u32 = 0x4;
pub const QS_MOUSEMOVE: u32 = 0x2;
pub const QS_PAINT: u32 = 0x20;
pub const QS_POSTMESSAGE: u32 = 0x8;
pub const QS_RAWINPUT: u32 = 0x400;
pub const QS_SENDMESSAGE: u32 = 0x40;
pub const QS_TIMER: u32 = 0x10;
pub const R2_BLACK: i32 = 0x1;
pub const R2_NOTMERGEPEN: i32 = 0x2;
pub const R2_MASKNOTPEN: i32 = 0x3;
pub const R2_NOTCOPYPEN: i32 = 0x4;
pub const R2_MASKPENNOT: i32 = 0x5;
pub const R2_NOT: i32 = 0x6;
pub const R2_XORPEN: i32 = 0x7;
pub const R2_NOTMASKPEN: i32 = 0x8;
pub const R2_MASKPEN: i32 = 0x9;
pub const R2_NOTXORPEN: i32 = 0xA;
pub const R2_NOP: i32 = 0xB;
pub const R2_MERGENOTPEN: i32 = 0xC;
pub const R2_COPYPEN: i32 = 0xD;
pub const R2_MERGEPENNOT: i32 = 0xE;
pub const R2_MERGEPEN: i32 = 0xF;
pub const R2_WHITE: i32 = 0x10;
pub const R2_LAST: i32 = 0x10;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct RasterizerStatus {
    pub n_size: i16,
    pub w_flags: i16,
    pub n_language_id: i16,
}
impl RasterizerStatus {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::RASTERIZER_STATUS {
        let Self { n_size, w_flags, n_language_id } = self;
        let nSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::RASTERIZER_STATUS>() as _;
        let wFlags = *w_flags;
        let nLanguageID = *n_language_id;
        windows_sys::Win32::Graphics::Gdi::RASTERIZER_STATUS { nSize, wFlags, nLanguageID }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::RASTERIZER_STATUS) -> Self {
        let windows_sys::Win32::Graphics::Gdi::RASTERIZER_STATUS { nSize, wFlags, nLanguageID } = win32;
        let n_size = nSize;
        let w_flags = wFlags;
        let n_language_id = nLanguageID;
        Self { n_size, w_flags, n_language_id }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Rbhittestinfo {
    pub pt: Point,
    pub flags: u32,
    pub i_band: i32,
}
impl Rbhittestinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::RBHITTESTINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::RBHITTESTINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Rebarbandinfoa<'a> {
    pub cb_size: u32,
    pub f_mask: u32,
    pub f_style: u32,
    pub clr_fore: u32,
    pub clr_back: u32,
    pub lp_text: Cow<'a, CStr>,
    pub cch: u32,
    pub i_image: i32,
    pub hwnd_child: Option<Hwnd>,
    pub cx_min_child: u32,
    pub cy_min_child: u32,
    pub cx: u32,
    pub hbm_back: Option<Hbitmap>,
    pub w_id: u32,
    pub cy_child: u32,
    pub cy_max_child: u32,
    pub cy_integral: u32,
    pub cx_ideal: u32,
    pub l_param: Lparam,
    pub cx_header: u32,
    pub rc_chevron_location: Rect,
    pub u_chevron_state: u32,
}
impl Rebarbandinfoa {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::REBARBANDINFOA {
        let Self { cb_size, f_mask, f_style, clr_fore, clr_back, lp_text, cch, i_image, hwnd_child, cx_min_child, cy_min_child, cx, hbm_back, w_id, cy_child, cy_max_child, cy_integral, cx_ideal, l_param, cx_header, rc_chevron_location, u_chevron_state } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::REBARBANDINFOA>() as _;
        let fMask = *f_mask;
        let fStyle = *f_style;
        let clrFore = *clr_fore;
        let clrBack = *clr_back;
        let lpText = lp_text.as_ptr();
        let cch = *cch;
        let iImage = *i_image;
        let hwndChild = hwnd_child.map_or(0, Hwnd::into_raw);
        let cxMinChild = *cx_min_child;
        let cyMinChild = *cy_min_child;
        let cx = *cx;
        let hbmBack = hbm_back.map_or(0, Hbitmap::into_raw);
        let wID = *w_id;
        let cyChild = *cy_child;
        let cyMaxChild = *cy_max_child;
        let cyIntegral = *cy_integral;
        let cxIdeal = *cx_ideal;
        let lParam = l_param.into_inner();
        let cxHeader = *cx_header;
        let rcChevronLocation = rc_chevron_location.to_win32();
        let uChevronState = *u_chevron_state;
        windows_sys::Win32::UI::Controls::REBARBANDINFOA { cbSize, fMask, fStyle, clrFore, clrBack, lpText, cch, iImage, hwndChild, cxMinChild, cyMinChild, cx, hbmBack, wID, cyChild, cyMaxChild, cyIntegral, cxIdeal, lParam, cxHeader, rcChevronLocation, uChevronState }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::REBARBANDINFOA) -> Self {
        let windows_sys::Win32::UI::Controls::REBARBANDINFOA { cbSize, fMask, fStyle, clrFore, clrBack, lpText, cch, iImage, hwndChild, cxMinChild, cyMinChild, cx, hbmBack, wID, cyChild, cyMaxChild, cyIntegral, cxIdeal, lParam, cxHeader, rcChevronLocation, uChevronState } = win32;
        let cb_size = cbSize;
        let f_mask = fMask;
        let f_style = fStyle;
        let clr_fore = clrFore;
        let clr_back = clrBack;
        let lpText = unsafe { CStr::from_ptr(lpText) };
        let lpText = lpText.to_bytes_with_nul().to_vec();
        let lp_text = Cow::Owned(unsafe { CString::from_vec_unchecked(lpText) });
        let cch = cch;
        let i_image = iImage;
        let hwnd_child = unsafe { Hwnd::new_optional(hwndChild) };
        let cx_min_child = cxMinChild;
        let cy_min_child = cyMinChild;
        let cx = cx;
        let hbm_back = unsafe { Hbitmap::new_optional(hbmBack) };
        let w_id = wID;
        let cy_child = cyChild;
        let cy_max_child = cyMaxChild;
        let cy_integral = cyIntegral;
        let cx_ideal = cxIdeal;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        let cx_header = cxHeader;
        let rc_chevron_location = unsafe { RECT::from_win32(rcChevronLocation) };
        let u_chevron_state = uChevronState;
        Self { cb_size, f_mask, f_style, clr_fore, clr_back, lp_text, cch, i_image, hwnd_child, cx_min_child, cy_min_child, cx, hbm_back, w_id, cy_child, cy_max_child, cy_integral, cx_ideal, l_param, cx_header, rc_chevron_location, u_chevron_state }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Rebarbandinfow<'a> {
    pub cb_size: u32,
    pub f_mask: u32,
    pub f_style: u32,
    pub clr_fore: u32,
    pub clr_back: u32,
    pub lp_text: Cow<'a, [u16]>,
    pub cch: u32,
    pub i_image: i32,
    pub hwnd_child: Option<Hwnd>,
    pub cx_min_child: u32,
    pub cy_min_child: u32,
    pub cx: u32,
    pub hbm_back: Option<Hbitmap>,
    pub w_id: u32,
    pub cy_child: u32,
    pub cy_max_child: u32,
    pub cy_integral: u32,
    pub cx_ideal: u32,
    pub l_param: Lparam,
    pub cx_header: u32,
    pub rc_chevron_location: Rect,
    pub u_chevron_state: u32,
}
impl Rebarbandinfow {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::REBARBANDINFOW {
        let Self { cb_size, f_mask, f_style, clr_fore, clr_back, lp_text, cch, i_image, hwnd_child, cx_min_child, cy_min_child, cx, hbm_back, w_id, cy_child, cy_max_child, cy_integral, cx_ideal, l_param, cx_header, rc_chevron_location, u_chevron_state } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::REBARBANDINFOW>() as _;
        let fMask = *f_mask;
        let fStyle = *f_style;
        let clrFore = *clr_fore;
        let clrBack = *clr_back;
        assert_eq!(lp_text.last(), Some(0));
        let lpText = lp_text.as_ptr();
        let cch = *cch;
        let iImage = *i_image;
        let hwndChild = hwnd_child.map_or(0, Hwnd::into_raw);
        let cxMinChild = *cx_min_child;
        let cyMinChild = *cy_min_child;
        let cx = *cx;
        let hbmBack = hbm_back.map_or(0, Hbitmap::into_raw);
        let wID = *w_id;
        let cyChild = *cy_child;
        let cyMaxChild = *cy_max_child;
        let cyIntegral = *cy_integral;
        let cxIdeal = *cx_ideal;
        let lParam = l_param.into_inner();
        let cxHeader = *cx_header;
        let rcChevronLocation = rc_chevron_location.to_win32();
        let uChevronState = *u_chevron_state;
        windows_sys::Win32::UI::Controls::REBARBANDINFOW { cbSize, fMask, fStyle, clrFore, clrBack, lpText, cch, iImage, hwndChild, cxMinChild, cyMinChild, cx, hbmBack, wID, cyChild, cyMaxChild, cyIntegral, cxIdeal, lParam, cxHeader, rcChevronLocation, uChevronState }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::REBARBANDINFOW) -> Self {
        let windows_sys::Win32::UI::Controls::REBARBANDINFOW { cbSize, fMask, fStyle, clrFore, clrBack, lpText, cch, iImage, hwndChild, cxMinChild, cyMinChild, cx, hbmBack, wID, cyChild, cyMaxChild, cyIntegral, cxIdeal, lParam, cxHeader, rcChevronLocation, uChevronState } = win32;
        let cb_size = cbSize;
        let f_mask = fMask;
        let f_style = fStyle;
        let clr_fore = clrFore;
        let clr_back = clrBack;
        let slen = unsafe { wide_strlen(lpText as *const u16) };
        let lpText = unsafe { slice::from_raw_parts(lpText, slen + 1) };
        let lp_text = lpText.to_vec();
        let cch = cch;
        let i_image = iImage;
        let hwnd_child = unsafe { Hwnd::new_optional(hwndChild) };
        let cx_min_child = cxMinChild;
        let cy_min_child = cyMinChild;
        let cx = cx;
        let hbm_back = unsafe { Hbitmap::new_optional(hbmBack) };
        let w_id = wID;
        let cy_child = cyChild;
        let cy_max_child = cyMaxChild;
        let cy_integral = cyIntegral;
        let cx_ideal = cxIdeal;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        let cx_header = cxHeader;
        let rc_chevron_location = unsafe { RECT::from_win32(rcChevronLocation) };
        let u_chevron_state = uChevronState;
        Self { cb_size, f_mask, f_style, clr_fore, clr_back, lp_text, cch, i_image, hwnd_child, cx_min_child, cy_min_child, cx, hbm_back, w_id, cy_child, cy_max_child, cy_integral, cx_ideal, l_param, cx_header, rc_chevron_location, u_chevron_state }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Rebarinfo {
    pub cb_size: u32,
    pub f_mask: u32,
    pub himl: Option<Himagelist>,
}
impl Rebarinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::REBARINFO {
        let Self { cb_size, f_mask, himl } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::REBARINFO>() as _;
        let fMask = *f_mask;
        let himl = himl.map_or(0, Himagelist::into_raw);
        windows_sys::Win32::UI::Controls::REBARINFO { cbSize, fMask, himl }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::REBARINFO) -> Self {
        let windows_sys::Win32::UI::Controls::REBARINFO { cbSize, fMask, himl } = win32;
        let cb_size = cbSize;
        let f_mask = fMask;
        let himl = unsafe { Himagelist::new_optional(himl) };
        Self { cb_size, f_mask, himl }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Rect {
    pub left: i32,
    pub top: i32,
    pub right: i32,
    pub bottom: i32,
}
impl Rect {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::RECT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::RECT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Rectl {
    pub left: i32,
    pub top: i32,
    pub right: i32,
    pub bottom: i32,
}
impl Rectl {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::RECTL {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::RECTL) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const RDW_INVALIDATE: u32 = 0x1;
pub const RDW_INTERNALPAINT: u32 = 0x2;
pub const RDW_ERASE: u32 = 0x4;
pub const RDW_VALIDATE: u32 = 0x8;
pub const RDW_NOINTERNALPAINT: u32 = 0x10;
pub const RDW_NOERASE: u32 = 0x20;
pub const RDW_NOCHILDREN: u32 = 0x40;
pub const RDW_ALLCHILDREN: u32 = 0x80;
pub const RDW_UPDATENOW: u32 = 0x100;
pub const RDW_ERASENOW: u32 = 0x200;
pub const RDW_FRAME: u32 = 0x400;
pub const RDW_NOFRAME: u32 = 0x800;
pub const REG_CREATED_NEW_KEY: u32 = 0x1;
pub const REG_OPENED_EXISTING_KEY: u32 = 0x2;
pub const REG_NOTIFY_CHANGE_NAME: u32 = 0x1;
pub const REG_NOTIFY_CHANGE_ATTRIBUTES: u32 = 0x2;
pub const REG_NOTIFY_CHANGE_LAST_SET: u32 = 0x4;
pub const REG_NOTIFY_CHANGE_SECURITY: u32 = 0x8;
pub const REG_NOTIFY_THREAD_AGNOSTIC: u32 = 0x10000000;
pub const REG_OPTION_RESERVED: u32 = 0x0;
pub const REG_OPTION_NON_VOLATILE: u32 = 0x0;
pub const REG_OPTION_VOLATILE: u32 = 0x1;
pub const REG_OPTION_CREATE_LINK: u32 = 0x2;
pub const REG_OPTION_BACKUP_RESTORE: u32 = 0x4;
pub const REG_OPTION_OPEN_LINK: u32 = 0x8;
pub const REG_OPTION_DONT_VIRTUALIZE: u32 = 0x10;
pub const REG_FORCE_RESTORE: i32 = 0x8;
pub const REG_WHOLE_HIVE_VOLATILE: i32 = 0x1;
pub const KEY_QUERY_VALUE: u32 = 0x1;
pub const KEY_SET_VALUE: u32 = 0x2;
pub const KEY_CREATE_SUB_KEY: u32 = 0x4;
pub const KEY_ENUMERATE_SUB_KEYS: u32 = 0x8;
pub const KEY_NOTIFY: u32 = 0x10;
pub const KEY_CREATE_LINK: u32 = 0x20;
pub const KEY_WOW64_32KEY: u32 = 0x200;
pub const KEY_WOW64_64KEY: u32 = 0x100;
pub const KEY_WOW64_RES: u32 = 0x300;
pub const KEY_READ: u32 = 0x20019;
pub const KEY_WRITE: u32 = 0x20006;
pub const KEY_EXECUTE: u32 = 0x20019;
pub const KEY_ALL_ACCESS: u32 = 0xF003F;
pub const REG_STANDARD_FORMAT: u32 = 0x1;
pub const REG_LATEST_FORMAT: u32 = 0x2;
pub const REG_NO_COMPRESSION: u32 = 0x4;
pub const REG_NONE: u32 = 0x0;
pub const REG_SZ: u32 = 0x1;
pub const REG_EXPAND_SZ: u32 = 0x2;
pub const REG_BINARY: u32 = 0x3;
pub const REG_DWORD: u32 = 0x4;
pub const REG_DWORD_LITTLE_ENDIAN: u32 = 0x4;
pub const REG_DWORD_BIG_ENDIAN: u32 = 0x5;
pub const REG_LINK: u32 = 0x6;
pub const REG_MULTI_SZ: u32 = 0x7;
pub const REG_RESOURCE_LIST: u32 = 0x8;
pub const REG_FULL_RESOURCE_DESCRIPTOR: u32 = 0x9;
pub const REG_RESOURCE_REQUIREMENTS_LIST: u32 = 0xA;
pub const REG_QWORD: u32 = 0xB;
pub const REG_QWORD_LITTLE_ENDIAN: u32 = 0xB;
pub const REST_NONE: i32 = 0x0;
pub const REST_NORUN: i32 = 0x1;
pub const REST_NOCLOSE: i32 = 0x2;
pub const REST_NOSAVESET: i32 = 0x4;
pub const REST_NOFILEMENU: i32 = 0x8;
pub const REST_NOSETFOLDERS: i32 = 0x10;
pub const REST_NOSETTASKBAR: i32 = 0x20;
pub const REST_NODESKTOP: i32 = 0x40;
pub const REST_NOFIND: i32 = 0x80;
pub const REST_NODRIVES: i32 = 0x100;
pub const REST_NODRIVEAUTORUN: i32 = 0x200;
pub const REST_NODRIVETYPEAUTORUN: i32 = 0x400;
pub const REST_NONETHOOD: i32 = 0x800;
pub const REST_STARTBANNER: i32 = 0x1000;
pub const REST_RESTRICTRUN: i32 = 0x2000;
pub const REST_NOPRINTERTABS: i32 = 0x4000;
pub const REST_NOPRINTERDELETE: i32 = 0x8000;
pub const REST_NOPRINTERADD: i32 = 0x10000;
pub const REST_NOSTARTMENUSUBFOLDERS: i32 = 0x20000;
pub const REST_MYDOCSONNET: i32 = 0x40000;
pub const REST_NOEXITTODOS: i32 = 0x80000;
pub const REST_ENFORCESHELLEXTSECURITY: i32 = 0x100000;
pub const REST_LINKRESOLVEIGNORELINKINFO: i32 = 0x200000;
pub const REST_NOCOMMONGROUPS: i32 = 0x400000;
pub const REST_SEPARATEDESKTOPPROCESS: i32 = 0x800000;
pub const REST_NOWEB: i32 = 0x1000000;
pub const REST_NOTRAYCONTEXTMENU: i32 = 0x2000000;
pub const REST_NOVIEWCONTEXTMENU: i32 = 0x4000000;
pub const REST_NONETCONNECTDISCONNECT: i32 = 0x8000000;
pub const REST_STARTMENULOGOFF: i32 = 0x10000000;
pub const REST_NOSETTINGSASSIST: i32 = 0x20000000;
pub const REST_NOINTERNETICON: i32 = 0x40000001;
pub const REST_NORECENTDOCSHISTORY: i32 = 0x40000002;
pub const REST_NORECENTDOCSMENU: i32 = 0x40000003;
pub const REST_NOACTIVEDESKTOP: i32 = 0x40000004;
pub const REST_NOACTIVEDESKTOPCHANGES: i32 = 0x40000005;
pub const REST_NOFAVORITESMENU: i32 = 0x40000006;
pub const REST_CLEARRECENTDOCSONEXIT: i32 = 0x40000007;
pub const REST_CLASSICSHELL: i32 = 0x40000008;
pub const REST_NOCUSTOMIZEWEBVIEW: i32 = 0x40000009;
pub const REST_NOHTMLWALLPAPER: i32 = 0x40000010;
pub const REST_NOCHANGINGWALLPAPER: i32 = 0x40000011;
pub const REST_NODESKCOMP: i32 = 0x40000012;
pub const REST_NOADDDESKCOMP: i32 = 0x40000013;
pub const REST_NODELDESKCOMP: i32 = 0x40000014;
pub const REST_NOCLOSEDESKCOMP: i32 = 0x40000015;
pub const REST_NOCLOSE_DRAGDROPBAND: i32 = 0x40000016;
pub const REST_NOMOVINGBAND: i32 = 0x40000017;
pub const REST_NOEDITDESKCOMP: i32 = 0x40000018;
pub const REST_NORESOLVESEARCH: i32 = 0x40000019;
pub const REST_NORESOLVETRACK: i32 = 0x4000001A;
pub const REST_FORCECOPYACLWITHFILE: i32 = 0x4000001B;
pub const REST_NOFORGETSOFTWAREUPDATE: i32 = 0x4000001D;
pub const REST_NOSETACTIVEDESKTOP: i32 = 0x4000001E;
pub const REST_NOUPDATEWINDOWS: i32 = 0x4000001F;
pub const REST_NOCHANGESTARMENU: i32 = 0x40000020;
pub const REST_NOFOLDEROPTIONS: i32 = 0x40000021;
pub const REST_HASFINDCOMPUTERS: i32 = 0x40000022;
pub const REST_INTELLIMENUS: i32 = 0x40000023;
pub const REST_RUNDLGMEMCHECKBOX: i32 = 0x40000024;
pub const REST_ARP_SHOW_POST_SETUP: i32 = 0x40000025;
pub const REST_NOCSC: i32 = 0x40000026;
pub const REST_NOCONTROLPANEL: i32 = 0x40000027;
pub const REST_ENUMWORKGROUP: i32 = 0x40000028;
pub const REST_ARP_NOARP: i32 = 0x40000029;
pub const REST_ARP_NOREMOVEPAGE: i32 = 0x4000002A;
pub const REST_ARP_NOADDPAGE: i32 = 0x4000002B;
pub const REST_ARP_NOWINSETUPPAGE: i32 = 0x4000002C;
pub const REST_GREYMSIADS: i32 = 0x4000002D;
pub const REST_NOCHANGEMAPPEDDRIVELABEL: i32 = 0x4000002E;
pub const REST_NOCHANGEMAPPEDDRIVECOMMENT: i32 = 0x4000002F;
pub const REST_MAX_RECENT_DOCS: i32 = 0x40000030;
pub const REST_NONETWORKCONNECTIONS: i32 = 0x40000031;
pub const REST_FORCESTARTMENULOGOFF: i32 = 0x40000032;
pub const REST_NOWEBVIEW: i32 = 0x40000033;
pub const REST_NOCUSTOMIZETHISFOLDER: i32 = 0x40000034;
pub const REST_NOENCRYPTION: i32 = 0x40000035;
pub const REST_DONTSHOWSUPERHIDDEN: i32 = 0x40000037;
pub const REST_NOSHELLSEARCHBUTTON: i32 = 0x40000038;
pub const REST_NOHARDWARETAB: i32 = 0x40000039;
pub const REST_NORUNASINSTALLPROMPT: i32 = 0x4000003A;
pub const REST_PROMPTRUNASINSTALLNETPATH: i32 = 0x4000003B;
pub const REST_NOMANAGEMYCOMPUTERVERB: i32 = 0x4000003C;
pub const REST_DISALLOWRUN: i32 = 0x4000003E;
pub const REST_NOWELCOMESCREEN: i32 = 0x4000003F;
pub const REST_RESTRICTCPL: i32 = 0x40000040;
pub const REST_DISALLOWCPL: i32 = 0x40000041;
pub const REST_NOSMBALLOONTIP: i32 = 0x40000042;
pub const REST_NOSMHELP: i32 = 0x40000043;
pub const REST_NOWINKEYS: i32 = 0x40000044;
pub const REST_NOENCRYPTONMOVE: i32 = 0x40000045;
pub const REST_NOLOCALMACHINERUN: i32 = 0x40000046;
pub const REST_NOCURRENTUSERRUN: i32 = 0x40000047;
pub const REST_NOLOCALMACHINERUNONCE: i32 = 0x40000048;
pub const REST_NOCURRENTUSERRUNONCE: i32 = 0x40000049;
pub const REST_FORCEACTIVEDESKTOPON: i32 = 0x4000004A;
pub const REST_NOVIEWONDRIVE: i32 = 0x4000004C;
pub const REST_NONETCRAWL: i32 = 0x4000004D;
pub const REST_NOSHAREDDOCUMENTS: i32 = 0x4000004E;
pub const REST_NOSMMYDOCS: i32 = 0x4000004F;
pub const REST_NOSMMYPICS: i32 = 0x40000050;
pub const REST_ALLOWBITBUCKDRIVES: i32 = 0x40000051;
pub const REST_NONLEGACYSHELLMODE: i32 = 0x40000052;
pub const REST_NOCONTROLPANELBARRICADE: i32 = 0x40000053;
pub const REST_NOSTARTPAGE: i32 = 0x40000054;
pub const REST_NOAUTOTRAYNOTIFY: i32 = 0x40000055;
pub const REST_NOTASKGROUPING: i32 = 0x40000056;
pub const REST_NOCDBURNING: i32 = 0x40000057;
pub const REST_MYCOMPNOPROP: i32 = 0x40000058;
pub const REST_MYDOCSNOPROP: i32 = 0x40000059;
pub const REST_NOSTARTPANEL: i32 = 0x4000005A;
pub const REST_NODISPLAYAPPEARANCEPAGE: i32 = 0x4000005B;
pub const REST_NOTHEMESTAB: i32 = 0x4000005C;
pub const REST_NOVISUALSTYLECHOICE: i32 = 0x4000005D;
pub const REST_NOSIZECHOICE: i32 = 0x4000005E;
pub const REST_NOCOLORCHOICE: i32 = 0x4000005F;
pub const REST_SETVISUALSTYLE: i32 = 0x40000060;
pub const REST_STARTRUNNOHOMEPATH: i32 = 0x40000061;
pub const REST_NOUSERNAMEINSTARTPANEL: i32 = 0x40000062;
pub const REST_NOMYCOMPUTERICON: i32 = 0x40000063;
pub const REST_NOSMNETWORKPLACES: i32 = 0x40000064;
pub const REST_NOSMPINNEDLIST: i32 = 0x40000065;
pub const REST_NOSMMYMUSIC: i32 = 0x40000066;
pub const REST_NOSMEJECTPC: i32 = 0x40000067;
pub const REST_NOSMMOREPROGRAMS: i32 = 0x40000068;
pub const REST_NOSMMFUPROGRAMS: i32 = 0x40000069;
pub const REST_NOTRAYITEMSDISPLAY: i32 = 0x4000006A;
pub const REST_NOTOOLBARSONTASKBAR: i32 = 0x4000006B;
pub const REST_NOSMCONFIGUREPROGRAMS: i32 = 0x4000006F;
pub const REST_HIDECLOCK: i32 = 0x40000070;
pub const REST_NOLOWDISKSPACECHECKS: i32 = 0x40000071;
pub const REST_NOENTIRENETWORK: i32 = 0x40000072;
pub const REST_NODESKTOPCLEANUP: i32 = 0x40000073;
pub const REST_BITBUCKNUKEONDELETE: i32 = 0x40000074;
pub const REST_BITBUCKCONFIRMDELETE: i32 = 0x40000075;
pub const REST_BITBUCKNOPROP: i32 = 0x40000076;
pub const REST_NODISPBACKGROUND: i32 = 0x40000077;
pub const REST_NODISPSCREENSAVEPG: i32 = 0x40000078;
pub const REST_NODISPSETTINGSPG: i32 = 0x40000079;
pub const REST_NODISPSCREENSAVEPREVIEW: i32 = 0x4000007A;
pub const REST_NODISPLAYCPL: i32 = 0x4000007B;
pub const REST_HIDERUNASVERB: i32 = 0x4000007C;
pub const REST_NOTHUMBNAILCACHE: i32 = 0x4000007D;
pub const REST_NOSTRCMPLOGICAL: i32 = 0x4000007E;
pub const REST_NOPUBLISHWIZARD: i32 = 0x4000007F;
pub const REST_NOONLINEPRINTSWIZARD: i32 = 0x40000080;
pub const REST_NOWEBSERVICES: i32 = 0x40000081;
pub const REST_ALLOWUNHASHEDWEBVIEW: i32 = 0x40000082;
pub const REST_ALLOWLEGACYWEBVIEW: i32 = 0x40000083;
pub const REST_REVERTWEBVIEWSECURITY: i32 = 0x40000084;
pub const REST_INHERITCONSOLEHANDLES: i32 = 0x40000086;
pub const REST_NOREMOTERECURSIVEEVENTS: i32 = 0x40000089;
pub const REST_NOREMOTECHANGENOTIFY: i32 = 0x40000091;
pub const REST_NOENUMENTIRENETWORK: i32 = 0x40000093;
pub const REST_NOINTERNETOPENWITH: i32 = 0x40000095;
pub const REST_DONTRETRYBADNETNAME: i32 = 0x4000009B;
pub const REST_ALLOWFILECLSIDJUNCTIONS: i32 = 0x4000009C;
pub const REST_NOUPNPINSTALL: i32 = 0x4000009D;
pub const REST_ARP_DONTGROUPPATCHES: i32 = 0x400000AC;
pub const REST_ARP_NOCHOOSEPROGRAMSPAGE: i32 = 0x400000AD;
pub const REST_NODISCONNECT: i32 = 0x41000001;
pub const REST_NOSECURITY: i32 = 0x41000002;
pub const REST_NOFILEASSOCIATE: i32 = 0x41000003;
pub const REST_ALLOWCOMMENTTOGGLE: i32 = 0x41000004;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Rgbquad {
    pub rgb_blue: u8,
    pub rgb_green: u8,
    pub rgb_red: u8,
    pub rgb_reserved: u8,
}
impl Rgbquad {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::RGBQUAD {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::RGBQUAD) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Rgbtriple {
    pub rgbt_blue: u8,
    pub rgbt_green: u8,
    pub rgbt_red: u8,
}
impl Rgbtriple {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::RGBTRIPLE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::RGBTRIPLE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Rgndata {
    pub rdh: Rgndataheader,
    pub buffer: [CHAR; 1],
}
impl Rgndata {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::RGNDATA {
        let Self { rdh, buffer } = self;
        let rdh = rdh.to_win32();
        let Buffer = [buffer[0]];
        windows_sys::Win32::Graphics::Gdi::RGNDATA { rdh, Buffer }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::RGNDATA) -> Self {
        let windows_sys::Win32::Graphics::Gdi::RGNDATA { rdh, Buffer } = win32;
        let rdh = unsafe { RGNDATAHEADER::from_win32(rdh) };
        let buffer = [Buffer[0]];
        Self { rdh, buffer }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Rgndataheader {
    pub dw_size: u32,
    pub i_type: u32,
    pub n_count: u32,
    pub n_rgn_size: u32,
    pub rc_bound: Rect,
}
impl Rgndataheader {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::RGNDATAHEADER {
        let Self { dw_size, i_type, n_count, n_rgn_size, rc_bound } = self;
        let dwSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::RGNDATAHEADER>() as _;
        let iType = *i_type;
        let nCount = *n_count;
        let nRgnSize = *n_rgn_size;
        let rcBound = rc_bound.to_win32();
        windows_sys::Win32::Graphics::Gdi::RGNDATAHEADER { dwSize, iType, nCount, nRgnSize, rcBound }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::RGNDATAHEADER) -> Self {
        let windows_sys::Win32::Graphics::Gdi::RGNDATAHEADER { dwSize, iType, nCount, nRgnSize, rcBound } = win32;
        let dw_size = dwSize;
        let i_type = iType;
        let n_count = nCount;
        let n_rgn_size = nRgnSize;
        let rc_bound = unsafe { RECT::from_win32(rcBound) };
        Self { dw_size, i_type, n_count, n_rgn_size, rc_bound }
    }
}
pub const RGN_AND: i32 = 0x1;
pub const RGN_OR: i32 = 0x2;
pub const RGN_XOR: i32 = 0x3;
pub const RGN_DIFF: i32 = 0x4;
pub const RGN_COPY: i32 = 0x5;
pub const RGN_MIN: i32 = 0x1;
pub const RGN_MAX: i32 = 0x5;
pub const SRCCOPY: u32 = 0xCC0020;
pub const SRCPAINT: u32 = 0xEE0086;
pub const SRCAND: u32 = 0x8800C6;
pub const SRCINVERT: u32 = 0x660046;
pub const SRCERASE: u32 = 0x440328;
pub const NOTSRCCOPY: u32 = 0x330008;
pub const NOTSRCERASE: u32 = 0x1100A6;
pub const MERGECOPY: u32 = 0xC000CA;
pub const MERGEPAINT: u32 = 0xBB0226;
pub const PATCOPY: u32 = 0xF00021;
pub const PATPAINT: u32 = 0xFB0A09;
pub const PATINVERT: u32 = 0x5A0049;
pub const DSTINVERT: u32 = 0x550009;
pub const BLACKNESS: u32 = 0x42;
pub const WHITENESS: u32 = 0xFF0062;
pub const NOMIRRORBITMAP: u32 = 0x80000000;
pub const CAPTUREBLT: u32 = 0x40000000;
pub const RRF_RT_ANY: u32 = 0xFFFF;
pub const RRF_RT_DWORD: u32 = 0x18;
pub const RRF_RT_QWORD: u32 = 0x48;
pub const RRF_RT_REG_BINARY: u32 = 0x8;
pub const RRF_RT_REG_DWORD: u32 = 0x10;
pub const RRF_RT_REG_EXPAND_SZ: u32 = 0x4;
pub const RRF_RT_REG_MULTI_SZ: u32 = 0x20;
pub const RRF_RT_REG_NONE: u32 = 0x1;
pub const RRF_RT_REG_QWORD: u32 = 0x40;
pub const RRF_RT_REG_SZ: u32 = 0x2;
pub const REFRESH_NORMAL: i32 = 0x0;
pub const REFRESH_IFEXPIRED: i32 = 0x1;
pub const REFRESH_COMPLETELY: i32 = 0x3;
pub const SCF_VALUE_NONE: u32 = 0x0;
pub const SCF_SCALE: u32 = 0x1;
pub const SCF_PHYSICAL: u32 = 0x2;
pub const SCNRT_ENABLE: i32 = 0x0;
pub const SCNRT_DISABLE: i32 = 0x1;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Scrollbarinfo {
    pub cb_size: u32,
    pub rc_scroll_bar: Rect,
    pub dxy_line_button: i32,
    pub xy_thumb_top: i32,
    pub xy_thumb_bottom: i32,
    pub reserved: i32,
    pub rgstate: [u32; 6],
}
impl Scrollbarinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::SCROLLBARINFO {
        let Self { cb_size, rc_scroll_bar, dxy_line_button, xy_thumb_top, xy_thumb_bottom, reserved, rgstate } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::SCROLLBARINFO>() as _;
        let rcScrollBar = rc_scroll_bar.to_win32();
        let dxyLineButton = *dxy_line_button;
        let xyThumbTop = *xy_thumb_top;
        let xyThumbBottom = *xy_thumb_bottom;
        let reserved = *reserved;
        let rgstate = [*rgstate[0],*rgstate[1],*rgstate[2],*rgstate[3],*rgstate[4],*rgstate[5]];
        windows_sys::Win32::UI::WindowsAndMessaging::SCROLLBARINFO { cbSize, rcScrollBar, dxyLineButton, xyThumbTop, xyThumbBottom, reserved, rgstate }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::SCROLLBARINFO) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::SCROLLBARINFO { cbSize, rcScrollBar, dxyLineButton, xyThumbTop, xyThumbBottom, reserved, rgstate } = win32;
        let cb_size = cbSize;
        let rc_scroll_bar = unsafe { RECT::from_win32(rcScrollBar) };
        let dxy_line_button = dxyLineButton;
        let xy_thumb_top = xyThumbTop;
        let xy_thumb_bottom = xyThumbBottom;
        let reserved = reserved;
        let rgstate = [rgstate[0],rgstate[1],rgstate[2],rgstate[3],rgstate[4],rgstate[5]];
        Self { cb_size, rc_scroll_bar, dxy_line_button, xy_thumb_top, xy_thumb_bottom, reserved, rgstate }
    }
}
pub const SB_CTL: u32 = 0x2;
pub const SB_HORZ: u32 = 0x0;
pub const SB_VERT: u32 = 0x1;
pub const SB_BOTH: u32 = 0x3;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Scrollinfo {
    pub cb_size: u32,
    pub f_mask: u32,
    pub n_min: i32,
    pub n_max: i32,
    pub n_page: u32,
    pub n_pos: i32,
    pub n_track_pos: i32,
}
impl Scrollinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::SCROLLINFO {
        let Self { cb_size, f_mask, n_min, n_max, n_page, n_pos, n_track_pos } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::SCROLLINFO>() as _;
        let fMask = f_mask;
        let nMin = *n_min;
        let nMax = *n_max;
        let nPage = *n_page;
        let nPos = *n_pos;
        let nTrackPos = *n_track_pos;
        windows_sys::Win32::UI::WindowsAndMessaging::SCROLLINFO { cbSize, fMask, nMin, nMax, nPage, nPos, nTrackPos }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::SCROLLINFO) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::SCROLLINFO { cbSize, fMask, nMin, nMax, nPage, nPos, nTrackPos } = win32;
        let cb_size = cbSize;
        let f_mask = fMask;
        let n_min = nMin;
        let n_max = nMax;
        let n_page = nPage;
        let n_pos = nPos;
        let n_track_pos = nTrackPos;
        Self { cb_size, f_mask, n_min, n_max, n_page, n_pos, n_track_pos }
    }
}
pub const SIF_ALL: u32 = 0x17;
pub const SIF_DISABLENOSCROLL: u32 = 0x8;
pub const SIF_PAGE: u32 = 0x2;
pub const SIF_POS: u32 = 0x4;
pub const SIF_RANGE: u32 = 0x1;
pub const SIF_TRACKPOS: u32 = 0x10;
pub const SECURELOCK_NOCHANGE: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
pub const SECURELOCK_SET_UNSECURE: i32 = 0x0;
pub const SECURELOCK_SET_MIXED: i32 = 0x1;
pub const SECURELOCK_SET_SECUREUNKNOWNBIT: i32 = 0x2;
pub const SECURELOCK_SET_SECURE40BIT: i32 = 0x3;
pub const SECURELOCK_SET_SECURE56BIT: i32 = 0x4;
pub const SECURELOCK_SET_FORTEZZA: i32 = 0x5;
pub const SECURELOCK_SET_SECURE128BIT: i32 = 0x6;
pub const SECURELOCK_FIRSTSUGGEST: i32 = 0x7;
pub const SECURELOCK_SUGGEST_UNSECURE: i32 = 0x7;
pub const SECURELOCK_SUGGEST_MIXED: i32 = 0x8;
pub const SECURELOCK_SUGGEST_SECUREUNKNOWNBIT: i32 = 0x9;
pub const SECURELOCK_SUGGEST_SECURE40BIT: i32 = 0xA;
pub const SECURELOCK_SUGGEST_SECURE56BIT: i32 = 0xB;
pub const SECURELOCK_SUGGEST_FORTEZZA: i32 = 0xC;
pub const SECURELOCK_SUGGEST_SECURE128BIT: i32 = 0xD;
pub const SMTO_ABORTIFHUNG: u32 = 0x2;
pub const SMTO_BLOCK: u32 = 0x1;
pub const SMTO_NORMAL: u32 = 0x0;
pub const SMTO_NOTIMEOUTIFNOTHUNG: u32 = 0x8;
pub const SMTO_ERRORONEXIT: u32 = 0x20;
pub const DCB_ACCUMULATE: u32 = 0x2;
pub const DCB_DISABLE: u32 = 0x8;
pub const DCB_ENABLE: u32 = 0x4;
pub const DCB_RESET: u32 = 0x1;
pub const SWP_ASYNCWINDOWPOS: u32 = 0x4000;
pub const SWP_DEFERERASE: u32 = 0x2000;
pub const SWP_DRAWFRAME: u32 = 0x20;
pub const SWP_FRAMECHANGED: u32 = 0x20;
pub const SWP_HIDEWINDOW: u32 = 0x80;
pub const SWP_NOACTIVATE: u32 = 0x10;
pub const SWP_NOCOPYBITS: u32 = 0x100;
pub const SWP_NOMOVE: u32 = 0x2;
pub const SWP_NOOWNERZORDER: u32 = 0x200;
pub const SWP_NOREDRAW: u32 = 0x8;
pub const SWP_NOREPOSITION: u32 = 0x200;
pub const SWP_NOSENDCHANGING: u32 = 0x400;
pub const SWP_NOSIZE: u32 = 0x1;
pub const SWP_NOZORDER: u32 = 0x4;
pub const SWP_SHOWWINDOW: u32 = 0x40;
pub const SWP_NOOWNERZORDER: u32 = 0x200;
pub const SFBS_FLAGS_ROUND_TO_NEAREST_DISPLAYED_DIGIT: i32 = 0x1;
pub const SFBS_FLAGS_TRUNCATE_UNDISPLAYED_DECIMAL_DIGITS: i32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct SfvmHelptopicData {
    pub wsz_help_file: [u8; 260],
    pub wsz_help_topic: [u8; 260],
}
impl SfvmHelptopicData {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::SFVM_HELPTOPIC_DATA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::SFVM_HELPTOPIC_DATA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const SFVM_MERGEMENU: i32 = 0x1;
pub const SFVM_INVOKECOMMAND: i32 = 0x2;
pub const SFVM_GETHELPTEXT: i32 = 0x3;
pub const SFVM_GETTOOLTIPTEXT: i32 = 0x4;
pub const SFVM_GETBUTTONINFO: i32 = 0x5;
pub const SFVM_GETBUTTONS: i32 = 0x6;
pub const SFVM_INITMENUPOPUP: i32 = 0x7;
pub const SFVM_FSNOTIFY: i32 = 0xE;
pub const SFVM_WINDOWCREATED: i32 = 0xF;
pub const SFVM_GETDETAILSOF: i32 = 0x17;
pub const SFVM_COLUMNCLICK: i32 = 0x18;
pub const SFVM_QUERYFSNOTIFY: i32 = 0x19;
pub const SFVM_DEFITEMCOUNT: i32 = 0x1A;
pub const SFVM_DEFVIEWMODE: i32 = 0x1B;
pub const SFVM_UNMERGEMENU: i32 = 0x1C;
pub const SFVM_UPDATESTATUSBAR: i32 = 0x1F;
pub const SFVM_BACKGROUNDENUM: i32 = 0x20;
pub const SFVM_DIDDRAGDROP: i32 = 0x24;
pub const SFVM_SETISFV: i32 = 0x27;
pub const SFVM_THISIDLIST: i32 = 0x29;
pub const SFVM_ADDPROPERTYPAGES: i32 = 0x2F;
pub const SFVM_BACKGROUNDENUMDONE: i32 = 0x30;
pub const SFVM_GETNOTIFY: i32 = 0x31;
pub const SFVM_GETSORTDEFAULTS: i32 = 0x35;
pub const SFVM_SIZE: i32 = 0x39;
pub const SFVM_GETZONE: i32 = 0x3A;
pub const SFVM_GETPANE: i32 = 0x3B;
pub const SFVM_GETHELPTOPIC: i32 = 0x3F;
pub const SFVM_GETANIMATION: i32 = 0x44;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct SfvmProppageData {
    pub dw_reserved: u32,
    pub pfn: Option<unsafe extern "system" fn(HPROPSHEETPAGE, LPARAM) -> BOOL>,
    pub l_param: Lparam,
}
impl SfvmProppageData {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::SFVM_PROPPAGE_DATA {
        let Self { dw_reserved, pfn, l_param } = self;
        let dwReserved = *dw_reserved;
        let pfn = Some(pfn);
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::Shell::SFVM_PROPPAGE_DATA { dwReserved, pfn, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::SFVM_PROPPAGE_DATA) -> Self {
        let windows_sys::Win32::UI::Shell::SFVM_PROPPAGE_DATA { dwReserved, pfn, lParam } = win32;
        let dw_reserved = dwReserved;
        let pfn = pfn;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { dw_reserved, pfn, l_param }
    }
}
pub const SFVS_SELECT_NONE: i32 = 0x0;
pub const SFVS_SELECT_ALLITEMS: i32 = 0x1;
pub const SFVS_SELECT_INVERT: i32 = 0x2;

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ShandlePtr {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl ShandlePtr {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for ShandlePtr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for ShandlePtr {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    
pub const SHARE_ROLE_INVALID: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
pub const SHARE_ROLE_READER: i32 = 0x0;
pub const SHARE_ROLE_CONTRIBUTOR: i32 = 0x1;
pub const SHARE_ROLE_CO_OWNER: i32 = 0x2;
pub const SHARE_ROLE_OWNER: i32 = 0x3;
pub const SHARE_ROLE_CUSTOM: i32 = 0x4;
pub const SHARE_ROLE_MIXED: i32 = 0x5;
pub const SHCNE_RENAMEITEM: u32 = 0x1;
pub const SHCNE_CREATE: u32 = 0x2;
pub const SHCNE_DELETE: u32 = 0x4;
pub const SHCNE_MKDIR: u32 = 0x8;
pub const SHCNE_RMDIR: u32 = 0x10;
pub const SHCNE_MEDIAINSERTED: u32 = 0x20;
pub const SHCNE_MEDIAREMOVED: u32 = 0x40;
pub const SHCNE_DRIVEREMOVED: u32 = 0x80;
pub const SHCNE_DRIVEADD: u32 = 0x100;
pub const SHCNE_NETSHARE: u32 = 0x200;
pub const SHCNE_NETUNSHARE: u32 = 0x400;
pub const SHCNE_ATTRIBUTES: u32 = 0x800;
pub const SHCNE_UPDATEDIR: u32 = 0x1000;
pub const SHCNE_UPDATEITEM: u32 = 0x2000;
pub const SHCNE_SERVERDISCONNECT: u32 = 0x4000;
pub const SHCNE_UPDATEIMAGE: u32 = 0x8000;
pub const SHCNE_DRIVEADDGUI: u32 = 0x10000;
pub const SHCNE_RENAMEFOLDER: u32 = 0x20000;
pub const SHCNE_FREESPACE: u32 = 0x40000;
pub const SHCNE_EXTENDED_EVENT: u32 = 0x4000000;
pub const SHCNE_ASSOCCHANGED: u32 = 0x8000000;
pub const SHCNE_DISKEVENTS: u32 = 0x2381F;
pub const SHCNE_GLOBALEVENTS: u32 = 0xC0581E0;
pub const SHCNE_ALLEVENTS: u32 = 0x7FFFFFFF;
pub const SHCNE_INTERRUPT: u32 = 0x80000000;
pub const SHCNF_IDLIST: u32 = 0x0;
pub const SHCNF_PATHA: u32 = 0x1;
pub const SHCNF_PRINTERA: u32 = 0x2;
pub const SHCNF_DWORD: u32 = 0x3;
pub const SHCNF_PATHW: u32 = 0x5;
pub const SHCNF_PRINTERW: u32 = 0x6;
pub const SHCNF_TYPE: u32 = 0xFF;
pub const SHCNF_FLUSH: u32 = 0x1000;
pub const SHCNF_FLUSHNOWAIT: u32 = 0x3000;
pub const SHCNF_NOTIFYRECURSIVE: u32 = 0x10000;
pub const SHCNF_PATH: u32 = 0x5;
pub const SHCNF_PRINTER: u32 = 0x6;
pub const SHCNRF_INTERRUPT_LEVEL: i32 = 0x1;
pub const SHCNRF_SHELL_LEVEL: i32 = 0x2;
pub const SHCNRF_RECURSIVE_INTERRUPT: i32 = 0x1000;
pub const SHCNRF_NEW_DELIVERY: i32 = 0x8000;
pub const SHDID_ROOT_REGITEM: i32 = 0x1;
pub const SHDID_FS_FILE: i32 = 0x2;
pub const SHDID_FS_DIRECTORY: i32 = 0x3;
pub const SHDID_FS_OTHER: i32 = 0x4;
pub const SHDID_COMPUTER_DRIVE35: i32 = 0x5;
pub const SHDID_COMPUTER_DRIVE525: i32 = 0x6;
pub const SHDID_COMPUTER_REMOVABLE: i32 = 0x7;
pub const SHDID_COMPUTER_FIXED: i32 = 0x8;
pub const SHDID_COMPUTER_NETDRIVE: i32 = 0x9;
pub const SHDID_COMPUTER_CDROM: i32 = 0xA;
pub const SHDID_COMPUTER_RAMDISK: i32 = 0xB;
pub const SHDID_COMPUTER_OTHER: i32 = 0xC;
pub const SHDID_NET_DOMAIN: i32 = 0xD;
pub const SHDID_NET_SERVER: i32 = 0xE;
pub const SHDID_NET_SHARE: i32 = 0xF;
pub const SHDID_NET_RESTOFNET: i32 = 0x10;
pub const SHDID_NET_OTHER: i32 = 0x11;
pub const SHDID_COMPUTER_IMAGING: i32 = 0x12;
pub const SHDID_COMPUTER_AUDIO: i32 = 0x13;
pub const SHDID_COMPUTER_SHAREDDOCS: i32 = 0x14;
pub const SHDID_MOBILE_DEVICE: i32 = 0x15;
pub const SHDID_REMOTE_DESKTOP_DRIVE: i32 = 0x16;
pub const SHFMT_ID_DEFAULT: u32 = 0xFFFF;
pub const SHFMT_OPT_NONE: i32 = 0x0;
pub const SHFMT_OPT_FULL: i32 = 0x1;
pub const SHFMT_OPT_SYSONLY: i32 = 0x2;
pub const SHFMT_ERROR: u32 = 0xFFFFFFFF;
pub const SHFMT_CANCEL: u32 = 0xFFFFFFFE;
pub const SHFMT_NOFORMAT: u32 = 0xFFFFFFFD;
pub const SHGDFIL_FINDDATA: i32 = 0x1;
pub const SHGDFIL_NETRESOURCE: i32 = 0x2;
pub const SHGDFIL_DESCRIPTIONID: i32 = 0x3;
pub const SHGFI_ADDOVERLAYS: i32 = 0x20;
pub const SHGFI_ATTR_SPECIFIED: i32 = 0x20000;
pub const SHGFI_ATTRIBUTES: i32 = 0x800;
pub const SHGFI_DISPLAYNAME: i32 = 0x200;
pub const SHGFI_EXETYPE: i32 = 0x2000;
pub const SHGFI_ICON: i32 = 0x100;
pub const SHGFI_ICONLOCATION: i32 = 0x1000;
pub const SHGFI_LARGEICON: i32 = 0x0;
pub const SHGFI_LINKOVERLAY: i32 = 0x8000;
pub const SHGFI_OPENICON: i32 = 0x2;
pub const SHGFI_OVERLAYINDEX: i32 = 0x40;
pub const SHGFI_PIDL: i32 = 0x8;
pub const SHGFI_SELECTED: i32 = 0x10000;
pub const SHGFI_SHELLICONSIZE: i32 = 0x4;
pub const SHGFI_SMALLICON: i32 = 0x1;
pub const SHGFI_SYSICONINDEX: i32 = 0x4000;
pub const SHGFI_TYPENAME: i32 = 0x400;
pub const SHGFI_USEFILEATTRIBUTES: i32 = 0x10;
pub const SHGFP_TYPE_CURRENT: i32 = 0x0;
pub const SHGFP_TYPE_DEFAULT: i32 = 0x1;
pub const GLOBALCOUNTER_SEARCHMANAGER: i32 = 0x0;
pub const GLOBALCOUNTER_SEARCHOPTIONS: i32 = 0x1;
pub const GLOBALCOUNTER_FOLDERSETTINGSCHANGE: i32 = 0x2;
pub const GLOBALCOUNTER_RATINGS: i32 = 0x3;
pub const GLOBALCOUNTER_APPROVEDSITES: i32 = 0x4;
pub const GLOBALCOUNTER_RESTRICTIONS: i32 = 0x5;
pub const GLOBALCOUNTER_SHELLSETTINGSCHANGED: i32 = 0x6;
pub const GLOBALCOUNTER_SYSTEMPIDLCHANGE: i32 = 0x7;
pub const GLOBALCOUNTER_OVERLAYMANAGER: i32 = 0x8;
pub const GLOBALCOUNTER_QUERYASSOCIATIONS: i32 = 0x9;
pub const GLOBALCOUNTER_IESESSIONS: i32 = 0xA;
pub const GLOBALCOUNTER_IEONLY_SESSIONS: i32 = 0xB;
pub const GLOBALCOUNTER_APPLICATION_DESTINATIONS: i32 = 0xC;
pub const UNUSED_RECYCLE_WAS_GLOBALCOUNTER_CSCSYNCINPROGRESS: i32 = 0xD;
pub const GLOBALCOUNTER_BITBUCKETNUMDELETERS: i32 = 0xE;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_SHARES: i32 = 0xF;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_A: i32 = 0x10;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_B: i32 = 0x11;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_C: i32 = 0x12;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_D: i32 = 0x13;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_E: i32 = 0x14;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_F: i32 = 0x15;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_G: i32 = 0x16;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_H: i32 = 0x17;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_I: i32 = 0x18;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_J: i32 = 0x19;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_K: i32 = 0x1A;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_L: i32 = 0x1B;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_M: i32 = 0x1C;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_N: i32 = 0x1D;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_O: i32 = 0x1E;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_P: i32 = 0x1F;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Q: i32 = 0x20;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_R: i32 = 0x21;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_S: i32 = 0x22;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_T: i32 = 0x23;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_U: i32 = 0x24;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_V: i32 = 0x25;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_W: i32 = 0x26;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_X: i32 = 0x27;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Y: i32 = 0x28;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Z: i32 = 0x29;
pub const UNUSED_RECYCLE_WAS_GLOBALCOUNTER_RECYCLEDIRTYCOUNT_SERVERDRIVE: i32 = 0x2A;
pub const UNUSED_RECYCLE_WAS_GLOBALCOUNTER_RECYCLEGLOBALDIRTYCOUNT: i32 = 0x2B;
pub const GLOBALCOUNTER_RECYCLEBINENUM: i32 = 0x2C;
pub const GLOBALCOUNTER_RECYCLEBINCORRUPTED: i32 = 0x2D;
pub const GLOBALCOUNTER_RATINGS_STATECOUNTER: i32 = 0x2E;
pub const GLOBALCOUNTER_PRIVATE_PROFILE_CACHE: i32 = 0x2F;
pub const GLOBALCOUNTER_INTERNETTOOLBAR_LAYOUT: i32 = 0x30;
pub const GLOBALCOUNTER_FOLDERDEFINITION_CACHE: i32 = 0x31;
pub const GLOBALCOUNTER_COMMONPLACES_LIST_CACHE: i32 = 0x32;
pub const GLOBALCOUNTER_PRIVATE_PROFILE_CACHE_MACHINEWIDE: i32 = 0x33;
pub const GLOBALCOUNTER_ASSOCCHANGED: i32 = 0x34;
pub const GLOBALCOUNTER_APP_ITEMS_STATE_STORE_CACHE: i32 = 0x35;
pub const GLOBALCOUNTER_SETTINGSYNC_ENABLED: i32 = 0x36;
pub const GLOBALCOUNTER_APPSFOLDER_FILETYPEASSOCIATION_COUNTER: i32 = 0x37;
pub const GLOBALCOUNTER_USERINFOCHANGED: i32 = 0x38;
pub const GLOBALCOUNTER_SYNC_ENGINE_INFORMATION_CACHE_MACHINEWIDE: i32 = 0x39;
pub const GLOBALCOUNTER_BANNERS_DATAMODEL_CACHE_MACHINEWIDE: i32 = 0x3A;
pub const GLOBALCOUNTER_MAXIMUMVALUE: i32 = 0x3B;
pub const SHOP_PRINTERNAME: i32 = 0x1;
pub const SHOP_FILEPATH: i32 = 0x2;
pub const SHOP_VOLUMEGUID: i32 = 0x4;
pub const SW_FORCEMINIMIZE: u32 = 0xB;
pub const SW_HIDE: u32 = 0x0;
pub const SW_MAXIMIZE: u32 = 0x3;
pub const SW_MINIMIZE: u32 = 0x6;
pub const SW_RESTORE: u32 = 0x9;
pub const SW_SHOW: u32 = 0x5;
pub const SW_SHOWDEFAULT: u32 = 0xA;
pub const SW_SHOWMAXIMIZED: u32 = 0x3;
pub const SW_SHOWMINIMIZED: u32 = 0x2;
pub const SW_SHOWMINNOACTIVE: u32 = 0x7;
pub const SW_SHOWNA: u32 = 0x8;
pub const SW_SHOWNOACTIVATE: u32 = 0x4;
pub const SW_SHOWNORMAL: u32 = 0x1;
pub const SW_NORMAL: u32 = 0x1;
pub const SW_MAX: u32 = 0xB;
pub const SW_PARENTCLOSING: u32 = 0x1;
pub const SW_OTHERZOOM: u32 = 0x2;
pub const SW_PARENTOPENING: u32 = 0x3;
pub const SW_OTHERUNZOOM: u32 = 0x4;
pub const SW_SCROLLCHILDREN: u32 = 0x1;
pub const SW_INVALIDATE: u32 = 0x2;
pub const SW_ERASE: u32 = 0x4;
pub const SW_SMOOTHSCROLL: u32 = 0x10;
pub const SHREGDEL_DEFAULT: i32 = 0x0;
pub const SHREGDEL_HKCU: i32 = 0x1;
pub const SHREGDEL_HKLM: i32 = 0x10;
pub const SHREGDEL_BOTH: i32 = 0x11;
pub const SHREGENUM_DEFAULT: i32 = 0x0;
pub const SHREGENUM_HKCU: i32 = 0x1;
pub const SHREGENUM_HKLM: i32 = 0x10;
pub const SHREGENUM_BOTH: i32 = 0x11;
pub const SIATTRIBFLAGS_AND: i32 = 0x1;
pub const SIATTRIBFLAGS_OR: i32 = 0x2;
pub const SIATTRIBFLAGS_APPCOMPAT: i32 = 0x3;
pub const SIATTRIBFLAGS_MASK: i32 = 0x3;
pub const SIATTRIBFLAGS_ALLITEMS: i32 = 0x4000;
pub const SIGDN_NORMALDISPLAY: i32 = 0x0;
pub const SIGDN_PARENTRELATIVEPARSING: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFF80018001;
pub const SIGDN_DESKTOPABSOLUTEPARSING: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFF80028000;
pub const SIGDN_PARENTRELATIVEEDITING: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFF80031001;
pub const SIGDN_DESKTOPABSOLUTEEDITING: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFF8004C000;
pub const SIGDN_FILESYSPATH: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFF80058000;
pub const SIGDN_URL: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFF80068000;
pub const SIGDN_PARENTRELATIVEFORADDRESSBAR: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFF8007C001;
pub const SIGDN_PARENTRELATIVE: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFF80080001;
pub const SIGDN_PARENTRELATIVEFORUI: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFF80094001;
pub const SIIGBF_RESIZETOFIT: i32 = 0x0;
pub const SIIGBF_BIGGERSIZEOK: i32 = 0x1;
pub const SIIGBF_MEMORYONLY: i32 = 0x2;
pub const SIIGBF_ICONONLY: i32 = 0x4;
pub const SIIGBF_THUMBNAILONLY: i32 = 0x8;
pub const SIIGBF_INCACHEONLY: i32 = 0x10;
pub const SIIGBF_CROPTOSQUARE: i32 = 0x20;
pub const SIIGBF_WIDETHUMBNAILS: i32 = 0x40;
pub const SIIGBF_ICONBACKGROUND: i32 = 0x80;
pub const SIIGBF_SCALEUP: i32 = 0x100;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Size {
    pub cx: i32,
    pub cy: i32,
}
impl Size {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::SIZE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::SIZE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const ST_TRUESIZE: i32 = 0x0;
pub const ST_STRETCH: i32 = 0x1;
pub const ST_TILE: i32 = 0x2;
pub const SLGP_SHORTPATH: i32 = 0x1;
pub const SLGP_UNCPRIORITY: i32 = 0x2;
pub const SLGP_RAWPATH: i32 = 0x4;
pub const SLGP_RELATIVEPRIORITY: i32 = 0x8;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Slowappinfo<'a> {
    pub ull_size: u64,
    pub ft_last_used: Filetime,
    pub i_times_used: i32,
    pub psz_image: Cow<'a, [u16]>,
}
impl Slowappinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::SLOWAPPINFO {
        let Self { ull_size, ft_last_used, i_times_used, psz_image } = self;
        let ullSize = mem::size_of::<windows_sys::Win32::UI::Shell::SLOWAPPINFO>() as _;
        let ftLastUsed = ft_last_used.to_win32();
        let iTimesUsed = *i_times_used;
        assert_eq!(psz_image.last(), Some(0));
        let pszImage = psz_image.as_ptr();
        windows_sys::Win32::UI::Shell::SLOWAPPINFO { ullSize, ftLastUsed, iTimesUsed, pszImage }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::SLOWAPPINFO) -> Self {
        let windows_sys::Win32::UI::Shell::SLOWAPPINFO { ullSize, ftLastUsed, iTimesUsed, pszImage } = win32;
        let ull_size = ullSize;
        let ft_last_used = unsafe { FILETIME::from_win32(ftLastUsed) };
        let i_times_used = iTimesUsed;
        let slen = unsafe { wide_strlen(pszImage as *const u16) };
        let pszImage = unsafe { slice::from_raw_parts(pszImage, slen + 1) };
        let psz_image = pszImage.to_vec();
        Self { ull_size, ft_last_used, i_times_used, psz_image }
    }
}
pub const SLR_NONE: i32 = 0x0;
pub const SLR_NO_UI: i32 = 0x1;
pub const SLR_ANY_MATCH: i32 = 0x2;
pub const SLR_UPDATE: i32 = 0x4;
pub const SLR_NOUPDATE: i32 = 0x8;
pub const SLR_NOSEARCH: i32 = 0x10;
pub const SLR_NOTRACK: i32 = 0x20;
pub const SLR_NOLINKINFO: i32 = 0x40;
pub const SLR_INVOKE_MSI: i32 = 0x80;
pub const SLR_NO_UI_WITH_MSG_PUMP: i32 = 0x101;
pub const SLR_OFFER_DELETE_WITHOUT_FILE: i32 = 0x200;
pub const SLR_KNOWNFOLDER: i32 = 0x400;
pub const SLR_MACHINE_IN_LOCAL_TARGET: i32 = 0x800;
pub const SLR_UPDATE_MACHINE_AND_SID: i32 = 0x1000;
pub const SLR_NO_OBJECT_ID: i32 = 0x2000;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Sminfo {
    pub dw_mask: u32,
    pub dw_type: u32,
    pub dw_flags: u32,
    pub i_icon: i32,
}
impl Sminfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::SMINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::SMINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const SMIF_ICON: i32 = 0x1;
pub const SMIF_ACCELERATOR: i32 = 0x2;
pub const SMIF_DROPTARGET: i32 = 0x4;
pub const SMIF_SUBMENU: i32 = 0x8;
pub const SMIF_CHECKED: i32 = 0x20;
pub const SMIF_DROPCASCADE: i32 = 0x40;
pub const SMIF_HIDDEN: i32 = 0x80;
pub const SMIF_DISABLED: i32 = 0x100;
pub const SMIF_TRACKPOPUP: i32 = 0x200;
pub const SMIF_DEMOTED: i32 = 0x400;
pub const SMIF_ALTSTATE: i32 = 0x800;
pub const SMIF_DRAGNDROP: i32 = 0x1000;
pub const SMIF_NEW: i32 = 0x2000;
pub const SMIM_TYPE: i32 = 0x1;
pub const SMIM_FLAGS: i32 = 0x2;
pub const SMIM_ICON: i32 = 0x4;
pub const SMIT_SEPARATOR: i32 = 0x1;
pub const SMIT_STRING: i32 = 0x2;
pub const SPSE_NORMAL: i32 = 0x1;
pub const SPSE_HOT: i32 = 0x2;
pub const SPSE_SELECTED: i32 = 0x3;
pub const SPSE_DISABLED: i32 = 0x4;
pub const SPSE_FOCUSED: i32 = 0x5;
pub const SPACTION_NONE: i32 = 0x0;
pub const SPACTION_MOVING: i32 = 0x1;
pub const SPACTION_COPYING: i32 = 0x2;
pub const SPACTION_RECYCLING: i32 = 0x3;
pub const SPACTION_APPLYINGATTRIBS: i32 = 0x4;
pub const SPACTION_DOWNLOADING: i32 = 0x5;
pub const SPACTION_SEARCHING_INTERNET: i32 = 0x6;
pub const SPACTION_CALCULATING: i32 = 0x7;
pub const SPACTION_UPLOADING: i32 = 0x8;
pub const SPACTION_SEARCHING_FILES: i32 = 0x9;
pub const SPACTION_DELETING: i32 = 0xA;
pub const SPACTION_RENAMING: i32 = 0xB;
pub const SPACTION_FORMATTING: i32 = 0xC;
pub const SPACTION_COPY_MOVING: i32 = 0xD;
pub const SPTEXT_ACTIONDESCRIPTION: i32 = 0x1;
pub const SPTEXT_ACTIONDETAIL: i32 = 0x2;
pub const SSF_SHOWALLOBJECTS: u32 = 0x1;
pub const SSF_SHOWEXTENSIONS: u32 = 0x2;
pub const SSF_HIDDENFILEEXTS: u32 = 0x4;
pub const SSF_SERVERADMINUI: u32 = 0x4;
pub const SSF_SHOWCOMPCOLOR: u32 = 0x8;
pub const SSF_SORTCOLUMNS: u32 = 0x10;
pub const SSF_SHOWSYSFILES: u32 = 0x20;
pub const SSF_DOUBLECLICKINWEBVIEW: u32 = 0x80;
pub const SSF_SHOWATTRIBCOL: u32 = 0x100;
pub const SSF_DESKTOPHTML: u32 = 0x200;
pub const SSF_WIN95CLASSIC: u32 = 0x400;
pub const SSF_DONTPRETTYPATH: u32 = 0x800;
pub const SSF_SHOWINFOTIP: u32 = 0x2000;
pub const SSF_MAPNETDRVBUTTON: u32 = 0x1000;
pub const SSF_NOCONFIRMRECYCLE: u32 = 0x8000;
pub const SSF_HIDEICONS: u32 = 0x4000;
pub const SSF_FILTER: u32 = 0x10000;
pub const SSF_WEBVIEW: u32 = 0x20000;
pub const SSF_SHOWSUPERHIDDEN: u32 = 0x40000;
pub const SSF_SEPPROCESS: u32 = 0x80000;
pub const SSF_NONETCRAWLING: u32 = 0x100000;
pub const SSF_STARTPANELON: u32 = 0x200000;
pub const SSF_SHOWSTARTPAGE: u32 = 0x400000;
pub const SSF_AUTOCHECKSELECT: u32 = 0x800000;
pub const SSF_ICONSONLY: u32 = 0x1000000;
pub const SSF_SHOWTYPEOVERLAY: u32 = 0x2000000;
pub const SSF_SHOWSTATUSBAR: u32 = 0x4000000;
pub const SPP_USERPANE: i32 = 0x1;
pub const SPP_MOREPROGRAMS: i32 = 0x2;
pub const SPP_MOREPROGRAMSARROW: i32 = 0x3;
pub const SPP_PROGLIST: i32 = 0x4;
pub const SPP_PROGLISTSEPARATOR: i32 = 0x5;
pub const SPP_PLACESLIST: i32 = 0x6;
pub const SPP_PLACESLISTSEPARATOR: i32 = 0x7;
pub const SPP_LOGOFF: i32 = 0x8;
pub const SPP_LOGOFFBUTTONS: i32 = 0x9;
pub const SPP_USERPICTURE: i32 = 0xA;
pub const SPP_PREVIEW: i32 = 0xB;
pub const SPP_MOREPROGRAMSTAB: i32 = 0xC;
pub const SPP_NSCHOST: i32 = 0xD;
pub const SPP_SOFTWAREEXPLORER: i32 = 0xE;
pub const SPP_OPENBOX: i32 = 0xF;
pub const SPP_SEARCHVIEW: i32 = 0x10;
pub const SPP_MOREPROGRAMSARROWBACK: i32 = 0x11;
pub const SPP_TOPMATCH: i32 = 0x12;
pub const SPP_LOGOFFSPLITBUTTONDROPDOWN: i32 = 0x13;
pub const STAT_TEXT: i32 = 0x1;
pub const STGOP_MOVE: i32 = 0x1;
pub const STGOP_COPY: i32 = 0x2;
pub const STGOP_SYNC: i32 = 0x3;
pub const STGOP_REMOVE: i32 = 0x5;
pub const STGOP_RENAME: i32 = 0x6;
pub const STGOP_APPLYPROPERTIES: i32 = 0x8;
pub const STGOP_NEW: i32 = 0xA;
pub const SPFF_NONE: i32 = 0x0;
pub const SPFF_DOWNLOAD_BY_DEFAULT: i32 = 0x1;
pub const SPFF_CREATED_ON_THIS_DEVICE: i32 = 0x2;
pub const STPF_NONE: i32 = 0x0;
pub const STPF_USEAPPTHUMBNAILALWAYS: i32 = 0x1;
pub const STPF_USEAPPTHUMBNAILWHENACTIVE: i32 = 0x2;
pub const STPF_USEAPPPEEKALWAYS: i32 = 0x4;
pub const STPF_USEAPPPEEKWHENACTIVE: i32 = 0x8;
pub const BLACKONWHITE: u32 = 0x1;
pub const COLORONCOLOR: u32 = 0x3;
pub const HALFTONE: u32 = 0x4;
pub const STRETCH_ANDSCANS: u32 = 0x1;
pub const STRETCH_DELETESCANS: u32 = 0x3;
pub const STRETCH_HALFTONE: u32 = 0x4;
pub const STRETCH_ORSCANS: u32 = 0x2;
pub const WHITEONBLACK: u32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Stylestruct {
    pub style_old: u32,
    pub style_new: u32,
}
impl Stylestruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::STYLESTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::STYLESTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const SVUIA_DEACTIVATE: i32 = 0x0;
pub const SVUIA_ACTIVATE_NOFOCUS: i32 = 0x1;
pub const SVUIA_ACTIVATE_FOCUS: i32 = 0x2;
pub const SVUIA_INPLACEACTIVATE: i32 = 0x3;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Systemtime {
    pub w_year: u16,
    pub w_month: u16,
    pub w_day_of_week: u16,
    pub w_day: u16,
    pub w_hour: u16,
    pub w_minute: u16,
    pub w_second: u16,
    pub w_milliseconds: u16,
}
impl Systemtime {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::SYSTEMTIME {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::SYSTEMTIME) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const OCR_APPSTARTING: u32 = 0x7F8A;
pub const OCR_NORMAL: u32 = 0x7F00;
pub const OCR_CROSS: u32 = 0x7F03;
pub const OCR_HAND: u32 = 0x7F89;
pub const OCR_HELP: u32 = 0x7F8B;
pub const OCR_IBEAM: u32 = 0x7F01;
pub const OCR_NO: u32 = 0x7F88;
pub const OCR_SIZEALL: u32 = 0x7F86;
pub const OCR_SIZENESW: u32 = 0x7F83;
pub const OCR_SIZENS: u32 = 0x7F85;
pub const OCR_SIZENWSE: u32 = 0x7F82;
pub const OCR_SIZEWE: u32 = 0x7F84;
pub const OCR_UP: u32 = 0x7F04;
pub const OCR_WAIT: u32 = 0x7F02;
pub const SM_ARRANGE: u32 = 0x38;
pub const SM_CLEANBOOT: u32 = 0x43;
pub const SM_CMONITORS: u32 = 0x50;
pub const SM_CMOUSEBUTTONS: u32 = 0x2B;
pub const SM_CONVERTIBLESLATEMODE: u32 = 0x2003;
pub const SM_CXBORDER: u32 = 0x5;
pub const SM_CXCURSOR: u32 = 0xD;
pub const SM_CXDLGFRAME: u32 = 0x7;
pub const SM_CXDOUBLECLK: u32 = 0x24;
pub const SM_CXDRAG: u32 = 0x44;
pub const SM_CXEDGE: u32 = 0x2D;
pub const SM_CXFIXEDFRAME: u32 = 0x7;
pub const SM_CXFOCUSBORDER: u32 = 0x53;
pub const SM_CXFRAME: u32 = 0x20;
pub const SM_CXFULLSCREEN: u32 = 0x10;
pub const SM_CXHSCROLL: u32 = 0x15;
pub const SM_CXHTHUMB: u32 = 0xA;
pub const SM_CXICON: u32 = 0xB;
pub const SM_CXICONSPACING: u32 = 0x26;
pub const SM_CXMAXIMIZED: u32 = 0x3D;
pub const SM_CXMAXTRACK: u32 = 0x3B;
pub const SM_CXMENUCHECK: u32 = 0x47;
pub const SM_CXMENUSIZE: u32 = 0x36;
pub const SM_CXMIN: u32 = 0x1C;
pub const SM_CXMINIMIZED: u32 = 0x39;
pub const SM_CXMINSPACING: u32 = 0x2F;
pub const SM_CXMINTRACK: u32 = 0x22;
pub const SM_CXPADDEDBORDER: u32 = 0x5C;
pub const SM_CXSCREEN: u32 = 0x0;
pub const SM_CXSIZE: u32 = 0x1E;
pub const SM_CXSIZEFRAME: u32 = 0x20;
pub const SM_CXSMICON: u32 = 0x31;
pub const SM_CXSMSIZE: u32 = 0x34;
pub const SM_CXVIRTUALSCREEN: u32 = 0x4E;
pub const SM_CXVSCROLL: u32 = 0x2;
pub const SM_CYBORDER: u32 = 0x6;
pub const SM_CYCAPTION: u32 = 0x4;
pub const SM_CYCURSOR: u32 = 0xE;
pub const SM_CYDLGFRAME: u32 = 0x8;
pub const SM_CYDOUBLECLK: u32 = 0x25;
pub const SM_CYDRAG: u32 = 0x45;
pub const SM_CYEDGE: u32 = 0x2E;
pub const SM_CYFIXEDFRAME: u32 = 0x8;
pub const SM_CYFOCUSBORDER: u32 = 0x54;
pub const SM_CYFRAME: u32 = 0x21;
pub const SM_CYFULLSCREEN: u32 = 0x11;
pub const SM_CYHSCROLL: u32 = 0x3;
pub const SM_CYICON: u32 = 0xC;
pub const SM_CYICONSPACING: u32 = 0x27;
pub const SM_CYKANJIWINDOW: u32 = 0x12;
pub const SM_CYMAXIMIZED: u32 = 0x3E;
pub const SM_CYMAXTRACK: u32 = 0x3C;
pub const SM_CYMENU: u32 = 0xF;
pub const SM_CYMENUCHECK: u32 = 0x48;
pub const SM_CYMENUSIZE: u32 = 0x37;
pub const SM_CYMIN: u32 = 0x1D;
pub const SM_CYMINIMIZED: u32 = 0x3A;
pub const SM_CYMINSPACING: u32 = 0x30;
pub const SM_CYMINTRACK: u32 = 0x23;
pub const SM_CYSCREEN: u32 = 0x1;
pub const SM_CYSIZE: u32 = 0x1F;
pub const SM_CYSIZEFRAME: u32 = 0x21;
pub const SM_CYSMCAPTION: u32 = 0x33;
pub const SM_CYSMICON: u32 = 0x32;
pub const SM_CYSMSIZE: u32 = 0x35;
pub const SM_CYVIRTUALSCREEN: u32 = 0x4F;
pub const SM_CYVSCROLL: u32 = 0x14;
pub const SM_CYVTHUMB: u32 = 0x9;
pub const SM_DBCSENABLED: u32 = 0x2A;
pub const SM_DEBUG: u32 = 0x16;
pub const SM_DIGITIZER: u32 = 0x5E;
pub const SM_IMMENABLED: u32 = 0x52;
pub const SM_MAXIMUMTOUCHES: u32 = 0x5F;
pub const SM_MEDIACENTER: u32 = 0x57;
pub const SM_MENUDROPALIGNMENT: u32 = 0x28;
pub const SM_MIDEASTENABLED: u32 = 0x4A;
pub const SM_MOUSEPRESENT: u32 = 0x13;
pub const SM_MOUSEHORIZONTALWHEELPRESENT: u32 = 0x5B;
pub const SM_MOUSEWHEELPRESENT: u32 = 0x4B;
pub const SM_NETWORK: u32 = 0x3F;
pub const SM_PENWINDOWS: u32 = 0x29;
pub const SM_REMOTECONTROL: u32 = 0x2001;
pub const SM_REMOTESESSION: u32 = 0x1000;
pub const SM_SAMEDISPLAYFORMAT: u32 = 0x51;
pub const SM_SECURE: u32 = 0x2C;
pub const SM_SERVERR2: u32 = 0x59;
pub const SM_SHOWSOUNDS: u32 = 0x46;
pub const SM_SHUTTINGDOWN: u32 = 0x2000;
pub const SM_SLOWMACHINE: u32 = 0x49;
pub const SM_STARTER: u32 = 0x58;
pub const SM_SWAPBUTTON: u32 = 0x17;
pub const SM_SYSTEMDOCKED: u32 = 0x2004;
pub const SM_TABLETPC: u32 = 0x56;
pub const SM_XVIRTUALSCREEN: u32 = 0x4C;
pub const SM_YVIRTUALSCREEN: u32 = 0x4D;
pub const SYSPAL_NOSTATIC: u32 = 0x2;
pub const SYSPAL_NOSTATIC256: u32 = 0x3;
pub const SYSPAL_STATIC: u32 = 0x1;
pub const SPI_GETBEEP: u32 = 0x1;
pub const SPI_SETBEEP: u32 = 0x2;
pub const SPI_GETMOUSE: u32 = 0x3;
pub const SPI_SETMOUSE: u32 = 0x4;
pub const SPI_GETBORDER: u32 = 0x5;
pub const SPI_SETBORDER: u32 = 0x6;
pub const SPI_GETKEYBOARDSPEED: u32 = 0xA;
pub const SPI_SETKEYBOARDSPEED: u32 = 0xB;
pub const SPI_LANGDRIVER: u32 = 0xC;
pub const SPI_ICONHORIZONTALSPACING: u32 = 0xD;
pub const SPI_GETSCREENSAVETIMEOUT: u32 = 0xE;
pub const SPI_SETSCREENSAVETIMEOUT: u32 = 0xF;
pub const SPI_GETSCREENSAVEACTIVE: u32 = 0x10;
pub const SPI_SETSCREENSAVEACTIVE: u32 = 0x11;
pub const SPI_GETGRIDGRANULARITY: u32 = 0x12;
pub const SPI_SETGRIDGRANULARITY: u32 = 0x13;
pub const SPI_SETDESKWALLPAPER: u32 = 0x14;
pub const SPI_SETDESKPATTERN: u32 = 0x15;
pub const SPI_GETKEYBOARDDELAY: u32 = 0x16;
pub const SPI_SETKEYBOARDDELAY: u32 = 0x17;
pub const SPI_ICONVERTICALSPACING: u32 = 0x18;
pub const SPI_GETICONTITLEWRAP: u32 = 0x19;
pub const SPI_SETICONTITLEWRAP: u32 = 0x1A;
pub const SPI_GETMENUDROPALIGNMENT: u32 = 0x1B;
pub const SPI_SETMENUDROPALIGNMENT: u32 = 0x1C;
pub const SPI_SETDOUBLECLKWIDTH: u32 = 0x1D;
pub const SPI_SETDOUBLECLKHEIGHT: u32 = 0x1E;
pub const SPI_GETICONTITLELOGFONT: u32 = 0x1F;
pub const SPI_SETDOUBLECLICKTIME: u32 = 0x20;
pub const SPI_SETMOUSEBUTTONSWAP: u32 = 0x21;
pub const SPI_SETICONTITLELOGFONT: u32 = 0x22;
pub const SPI_GETFASTTASKSWITCH: u32 = 0x23;
pub const SPI_SETFASTTASKSWITCH: u32 = 0x24;
pub const SPI_SETDRAGFULLWINDOWS: u32 = 0x25;
pub const SPI_GETDRAGFULLWINDOWS: u32 = 0x26;
pub const SPI_GETNONCLIENTMETRICS: u32 = 0x29;
pub const SPI_SETNONCLIENTMETRICS: u32 = 0x2A;
pub const SPI_GETMINIMIZEDMETRICS: u32 = 0x2B;
pub const SPI_SETMINIMIZEDMETRICS: u32 = 0x2C;
pub const SPI_GETICONMETRICS: u32 = 0x2D;
pub const SPI_SETICONMETRICS: u32 = 0x2E;
pub const SPI_SETWORKAREA: u32 = 0x2F;
pub const SPI_GETWORKAREA: u32 = 0x30;
pub const SPI_SETPENWINDOWS: u32 = 0x31;
pub const SPI_GETHIGHCONTRAST: u32 = 0x42;
pub const SPI_SETHIGHCONTRAST: u32 = 0x43;
pub const SPI_GETKEYBOARDPREF: u32 = 0x44;
pub const SPI_SETKEYBOARDPREF: u32 = 0x45;
pub const SPI_GETSCREENREADER: u32 = 0x46;
pub const SPI_SETSCREENREADER: u32 = 0x47;
pub const SPI_GETANIMATION: u32 = 0x48;
pub const SPI_SETANIMATION: u32 = 0x49;
pub const SPI_GETFONTSMOOTHING: u32 = 0x4A;
pub const SPI_SETFONTSMOOTHING: u32 = 0x4B;
pub const SPI_SETDRAGWIDTH: u32 = 0x4C;
pub const SPI_SETDRAGHEIGHT: u32 = 0x4D;
pub const SPI_SETHANDHELD: u32 = 0x4E;
pub const SPI_GETLOWPOWERTIMEOUT: u32 = 0x4F;
pub const SPI_GETPOWEROFFTIMEOUT: u32 = 0x50;
pub const SPI_SETLOWPOWERTIMEOUT: u32 = 0x51;
pub const SPI_SETPOWEROFFTIMEOUT: u32 = 0x52;
pub const SPI_GETLOWPOWERACTIVE: u32 = 0x53;
pub const SPI_GETPOWEROFFACTIVE: u32 = 0x54;
pub const SPI_SETLOWPOWERACTIVE: u32 = 0x55;
pub const SPI_SETPOWEROFFACTIVE: u32 = 0x56;
pub const SPI_SETCURSORS: u32 = 0x57;
pub const SPI_SETICONS: u32 = 0x58;
pub const SPI_GETDEFAULTINPUTLANG: u32 = 0x59;
pub const SPI_SETDEFAULTINPUTLANG: u32 = 0x5A;
pub const SPI_SETLANGTOGGLE: u32 = 0x5B;
pub const SPI_GETWINDOWSEXTENSION: u32 = 0x5C;
pub const SPI_SETMOUSETRAILS: u32 = 0x5D;
pub const SPI_GETMOUSETRAILS: u32 = 0x5E;
pub const SPI_SETSCREENSAVERRUNNING: u32 = 0x61;
pub const SPI_SCREENSAVERRUNNING: u32 = 0x61;
pub const SPI_GETFILTERKEYS: u32 = 0x32;
pub const SPI_SETFILTERKEYS: u32 = 0x33;
pub const SPI_GETTOGGLEKEYS: u32 = 0x34;
pub const SPI_SETTOGGLEKEYS: u32 = 0x35;
pub const SPI_GETMOUSEKEYS: u32 = 0x36;
pub const SPI_SETMOUSEKEYS: u32 = 0x37;
pub const SPI_GETSHOWSOUNDS: u32 = 0x38;
pub const SPI_SETSHOWSOUNDS: u32 = 0x39;
pub const SPI_GETSTICKYKEYS: u32 = 0x3A;
pub const SPI_SETSTICKYKEYS: u32 = 0x3B;
pub const SPI_GETACCESSTIMEOUT: u32 = 0x3C;
pub const SPI_SETACCESSTIMEOUT: u32 = 0x3D;
pub const SPI_GETSERIALKEYS: u32 = 0x3E;
pub const SPI_SETSERIALKEYS: u32 = 0x3F;
pub const SPI_GETSOUNDSENTRY: u32 = 0x40;
pub const SPI_SETSOUNDSENTRY: u32 = 0x41;
pub const SPI_GETSNAPTODEFBUTTON: u32 = 0x5F;
pub const SPI_SETSNAPTODEFBUTTON: u32 = 0x60;
pub const SPI_GETMOUSEHOVERWIDTH: u32 = 0x62;
pub const SPI_SETMOUSEHOVERWIDTH: u32 = 0x63;
pub const SPI_GETMOUSEHOVERHEIGHT: u32 = 0x64;
pub const SPI_SETMOUSEHOVERHEIGHT: u32 = 0x65;
pub const SPI_GETMOUSEHOVERTIME: u32 = 0x66;
pub const SPI_SETMOUSEHOVERTIME: u32 = 0x67;
pub const SPI_GETWHEELSCROLLLINES: u32 = 0x68;
pub const SPI_SETWHEELSCROLLLINES: u32 = 0x69;
pub const SPI_GETMENUSHOWDELAY: u32 = 0x6A;
pub const SPI_SETMENUSHOWDELAY: u32 = 0x6B;
pub const SPI_GETWHEELSCROLLCHARS: u32 = 0x6C;
pub const SPI_SETWHEELSCROLLCHARS: u32 = 0x6D;
pub const SPI_GETSHOWIMEUI: u32 = 0x6E;
pub const SPI_SETSHOWIMEUI: u32 = 0x6F;
pub const SPI_GETMOUSESPEED: u32 = 0x70;
pub const SPI_SETMOUSESPEED: u32 = 0x71;
pub const SPI_GETSCREENSAVERRUNNING: u32 = 0x72;
pub const SPI_GETDESKWALLPAPER: u32 = 0x73;
pub const SPI_GETAUDIODESCRIPTION: u32 = 0x74;
pub const SPI_SETAUDIODESCRIPTION: u32 = 0x75;
pub const SPI_GETSCREENSAVESECURE: u32 = 0x76;
pub const SPI_SETSCREENSAVESECURE: u32 = 0x77;
pub const SPI_GETHUNGAPPTIMEOUT: u32 = 0x78;
pub const SPI_SETHUNGAPPTIMEOUT: u32 = 0x79;
pub const SPI_GETWAITTOKILLTIMEOUT: u32 = 0x7A;
pub const SPI_SETWAITTOKILLTIMEOUT: u32 = 0x7B;
pub const SPI_GETWAITTOKILLSERVICETIMEOUT: u32 = 0x7C;
pub const SPI_SETWAITTOKILLSERVICETIMEOUT: u32 = 0x7D;
pub const SPI_GETMOUSEDOCKTHRESHOLD: u32 = 0x7E;
pub const SPI_SETMOUSEDOCKTHRESHOLD: u32 = 0x7F;
pub const SPI_GETPENDOCKTHRESHOLD: u32 = 0x80;
pub const SPI_SETPENDOCKTHRESHOLD: u32 = 0x81;
pub const SPI_GETWINARRANGING: u32 = 0x82;
pub const SPI_SETWINARRANGING: u32 = 0x83;
pub const SPI_GETMOUSEDRAGOUTTHRESHOLD: u32 = 0x84;
pub const SPI_SETMOUSEDRAGOUTTHRESHOLD: u32 = 0x85;
pub const SPI_GETPENDRAGOUTTHRESHOLD: u32 = 0x86;
pub const SPI_SETPENDRAGOUTTHRESHOLD: u32 = 0x87;
pub const SPI_GETMOUSESIDEMOVETHRESHOLD: u32 = 0x88;
pub const SPI_SETMOUSESIDEMOVETHRESHOLD: u32 = 0x89;
pub const SPI_GETPENSIDEMOVETHRESHOLD: u32 = 0x8A;
pub const SPI_SETPENSIDEMOVETHRESHOLD: u32 = 0x8B;
pub const SPI_GETDRAGFROMMAXIMIZE: u32 = 0x8C;
pub const SPI_SETDRAGFROMMAXIMIZE: u32 = 0x8D;
pub const SPI_GETSNAPSIZING: u32 = 0x8E;
pub const SPI_SETSNAPSIZING: u32 = 0x8F;
pub const SPI_GETDOCKMOVING: u32 = 0x90;
pub const SPI_SETDOCKMOVING: u32 = 0x91;
pub const SPI_GETTOUCHPREDICTIONPARAMETERS: u32 = 0x9C;
pub const SPI_SETTOUCHPREDICTIONPARAMETERS: u32 = 0x9D;
pub const SPI_GETLOGICALDPIOVERRIDE: u32 = 0x9E;
pub const SPI_SETLOGICALDPIOVERRIDE: u32 = 0x9F;
pub const SPI_GETMENURECT: u32 = 0xA2;
pub const SPI_SETMENURECT: u32 = 0xA3;
pub const SPI_GETACTIVEWINDOWTRACKING: u32 = 0x1000;
pub const SPI_SETACTIVEWINDOWTRACKING: u32 = 0x1001;
pub const SPI_GETMENUANIMATION: u32 = 0x1002;
pub const SPI_SETMENUANIMATION: u32 = 0x1003;
pub const SPI_GETCOMBOBOXANIMATION: u32 = 0x1004;
pub const SPI_SETCOMBOBOXANIMATION: u32 = 0x1005;
pub const SPI_GETLISTBOXSMOOTHSCROLLING: u32 = 0x1006;
pub const SPI_SETLISTBOXSMOOTHSCROLLING: u32 = 0x1007;
pub const SPI_GETGRADIENTCAPTIONS: u32 = 0x1008;
pub const SPI_SETGRADIENTCAPTIONS: u32 = 0x1009;
pub const SPI_GETKEYBOARDCUES: u32 = 0x100A;
pub const SPI_SETKEYBOARDCUES: u32 = 0x100B;
pub const SPI_GETMENUUNDERLINES: u32 = 0x100A;
pub const SPI_SETMENUUNDERLINES: u32 = 0x100B;
pub const SPI_GETACTIVEWNDTRKZORDER: u32 = 0x100C;
pub const SPI_SETACTIVEWNDTRKZORDER: u32 = 0x100D;
pub const SPI_GETHOTTRACKING: u32 = 0x100E;
pub const SPI_SETHOTTRACKING: u32 = 0x100F;
pub const SPI_GETMENUFADE: u32 = 0x1012;
pub const SPI_SETMENUFADE: u32 = 0x1013;
pub const SPI_GETSELECTIONFADE: u32 = 0x1014;
pub const SPI_SETSELECTIONFADE: u32 = 0x1015;
pub const SPI_GETTOOLTIPANIMATION: u32 = 0x1016;
pub const SPI_SETTOOLTIPANIMATION: u32 = 0x1017;
pub const SPI_GETTOOLTIPFADE: u32 = 0x1018;
pub const SPI_SETTOOLTIPFADE: u32 = 0x1019;
pub const SPI_GETCURSORSHADOW: u32 = 0x101A;
pub const SPI_SETCURSORSHADOW: u32 = 0x101B;
pub const SPI_GETMOUSESONAR: u32 = 0x101C;
pub const SPI_SETMOUSESONAR: u32 = 0x101D;
pub const SPI_GETMOUSECLICKLOCK: u32 = 0x101E;
pub const SPI_SETMOUSECLICKLOCK: u32 = 0x101F;
pub const SPI_GETMOUSEVANISH: u32 = 0x1020;
pub const SPI_SETMOUSEVANISH: u32 = 0x1021;
pub const SPI_GETFLATMENU: u32 = 0x1022;
pub const SPI_SETFLATMENU: u32 = 0x1023;
pub const SPI_GETDROPSHADOW: u32 = 0x1024;
pub const SPI_SETDROPSHADOW: u32 = 0x1025;
pub const SPI_GETBLOCKSENDINPUTRESETS: u32 = 0x1026;
pub const SPI_SETBLOCKSENDINPUTRESETS: u32 = 0x1027;
pub const SPI_GETUIEFFECTS: u32 = 0x103E;
pub const SPI_SETUIEFFECTS: u32 = 0x103F;
pub const SPI_GETDISABLEOVERLAPPEDCONTENT: u32 = 0x1040;
pub const SPI_SETDISABLEOVERLAPPEDCONTENT: u32 = 0x1041;
pub const SPI_GETCLIENTAREAANIMATION: u32 = 0x1042;
pub const SPI_SETCLIENTAREAANIMATION: u32 = 0x1043;
pub const SPI_GETCLEARTYPE: u32 = 0x1048;
pub const SPI_SETCLEARTYPE: u32 = 0x1049;
pub const SPI_GETSPEECHRECOGNITION: u32 = 0x104A;
pub const SPI_SETSPEECHRECOGNITION: u32 = 0x104B;
pub const SPI_GETCARETBROWSING: u32 = 0x104C;
pub const SPI_SETCARETBROWSING: u32 = 0x104D;
pub const SPI_GETTHREADLOCALINPUTSETTINGS: u32 = 0x104E;
pub const SPI_SETTHREADLOCALINPUTSETTINGS: u32 = 0x104F;
pub const SPI_GETSYSTEMLANGUAGEBAR: u32 = 0x1050;
pub const SPI_SETSYSTEMLANGUAGEBAR: u32 = 0x1051;
pub const SPI_GETFOREGROUNDLOCKTIMEOUT: u32 = 0x2000;
pub const SPI_SETFOREGROUNDLOCKTIMEOUT: u32 = 0x2001;
pub const SPI_GETACTIVEWNDTRKTIMEOUT: u32 = 0x2002;
pub const SPI_SETACTIVEWNDTRKTIMEOUT: u32 = 0x2003;
pub const SPI_GETFOREGROUNDFLASHCOUNT: u32 = 0x2004;
pub const SPI_SETFOREGROUNDFLASHCOUNT: u32 = 0x2005;
pub const SPI_GETCARETWIDTH: u32 = 0x2006;
pub const SPI_SETCARETWIDTH: u32 = 0x2007;
pub const SPI_GETMOUSECLICKLOCKTIME: u32 = 0x2008;
pub const SPI_SETMOUSECLICKLOCKTIME: u32 = 0x2009;
pub const SPI_GETFONTSMOOTHINGTYPE: u32 = 0x200A;
pub const SPI_SETFONTSMOOTHINGTYPE: u32 = 0x200B;
pub const SPI_GETFONTSMOOTHINGCONTRAST: u32 = 0x200C;
pub const SPI_SETFONTSMOOTHINGCONTRAST: u32 = 0x200D;
pub const SPI_GETFOCUSBORDERWIDTH: u32 = 0x200E;
pub const SPI_SETFOCUSBORDERWIDTH: u32 = 0x200F;
pub const SPI_GETFOCUSBORDERHEIGHT: u32 = 0x2010;
pub const SPI_SETFOCUSBORDERHEIGHT: u32 = 0x2011;
pub const SPI_GETFONTSMOOTHINGORIENTATION: u32 = 0x2012;
pub const SPI_SETFONTSMOOTHINGORIENTATION: u32 = 0x2013;
pub const SPI_GETMINIMUMHITRADIUS: u32 = 0x2014;
pub const SPI_SETMINIMUMHITRADIUS: u32 = 0x2015;
pub const SPI_GETMESSAGEDURATION: u32 = 0x2016;
pub const SPI_SETMESSAGEDURATION: u32 = 0x2017;
pub const SPI_GETCONTACTVISUALIZATION: u32 = 0x2018;
pub const SPI_SETCONTACTVISUALIZATION: u32 = 0x2019;
pub const SPI_GETGESTUREVISUALIZATION: u32 = 0x201A;
pub const SPI_SETGESTUREVISUALIZATION: u32 = 0x201B;
pub const SPI_GETMOUSEWHEELROUTING: u32 = 0x201C;
pub const SPI_SETMOUSEWHEELROUTING: u32 = 0x201D;
pub const SPI_GETPENVISUALIZATION: u32 = 0x201E;
pub const SPI_SETPENVISUALIZATION: u32 = 0x201F;
pub const SPI_GETPENARBITRATIONTYPE: u32 = 0x2020;
pub const SPI_SETPENARBITRATIONTYPE: u32 = 0x2021;
pub const SPI_GETCARETTIMEOUT: u32 = 0x2022;
pub const SPI_SETCARETTIMEOUT: u32 = 0x2023;
pub const SPI_GETHANDEDNESS: u32 = 0x2024;
pub const SPI_SETHANDEDNESS: u32 = 0x2025;
pub const SPIF_UPDATEINIFILE: u32 = 0x1;
pub const SPIF_SENDCHANGE: u32 = 0x2;
pub const SPIF_SENDWININICHANGE: u32 = 0x2;
pub const COLOR_3DDKSHADOW: u32 = 0x15;
pub const COLOR_3DFACE: u32 = 0xF;
pub const COLOR_3DHIGHLIGHT: u32 = 0x14;
pub const COLOR_3DHILIGHT: u32 = 0x14;
pub const COLOR_3DLIGHT: u32 = 0x16;
pub const COLOR_3DSHADOW: u32 = 0x10;
pub const COLOR_ACTIVEBORDER: u32 = 0xA;
pub const COLOR_ACTIVECAPTION: u32 = 0x2;
pub const COLOR_APPWORKSPACE: u32 = 0xC;
pub const COLOR_BACKGROUND: u32 = 0x1;
pub const COLOR_BTNFACE: u32 = 0xF;
pub const COLOR_BTNHIGHLIGHT: u32 = 0x14;
pub const COLOR_BTNHILIGHT: u32 = 0x14;
pub const COLOR_BTNSHADOW: u32 = 0x10;
pub const COLOR_BTNTEXT: u32 = 0x12;
pub const COLOR_CAPTIONTEXT: u32 = 0x9;
pub const COLOR_DESKTOP: u32 = 0x1;
pub const COLOR_GRADIENTACTIVECAPTION: u32 = 0x1B;
pub const COLOR_GRADIENTINACTIVECAPTION: u32 = 0x1C;
pub const COLOR_GRAYTEXT: u32 = 0x11;
pub const COLOR_HIGHLIGHT: u32 = 0xD;
pub const COLOR_HIGHLIGHTTEXT: u32 = 0xE;
pub const COLOR_HOTLIGHT: u32 = 0x1A;
pub const COLOR_INACTIVEBORDER: u32 = 0xB;
pub const COLOR_INACTIVECAPTION: u32 = 0x3;
pub const COLOR_INACTIVECAPTIONTEXT: u32 = 0x13;
pub const COLOR_INFOBK: u32 = 0x18;
pub const COLOR_INFOTEXT: u32 = 0x17;
pub const COLOR_MENU: u32 = 0x4;
pub const COLOR_MENUHILIGHT: u32 = 0x1D;
pub const COLOR_MENUBAR: u32 = 0x1E;
pub const COLOR_MENUTEXT: u32 = 0x7;
pub const COLOR_SCROLLBAR: u32 = 0x0;
pub const COLOR_WINDOW: u32 = 0x5;
pub const COLOR_WINDOWFRAME: u32 = 0x6;
pub const COLOR_WINDOWTEXT: u32 = 0x8;
pub const SECURE_LOCK_ICON_UNSECURE: i32 = 0x0;
pub const SECURE_LOCK_ICON_MIXED: i32 = 0x1;
pub const SECURE_LOCK_ICON_SECURE_UNKNOWN_BITS: i32 = 0x2;
pub const SECURE_LOCK_ICON_SECURE40_BIT: i32 = 0x3;
pub const SECURE_LOCK_ICON_SECURE56_BIT: i32 = 0x4;
pub const SECURE_LOCK_ICON_SECURE_FORTEZZA: i32 = 0x5;
pub const SECURE_LOCK_ICON_SECURE128_BIT: i32 = 0x6;

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ShFindChangeNotificationHandle {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl ShFindChangeNotificationHandle {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Self {
        NonZeroIsize::new(handle).map(|handle| {
            Self {
                handle,
                _thread_unsafe: PhantomData,
            }
        })
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for ShFindChangeNotificationHandle {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for ShFindChangeNotificationHandle {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    
pub const SFVVO_SHOWALLOBJECTS: i32 = 0x1;
pub const SFVVO_SHOWEXTENSIONS: i32 = 0x2;
pub const SFVVO_SHOWCOMPCOLOR: i32 = 0x8;
pub const SFVVO_SHOWSYSFILES: i32 = 0x20;
pub const SFVVO_WIN95CLASSIC: i32 = 0x40;
pub const SFVVO_DOUBLECLICKINWEBVIEW: i32 = 0x80;
pub const SFVVO_DESKTOPHTML: i32 = 0x200;
pub const SSF_DESKTOP: i32 = 0x0;
pub const SSF_PROGRAMS: i32 = 0x2;
pub const SSF_CONTROLS: i32 = 0x3;
pub const SSF_PRINTERS: i32 = 0x4;
pub const SSF_PERSONAL: i32 = 0x5;
pub const SSF_FAVORITES: i32 = 0x6;
pub const SSF_STARTUP: i32 = 0x7;
pub const SSF_RECENT: i32 = 0x8;
pub const SSF_SENDTO: i32 = 0x9;
pub const SSF_BITBUCKET: i32 = 0xA;
pub const SSF_STARTMENU: i32 = 0xB;
pub const SSF_DESKTOPDIRECTORY: i32 = 0x10;
pub const SSF_DRIVES: i32 = 0x11;
pub const SSF_NETWORK: i32 = 0x12;
pub const SSF_NETHOOD: i32 = 0x13;
pub const SSF_FONTS: i32 = 0x14;
pub const SSF_TEMPLATES: i32 = 0x15;
pub const SSF_COMMONSTARTMENU: i32 = 0x16;
pub const SSF_COMMONPROGRAMS: i32 = 0x17;
pub const SSF_COMMONSTARTUP: i32 = 0x18;
pub const SSF_COMMONDESKTOPDIR: i32 = 0x19;
pub const SSF_APPDATA: i32 = 0x1A;
pub const SSF_PRINTHOOD: i32 = 0x1B;
pub const SSF_LOCALAPPDATA: i32 = 0x1C;
pub const SSF_ALTSTARTUP: i32 = 0x1D;
pub const SSF_COMMONALTSTARTUP: i32 = 0x1E;
pub const SSF_COMMONFAVORITES: i32 = 0x1F;
pub const SSF_INTERNETCACHE: i32 = 0x20;
pub const SSF_COOKIES: i32 = 0x21;
pub const SSF_HISTORY: i32 = 0x22;
pub const SSF_COMMONAPPDATA: i32 = 0x23;
pub const SSF_WINDOWS: i32 = 0x24;
pub const SSF_SYSTEM: i32 = 0x25;
pub const SSF_PROGRAMFILES: i32 = 0x26;
pub const SSF_MYPICTURES: i32 = 0x27;
pub const SSF_PROFILE: i32 = 0x28;
pub const SSF_SYSTE_MX86: i32 = 0x29;
pub const SSF_PROGRAMFILE_SX86: i32 = 0x30;
pub const SWFO_NEEDDISPATCH: i32 = 0x1;
pub const SWFO_INCLUDEPENDING: i32 = 0x2;
pub const SWFO_COOKIEPASSED: i32 = 0x4;
pub const SWC_EXPLORER: i32 = 0x0;
pub const SWC_BROWSER: i32 = 0x1;
pub const SWC_3RDPARTY: i32 = 0x2;
pub const SWC_CALLBACK: i32 = 0x4;
pub const SWC_DESKTOP: i32 = 0x8;
pub const TDP_GROUPCOUNT: i32 = 0x1;
pub const TDP_FLASHBUTTON: i32 = 0x2;
pub const TDP_FLASHBUTTONGROUPMENU: i32 = 0x3;
pub const TBP_BACKGROUNDBOTTOM: i32 = 0x1;
pub const TBP_BACKGROUNDRIGHT: i32 = 0x2;
pub const TBP_BACKGROUNDTOP: i32 = 0x3;
pub const TBP_BACKGROUNDLEFT: i32 = 0x4;
pub const TBP_SIZINGBARBOTTOM: i32 = 0x5;
pub const TBP_SIZINGBARRIGHT: i32 = 0x6;
pub const TBP_SIZINGBARTOP: i32 = 0x7;
pub const TBP_SIZINGBARLEFT: i32 = 0x8;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct TaCubicBezier {
    pub header: TaTimingfunction,
    pub r_x0: f32,
    pub r_y0: f32,
    pub r_x1: f32,
    pub r_y1: f32,
}
impl TaCubicBezier {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TA_CUBIC_BEZIER {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TA_CUBIC_BEZIER) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const TAP_FLAGS: i32 = 0x0;
pub const TAP_TRANSFORMCOUNT: i32 = 0x1;
pub const TAP_STAGGERDELAY: i32 = 0x2;
pub const TAP_STAGGERDELAYCAP: i32 = 0x3;
pub const TAP_STAGGERDELAYFACTOR: i32 = 0x4;
pub const TAP_ZORDER: i32 = 0x5;
pub const TAPF_NONE: u32 = 0x0;
pub const TAPF_HASSTAGGER: u32 = 0x1;
pub const TAPF_ISRTLAWARE: u32 = 0x2;
pub const TAPF_ALLOWCOLLECTION: u32 = 0x4;
pub const TAPF_HASBACKGROUND: u32 = 0x8;
pub const TAPF_HASPERSPECTIVE: u32 = 0x10;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct TaTimingfunction {
    pub e_timing_function_type: i32,
}
impl TaTimingfunction {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TA_TIMINGFUNCTION {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TA_TIMINGFUNCTION) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const TTFT_UNDEFINED: i32 = 0x0;
pub const TTFT_CUBIC_BEZIER: i32 = 0x1;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct TaTransform {
    pub e_transform_type: i32,
    pub dw_timing_function_id: u32,
    pub dw_start_time: u32,
    pub dw_duration_time: u32,
    pub e_flags: i32,
}
impl TaTransform {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TA_TRANSFORM {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TA_TRANSFORM) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct TaTransform2d {
    pub header: TaTransform,
    pub r_x: f32,
    pub r_y: f32,
    pub r_initial_x: f32,
    pub r_initial_y: f32,
    pub r_origin_x: f32,
    pub r_origin_y: f32,
}
impl TaTransform2d {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TA_TRANSFORM_2D {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TA_TRANSFORM_2D) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct TaTransformClip {
    pub header: TaTransform,
    pub r_left: f32,
    pub r_top: f32,
    pub r_right: f32,
    pub r_bottom: f32,
    pub r_initial_left: f32,
    pub r_initial_top: f32,
    pub r_initial_right: f32,
    pub r_initial_bottom: f32,
}
impl TaTransformClip {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TA_TRANSFORM_CLIP {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TA_TRANSFORM_CLIP) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const TATF_NONE: i32 = 0x0;
pub const TATF_TARGETVALUES_USER: i32 = 0x1;
pub const TATF_HASINITIALVALUES: i32 = 0x2;
pub const TATF_HASORIGINVALUES: i32 = 0x4;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct TaTransformOpacity {
    pub header: TaTransform,
    pub r_opacity: f32,
    pub r_initial_opacity: f32,
}
impl TaTransformOpacity {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TA_TRANSFORM_OPACITY {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TA_TRANSFORM_OPACITY) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const TATT_TRANSLATE_2D: i32 = 0x0;
pub const TATT_SCALE_2D: i32 = 0x1;
pub const TATT_OPACITY: i32 = 0x2;
pub const TATT_CLIP: i32 = 0x3;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tbaddbitmap {
    pub h_inst: Option<Hinstance>,
    pub n_id: usize,
}
impl Tbaddbitmap {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TBADDBITMAP {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TBADDBITMAP) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tbbutton {
    pub i_bitmap: i32,
    pub id_command: i32,
    pub fs_state: u8,
    pub fs_style: u8,
    pub b_reserved: [u8; 2],
    pub dw_data: usize,
    pub i_string: isize,
}
impl Tbbutton {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TBBUTTON {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TBBUTTON) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tbbuttoninfoa<'a> {
    pub cb_size: u32,
    pub dw_mask: u32,
    pub id_command: i32,
    pub i_image: i32,
    pub fs_state: u8,
    pub fs_style: u8,
    pub cx: u16,
    pub l_param: usize,
    pub psz_text: Cow<'a, CStr>,
    pub cch_text: i32,
}
impl Tbbuttoninfoa {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TBBUTTONINFOA {
        let Self { cb_size, dw_mask, id_command, i_image, fs_state, fs_style, cx, l_param, psz_text, cch_text } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::TBBUTTONINFOA>() as _;
        let dwMask = dw_mask;
        let idCommand = *id_command;
        let iImage = *i_image;
        let fsState = *fs_state;
        let fsStyle = *fs_style;
        let cx = *cx;
        let lParam = *l_param;
        let pszText = psz_text.as_ptr();
        let cchText = *cch_text;
        windows_sys::Win32::UI::Controls::TBBUTTONINFOA { cbSize, dwMask, idCommand, iImage, fsState, fsStyle, cx, lParam, pszText, cchText }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TBBUTTONINFOA) -> Self {
        let windows_sys::Win32::UI::Controls::TBBUTTONINFOA { cbSize, dwMask, idCommand, iImage, fsState, fsStyle, cx, lParam, pszText, cchText } = win32;
        let cb_size = cbSize;
        let dw_mask = dwMask;
        let id_command = idCommand;
        let i_image = iImage;
        let fs_state = fsState;
        let fs_style = fsStyle;
        let cx = cx;
        let l_param = lParam;
        let pszText = unsafe { CStr::from_ptr(pszText) };
        let pszText = pszText.to_bytes_with_nul().to_vec();
        let psz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(pszText) });
        let cch_text = cchText;
        Self { cb_size, dw_mask, id_command, i_image, fs_state, fs_style, cx, l_param, psz_text, cch_text }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tbbuttoninfow<'a> {
    pub cb_size: u32,
    pub dw_mask: u32,
    pub id_command: i32,
    pub i_image: i32,
    pub fs_state: u8,
    pub fs_style: u8,
    pub cx: u16,
    pub l_param: usize,
    pub psz_text: Cow<'a, [u16]>,
    pub cch_text: i32,
}
impl Tbbuttoninfow {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TBBUTTONINFOW {
        let Self { cb_size, dw_mask, id_command, i_image, fs_state, fs_style, cx, l_param, psz_text, cch_text } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::TBBUTTONINFOW>() as _;
        let dwMask = dw_mask;
        let idCommand = *id_command;
        let iImage = *i_image;
        let fsState = *fs_state;
        let fsStyle = *fs_style;
        let cx = *cx;
        let lParam = *l_param;
        assert_eq!(psz_text.last(), Some(0));
        let pszText = psz_text.as_ptr();
        let cchText = *cch_text;
        windows_sys::Win32::UI::Controls::TBBUTTONINFOW { cbSize, dwMask, idCommand, iImage, fsState, fsStyle, cx, lParam, pszText, cchText }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TBBUTTONINFOW) -> Self {
        let windows_sys::Win32::UI::Controls::TBBUTTONINFOW { cbSize, dwMask, idCommand, iImage, fsState, fsStyle, cx, lParam, pszText, cchText } = win32;
        let cb_size = cbSize;
        let dw_mask = dwMask;
        let id_command = idCommand;
        let i_image = iImage;
        let fs_state = fsState;
        let fs_style = fsStyle;
        let cx = cx;
        let l_param = lParam;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = pszText.to_vec();
        let cch_text = cchText;
        Self { cb_size, dw_mask, id_command, i_image, fs_state, fs_style, cx, l_param, psz_text, cch_text }
    }
}
pub const TBIF_BYINDEX: u32 = 0x80000000;
pub const TBIF_COMMAND: u32 = 0x20;
pub const TBIF_IMAGE: u32 = 0x1;
pub const TBIF_LPARAM: u32 = 0x10;
pub const TBIF_SIZE: u32 = 0x40;
pub const TBIF_STATE: u32 = 0x4;
pub const TBIF_STYLE: u32 = 0x8;
pub const TBIF_TEXT: u32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tbinfo {
    pub cbuttons: u32,
    pub u_flags: u32,
}
impl Tbinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::TBINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::TBINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tbinsertmark {
    pub i_button: i32,
    pub dw_flags: u32,
}
impl Tbinsertmark {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TBINSERTMARK {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TBINSERTMARK) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const TBIMHT_NONE: u32 = 0x0;
pub const TBIMHT_AFTER: u32 = 0x1;
pub const TBIMHT_BACKGROUND: u32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tbmetrics {
    pub cb_size: u32,
    pub dw_mask: u32,
    pub cx_pad: i32,
    pub cy_pad: i32,
    pub cx_bar_pad: i32,
    pub cy_bar_pad: i32,
    pub cx_button_spacing: i32,
    pub cy_button_spacing: i32,
}
impl Tbmetrics {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TBMETRICS {
        let Self { cb_size, dw_mask, cx_pad, cy_pad, cx_bar_pad, cy_bar_pad, cx_button_spacing, cy_button_spacing } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::TBMETRICS>() as _;
        let dwMask = *dw_mask;
        let cxPad = *cx_pad;
        let cyPad = *cy_pad;
        let cxBarPad = *cx_bar_pad;
        let cyBarPad = *cy_bar_pad;
        let cxButtonSpacing = *cx_button_spacing;
        let cyButtonSpacing = *cy_button_spacing;
        windows_sys::Win32::UI::Controls::TBMETRICS { cbSize, dwMask, cxPad, cyPad, cxBarPad, cyBarPad, cxButtonSpacing, cyButtonSpacing }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TBMETRICS) -> Self {
        let windows_sys::Win32::UI::Controls::TBMETRICS { cbSize, dwMask, cxPad, cyPad, cxBarPad, cyBarPad, cxButtonSpacing, cyButtonSpacing } = win32;
        let cb_size = cbSize;
        let dw_mask = dwMask;
        let cx_pad = cxPad;
        let cy_pad = cyPad;
        let cx_bar_pad = cxBarPad;
        let cy_bar_pad = cyBarPad;
        let cx_button_spacing = cxButtonSpacing;
        let cy_button_spacing = cyButtonSpacing;
        Self { cb_size, dw_mask, cx_pad, cy_pad, cx_bar_pad, cy_bar_pad, cx_button_spacing, cy_button_spacing }
    }
}
pub const TBPF_NOPROGRESS: i32 = 0x0;
pub const TBPF_INDETERMINATE: i32 = 0x1;
pub const TBPF_NORMAL: i32 = 0x2;
pub const TBPF_ERROR: i32 = 0x4;
pub const TBPF_PAUSED: i32 = 0x8;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tbreplacebitmap {
    pub h_inst_old: Option<Hinstance>,
    pub n_id_old: usize,
    pub h_inst_new: Option<Hinstance>,
    pub n_id_new: usize,
    pub n_buttons: i32,
}
impl Tbreplacebitmap {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TBREPLACEBITMAP {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TBREPLACEBITMAP) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tbsaveparamsa<'a> {
    pub hkr: Option<Hkey>,
    pub psz_sub_key: Cow<'a, CStr>,
    pub psz_value_name: Cow<'a, CStr>,
}
impl Tbsaveparamsa {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TBSAVEPARAMSA {
        let Self { hkr, psz_sub_key, psz_value_name } = self;
        let hkr = hkr.map_or(0, Hkey::into_raw);
        let pszSubKey = psz_sub_key.as_ptr();
        let pszValueName = psz_value_name.as_ptr();
        windows_sys::Win32::UI::Controls::TBSAVEPARAMSA { hkr, pszSubKey, pszValueName }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TBSAVEPARAMSA) -> Self {
        let windows_sys::Win32::UI::Controls::TBSAVEPARAMSA { hkr, pszSubKey, pszValueName } = win32;
        let hkr = unsafe { Hkey::new_optional(hkr) };
        let pszSubKey = unsafe { CStr::from_ptr(pszSubKey) };
        let pszSubKey = pszSubKey.to_bytes_with_nul().to_vec();
        let psz_sub_key = Cow::Owned(unsafe { CString::from_vec_unchecked(pszSubKey) });
        let pszValueName = unsafe { CStr::from_ptr(pszValueName) };
        let pszValueName = pszValueName.to_bytes_with_nul().to_vec();
        let psz_value_name = Cow::Owned(unsafe { CString::from_vec_unchecked(pszValueName) });
        Self { hkr, psz_sub_key, psz_value_name }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tbsaveparamsw<'a> {
    pub hkr: Option<Hkey>,
    pub psz_sub_key: Cow<'a, [u16]>,
    pub psz_value_name: Cow<'a, [u16]>,
}
impl Tbsaveparamsw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TBSAVEPARAMSW {
        let Self { hkr, psz_sub_key, psz_value_name } = self;
        let hkr = hkr.map_or(0, Hkey::into_raw);
        assert_eq!(psz_sub_key.last(), Some(0));
        let pszSubKey = psz_sub_key.as_ptr();
        assert_eq!(psz_value_name.last(), Some(0));
        let pszValueName = psz_value_name.as_ptr();
        windows_sys::Win32::UI::Controls::TBSAVEPARAMSW { hkr, pszSubKey, pszValueName }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TBSAVEPARAMSW) -> Self {
        let windows_sys::Win32::UI::Controls::TBSAVEPARAMSW { hkr, pszSubKey, pszValueName } = win32;
        let hkr = unsafe { Hkey::new_optional(hkr) };
        let slen = unsafe { wide_strlen(pszSubKey as *const u16) };
        let pszSubKey = unsafe { slice::from_raw_parts(pszSubKey, slen + 1) };
        let psz_sub_key = pszSubKey.to_vec();
        let slen = unsafe { wide_strlen(pszValueName as *const u16) };
        let pszValueName = unsafe { slice::from_raw_parts(pszValueName, slen + 1) };
        let psz_value_name = pszValueName.to_vec();
        Self { hkr, psz_sub_key, psz_value_name }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tchittestinfo {
    pub pt: Point,
    pub flags: u32,
}
impl Tchittestinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TCHITTESTINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TCHITTESTINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const TCHT_NOWHERE: u32 = 0x1;
pub const TCHT_ONITEM: u32 = 0x6;
pub const TCHT_ONITEMICON: u32 = 0x2;
pub const TCHT_ONITEMLABEL: u32 = 0x4;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tcitema<'a> {
    pub mask: u32,
    pub dw_state: u32,
    pub dw_state_mask: u32,
    pub psz_text: Cow<'a, CStr>,
    pub cch_text_max: i32,
    pub i_image: i32,
    pub l_param: Lparam,
}
impl Tcitema {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TCITEMA {
        let Self { mask, dw_state, dw_state_mask, psz_text, cch_text_max, i_image, l_param } = self;
        let mask = mask;
        let dwState = *dw_state;
        let dwStateMask = *dw_state_mask;
        let pszText = psz_text.as_ptr();
        let cchTextMax = *cch_text_max;
        let iImage = *i_image;
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::Controls::TCITEMA { mask, dwState, dwStateMask, pszText, cchTextMax, iImage, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TCITEMA) -> Self {
        let windows_sys::Win32::UI::Controls::TCITEMA { mask, dwState, dwStateMask, pszText, cchTextMax, iImage, lParam } = win32;
        let mask = mask;
        let dw_state = dwState;
        let dw_state_mask = dwStateMask;
        let pszText = unsafe { CStr::from_ptr(pszText) };
        let pszText = pszText.to_bytes_with_nul().to_vec();
        let psz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(pszText) });
        let cch_text_max = cchTextMax;
        let i_image = iImage;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { mask, dw_state, dw_state_mask, psz_text, cch_text_max, i_image, l_param }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tcitemheadera<'a> {
    pub mask: u32,
    pub lp_reserved1: u32,
    pub lp_reserved2: u32,
    pub psz_text: Cow<'a, CStr>,
    pub cch_text_max: i32,
    pub i_image: i32,
}
impl Tcitemheadera {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TCITEMHEADERA {
        let Self { mask, lp_reserved1, lp_reserved2, psz_text, cch_text_max, i_image } = self;
        let mask = mask;
        let lpReserved1 = *lp_reserved1;
        let lpReserved2 = *lp_reserved2;
        let pszText = psz_text.as_ptr();
        let cchTextMax = *cch_text_max;
        let iImage = *i_image;
        windows_sys::Win32::UI::Controls::TCITEMHEADERA { mask, lpReserved1, lpReserved2, pszText, cchTextMax, iImage }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TCITEMHEADERA) -> Self {
        let windows_sys::Win32::UI::Controls::TCITEMHEADERA { mask, lpReserved1, lpReserved2, pszText, cchTextMax, iImage } = win32;
        let mask = mask;
        let lp_reserved1 = lpReserved1;
        let lp_reserved2 = lpReserved2;
        let pszText = unsafe { CStr::from_ptr(pszText) };
        let pszText = pszText.to_bytes_with_nul().to_vec();
        let psz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(pszText) });
        let cch_text_max = cchTextMax;
        let i_image = iImage;
        Self { mask, lp_reserved1, lp_reserved2, psz_text, cch_text_max, i_image }
    }
}
pub const TCIF_IMAGE: u32 = 0x2;
pub const TCIF_RTLREADING: u32 = 0x4;
pub const TCIF_TEXT: u32 = 0x1;
pub const TCIF_PARAM: u32 = 0x8;
pub const TCIF_STATE: u32 = 0x10;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tcitemheaderw<'a> {
    pub mask: u32,
    pub lp_reserved1: u32,
    pub lp_reserved2: u32,
    pub psz_text: Cow<'a, [u16]>,
    pub cch_text_max: i32,
    pub i_image: i32,
}
impl Tcitemheaderw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TCITEMHEADERW {
        let Self { mask, lp_reserved1, lp_reserved2, psz_text, cch_text_max, i_image } = self;
        let mask = mask;
        let lpReserved1 = *lp_reserved1;
        let lpReserved2 = *lp_reserved2;
        assert_eq!(psz_text.last(), Some(0));
        let pszText = psz_text.as_ptr();
        let cchTextMax = *cch_text_max;
        let iImage = *i_image;
        windows_sys::Win32::UI::Controls::TCITEMHEADERW { mask, lpReserved1, lpReserved2, pszText, cchTextMax, iImage }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TCITEMHEADERW) -> Self {
        let windows_sys::Win32::UI::Controls::TCITEMHEADERW { mask, lpReserved1, lpReserved2, pszText, cchTextMax, iImage } = win32;
        let mask = mask;
        let lp_reserved1 = lpReserved1;
        let lp_reserved2 = lpReserved2;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = pszText.to_vec();
        let cch_text_max = cchTextMax;
        let i_image = iImage;
        Self { mask, lp_reserved1, lp_reserved2, psz_text, cch_text_max, i_image }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tcitemw<'a> {
    pub mask: u32,
    pub dw_state: u32,
    pub dw_state_mask: u32,
    pub psz_text: Cow<'a, [u16]>,
    pub cch_text_max: i32,
    pub i_image: i32,
    pub l_param: Lparam,
}
impl Tcitemw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TCITEMW {
        let Self { mask, dw_state, dw_state_mask, psz_text, cch_text_max, i_image, l_param } = self;
        let mask = mask;
        let dwState = *dw_state;
        let dwStateMask = *dw_state_mask;
        assert_eq!(psz_text.last(), Some(0));
        let pszText = psz_text.as_ptr();
        let cchTextMax = *cch_text_max;
        let iImage = *i_image;
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::Controls::TCITEMW { mask, dwState, dwStateMask, pszText, cchTextMax, iImage, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TCITEMW) -> Self {
        let windows_sys::Win32::UI::Controls::TCITEMW { mask, dwState, dwStateMask, pszText, cchTextMax, iImage, lParam } = win32;
        let mask = mask;
        let dw_state = dwState;
        let dw_state_mask = dwStateMask;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = pszText.to_vec();
        let cch_text_max = cchTextMax;
        let i_image = iImage;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { mask, dw_state, dw_state_mask, psz_text, cch_text_max, i_image, l_param }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Textmetrica {
    pub tm_height: i32,
    pub tm_ascent: i32,
    pub tm_descent: i32,
    pub tm_internal_leading: i32,
    pub tm_external_leading: i32,
    pub tm_ave_char_width: i32,
    pub tm_max_char_width: i32,
    pub tm_weight: i32,
    pub tm_overhang: i32,
    pub tm_digitized_aspect_x: i32,
    pub tm_digitized_aspect_y: i32,
    pub tm_first_char: u8,
    pub tm_last_char: u8,
    pub tm_default_char: u8,
    pub tm_break_char: u8,
    pub tm_italic: u8,
    pub tm_underlined: u8,
    pub tm_struck_out: u8,
    pub tm_pitch_and_family: u8,
    pub tm_char_set: u8,
}
impl Textmetrica {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::TEXTMETRICA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::TEXTMETRICA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Textmetricw {
    pub tm_height: i32,
    pub tm_ascent: i32,
    pub tm_descent: i32,
    pub tm_internal_leading: i32,
    pub tm_external_leading: i32,
    pub tm_ave_char_width: i32,
    pub tm_max_char_width: i32,
    pub tm_weight: i32,
    pub tm_overhang: i32,
    pub tm_digitized_aspect_x: i32,
    pub tm_digitized_aspect_y: i32,
    pub tm_first_char: u8,
    pub tm_last_char: u8,
    pub tm_default_char: u8,
    pub tm_break_char: u8,
    pub tm_italic: u8,
    pub tm_underlined: u8,
    pub tm_struck_out: u8,
    pub tm_pitch_and_family: u8,
    pub tm_char_set: u8,
}
impl Textmetricw {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::TEXTMETRICW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::TEXTMETRICW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const TST_NONE: i32 = 0x0;
pub const TST_SINGLE: i32 = 0x1;
pub const TST_CONTINUOUS: i32 = 0x2;
pub const TA_NOUPDATECP: u32 = 0x0;
pub const TA_UPDATECP: u32 = 0x1;
pub const TA_LEFT: u32 = 0x0;
pub const TA_RIGHT: u32 = 0x2;
pub const TA_CENTER: u32 = 0x6;
pub const TA_TOP: u32 = 0x0;
pub const TA_BOTTOM: u32 = 0x8;
pub const TA_BASELINE: u32 = 0x18;
pub const TA_RTLREADING: u32 = 0x100;
pub const TA_MASK: u32 = 0x11F;
pub const VTA_BASELINE: u32 = 0x18;
pub const VTA_LEFT: u32 = 0x8;
pub const VTA_RIGHT: u32 = 0x0;
pub const VTA_CENTER: u32 = 0x6;
pub const VTA_BOTTOM: u32 = 0x2;
pub const VTA_TOP: u32 = 0x0;
pub const TS_MIN: i32 = 0x0;
pub const TS_TRUE: i32 = 0x1;
pub const TS_DRAW: i32 = 0x2;
pub const TMT_RESERVEDLOW: u32 = 0x0;
pub const TMT_RESERVEDHIGH: u32 = 0x1F3F;
pub const TMT_DIBDATA: u32 = 0x2;
pub const TMT_GLYPHDIBDATA: u32 = 0x8;
pub const TMT_ENUM: u32 = 0xC8;
pub const TMT_STRING: u32 = 0xC9;
pub const TMT_INT: u32 = 0xCA;
pub const TMT_BOOL: u32 = 0xCB;
pub const TMT_COLOR: u32 = 0xCC;
pub const TMT_MARGINS: u32 = 0xCD;
pub const TMT_FILENAME: u32 = 0xCE;
pub const TMT_SIZE: u32 = 0xCF;
pub const TMT_POSITION: u32 = 0xD0;
pub const TMT_RECT: u32 = 0xD1;
pub const TMT_FONT: u32 = 0xD2;
pub const TMT_INTLIST: u32 = 0xD3;
pub const TMT_HBITMAP: u32 = 0xD4;
pub const TMT_DISKSTREAM: u32 = 0xD5;
pub const TMT_STREAM: u32 = 0xD6;
pub const TMT_BITMAPREF: u32 = 0xD7;
pub const TMT_FLOAT: u32 = 0xD8;
pub const TMT_FLOATLIST: u32 = 0xD9;
pub const TMT_COLORSCHEMES: u32 = 0x191;
pub const TMT_SIZES: u32 = 0x192;
pub const TMT_CHARSET: u32 = 0x193;
pub const TMT_NAME: u32 = 0x258;
pub const TMT_DISPLAYNAME: u32 = 0x259;
pub const TMT_TOOLTIP: u32 = 0x25A;
pub const TMT_COMPANY: u32 = 0x25B;
pub const TMT_AUTHOR: u32 = 0x25C;
pub const TMT_COPYRIGHT: u32 = 0x25D;
pub const TMT_URL: u32 = 0x25E;
pub const TMT_VERSION: u32 = 0x25F;
pub const TMT_DESCRIPTION: u32 = 0x260;
pub const TMT_FIRST_RCSTRING_NAME: u32 = 0x259;
pub const TMT_LAST_RCSTRING_NAME: u32 = 0x260;
pub const TMT_CAPTIONFONT: u32 = 0x321;
pub const TMT_SMALLCAPTIONFONT: u32 = 0x322;
pub const TMT_MENUFONT: u32 = 0x323;
pub const TMT_STATUSFONT: u32 = 0x324;
pub const TMT_MSGBOXFONT: u32 = 0x325;
pub const TMT_ICONTITLEFONT: u32 = 0x326;
pub const TMT_HEADING1FONT: u32 = 0x327;
pub const TMT_HEADING2FONT: u32 = 0x328;
pub const TMT_BODYFONT: u32 = 0x329;
pub const TMT_FIRSTFONT: u32 = 0x321;
pub const TMT_LASTFONT: u32 = 0x329;
pub const TMT_FLATMENUS: u32 = 0x3E9;
pub const TMT_FIRSTBOOL: u32 = 0x3E9;
pub const TMT_LASTBOOL: u32 = 0x3E9;
pub const TMT_SIZINGBORDERWIDTH: u32 = 0x4B1;
pub const TMT_SCROLLBARWIDTH: u32 = 0x4B2;
pub const TMT_SCROLLBARHEIGHT: u32 = 0x4B3;
pub const TMT_CAPTIONBARWIDTH: u32 = 0x4B4;
pub const TMT_CAPTIONBARHEIGHT: u32 = 0x4B5;
pub const TMT_SMCAPTIONBARWIDTH: u32 = 0x4B6;
pub const TMT_SMCAPTIONBARHEIGHT: u32 = 0x4B7;
pub const TMT_MENUBARWIDTH: u32 = 0x4B8;
pub const TMT_MENUBARHEIGHT: u32 = 0x4B9;
pub const TMT_PADDEDBORDERWIDTH: u32 = 0x4BA;
pub const TMT_FIRSTSIZE: u32 = 0x4B1;
pub const TMT_LASTSIZE: u32 = 0x4BA;
pub const TMT_MINCOLORDEPTH: u32 = 0x515;
pub const TMT_FIRSTINT: u32 = 0x515;
pub const TMT_LASTINT: u32 = 0x515;
pub const TMT_CSSNAME: u32 = 0x579;
pub const TMT_XMLNAME: u32 = 0x57A;
pub const TMT_LASTUPDATED: u32 = 0x57B;
pub const TMT_ALIAS: u32 = 0x57C;
pub const TMT_FIRSTSTRING: u32 = 0x579;
pub const TMT_LASTSTRING: u32 = 0x57C;
pub const TMT_SCROLLBAR: u32 = 0x641;
pub const TMT_BACKGROUND: u32 = 0x642;
pub const TMT_ACTIVECAPTION: u32 = 0x643;
pub const TMT_INACTIVECAPTION: u32 = 0x644;
pub const TMT_MENU: u32 = 0x645;
pub const TMT_WINDOW: u32 = 0x646;
pub const TMT_WINDOWFRAME: u32 = 0x647;
pub const TMT_MENUTEXT: u32 = 0x648;
pub const TMT_WINDOWTEXT: u32 = 0x649;
pub const TMT_CAPTIONTEXT: u32 = 0x64A;
pub const TMT_ACTIVEBORDER: u32 = 0x64B;
pub const TMT_INACTIVEBORDER: u32 = 0x64C;
pub const TMT_APPWORKSPACE: u32 = 0x64D;
pub const TMT_HIGHLIGHT: u32 = 0x64E;
pub const TMT_HIGHLIGHTTEXT: u32 = 0x64F;
pub const TMT_BTNFACE: u32 = 0x650;
pub const TMT_BTNSHADOW: u32 = 0x651;
pub const TMT_GRAYTEXT: u32 = 0x652;
pub const TMT_BTNTEXT: u32 = 0x653;
pub const TMT_INACTIVECAPTIONTEXT: u32 = 0x654;
pub const TMT_BTNHIGHLIGHT: u32 = 0x655;
pub const TMT_DKSHADOW3D: u32 = 0x656;
pub const TMT_LIGHT3D: u32 = 0x657;
pub const TMT_INFOTEXT: u32 = 0x658;
pub const TMT_INFOBK: u32 = 0x659;
pub const TMT_BUTTONALTERNATEFACE: u32 = 0x65A;
pub const TMT_HOTTRACKING: u32 = 0x65B;
pub const TMT_GRADIENTACTIVECAPTION: u32 = 0x65C;
pub const TMT_GRADIENTINACTIVECAPTION: u32 = 0x65D;
pub const TMT_MENUHILIGHT: u32 = 0x65E;
pub const TMT_MENUBAR: u32 = 0x65F;
pub const TMT_FIRSTCOLOR: u32 = 0x641;
pub const TMT_LASTCOLOR: u32 = 0x65F;
pub const TMT_FROMHUE1: u32 = 0x709;
pub const TMT_FROMHUE2: u32 = 0x70A;
pub const TMT_FROMHUE3: u32 = 0x70B;
pub const TMT_FROMHUE4: u32 = 0x70C;
pub const TMT_FROMHUE5: u32 = 0x70D;
pub const TMT_TOHUE1: u32 = 0x70E;
pub const TMT_TOHUE2: u32 = 0x70F;
pub const TMT_TOHUE3: u32 = 0x710;
pub const TMT_TOHUE4: u32 = 0x711;
pub const TMT_TOHUE5: u32 = 0x712;
pub const TMT_FROMCOLOR1: u32 = 0x7D1;
pub const TMT_FROMCOLOR2: u32 = 0x7D2;
pub const TMT_FROMCOLOR3: u32 = 0x7D3;
pub const TMT_FROMCOLOR4: u32 = 0x7D4;
pub const TMT_FROMCOLOR5: u32 = 0x7D5;
pub const TMT_TOCOLOR1: u32 = 0x7D6;
pub const TMT_TOCOLOR2: u32 = 0x7D7;
pub const TMT_TOCOLOR3: u32 = 0x7D8;
pub const TMT_TOCOLOR4: u32 = 0x7D9;
pub const TMT_TOCOLOR5: u32 = 0x7DA;
pub const TMT_TRANSPARENT: u32 = 0x899;
pub const TMT_AUTOSIZE: u32 = 0x89A;
pub const TMT_BORDERONLY: u32 = 0x89B;
pub const TMT_COMPOSITED: u32 = 0x89C;
pub const TMT_BGFILL: u32 = 0x89D;
pub const TMT_GLYPHTRANSPARENT: u32 = 0x89E;
pub const TMT_GLYPHONLY: u32 = 0x89F;
pub const TMT_ALWAYSSHOWSIZINGBAR: u32 = 0x8A0;
pub const TMT_MIRRORIMAGE: u32 = 0x8A1;
pub const TMT_UNIFORMSIZING: u32 = 0x8A2;
pub const TMT_INTEGRALSIZING: u32 = 0x8A3;
pub const TMT_SOURCEGROW: u32 = 0x8A4;
pub const TMT_SOURCESHRINK: u32 = 0x8A5;
pub const TMT_DRAWBORDERS: u32 = 0x8A6;
pub const TMT_NOETCHEDEFFECT: u32 = 0x8A7;
pub const TMT_TEXTAPPLYOVERLAY: u32 = 0x8A8;
pub const TMT_TEXTGLOW: u32 = 0x8A9;
pub const TMT_TEXTITALIC: u32 = 0x8AA;
pub const TMT_COMPOSITEDOPAQUE: u32 = 0x8AB;
pub const TMT_LOCALIZEDMIRRORIMAGE: u32 = 0x8AC;
pub const TMT_IMAGECOUNT: u32 = 0x961;
pub const TMT_ALPHALEVEL: u32 = 0x962;
pub const TMT_BORDERSIZE: u32 = 0x963;
pub const TMT_ROUNDCORNERWIDTH: u32 = 0x964;
pub const TMT_ROUNDCORNERHEIGHT: u32 = 0x965;
pub const TMT_GRADIENTRATIO1: u32 = 0x966;
pub const TMT_GRADIENTRATIO2: u32 = 0x967;
pub const TMT_GRADIENTRATIO3: u32 = 0x968;
pub const TMT_GRADIENTRATIO4: u32 = 0x969;
pub const TMT_GRADIENTRATIO5: u32 = 0x96A;
pub const TMT_PROGRESSCHUNKSIZE: u32 = 0x96B;
pub const TMT_PROGRESSSPACESIZE: u32 = 0x96C;
pub const TMT_SATURATION: u32 = 0x96D;
pub const TMT_TEXTBORDERSIZE: u32 = 0x96E;
pub const TMT_ALPHATHRESHOLD: u32 = 0x96F;
pub const TMT_WIDTH: u32 = 0x970;
pub const TMT_HEIGHT: u32 = 0x971;
pub const TMT_GLYPHINDEX: u32 = 0x972;
pub const TMT_TRUESIZESTRETCHMARK: u32 = 0x973;
pub const TMT_MINDPI1: u32 = 0x974;
pub const TMT_MINDPI2: u32 = 0x975;
pub const TMT_MINDPI3: u32 = 0x976;
pub const TMT_MINDPI4: u32 = 0x977;
pub const TMT_MINDPI5: u32 = 0x978;
pub const TMT_TEXTGLOWSIZE: u32 = 0x979;
pub const TMT_FRAMESPERSECOND: u32 = 0x97A;
pub const TMT_PIXELSPERFRAME: u32 = 0x97B;
pub const TMT_ANIMATIONDELAY: u32 = 0x97C;
pub const TMT_GLOWINTENSITY: u32 = 0x97D;
pub const TMT_OPACITY: u32 = 0x97E;
pub const TMT_COLORIZATIONCOLOR: u32 = 0x97F;
pub const TMT_COLORIZATIONOPACITY: u32 = 0x980;
pub const TMT_MINDPI6: u32 = 0x981;
pub const TMT_MINDPI7: u32 = 0x982;
pub const TMT_GLYPHFONT: u32 = 0xA29;
pub const TMT_IMAGEFILE: u32 = 0xBB9;
pub const TMT_IMAGEFILE1: u32 = 0xBBA;
pub const TMT_IMAGEFILE2: u32 = 0xBBB;
pub const TMT_IMAGEFILE3: u32 = 0xBBC;
pub const TMT_IMAGEFILE4: u32 = 0xBBD;
pub const TMT_IMAGEFILE5: u32 = 0xBBE;
pub const TMT_GLYPHIMAGEFILE: u32 = 0xBC0;
pub const TMT_IMAGEFILE6: u32 = 0xBC1;
pub const TMT_IMAGEFILE7: u32 = 0xBC2;
pub const TMT_TEXT: u32 = 0xC81;
pub const TMT_CLASSICVALUE: u32 = 0xC82;
pub const TMT_OFFSET: u32 = 0xD49;
pub const TMT_TEXTSHADOWOFFSET: u32 = 0xD4A;
pub const TMT_MINSIZE: u32 = 0xD4B;
pub const TMT_MINSIZE1: u32 = 0xD4C;
pub const TMT_MINSIZE2: u32 = 0xD4D;
pub const TMT_MINSIZE3: u32 = 0xD4E;
pub const TMT_MINSIZE4: u32 = 0xD4F;
pub const TMT_MINSIZE5: u32 = 0xD50;
pub const TMT_NORMALSIZE: u32 = 0xD51;
pub const TMT_MINSIZE6: u32 = 0xD52;
pub const TMT_MINSIZE7: u32 = 0xD53;
pub const TMT_SIZINGMARGINS: u32 = 0xE11;
pub const TMT_CONTENTMARGINS: u32 = 0xE12;
pub const TMT_CAPTIONMARGINS: u32 = 0xE13;
pub const TMT_BORDERCOLOR: u32 = 0xED9;
pub const TMT_FILLCOLOR: u32 = 0xEDA;
pub const TMT_TEXTCOLOR: u32 = 0xEDB;
pub const TMT_EDGELIGHTCOLOR: u32 = 0xEDC;
pub const TMT_EDGEHIGHLIGHTCOLOR: u32 = 0xEDD;
pub const TMT_EDGESHADOWCOLOR: u32 = 0xEDE;
pub const TMT_EDGEDKSHADOWCOLOR: u32 = 0xEDF;
pub const TMT_EDGEFILLCOLOR: u32 = 0xEE0;
pub const TMT_TRANSPARENTCOLOR: u32 = 0xEE1;
pub const TMT_GRADIENTCOLOR1: u32 = 0xEE2;
pub const TMT_GRADIENTCOLOR2: u32 = 0xEE3;
pub const TMT_GRADIENTCOLOR3: u32 = 0xEE4;
pub const TMT_GRADIENTCOLOR4: u32 = 0xEE5;
pub const TMT_GRADIENTCOLOR5: u32 = 0xEE6;
pub const TMT_SHADOWCOLOR: u32 = 0xEE7;
pub const TMT_GLOWCOLOR: u32 = 0xEE8;
pub const TMT_TEXTBORDERCOLOR: u32 = 0xEE9;
pub const TMT_TEXTSHADOWCOLOR: u32 = 0xEEA;
pub const TMT_GLYPHTEXTCOLOR: u32 = 0xEEB;
pub const TMT_GLYPHTRANSPARENTCOLOR: u32 = 0xEEC;
pub const TMT_FILLCOLORHINT: u32 = 0xEED;
pub const TMT_BORDERCOLORHINT: u32 = 0xEEE;
pub const TMT_ACCENTCOLORHINT: u32 = 0xEEF;
pub const TMT_TEXTCOLORHINT: u32 = 0xEF0;
pub const TMT_HEADING1TEXTCOLOR: u32 = 0xEF1;
pub const TMT_HEADING2TEXTCOLOR: u32 = 0xEF2;
pub const TMT_BODYTEXTCOLOR: u32 = 0xEF3;
pub const TMT_BGTYPE: u32 = 0xFA1;
pub const TMT_BORDERTYPE: u32 = 0xFA2;
pub const TMT_FILLTYPE: u32 = 0xFA3;
pub const TMT_SIZINGTYPE: u32 = 0xFA4;
pub const TMT_HALIGN: u32 = 0xFA5;
pub const TMT_CONTENTALIGNMENT: u32 = 0xFA6;
pub const TMT_VALIGN: u32 = 0xFA7;
pub const TMT_OFFSETTYPE: u32 = 0xFA8;
pub const TMT_ICONEFFECT: u32 = 0xFA9;
pub const TMT_TEXTSHADOWTYPE: u32 = 0xFAA;
pub const TMT_IMAGELAYOUT: u32 = 0xFAB;
pub const TMT_GLYPHTYPE: u32 = 0xFAC;
pub const TMT_IMAGESELECTTYPE: u32 = 0xFAD;
pub const TMT_GLYPHFONTSIZINGTYPE: u32 = 0xFAE;
pub const TMT_TRUESIZESCALINGTYPE: u32 = 0xFAF;
pub const TMT_USERPICTURE: u32 = 0x1389;
pub const TMT_DEFAULTPANESIZE: u32 = 0x138A;
pub const TMT_BLENDCOLOR: u32 = 0x138B;
pub const TMT_CUSTOMSPLITRECT: u32 = 0x138C;
pub const TMT_ANIMATIONBUTTONRECT: u32 = 0x138D;
pub const TMT_ANIMATIONDURATION: u32 = 0x138E;
pub const TMT_TRANSITIONDURATIONS: u32 = 0x1770;
pub const TMT_SCALEDBACKGROUND: u32 = 0x1B59;
pub const TMT_ATLASIMAGE: u32 = 0x1F40;
pub const TMT_ATLASINPUTIMAGE: u32 = 0x1F41;
pub const TMT_ATLASRECT: u32 = 0x1F42;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Thumbbutton {
    pub dw_mask: i32,
    pub i_id: u32,
    pub i_bitmap: u32,
    pub h_icon: Option<Hicon>,
    pub sz_tip: [u8; 260],
    pub dw_flags: i32,
}
impl Thumbbutton {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::THUMBBUTTON {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::THUMBBUTTON) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const THBF_ENABLED: i32 = 0x0;
pub const THBF_DISABLED: i32 = 0x1;
pub const THBF_DISMISSONCLICK: i32 = 0x2;
pub const THBF_NOBACKGROUND: i32 = 0x4;
pub const THBF_HIDDEN: i32 = 0x8;
pub const THBF_NONINTERACTIVE: i32 = 0x10;
pub const THB_BITMAP: i32 = 0x1;
pub const THB_ICON: i32 = 0x2;
pub const THB_TOOLTIP: i32 = 0x4;
pub const THB_FLAGS: i32 = 0x8;
pub const MDITILE_HORIZONTAL: u32 = 0x1;
pub const MDITILE_VERTICAL: u32 = 0x0;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Titlebarinfo {
    pub cb_size: u32,
    pub rc_title_bar: Rect,
    pub rgstate: [u32; 6],
}
impl Titlebarinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::TITLEBARINFO {
        let Self { cb_size, rc_title_bar, rgstate } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::TITLEBARINFO>() as _;
        let rcTitleBar = rc_title_bar.to_win32();
        let rgstate = [*rgstate[0],*rgstate[1],*rgstate[2],*rgstate[3],*rgstate[4],*rgstate[5]];
        windows_sys::Win32::UI::WindowsAndMessaging::TITLEBARINFO { cbSize, rcTitleBar, rgstate }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::TITLEBARINFO) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::TITLEBARINFO { cbSize, rcTitleBar, rgstate } = win32;
        let cb_size = cbSize;
        let rc_title_bar = unsafe { RECT::from_win32(rcTitleBar) };
        let rgstate = [rgstate[0],rgstate[1],rgstate[2],rgstate[3],rgstate[4],rgstate[5]];
        Self { cb_size, rc_title_bar, rgstate }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Titlebarinfoex {
    pub cb_size: u32,
    pub rc_title_bar: Rect,
    pub rgstate: [u32; 6],
    pub rgrect: [Rect; 6],
}
impl Titlebarinfoex {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::TITLEBARINFOEX {
        let Self { cb_size, rc_title_bar, rgstate, rgrect } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::TITLEBARINFOEX>() as _;
        let rcTitleBar = rc_title_bar.to_win32();
        let rgstate = [*rgstate[0],*rgstate[1],*rgstate[2],*rgstate[3],*rgstate[4],*rgstate[5]];
        let rgrect = [rgrect[0].to_win32(),rgrect[1].to_win32(),rgrect[2].to_win32(),rgrect[3].to_win32(),rgrect[4].to_win32(),rgrect[5].to_win32()];
        windows_sys::Win32::UI::WindowsAndMessaging::TITLEBARINFOEX { cbSize, rcTitleBar, rgstate, rgrect }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::TITLEBARINFOEX) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::TITLEBARINFOEX { cbSize, rcTitleBar, rgstate, rgrect } = win32;
        let cb_size = cbSize;
        let rc_title_bar = unsafe { RECT::from_win32(rcTitleBar) };
        let rgstate = [rgstate[0],rgstate[1],rgstate[2],rgstate[3],rgstate[4],rgstate[5]];
        let rgrect = [unsafe { RECT::from_win32(rgrect[0]) },unsafe { RECT::from_win32(rgrect[1]) },unsafe { RECT::from_win32(rgrect[2]) },unsafe { RECT::from_win32(rgrect[3]) },unsafe { RECT::from_win32(rgrect[4]) },unsafe { RECT::from_win32(rgrect[5]) }];
        Self { cb_size, rc_title_bar, rgstate, rgrect }
    }
}
pub const TI_BITMAP: i32 = 0x1;
pub const TI_JPEG: i32 = 0x2;
pub const TLEF_RELATIVE_INCLUDE_CURRENT: i32 = 0x1;
pub const TLEF_RELATIVE_BACK: i32 = 0x10;
pub const TLEF_RELATIVE_FORE: i32 = 0x20;
pub const TLEF_INCLUDE_UNINVOKEABLE: i32 = 0x40;
pub const TLEF_ABSOLUTE: i32 = 0x31;
pub const TLEF_EXCLUDE_SUBFRAME_ENTRIES: i32 = 0x80;
pub const TLEF_EXCLUDE_ABOUT_PAGES: i32 = 0x100;
pub const TOUCH_FEEDBACK_DEFAULT: u32 = 0x1;
pub const TOUCH_FEEDBACK_INDIRECT: u32 = 0x2;
pub const TOUCH_FEEDBACK_NONE: u32 = 0x3;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct TouchHitTestingInput {
    pub pointer_id: u32,
    pub point: Point,
    pub bounding_box: Rect,
    pub non_occluded_bounding_box: Rect,
    pub orientation: u32,
}
impl TouchHitTestingInput {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TOUCH_HIT_TESTING_INPUT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TOUCH_HIT_TESTING_INPUT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct TouchHitTestingProximityEvaluation {
    pub score: u16,
    pub adjusted_point: Point,
}
impl TouchHitTestingProximityEvaluation {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TOUCH_HIT_TESTING_PROXIMITY_EVALUATION {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TOUCH_HIT_TESTING_PROXIMITY_EVALUATION) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tpmparams {
    pub cb_size: u32,
    pub rc_exclude: Rect,
}
impl Tpmparams {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::TPMPARAMS {
        let Self { cb_size, rc_exclude } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::TPMPARAMS>() as _;
        let rcExclude = rc_exclude.to_win32();
        windows_sys::Win32::UI::WindowsAndMessaging::TPMPARAMS { cbSize, rcExclude }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::TPMPARAMS) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::TPMPARAMS { cbSize, rcExclude } = win32;
        let cb_size = cbSize;
        let rc_exclude = unsafe { RECT::from_win32(rcExclude) };
        Self { cb_size, rc_exclude }
    }
}
pub const TPM_LEFTBUTTON: u32 = 0x0;
pub const TPM_RIGHTBUTTON: u32 = 0x2;
pub const TPM_LEFTALIGN: u32 = 0x0;
pub const TPM_CENTERALIGN: u32 = 0x4;
pub const TPM_RIGHTALIGN: u32 = 0x8;
pub const TPM_TOPALIGN: u32 = 0x0;
pub const TPM_VCENTERALIGN: u32 = 0x10;
pub const TPM_BOTTOMALIGN: u32 = 0x20;
pub const TPM_HORIZONTAL: u32 = 0x0;
pub const TPM_VERTICAL: u32 = 0x40;
pub const TPM_NONOTIFY: u32 = 0x80;
pub const TPM_RETURNCMD: u32 = 0x100;
pub const TPM_RECURSE: u32 = 0x1;
pub const TPM_HORPOSANIMATION: u32 = 0x400;
pub const TPM_HORNEGANIMATION: u32 = 0x800;
pub const TPM_VERPOSANIMATION: u32 = 0x1000;
pub const TPM_VERNEGANIMATION: u32 = 0x2000;
pub const TPM_NOANIMATION: u32 = 0x4000;
pub const TPM_LAYOUTRTL: u32 = 0x8000;
pub const TPM_WORKAREA: u32 = 0x10000;
pub const MCTGC_HOT: i32 = 0x1;
pub const MCTGC_HASSTATE: i32 = 0x2;
pub const MCTGC_HASSTATEHOT: i32 = 0x3;
pub const MCTGC_TODAY: i32 = 0x4;
pub const MCTGC_TODAYSELECTED: i32 = 0x5;
pub const MCTGC_SELECTED: i32 = 0x6;
pub const MCTGC_SELECTEDHOT: i32 = 0x7;
pub const MCTGCU_HOT: i32 = 0x1;
pub const MCTGCU_HASSTATE: i32 = 0x2;
pub const MCTGCU_HASSTATEHOT: i32 = 0x3;
pub const MCTGCU_SELECTED: i32 = 0x4;
pub const MCTGCU_SELECTEDHOT: i32 = 0x5;
pub const TNP_BACKGROUND: i32 = 0x1;
pub const TNP_ANIMBACKGROUND: i32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Trivertex {
    pub x: i32,
    pub y: i32,
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub alpha: u16,
}
impl Trivertex {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::TRIVERTEX {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::TRIVERTEX) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const TSST_NONE: i32 = 0x0;
pub const TSST_SIZE: i32 = 0x1;
pub const TSST_DPI: i32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Ttembedinfo<'a> {
    pub us_struct_size: u16,
    pub us_root_str_size: u16,
    pub pus_root_str: &'a mut u16,
}
impl Ttembedinfo {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::TTEMBEDINFO {
        let Self { us_struct_size, us_root_str_size, pus_root_str } = self;
        let usStructSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::TTEMBEDINFO>() as _;
        let usRootStrSize = *us_root_str_size;
        let pusRootStr = unsafe { &mut *(pus_root_str as *mut _ as *mut _) };
        windows_sys::Win32::Graphics::Gdi::TTEMBEDINFO { usStructSize, usRootStrSize, pusRootStr }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::TTEMBEDINFO) -> Self {
        let windows_sys::Win32::Graphics::Gdi::TTEMBEDINFO { usStructSize, usRootStrSize, pusRootStr } = win32;
        let us_struct_size = usStructSize;
        let us_root_str_size = usRootStrSize;
        let pus_root_str = unsafe { &mut *(pusRootStr as *mut _ as *mut _) };
        Self { us_struct_size, us_root_str_size, pus_root_str }
    }
}
pub const TTEMBED_EMBEDEUDC: u32 = 0x20;
pub const TTEMBED_RAW: u32 = 0x0;
pub const TTEMBED_SUBSET: u32 = 0x1;
pub const TTEMBED_TTCOMPRESSED: u32 = 0x4;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Ttgettitle<'a> {
    pub dw_size: u32,
    pub u_title_bitmap: u32,
    pub cch: u32,
    pub psz_title: Cow<'a, [u16]>,
}
impl Ttgettitle {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TTGETTITLE {
        let Self { dw_size, u_title_bitmap, cch, psz_title } = self;
        let dwSize = mem::size_of::<windows_sys::Win32::UI::Controls::TTGETTITLE>() as _;
        let uTitleBitmap = *u_title_bitmap;
        let cch = *cch;
        assert_eq!(psz_title.last(), Some(0));
        let pszTitle = psz_title.as_ptr();
        windows_sys::Win32::UI::Controls::TTGETTITLE { dwSize, uTitleBitmap, cch, pszTitle }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TTGETTITLE) -> Self {
        let windows_sys::Win32::UI::Controls::TTGETTITLE { dwSize, uTitleBitmap, cch, pszTitle } = win32;
        let dw_size = dwSize;
        let u_title_bitmap = uTitleBitmap;
        let cch = cch;
        let slen = unsafe { wide_strlen(pszTitle as *const u16) };
        let pszTitle = unsafe { slice::from_raw_parts(pszTitle, slen + 1) };
        let psz_title = pszTitle.to_vec();
        Self { dw_size, u_title_bitmap, cch, psz_title }
    }
}
//  Not generated due to containing a void type
//  #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Tthittestinfoa<'a> {
//      pub hwnd: Option<Hwnd>,
//      pub pt: Point,
//      pub ti: Tttoolinfoa<'a>,
//  }
//  impl Tthittestinfoa {
//      fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TTHITTESTINFOA {
//          let Self { hwnd, pt, ti } = self;
//          let hwnd = hwnd.map_or(0, Hwnd::into_raw);
//          let pt = pt.to_win32();
//          let ti = ti.to_win32();
//          windows_sys::Win32::UI::Controls::TTHITTESTINFOA { hwnd, pt, ti }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TTHITTESTINFOA) -> Self {
//          let windows_sys::Win32::UI::Controls::TTHITTESTINFOA { hwnd, pt, ti } = win32;
//          let hwnd = unsafe { Hwnd::new_optional(hwnd) };
//          let pt = unsafe { POINT::from_win32(pt) };
//          let ti = unsafe { TTTOOLINFOA::from_win32(ti) };
//          Self { hwnd, pt, ti }
//      }
//  }
//  Not generated due to containing a void type
//  #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Tthittestinfow<'a> {
//      pub hwnd: Option<Hwnd>,
//      pub pt: Point,
//      pub ti: Tttoolinfow<'a>,
//  }
//  impl Tthittestinfow {
//      fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TTHITTESTINFOW {
//          let Self { hwnd, pt, ti } = self;
//          let hwnd = hwnd.map_or(0, Hwnd::into_raw);
//          let pt = pt.to_win32();
//          let ti = ti.to_win32();
//          windows_sys::Win32::UI::Controls::TTHITTESTINFOW { hwnd, pt, ti }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TTHITTESTINFOW) -> Self {
//          let windows_sys::Win32::UI::Controls::TTHITTESTINFOW { hwnd, pt, ti } = win32;
//          let hwnd = unsafe { Hwnd::new_optional(hwnd) };
//          let pt = unsafe { POINT::from_win32(pt) };
//          let ti = unsafe { TTTOOLINFOW::from_win32(ti) };
//          Self { hwnd, pt, ti }
//      }
//  }
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Ttloadinfo<'a> {
    pub us_struct_size: u16,
    pub us_ref_str_size: u16,
    pub pus_ref_str: &'a mut u16,
}
impl Ttloadinfo {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::TTLOADINFO {
        let Self { us_struct_size, us_ref_str_size, pus_ref_str } = self;
        let usStructSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::TTLOADINFO>() as _;
        let usRefStrSize = *us_ref_str_size;
        let pusRefStr = unsafe { &mut *(pus_ref_str as *mut _ as *mut _) };
        windows_sys::Win32::Graphics::Gdi::TTLOADINFO { usStructSize, usRefStrSize, pusRefStr }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::TTLOADINFO) -> Self {
        let windows_sys::Win32::Graphics::Gdi::TTLOADINFO { usStructSize, usRefStrSize, pusRefStr } = win32;
        let us_struct_size = usStructSize;
        let us_ref_str_size = usRefStrSize;
        let pus_ref_str = unsafe { &mut *(pusRefStr as *mut _ as *mut _) };
        Self { us_struct_size, us_ref_str_size, pus_ref_str }
    }
}
pub const TTLOAD_FONT_SUBSETTED: u32 = 0x1;
pub const TTLOAD_FONT_IN_SYSSTARTUP: u32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Ttpolycurve {
    pub w_type: u16,
    pub cpfx: u16,
    pub apfx: [Pointfx; 1],
}
impl Ttpolycurve {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::TTPOLYCURVE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::TTPOLYCURVE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Ttpolygonheader {
    pub cb: u32,
    pub dw_type: u32,
    pub pfx_start: Pointfx,
}
impl Ttpolygonheader {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::TTPOLYGONHEADER {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::TTPOLYGONHEADER) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
//  Not generated due to containing a void type
//  #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Tttoolinfoa<'a> {
//      pub cb_size: u32,
//      pub u_flags: u32,
//      pub hwnd: Option<Hwnd>,
//      pub u_id: usize,
//      pub rect: Rect,
//      pub hinst: Option<Hinstance>,
//      pub lpsz_text: Cow<'a, CStr>,
//      pub l_param: Lparam,
//      pub lp_reserved: &'a mut todo_void,
//  }
//  impl Tttoolinfoa {
//      fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TTTOOLINFOA {
//          let Self { cb_size, u_flags, hwnd, u_id, rect, hinst, lpsz_text, l_param, lp_reserved } = self;
//          let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::TTTOOLINFOA>() as _;
//          let uFlags = u_flags;
//          let hwnd = hwnd.map_or(0, Hwnd::into_raw);
//          let uId = *u_id;
//          let rect = rect.to_win32();
//          let hinst = hinst.map_or(0, Hinstance::into_raw);
//          let lpszText = lpsz_text.as_ptr();
//          let lParam = l_param.into_inner();
//          let lpReserved = unsafe { &mut *(lp_reserved as *mut _ as *mut _) };
//          windows_sys::Win32::UI::Controls::TTTOOLINFOA { cbSize, uFlags, hwnd, uId, rect, hinst, lpszText, lParam, lpReserved }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TTTOOLINFOA) -> Self {
//          let windows_sys::Win32::UI::Controls::TTTOOLINFOA { cbSize, uFlags, hwnd, uId, rect, hinst, lpszText, lParam, lpReserved } = win32;
//          let cb_size = cbSize;
//          let u_flags = uFlags;
//          let hwnd = unsafe { Hwnd::new_optional(hwnd) };
//          let u_id = uId;
//          let rect = unsafe { RECT::from_win32(rect) };
//          let hinst = unsafe { Hinstance::new_optional(hinst) };
//          let lpszText = unsafe { CStr::from_ptr(lpszText) };
//          let lpszText = lpszText.to_bytes_with_nul().to_vec();
//          let lpsz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(lpszText) });
//          let l_param = unsafe { Lparam::from_inner(lParam) };
//          let lp_reserved = unsafe { &mut *(lpReserved as *mut _ as *mut _) };
//          Self { cb_size, u_flags, hwnd, u_id, rect, hinst, lpsz_text, l_param, lp_reserved }
//      }
//  }
//  Not generated due to containing a void type
//  #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Tttoolinfow<'a> {
//      pub cb_size: u32,
//      pub u_flags: u32,
//      pub hwnd: Option<Hwnd>,
//      pub u_id: usize,
//      pub rect: Rect,
//      pub hinst: Option<Hinstance>,
//      pub lpsz_text: Cow<'a, [u16]>,
//      pub l_param: Lparam,
//      pub lp_reserved: &'a mut todo_void,
//  }
//  impl Tttoolinfow {
//      fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TTTOOLINFOW {
//          let Self { cb_size, u_flags, hwnd, u_id, rect, hinst, lpsz_text, l_param, lp_reserved } = self;
//          let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::TTTOOLINFOW>() as _;
//          let uFlags = u_flags;
//          let hwnd = hwnd.map_or(0, Hwnd::into_raw);
//          let uId = *u_id;
//          let rect = rect.to_win32();
//          let hinst = hinst.map_or(0, Hinstance::into_raw);
//          assert_eq!(lpsz_text.last(), Some(0));
//          let lpszText = lpsz_text.as_ptr();
//          let lParam = l_param.into_inner();
//          let lpReserved = unsafe { &mut *(lp_reserved as *mut _ as *mut _) };
//          windows_sys::Win32::UI::Controls::TTTOOLINFOW { cbSize, uFlags, hwnd, uId, rect, hinst, lpszText, lParam, lpReserved }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TTTOOLINFOW) -> Self {
//          let windows_sys::Win32::UI::Controls::TTTOOLINFOW { cbSize, uFlags, hwnd, uId, rect, hinst, lpszText, lParam, lpReserved } = win32;
//          let cb_size = cbSize;
//          let u_flags = uFlags;
//          let hwnd = unsafe { Hwnd::new_optional(hwnd) };
//          let u_id = uId;
//          let rect = unsafe { RECT::from_win32(rect) };
//          let hinst = unsafe { Hinstance::new_optional(hinst) };
//          let slen = unsafe { wide_strlen(lpszText as *const u16) };
//          let lpszText = unsafe { slice::from_raw_parts(lpszText, slen + 1) };
//          let lpsz_text = lpszText.to_vec();
//          let l_param = unsafe { Lparam::from_inner(lParam) };
//          let lp_reserved = unsafe { &mut *(lpReserved as *mut _ as *mut _) };
//          Self { cb_size, u_flags, hwnd, u_id, rect, hinst, lpsz_text, l_param, lp_reserved }
//      }
//  }
pub const TTF_ABSOLUTE: u32 = 0x80;
pub const TTF_CENTERTIP: u32 = 0x2;
pub const TTF_IDISHWND: u32 = 0x1;
pub const TTF_PARSELINKS: u32 = 0x1000;
pub const TTF_RTLREADING: u32 = 0x4;
pub const TTF_SUBCLASS: u32 = 0x10;
pub const TTF_TRACK: u32 = 0x20;
pub const TTF_TRANSPARENT: u32 = 0x100;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Ttvalidationtestsparams<'a> {
    pub ul_struct_size: u32,
    pub l_test_from_size: i32,
    pub l_test_to_size: i32,
    pub ul_char_set: u32,
    pub us_reserved1: u16,
    pub us_char_code_count: u16,
    pub pus_char_code_set: &'a mut u16,
}
impl Ttvalidationtestsparams {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::TTVALIDATIONTESTSPARAMS {
        let Self { ul_struct_size, l_test_from_size, l_test_to_size, ul_char_set, us_reserved1, us_char_code_count, pus_char_code_set } = self;
        let ulStructSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::TTVALIDATIONTESTSPARAMS>() as _;
        let lTestFromSize = *l_test_from_size;
        let lTestToSize = *l_test_to_size;
        let ulCharSet = *ul_char_set;
        let usReserved1 = *us_reserved1;
        let usCharCodeCount = *us_char_code_count;
        let pusCharCodeSet = unsafe { &mut *(pus_char_code_set as *mut _ as *mut _) };
        windows_sys::Win32::Graphics::Gdi::TTVALIDATIONTESTSPARAMS { ulStructSize, lTestFromSize, lTestToSize, ulCharSet, usReserved1, usCharCodeCount, pusCharCodeSet }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::TTVALIDATIONTESTSPARAMS) -> Self {
        let windows_sys::Win32::Graphics::Gdi::TTVALIDATIONTESTSPARAMS { ulStructSize, lTestFromSize, lTestToSize, ulCharSet, usReserved1, usCharCodeCount, pusCharCodeSet } = win32;
        let ul_struct_size = ulStructSize;
        let l_test_from_size = lTestFromSize;
        let l_test_to_size = lTestToSize;
        let ul_char_set = ulCharSet;
        let us_reserved1 = usReserved1;
        let us_char_code_count = usCharCodeCount;
        let pus_char_code_set = unsafe { &mut *(pusCharCodeSet as *mut _ as *mut _) };
        Self { ul_struct_size, l_test_from_size, l_test_to_size, ul_char_set, us_reserved1, us_char_code_count, pus_char_code_set }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Ttvalidationtestsparamsex<'a> {
    pub ul_struct_size: u32,
    pub l_test_from_size: i32,
    pub l_test_to_size: i32,
    pub ul_char_set: u32,
    pub us_reserved1: u16,
    pub us_char_code_count: u16,
    pub pul_char_code_set: &'a mut u32,
}
impl Ttvalidationtestsparamsex {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::TTVALIDATIONTESTSPARAMSEX {
        let Self { ul_struct_size, l_test_from_size, l_test_to_size, ul_char_set, us_reserved1, us_char_code_count, pul_char_code_set } = self;
        let ulStructSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::TTVALIDATIONTESTSPARAMSEX>() as _;
        let lTestFromSize = *l_test_from_size;
        let lTestToSize = *l_test_to_size;
        let ulCharSet = *ul_char_set;
        let usReserved1 = *us_reserved1;
        let usCharCodeCount = *us_char_code_count;
        let pulCharCodeSet = unsafe { &mut *(pul_char_code_set as *mut _ as *mut _) };
        windows_sys::Win32::Graphics::Gdi::TTVALIDATIONTESTSPARAMSEX { ulStructSize, lTestFromSize, lTestToSize, ulCharSet, usReserved1, usCharCodeCount, pulCharCodeSet }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::TTVALIDATIONTESTSPARAMSEX) -> Self {
        let windows_sys::Win32::Graphics::Gdi::TTVALIDATIONTESTSPARAMSEX { ulStructSize, lTestFromSize, lTestToSize, ulCharSet, usReserved1, usCharCodeCount, pulCharCodeSet } = win32;
        let ul_struct_size = ulStructSize;
        let l_test_from_size = lTestFromSize;
        let l_test_to_size = lTestToSize;
        let ul_char_set = ulCharSet;
        let us_reserved1 = usReserved1;
        let us_char_code_count = usCharCodeCount;
        let pul_char_code_set = unsafe { &mut *(pulCharCodeSet as *mut _ as *mut _) };
        Self { ul_struct_size, l_test_from_size, l_test_to_size, ul_char_set, us_reserved1, us_char_code_count, pul_char_code_set }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tvgetitempartrectinfo<'a> {
    pub hti: Option<Htreeitem>,
    pub prc: &'a mut Rect,
    pub part_id: i32,
}
impl Tvgetitempartrectinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TVGETITEMPARTRECTINFO {
        let Self { hti, prc, part_id } = self;
        let hti = hti.map_or(0, Htreeitem::into_raw);
        let prc = unsafe { &mut *(prc as *mut _ as *mut _) };
        let partID = part_id;
        windows_sys::Win32::UI::Controls::TVGETITEMPARTRECTINFO { hti, prc, partID }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TVGETITEMPARTRECTINFO) -> Self {
        let windows_sys::Win32::UI::Controls::TVGETITEMPARTRECTINFO { hti, prc, partID } = win32;
        let hti = unsafe { Htreeitem::new_optional(hti) };
        let prc = unsafe { &mut *(prc as *mut _ as *mut _) };
        let part_id = partID;
        Self { hti, prc, part_id }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tvhittestinfo {
    pub pt: Point,
    pub flags: u32,
    pub h_item: Option<Htreeitem>,
}
impl Tvhittestinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TVHITTESTINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TVHITTESTINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const TVHT_ABOVE: u32 = 0x100;
pub const TVHT_BELOW: u32 = 0x200;
pub const TVHT_NOWHERE: u32 = 0x1;
pub const TVHT_ONITEM: u32 = 0x46;
pub const TVHT_ONITEMBUTTON: u32 = 0x10;
pub const TVHT_ONITEMICON: u32 = 0x2;
pub const TVHT_ONITEMINDENT: u32 = 0x8;
pub const TVHT_ONITEMLABEL: u32 = 0x4;
pub const TVHT_ONITEMRIGHT: u32 = 0x20;
pub const TVHT_ONITEMSTATEICON: u32 = 0x40;
pub const TVHT_TOLEFT: u32 = 0x800;
pub const TVHT_TORIGHT: u32 = 0x400;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tvinsertstructa<'a> {
    pub h_parent: Option<Htreeitem>,
    pub h_insert_after: Option<Htreeitem>,
    pub anonymous: Tvinsertstructa5<'a>,
}
impl Tvinsertstructa {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TVINSERTSTRUCTA {
        let Self { h_parent, h_insert_after, anonymous } = self;
        let hParent = h_parent.map_or(0, Htreeitem::into_raw);
        let hInsertAfter = h_insert_after.map_or(0, Htreeitem::into_raw);
        let Anonymous = anonymous.to_win32();
        windows_sys::Win32::UI::Controls::TVINSERTSTRUCTA { hParent, hInsertAfter, Anonymous }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TVINSERTSTRUCTA) -> Self {
        let windows_sys::Win32::UI::Controls::TVINSERTSTRUCTA { hParent, hInsertAfter, Anonymous } = win32;
        let h_parent = unsafe { Htreeitem::new_optional(hParent) };
        let h_insert_after = unsafe { Htreeitem::new_optional(hInsertAfter) };
        let anonymous = unsafe { TVINSERTSTRUCTA_5::from_win32(Anonymous) };
        Self { h_parent, h_insert_after, anonymous }
    }
}
#[repr(C)]
pub union Tvinsertstructa5<'a> {
    pub field0: Tvitemexa<'a>,
    pub field1: Tvitema<'a>,
}
impl Tvinsertstructa5 {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TVINSERTSTRUCTA_5 {
        let Self { field0, field1 } = self;
        let field0 = field0.to_win32();
        let field1 = field1.to_win32();
        windows_sys::Win32::UI::Controls::TVINSERTSTRUCTA_5 { field0, field1 }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TVINSERTSTRUCTA_5) -> Self {
        let windows_sys::Win32::UI::Controls::TVINSERTSTRUCTA_5 { field0, field1 } = win32;
        let field0 = unsafe { TVITEMEXA::from_win32(field0) };
        let field1 = unsafe { TVITEMA::from_win32(field1) };
        Self { field0, field1 }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tvitemexa<'a> {
    pub mask: u32,
    pub h_item: Option<Htreeitem>,
    pub state: u32,
    pub state_mask: u32,
    pub psz_text: Cow<'a, CStr>,
    pub cch_text_max: i32,
    pub i_image: i32,
    pub i_selected_image: i32,
    pub c_children: i32,
    pub l_param: Lparam,
    pub i_integral: i32,
    pub u_state_ex: u32,
    pub hwnd: Option<Hwnd>,
    pub i_expanded_image: i32,
    pub i_reserved: i32,
}
impl Tvitemexa {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TVITEMEXA {
        let Self { mask, h_item, state, state_mask, psz_text, cch_text_max, i_image, i_selected_image, c_children, l_param, i_integral, u_state_ex, hwnd, i_expanded_image, i_reserved } = self;
        let mask = mask;
        let hItem = h_item.map_or(0, Htreeitem::into_raw);
        let state = *state;
        let stateMask = *state_mask;
        let pszText = psz_text.as_ptr();
        let cchTextMax = *cch_text_max;
        let iImage = *i_image;
        let iSelectedImage = *i_selected_image;
        let cChildren = c_children;
        let lParam = l_param.into_inner();
        let iIntegral = *i_integral;
        let uStateEx = *u_state_ex;
        let hwnd = hwnd.map_or(0, Hwnd::into_raw);
        let iExpandedImage = *i_expanded_image;
        let iReserved = *i_reserved;
        windows_sys::Win32::UI::Controls::TVITEMEXA { mask, hItem, state, stateMask, pszText, cchTextMax, iImage, iSelectedImage, cChildren, lParam, iIntegral, uStateEx, hwnd, iExpandedImage, iReserved }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TVITEMEXA) -> Self {
        let windows_sys::Win32::UI::Controls::TVITEMEXA { mask, hItem, state, stateMask, pszText, cchTextMax, iImage, iSelectedImage, cChildren, lParam, iIntegral, uStateEx, hwnd, iExpandedImage, iReserved } = win32;
        let mask = mask;
        let h_item = unsafe { Htreeitem::new_optional(hItem) };
        let state = state;
        let state_mask = stateMask;
        let pszText = unsafe { CStr::from_ptr(pszText) };
        let pszText = pszText.to_bytes_with_nul().to_vec();
        let psz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(pszText) });
        let cch_text_max = cchTextMax;
        let i_image = iImage;
        let i_selected_image = iSelectedImage;
        let c_children = cChildren;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        let i_integral = iIntegral;
        let u_state_ex = uStateEx;
        let hwnd = unsafe { Hwnd::new_optional(hwnd) };
        let i_expanded_image = iExpandedImage;
        let i_reserved = iReserved;
        Self { mask, h_item, state, state_mask, psz_text, cch_text_max, i_image, i_selected_image, c_children, l_param, i_integral, u_state_ex, hwnd, i_expanded_image, i_reserved }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tvitema<'a> {
    pub mask: u32,
    pub h_item: Option<Htreeitem>,
    pub state: u32,
    pub state_mask: u32,
    pub psz_text: Cow<'a, CStr>,
    pub cch_text_max: i32,
    pub i_image: i32,
    pub i_selected_image: i32,
    pub c_children: i32,
    pub l_param: Lparam,
}
impl Tvitema {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TVITEMA {
        let Self { mask, h_item, state, state_mask, psz_text, cch_text_max, i_image, i_selected_image, c_children, l_param } = self;
        let mask = mask;
        let hItem = h_item.map_or(0, Htreeitem::into_raw);
        let state = *state;
        let stateMask = *state_mask;
        let pszText = psz_text.as_ptr();
        let cchTextMax = *cch_text_max;
        let iImage = *i_image;
        let iSelectedImage = *i_selected_image;
        let cChildren = c_children;
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::Controls::TVITEMA { mask, hItem, state, stateMask, pszText, cchTextMax, iImage, iSelectedImage, cChildren, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TVITEMA) -> Self {
        let windows_sys::Win32::UI::Controls::TVITEMA { mask, hItem, state, stateMask, pszText, cchTextMax, iImage, iSelectedImage, cChildren, lParam } = win32;
        let mask = mask;
        let h_item = unsafe { Htreeitem::new_optional(hItem) };
        let state = state;
        let state_mask = stateMask;
        let pszText = unsafe { CStr::from_ptr(pszText) };
        let pszText = pszText.to_bytes_with_nul().to_vec();
        let psz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(pszText) });
        let cch_text_max = cchTextMax;
        let i_image = iImage;
        let i_selected_image = iSelectedImage;
        let c_children = cChildren;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { mask, h_item, state, state_mask, psz_text, cch_text_max, i_image, i_selected_image, c_children, l_param }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tvinsertstructw<'a> {
    pub h_parent: Option<Htreeitem>,
    pub h_insert_after: Option<Htreeitem>,
    pub anonymous: Tvinsertstructw6<'a>,
}
impl Tvinsertstructw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TVINSERTSTRUCTW {
        let Self { h_parent, h_insert_after, anonymous } = self;
        let hParent = h_parent.map_or(0, Htreeitem::into_raw);
        let hInsertAfter = h_insert_after.map_or(0, Htreeitem::into_raw);
        let Anonymous = anonymous.to_win32();
        windows_sys::Win32::UI::Controls::TVINSERTSTRUCTW { hParent, hInsertAfter, Anonymous }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TVINSERTSTRUCTW) -> Self {
        let windows_sys::Win32::UI::Controls::TVINSERTSTRUCTW { hParent, hInsertAfter, Anonymous } = win32;
        let h_parent = unsafe { Htreeitem::new_optional(hParent) };
        let h_insert_after = unsafe { Htreeitem::new_optional(hInsertAfter) };
        let anonymous = unsafe { TVINSERTSTRUCTW_6::from_win32(Anonymous) };
        Self { h_parent, h_insert_after, anonymous }
    }
}
#[repr(C)]
pub union Tvinsertstructw6<'a> {
    pub field0: Tvitemexw<'a>,
    pub field1: Tvitemw<'a>,
}
impl Tvinsertstructw6 {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TVINSERTSTRUCTW_6 {
        let Self { field0, field1 } = self;
        let field0 = field0.to_win32();
        let field1 = field1.to_win32();
        windows_sys::Win32::UI::Controls::TVINSERTSTRUCTW_6 { field0, field1 }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TVINSERTSTRUCTW_6) -> Self {
        let windows_sys::Win32::UI::Controls::TVINSERTSTRUCTW_6 { field0, field1 } = win32;
        let field0 = unsafe { TVITEMEXW::from_win32(field0) };
        let field1 = unsafe { TVITEMW::from_win32(field1) };
        Self { field0, field1 }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tvitemexw<'a> {
    pub mask: u32,
    pub h_item: Option<Htreeitem>,
    pub state: u32,
    pub state_mask: u32,
    pub psz_text: Cow<'a, [u16]>,
    pub cch_text_max: i32,
    pub i_image: i32,
    pub i_selected_image: i32,
    pub c_children: i32,
    pub l_param: Lparam,
    pub i_integral: i32,
    pub u_state_ex: u32,
    pub hwnd: Option<Hwnd>,
    pub i_expanded_image: i32,
    pub i_reserved: i32,
}
impl Tvitemexw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TVITEMEXW {
        let Self { mask, h_item, state, state_mask, psz_text, cch_text_max, i_image, i_selected_image, c_children, l_param, i_integral, u_state_ex, hwnd, i_expanded_image, i_reserved } = self;
        let mask = mask;
        let hItem = h_item.map_or(0, Htreeitem::into_raw);
        let state = *state;
        let stateMask = *state_mask;
        assert_eq!(psz_text.last(), Some(0));
        let pszText = psz_text.as_ptr();
        let cchTextMax = *cch_text_max;
        let iImage = *i_image;
        let iSelectedImage = *i_selected_image;
        let cChildren = c_children;
        let lParam = l_param.into_inner();
        let iIntegral = *i_integral;
        let uStateEx = *u_state_ex;
        let hwnd = hwnd.map_or(0, Hwnd::into_raw);
        let iExpandedImage = *i_expanded_image;
        let iReserved = *i_reserved;
        windows_sys::Win32::UI::Controls::TVITEMEXW { mask, hItem, state, stateMask, pszText, cchTextMax, iImage, iSelectedImage, cChildren, lParam, iIntegral, uStateEx, hwnd, iExpandedImage, iReserved }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TVITEMEXW) -> Self {
        let windows_sys::Win32::UI::Controls::TVITEMEXW { mask, hItem, state, stateMask, pszText, cchTextMax, iImage, iSelectedImage, cChildren, lParam, iIntegral, uStateEx, hwnd, iExpandedImage, iReserved } = win32;
        let mask = mask;
        let h_item = unsafe { Htreeitem::new_optional(hItem) };
        let state = state;
        let state_mask = stateMask;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = pszText.to_vec();
        let cch_text_max = cchTextMax;
        let i_image = iImage;
        let i_selected_image = iSelectedImage;
        let c_children = cChildren;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        let i_integral = iIntegral;
        let u_state_ex = uStateEx;
        let hwnd = unsafe { Hwnd::new_optional(hwnd) };
        let i_expanded_image = iExpandedImage;
        let i_reserved = iReserved;
        Self { mask, h_item, state, state_mask, psz_text, cch_text_max, i_image, i_selected_image, c_children, l_param, i_integral, u_state_ex, hwnd, i_expanded_image, i_reserved }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tvitemw<'a> {
    pub mask: u32,
    pub h_item: Option<Htreeitem>,
    pub state: u32,
    pub state_mask: u32,
    pub psz_text: Cow<'a, [u16]>,
    pub cch_text_max: i32,
    pub i_image: i32,
    pub i_selected_image: i32,
    pub c_children: i32,
    pub l_param: Lparam,
}
impl Tvitemw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TVITEMW {
        let Self { mask, h_item, state, state_mask, psz_text, cch_text_max, i_image, i_selected_image, c_children, l_param } = self;
        let mask = mask;
        let hItem = h_item.map_or(0, Htreeitem::into_raw);
        let state = *state;
        let stateMask = *state_mask;
        assert_eq!(psz_text.last(), Some(0));
        let pszText = psz_text.as_ptr();
        let cchTextMax = *cch_text_max;
        let iImage = *i_image;
        let iSelectedImage = *i_selected_image;
        let cChildren = c_children;
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::Controls::TVITEMW { mask, hItem, state, stateMask, pszText, cchTextMax, iImage, iSelectedImage, cChildren, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TVITEMW) -> Self {
        let windows_sys::Win32::UI::Controls::TVITEMW { mask, hItem, state, stateMask, pszText, cchTextMax, iImage, iSelectedImage, cChildren, lParam } = win32;
        let mask = mask;
        let h_item = unsafe { Htreeitem::new_optional(hItem) };
        let state = state;
        let state_mask = stateMask;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = pszText.to_vec();
        let cch_text_max = cchTextMax;
        let i_image = iImage;
        let i_selected_image = iSelectedImage;
        let c_children = cChildren;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { mask, h_item, state, state_mask, psz_text, cch_text_max, i_image, i_selected_image, c_children, l_param }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tvitema<'a> {
    pub mask: u32,
    pub h_item: Option<Htreeitem>,
    pub state: u32,
    pub state_mask: u32,
    pub psz_text: Cow<'a, CStr>,
    pub cch_text_max: i32,
    pub i_image: i32,
    pub i_selected_image: i32,
    pub c_children: i32,
    pub l_param: Lparam,
}
impl Tvitema {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TVITEMA {
        let Self { mask, h_item, state, state_mask, psz_text, cch_text_max, i_image, i_selected_image, c_children, l_param } = self;
        let mask = mask;
        let hItem = h_item.map_or(0, Htreeitem::into_raw);
        let state = *state;
        let stateMask = *state_mask;
        let pszText = psz_text.as_ptr();
        let cchTextMax = *cch_text_max;
        let iImage = *i_image;
        let iSelectedImage = *i_selected_image;
        let cChildren = c_children;
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::Controls::TVITEMA { mask, hItem, state, stateMask, pszText, cchTextMax, iImage, iSelectedImage, cChildren, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TVITEMA) -> Self {
        let windows_sys::Win32::UI::Controls::TVITEMA { mask, hItem, state, stateMask, pszText, cchTextMax, iImage, iSelectedImage, cChildren, lParam } = win32;
        let mask = mask;
        let h_item = unsafe { Htreeitem::new_optional(hItem) };
        let state = state;
        let state_mask = stateMask;
        let pszText = unsafe { CStr::from_ptr(pszText) };
        let pszText = pszText.to_bytes_with_nul().to_vec();
        let psz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(pszText) });
        let cch_text_max = cchTextMax;
        let i_image = iImage;
        let i_selected_image = iSelectedImage;
        let c_children = cChildren;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { mask, h_item, state, state_mask, psz_text, cch_text_max, i_image, i_selected_image, c_children, l_param }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tvitemexa<'a> {
    pub mask: u32,
    pub h_item: Option<Htreeitem>,
    pub state: u32,
    pub state_mask: u32,
    pub psz_text: Cow<'a, CStr>,
    pub cch_text_max: i32,
    pub i_image: i32,
    pub i_selected_image: i32,
    pub c_children: i32,
    pub l_param: Lparam,
    pub i_integral: i32,
    pub u_state_ex: u32,
    pub hwnd: Option<Hwnd>,
    pub i_expanded_image: i32,
    pub i_reserved: i32,
}
impl Tvitemexa {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TVITEMEXA {
        let Self { mask, h_item, state, state_mask, psz_text, cch_text_max, i_image, i_selected_image, c_children, l_param, i_integral, u_state_ex, hwnd, i_expanded_image, i_reserved } = self;
        let mask = mask;
        let hItem = h_item.map_or(0, Htreeitem::into_raw);
        let state = *state;
        let stateMask = *state_mask;
        let pszText = psz_text.as_ptr();
        let cchTextMax = *cch_text_max;
        let iImage = *i_image;
        let iSelectedImage = *i_selected_image;
        let cChildren = c_children;
        let lParam = l_param.into_inner();
        let iIntegral = *i_integral;
        let uStateEx = *u_state_ex;
        let hwnd = hwnd.map_or(0, Hwnd::into_raw);
        let iExpandedImage = *i_expanded_image;
        let iReserved = *i_reserved;
        windows_sys::Win32::UI::Controls::TVITEMEXA { mask, hItem, state, stateMask, pszText, cchTextMax, iImage, iSelectedImage, cChildren, lParam, iIntegral, uStateEx, hwnd, iExpandedImage, iReserved }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TVITEMEXA) -> Self {
        let windows_sys::Win32::UI::Controls::TVITEMEXA { mask, hItem, state, stateMask, pszText, cchTextMax, iImage, iSelectedImage, cChildren, lParam, iIntegral, uStateEx, hwnd, iExpandedImage, iReserved } = win32;
        let mask = mask;
        let h_item = unsafe { Htreeitem::new_optional(hItem) };
        let state = state;
        let state_mask = stateMask;
        let pszText = unsafe { CStr::from_ptr(pszText) };
        let pszText = pszText.to_bytes_with_nul().to_vec();
        let psz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(pszText) });
        let cch_text_max = cchTextMax;
        let i_image = iImage;
        let i_selected_image = iSelectedImage;
        let c_children = cChildren;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        let i_integral = iIntegral;
        let u_state_ex = uStateEx;
        let hwnd = unsafe { Hwnd::new_optional(hwnd) };
        let i_expanded_image = iExpandedImage;
        let i_reserved = iReserved;
        Self { mask, h_item, state, state_mask, psz_text, cch_text_max, i_image, i_selected_image, c_children, l_param, i_integral, u_state_ex, hwnd, i_expanded_image, i_reserved }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tvitemexw<'a> {
    pub mask: u32,
    pub h_item: Option<Htreeitem>,
    pub state: u32,
    pub state_mask: u32,
    pub psz_text: Cow<'a, [u16]>,
    pub cch_text_max: i32,
    pub i_image: i32,
    pub i_selected_image: i32,
    pub c_children: i32,
    pub l_param: Lparam,
    pub i_integral: i32,
    pub u_state_ex: u32,
    pub hwnd: Option<Hwnd>,
    pub i_expanded_image: i32,
    pub i_reserved: i32,
}
impl Tvitemexw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TVITEMEXW {
        let Self { mask, h_item, state, state_mask, psz_text, cch_text_max, i_image, i_selected_image, c_children, l_param, i_integral, u_state_ex, hwnd, i_expanded_image, i_reserved } = self;
        let mask = mask;
        let hItem = h_item.map_or(0, Htreeitem::into_raw);
        let state = *state;
        let stateMask = *state_mask;
        assert_eq!(psz_text.last(), Some(0));
        let pszText = psz_text.as_ptr();
        let cchTextMax = *cch_text_max;
        let iImage = *i_image;
        let iSelectedImage = *i_selected_image;
        let cChildren = c_children;
        let lParam = l_param.into_inner();
        let iIntegral = *i_integral;
        let uStateEx = *u_state_ex;
        let hwnd = hwnd.map_or(0, Hwnd::into_raw);
        let iExpandedImage = *i_expanded_image;
        let iReserved = *i_reserved;
        windows_sys::Win32::UI::Controls::TVITEMEXW { mask, hItem, state, stateMask, pszText, cchTextMax, iImage, iSelectedImage, cChildren, lParam, iIntegral, uStateEx, hwnd, iExpandedImage, iReserved }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TVITEMEXW) -> Self {
        let windows_sys::Win32::UI::Controls::TVITEMEXW { mask, hItem, state, stateMask, pszText, cchTextMax, iImage, iSelectedImage, cChildren, lParam, iIntegral, uStateEx, hwnd, iExpandedImage, iReserved } = win32;
        let mask = mask;
        let h_item = unsafe { Htreeitem::new_optional(hItem) };
        let state = state;
        let state_mask = stateMask;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = pszText.to_vec();
        let cch_text_max = cchTextMax;
        let i_image = iImage;
        let i_selected_image = iSelectedImage;
        let c_children = cChildren;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        let i_integral = iIntegral;
        let u_state_ex = uStateEx;
        let hwnd = unsafe { Hwnd::new_optional(hwnd) };
        let i_expanded_image = iExpandedImage;
        let i_reserved = iReserved;
        Self { mask, h_item, state, state_mask, psz_text, cch_text_max, i_image, i_selected_image, c_children, l_param, i_integral, u_state_ex, hwnd, i_expanded_image, i_reserved }
    }
}
pub const I_ZERO: i32 = 0x0;
pub const I_ONE_OR_MORE: i32 = 0x1;
pub const I_CHILDRENCALLBACK: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
pub const I_CHILDRENAUTO: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE;
pub const TVGIPR_BUTTON: i32 = 0x1;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tvitemw<'a> {
    pub mask: u32,
    pub h_item: Option<Htreeitem>,
    pub state: u32,
    pub state_mask: u32,
    pub psz_text: Cow<'a, [u16]>,
    pub cch_text_max: i32,
    pub i_image: i32,
    pub i_selected_image: i32,
    pub c_children: i32,
    pub l_param: Lparam,
}
impl Tvitemw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TVITEMW {
        let Self { mask, h_item, state, state_mask, psz_text, cch_text_max, i_image, i_selected_image, c_children, l_param } = self;
        let mask = mask;
        let hItem = h_item.map_or(0, Htreeitem::into_raw);
        let state = *state;
        let stateMask = *state_mask;
        assert_eq!(psz_text.last(), Some(0));
        let pszText = psz_text.as_ptr();
        let cchTextMax = *cch_text_max;
        let iImage = *i_image;
        let iSelectedImage = *i_selected_image;
        let cChildren = c_children;
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::Controls::TVITEMW { mask, hItem, state, stateMask, pszText, cchTextMax, iImage, iSelectedImage, cChildren, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TVITEMW) -> Self {
        let windows_sys::Win32::UI::Controls::TVITEMW { mask, hItem, state, stateMask, pszText, cchTextMax, iImage, iSelectedImage, cChildren, lParam } = win32;
        let mask = mask;
        let h_item = unsafe { Htreeitem::new_optional(hItem) };
        let state = state;
        let state_mask = stateMask;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = pszText.to_vec();
        let cch_text_max = cchTextMax;
        let i_image = iImage;
        let i_selected_image = iSelectedImage;
        let c_children = cChildren;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { mask, h_item, state, state_mask, psz_text, cch_text_max, i_image, i_selected_image, c_children, l_param }
    }
}
pub const TVIF_CHILDREN: u32 = 0x40;
pub const TVIF_DI_SETITEM: u32 = 0x1000;
pub const TVIF_HANDLE: u32 = 0x10;
pub const TVIF_IMAGE: u32 = 0x2;
pub const TVIF_PARAM: u32 = 0x4;
pub const TVIF_SELECTEDIMAGE: u32 = 0x20;
pub const TVIF_STATE: u32 = 0x8;
pub const TVIF_TEXT: u32 = 0x1;
pub const TVIF_EXPANDEDIMAGE: u32 = 0x200;
pub const TVIF_INTEGRAL: u32 = 0x80;
pub const TVIF_STATEEX: u32 = 0x100;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tvsortcb {
    pub h_parent: Option<Htreeitem>,
    pub lpfn_compare: Option<unsafe extern "system" fn(LPARAM, LPARAM, LPARAM) -> i32>,
    pub l_param: Lparam,
}
impl Tvsortcb {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TVSORTCB {
        let Self { h_parent, lpfn_compare, l_param } = self;
        let hParent = h_parent.map_or(0, Htreeitem::into_raw);
        let lpfnCompare = Some(lpfn_compare);
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::Controls::TVSORTCB { hParent, lpfnCompare, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TVSORTCB) -> Self {
        let windows_sys::Win32::UI::Controls::TVSORTCB { hParent, lpfnCompare, lParam } = win32;
        let h_parent = unsafe { Htreeitem::new_optional(hParent) };
        let lpfn_compare = lpfnCompare;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { h_parent, lpfn_compare, l_param }
    }
}
pub const EXTRACT_IF_NOT_CACHED: i32 = 0x0;
pub const RETURN_ONLY_IF_CACHED: i32 = 0x1;
pub const RESIZE_THUMBNAIL: i32 = 0x2;
pub const ALLOW_SMALLER_SIZE: i32 = 0x4;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct TouchPredictionParameters {
    pub cb_size: u32,
    pub dw_latency: u32,
    pub dw_sample_time: u32,
    pub b_use_hw_time_stamp: u32,
}
impl TouchPredictionParameters {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::TouchPredictionParameters {
        let Self { cb_size, dw_latency, dw_sample_time, b_use_hw_time_stamp } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::TouchPredictionParameters>() as _;
        let dwLatency = *dw_latency;
        let dwSampleTime = *dw_sample_time;
        let bUseHWTimeStamp = *b_use_hw_time_stamp;
        windows_sys::Win32::UI::WindowsAndMessaging::TouchPredictionParameters { cbSize, dwLatency, dwSampleTime, bUseHWTimeStamp }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::TouchPredictionParameters) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::TouchPredictionParameters { cbSize, dwLatency, dwSampleTime, bUseHWTimeStamp } = win32;
        let cb_size = cbSize;
        let dw_latency = dwLatency;
        let dw_sample_time = dwSampleTime;
        let b_use_hw_time_stamp = bUseHWTimeStamp;
        Self { cb_size, dw_latency, dw_sample_time, b_use_hw_time_stamp }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Udaccel {
    pub n_sec: u32,
    pub n_inc: u32,
}
impl Udaccel {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::UDACCEL {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::UDACCEL) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const UR_RESOLUTION_CHANGE: i32 = 0x0;
pub const UR_MONITOR_DISCONNECT: i32 = 0x1;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct UnicodeString<'a> {
    pub length: u16,
    pub maximum_length: u16,
    pub buffer: Cow<'a, [u16]>,
}
impl UnicodeString {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::UNICODE_STRING {
        let Self { length, maximum_length, buffer } = self;
        let Length = *length;
        let MaximumLength = *maximum_length;
        assert_eq!(buffer.last(), Some(0));
        let Buffer = buffer.as_ptr();
        windows_sys::Win32::Foundation::UNICODE_STRING { Length, MaximumLength, Buffer }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::UNICODE_STRING) -> Self {
        let windows_sys::Win32::Foundation::UNICODE_STRING { Length, MaximumLength, Buffer } = win32;
        let length = Length;
        let maximum_length = MaximumLength;
        let slen = unsafe { wide_strlen(Buffer as *const u16) };
        let Buffer = unsafe { slice::from_raw_parts(Buffer, slen + 1) };
        let buffer = Buffer.to_vec();
        Self { length, maximum_length, buffer }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Updatelayeredwindowinfo<'a> {
    pub cb_size: u32,
    pub hdc_dst: Option<Hdc>,
    pub ppt_dst: Cow<'a, Point>,
    pub psize: Cow<'a, Size>,
    pub hdc_src: Option<Hdc>,
    pub ppt_src: Cow<'a, Point>,
    pub cr_key: u32,
    pub pblend: Cow<'a, Blendfunction>,
    pub dw_flags: u32,
    pub prc_dirty: Cow<'a, Rect>,
}
impl Updatelayeredwindowinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::UPDATELAYEREDWINDOWINFO {
        let Self { cb_size, hdc_dst, ppt_dst, psize, hdc_src, ppt_src, cr_key, pblend, dw_flags, prc_dirty } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::UPDATELAYEREDWINDOWINFO>() as _;
        let hdcDst = hdc_dst.map_or(0, Hdc::into_raw);
        let pptDst = unsafe { &*(&**ppt_dst as *const _ as *const _) };
        let psize = unsafe { &*(&**psize as *const _ as *const _) };
        let hdcSrc = hdc_src.map_or(0, Hdc::into_raw);
        let pptSrc = unsafe { &*(&**ppt_src as *const _ as *const _) };
        let crKey = *cr_key;
        let pblend = unsafe { &*(&**pblend as *const _ as *const _) };
        let dwFlags = dw_flags;
        let prcDirty = unsafe { &*(&**prc_dirty as *const _ as *const _) };
        windows_sys::Win32::UI::WindowsAndMessaging::UPDATELAYEREDWINDOWINFO { cbSize, hdcDst, pptDst, psize, hdcSrc, pptSrc, crKey, pblend, dwFlags, prcDirty }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::UPDATELAYEREDWINDOWINFO) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::UPDATELAYEREDWINDOWINFO { cbSize, hdcDst, pptDst, psize, hdcSrc, pptSrc, crKey, pblend, dwFlags, prcDirty } = win32;
        let cb_size = cbSize;
        let hdc_dst = unsafe { Hdc::new_optional(hdcDst) };
        let ppt_dst = Cow::Borrowed(unsafe { &*(pptDst as *const _ as *const _) });
        let psize = Cow::Borrowed(unsafe { &*(psize as *const _ as *const _) });
        let hdc_src = unsafe { Hdc::new_optional(hdcSrc) };
        let ppt_src = Cow::Borrowed(unsafe { &*(pptSrc as *const _ as *const _) });
        let cr_key = crKey;
        let pblend = Cow::Borrowed(unsafe { &*(pblend as *const _ as *const _) });
        let dw_flags = dwFlags;
        let prc_dirty = Cow::Borrowed(unsafe { &*(prcDirty as *const _ as *const _) });
        Self { cb_size, hdc_dst, ppt_dst, psize, hdc_src, ppt_src, cr_key, pblend, dw_flags, prc_dirty }
    }
}
pub const ULW_ALPHA: u32 = 0x2;
pub const ULW_COLORKEY: u32 = 0x1;
pub const ULW_OPAQUE: u32 = 0x4;
pub const ULW_EX_NORESIZE: u32 = 0x8;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct UsageProperties {
    pub level: u16,
    pub page: u16,
    pub usage: u16,
    pub logical_minimum: i32,
    pub logical_maximum: i32,
    pub unit: u16,
    pub exponent: u16,
    pub count: u8,
    pub physical_minimum: i32,
    pub physical_maximum: i32,
}
impl UsageProperties {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::USAGE_PROPERTIES {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::USAGE_PROPERTIES) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Valenta<'a> {
    pub ve_valuename: Cow<'a, CStr>,
    pub ve_valuelen: u32,
    pub ve_valueptr: usize,
    pub ve_type: u32,
}
impl Valenta {
    fn to_win32(&self) -> windows_sys::Win32::System::Registry::VALENTA {
        let Self { ve_valuename, ve_valuelen, ve_valueptr, ve_type } = self;
        let ve_valuename = ve_valuename.as_ptr();
        let ve_valuelen = *ve_valuelen;
        let ve_valueptr = *ve_valueptr;
        let ve_type = ve_type;
        windows_sys::Win32::System::Registry::VALENTA { ve_valuename, ve_valuelen, ve_valueptr, ve_type }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::System::Registry::VALENTA) -> Self {
        let windows_sys::Win32::System::Registry::VALENTA { ve_valuename, ve_valuelen, ve_valueptr, ve_type } = win32;
        let ve_valuename = unsafe { CStr::from_ptr(ve_valuename) };
        let ve_valuename = ve_valuename.to_bytes_with_nul().to_vec();
        let ve_valuename = Cow::Owned(unsafe { CString::from_vec_unchecked(ve_valuename) });
        let ve_valuelen = ve_valuelen;
        let ve_valueptr = ve_valueptr;
        let ve_type = ve_type;
        Self { ve_valuename, ve_valuelen, ve_valueptr, ve_type }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Valentw<'a> {
    pub ve_valuename: Cow<'a, [u16]>,
    pub ve_valuelen: u32,
    pub ve_valueptr: usize,
    pub ve_type: u32,
}
impl Valentw {
    fn to_win32(&self) -> windows_sys::Win32::System::Registry::VALENTW {
        let Self { ve_valuename, ve_valuelen, ve_valueptr, ve_type } = self;
        assert_eq!(ve_valuename.last(), Some(0));
        let ve_valuename = ve_valuename.as_ptr();
        let ve_valuelen = *ve_valuelen;
        let ve_valueptr = *ve_valueptr;
        let ve_type = ve_type;
        windows_sys::Win32::System::Registry::VALENTW { ve_valuename, ve_valuelen, ve_valueptr, ve_type }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::System::Registry::VALENTW) -> Self {
        let windows_sys::Win32::System::Registry::VALENTW { ve_valuename, ve_valuelen, ve_valueptr, ve_type } = win32;
        let slen = unsafe { wide_strlen(ve_valuename as *const u16) };
        let ve_valuename = unsafe { slice::from_raw_parts(ve_valuename, slen + 1) };
        let ve_valuename = ve_valuename.to_vec();
        let ve_valuelen = ve_valuelen;
        let ve_valueptr = ve_valueptr;
        let ve_type = ve_type;
        Self { ve_valuename, ve_valuelen, ve_valueptr, ve_type }
    }
}
pub const VALIDATEUNC_CONNECT: i32 = 0x1;
pub const VALIDATEUNC_NOUI: i32 = 0x2;
pub const VALIDATEUNC_PRINT: i32 = 0x4;
pub const VALIDATEUNC_PERSIST: i32 = 0x8;
pub const VALIDATEUNC_VALID: i32 = 0xF;
pub const VA_TOP: i32 = 0x0;
pub const VA_CENTER: i32 = 0x1;
pub const VA_BOTTOM: i32 = 0x2;
pub const VPCF_TEXT: i32 = 0x1;
pub const VPCF_BACKGROUND: i32 = 0x2;
pub const VPCF_SORTCOLUMN: i32 = 0x3;
pub const VPCF_SUBTEXT: i32 = 0x4;
pub const VPCF_TEXTBACKGROUND: i32 = 0x5;
pub const VPWF_DEFAULT: i32 = 0x0;
pub const VPWF_ALPHABLEND: i32 = 0x1;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Wcrange {
    pub wc_low: u8,
    pub c_glyphs: u16,
}
impl Wcrange {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::WCRANGE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::WCRANGE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Wglswap {
    pub hdc: Option<Hdc>,
    pub ui_flags: u32,
}
impl Wglswap {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::WGLSWAP {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::WGLSWAP) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const NO_ERROR: u32 = 0x0;
pub const WAIT_TIMEOUT: u32 = 0x102;
pub const WAIT_FAILED: u32 = 0xFFFFFFFF;
pub const ERROR_SUCCESS: u32 = 0x0;
pub const ERROR_INVALID_FUNCTION: u32 = 0x1;
pub const ERROR_FILE_NOT_FOUND: u32 = 0x2;
pub const ERROR_PATH_NOT_FOUND: u32 = 0x3;
pub const ERROR_TOO_MANY_OPEN_FILES: u32 = 0x4;
pub const ERROR_ACCESS_DENIED: u32 = 0x5;
pub const ERROR_INVALID_HANDLE: u32 = 0x6;
pub const ERROR_ARENA_TRASHED: u32 = 0x7;
pub const ERROR_NOT_ENOUGH_MEMORY: u32 = 0x8;
pub const ERROR_INVALID_BLOCK: u32 = 0x9;
pub const ERROR_BAD_ENVIRONMENT: u32 = 0xA;
pub const ERROR_BAD_FORMAT: u32 = 0xB;
pub const ERROR_INVALID_ACCESS: u32 = 0xC;
pub const ERROR_INVALID_DATA: u32 = 0xD;
pub const ERROR_OUTOFMEMORY: u32 = 0xE;
pub const ERROR_INVALID_DRIVE: u32 = 0xF;
pub const ERROR_CURRENT_DIRECTORY: u32 = 0x10;
pub const ERROR_NOT_SAME_DEVICE: u32 = 0x11;
pub const ERROR_NO_MORE_FILES: u32 = 0x12;
pub const ERROR_WRITE_PROTECT: u32 = 0x13;
pub const ERROR_BAD_UNIT: u32 = 0x14;
pub const ERROR_NOT_READY: u32 = 0x15;
pub const ERROR_BAD_COMMAND: u32 = 0x16;
pub const ERROR_CRC: u32 = 0x17;
pub const ERROR_BAD_LENGTH: u32 = 0x18;
pub const ERROR_SEEK: u32 = 0x19;
pub const ERROR_NOT_DOS_DISK: u32 = 0x1A;
pub const ERROR_SECTOR_NOT_FOUND: u32 = 0x1B;
pub const ERROR_OUT_OF_PAPER: u32 = 0x1C;
pub const ERROR_WRITE_FAULT: u32 = 0x1D;
pub const ERROR_READ_FAULT: u32 = 0x1E;
pub const ERROR_GEN_FAILURE: u32 = 0x1F;
pub const ERROR_SHARING_VIOLATION: u32 = 0x20;
pub const ERROR_LOCK_VIOLATION: u32 = 0x21;
pub const ERROR_WRONG_DISK: u32 = 0x22;
pub const ERROR_SHARING_BUFFER_EXCEEDED: u32 = 0x24;
pub const ERROR_HANDLE_EOF: u32 = 0x26;
pub const ERROR_HANDLE_DISK_FULL: u32 = 0x27;
pub const ERROR_NOT_SUPPORTED: u32 = 0x32;
pub const ERROR_REM_NOT_LIST: u32 = 0x33;
pub const ERROR_DUP_NAME: u32 = 0x34;
pub const ERROR_BAD_NETPATH: u32 = 0x35;
pub const ERROR_NETWORK_BUSY: u32 = 0x36;
pub const ERROR_DEV_NOT_EXIST: u32 = 0x37;
pub const ERROR_TOO_MANY_CMDS: u32 = 0x38;
pub const ERROR_ADAP_HDW_ERR: u32 = 0x39;
pub const ERROR_BAD_NET_RESP: u32 = 0x3A;
pub const ERROR_UNEXP_NET_ERR: u32 = 0x3B;
pub const ERROR_BAD_REM_ADAP: u32 = 0x3C;
pub const ERROR_PRINTQ_FULL: u32 = 0x3D;
pub const ERROR_NO_SPOOL_SPACE: u32 = 0x3E;
pub const ERROR_PRINT_CANCELLED: u32 = 0x3F;
pub const ERROR_NETNAME_DELETED: u32 = 0x40;
pub const ERROR_NETWORK_ACCESS_DENIED: u32 = 0x41;
pub const ERROR_BAD_DEV_TYPE: u32 = 0x42;
pub const ERROR_BAD_NET_NAME: u32 = 0x43;
pub const ERROR_TOO_MANY_NAMES: u32 = 0x44;
pub const ERROR_TOO_MANY_SESS: u32 = 0x45;
pub const ERROR_SHARING_PAUSED: u32 = 0x46;
pub const ERROR_REQ_NOT_ACCEP: u32 = 0x47;
pub const ERROR_REDIR_PAUSED: u32 = 0x48;
pub const ERROR_FILE_EXISTS: u32 = 0x50;
pub const ERROR_CANNOT_MAKE: u32 = 0x52;
pub const ERROR_FAIL_I24: u32 = 0x53;
pub const ERROR_OUT_OF_STRUCTURES: u32 = 0x54;
pub const ERROR_ALREADY_ASSIGNED: u32 = 0x55;
pub const ERROR_INVALID_PASSWORD: u32 = 0x56;
pub const ERROR_INVALID_PARAMETER: u32 = 0x57;
pub const ERROR_NET_WRITE_FAULT: u32 = 0x58;
pub const ERROR_NO_PROC_SLOTS: u32 = 0x59;
pub const ERROR_TOO_MANY_SEMAPHORES: u32 = 0x64;
pub const ERROR_EXCL_SEM_ALREADY_OWNED: u32 = 0x65;
pub const ERROR_SEM_IS_SET: u32 = 0x66;
pub const ERROR_TOO_MANY_SEM_REQUESTS: u32 = 0x67;
pub const ERROR_INVALID_AT_INTERRUPT_TIME: u32 = 0x68;
pub const ERROR_SEM_OWNER_DIED: u32 = 0x69;
pub const ERROR_SEM_USER_LIMIT: u32 = 0x6A;
pub const ERROR_DISK_CHANGE: u32 = 0x6B;
pub const ERROR_DRIVE_LOCKED: u32 = 0x6C;
pub const ERROR_BROKEN_PIPE: u32 = 0x6D;
pub const ERROR_OPEN_FAILED: u32 = 0x6E;
pub const ERROR_BUFFER_OVERFLOW: u32 = 0x6F;
pub const ERROR_DISK_FULL: u32 = 0x70;
pub const ERROR_NO_MORE_SEARCH_HANDLES: u32 = 0x71;
pub const ERROR_INVALID_TARGET_HANDLE: u32 = 0x72;
pub const ERROR_INVALID_CATEGORY: u32 = 0x75;
pub const ERROR_INVALID_VERIFY_SWITCH: u32 = 0x76;
pub const ERROR_BAD_DRIVER_LEVEL: u32 = 0x77;
pub const ERROR_CALL_NOT_IMPLEMENTED: u32 = 0x78;
pub const ERROR_SEM_TIMEOUT: u32 = 0x79;
pub const ERROR_INSUFFICIENT_BUFFER: u32 = 0x7A;
pub const ERROR_INVALID_NAME: u32 = 0x7B;
pub const ERROR_INVALID_LEVEL: u32 = 0x7C;
pub const ERROR_NO_VOLUME_LABEL: u32 = 0x7D;
pub const ERROR_MOD_NOT_FOUND: u32 = 0x7E;
pub const ERROR_PROC_NOT_FOUND: u32 = 0x7F;
pub const ERROR_WAIT_NO_CHILDREN: u32 = 0x80;
pub const ERROR_CHILD_NOT_COMPLETE: u32 = 0x81;
pub const ERROR_DIRECT_ACCESS_HANDLE: u32 = 0x82;
pub const ERROR_NEGATIVE_SEEK: u32 = 0x83;
pub const ERROR_SEEK_ON_DEVICE: u32 = 0x84;
pub const ERROR_IS_JOIN_TARGET: u32 = 0x85;
pub const ERROR_IS_JOINED: u32 = 0x86;
pub const ERROR_IS_SUBSTED: u32 = 0x87;
pub const ERROR_NOT_JOINED: u32 = 0x88;
pub const ERROR_NOT_SUBSTED: u32 = 0x89;
pub const ERROR_JOIN_TO_JOIN: u32 = 0x8A;
pub const ERROR_SUBST_TO_SUBST: u32 = 0x8B;
pub const ERROR_JOIN_TO_SUBST: u32 = 0x8C;
pub const ERROR_SUBST_TO_JOIN: u32 = 0x8D;
pub const ERROR_BUSY_DRIVE: u32 = 0x8E;
pub const ERROR_SAME_DRIVE: u32 = 0x8F;
pub const ERROR_DIR_NOT_ROOT: u32 = 0x90;
pub const ERROR_DIR_NOT_EMPTY: u32 = 0x91;
pub const ERROR_IS_SUBST_PATH: u32 = 0x92;
pub const ERROR_IS_JOIN_PATH: u32 = 0x93;
pub const ERROR_PATH_BUSY: u32 = 0x94;
pub const ERROR_IS_SUBST_TARGET: u32 = 0x95;
pub const ERROR_SYSTEM_TRACE: u32 = 0x96;
pub const ERROR_INVALID_EVENT_COUNT: u32 = 0x97;
pub const ERROR_TOO_MANY_MUXWAITERS: u32 = 0x98;
pub const ERROR_INVALID_LIST_FORMAT: u32 = 0x99;
pub const ERROR_LABEL_TOO_LONG: u32 = 0x9A;
pub const ERROR_TOO_MANY_TCBS: u32 = 0x9B;
pub const ERROR_SIGNAL_REFUSED: u32 = 0x9C;
pub const ERROR_DISCARDED: u32 = 0x9D;
pub const ERROR_NOT_LOCKED: u32 = 0x9E;
pub const ERROR_BAD_THREADID_ADDR: u32 = 0x9F;
pub const ERROR_BAD_ARGUMENTS: u32 = 0xA0;
pub const ERROR_BAD_PATHNAME: u32 = 0xA1;
pub const ERROR_SIGNAL_PENDING: u32 = 0xA2;
pub const ERROR_MAX_THRDS_REACHED: u32 = 0xA4;
pub const ERROR_LOCK_FAILED: u32 = 0xA7;
pub const ERROR_BUSY: u32 = 0xAA;
pub const ERROR_DEVICE_SUPPORT_IN_PROGRESS: u32 = 0xAB;
pub const ERROR_CANCEL_VIOLATION: u32 = 0xAD;
pub const ERROR_ATOMIC_LOCKS_NOT_SUPPORTED: u32 = 0xAE;
pub const ERROR_INVALID_SEGMENT_NUMBER: u32 = 0xB4;
pub const ERROR_INVALID_ORDINAL: u32 = 0xB6;
pub const ERROR_ALREADY_EXISTS: u32 = 0xB7;
pub const ERROR_INVALID_FLAG_NUMBER: u32 = 0xBA;
pub const ERROR_SEM_NOT_FOUND: u32 = 0xBB;
pub const ERROR_INVALID_STARTING_CODESEG: u32 = 0xBC;
pub const ERROR_INVALID_STACKSEG: u32 = 0xBD;
pub const ERROR_INVALID_MODULETYPE: u32 = 0xBE;
pub const ERROR_INVALID_EXE_SIGNATURE: u32 = 0xBF;
pub const ERROR_EXE_MARKED_INVALID: u32 = 0xC0;
pub const ERROR_BAD_EXE_FORMAT: u32 = 0xC1;
pub const ERROR_ITERATED_DATA_EXCEEDS_64K: u32 = 0xC2;
pub const ERROR_INVALID_MINALLOCSIZE: u32 = 0xC3;
pub const ERROR_DYNLINK_FROM_INVALID_RING: u32 = 0xC4;
pub const ERROR_IOPL_NOT_ENABLED: u32 = 0xC5;
pub const ERROR_INVALID_SEGDPL: u32 = 0xC6;
pub const ERROR_AUTODATASEG_EXCEEDS_64K: u32 = 0xC7;
pub const ERROR_RING2SEG_MUST_BE_MOVABLE: u32 = 0xC8;
pub const ERROR_RELOC_CHAIN_XEEDS_SEGLIM: u32 = 0xC9;
pub const ERROR_INFLOOP_IN_RELOC_CHAIN: u32 = 0xCA;
pub const ERROR_ENVVAR_NOT_FOUND: u32 = 0xCB;
pub const ERROR_NO_SIGNAL_SENT: u32 = 0xCD;
pub const ERROR_FILENAME_EXCED_RANGE: u32 = 0xCE;
pub const ERROR_RING2_STACK_IN_USE: u32 = 0xCF;
pub const ERROR_META_EXPANSION_TOO_LONG: u32 = 0xD0;
pub const ERROR_INVALID_SIGNAL_NUMBER: u32 = 0xD1;
pub const ERROR_THREAD_1_INACTIVE: u32 = 0xD2;
pub const ERROR_LOCKED: u32 = 0xD4;
pub const ERROR_TOO_MANY_MODULES: u32 = 0xD6;
pub const ERROR_NESTING_NOT_ALLOWED: u32 = 0xD7;
pub const ERROR_EXE_MACHINE_TYPE_MISMATCH: u32 = 0xD8;
pub const ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY: u32 = 0xD9;
pub const ERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY: u32 = 0xDA;
pub const ERROR_FILE_CHECKED_OUT: u32 = 0xDC;
pub const ERROR_CHECKOUT_REQUIRED: u32 = 0xDD;
pub const ERROR_BAD_FILE_TYPE: u32 = 0xDE;
pub const ERROR_FILE_TOO_LARGE: u32 = 0xDF;
pub const ERROR_FORMS_AUTH_REQUIRED: u32 = 0xE0;
pub const ERROR_VIRUS_INFECTED: u32 = 0xE1;
pub const ERROR_VIRUS_DELETED: u32 = 0xE2;
pub const ERROR_PIPE_LOCAL: u32 = 0xE5;
pub const ERROR_BAD_PIPE: u32 = 0xE6;
pub const ERROR_PIPE_BUSY: u32 = 0xE7;
pub const ERROR_NO_DATA: u32 = 0xE8;
pub const ERROR_PIPE_NOT_CONNECTED: u32 = 0xE9;
pub const ERROR_MORE_DATA: u32 = 0xEA;
pub const ERROR_NO_WORK_DONE: u32 = 0xEB;
pub const ERROR_VC_DISCONNECTED: u32 = 0xF0;
pub const ERROR_INVALID_EA_NAME: u32 = 0xFE;
pub const ERROR_EA_LIST_INCONSISTENT: u32 = 0xFF;
pub const ERROR_NO_MORE_ITEMS: u32 = 0x103;
pub const ERROR_CANNOT_COPY: u32 = 0x10A;
pub const ERROR_DIRECTORY: u32 = 0x10B;
pub const ERROR_EAS_DIDNT_FIT: u32 = 0x113;
pub const ERROR_EA_FILE_CORRUPT: u32 = 0x114;
pub const ERROR_EA_TABLE_FULL: u32 = 0x115;
pub const ERROR_INVALID_EA_HANDLE: u32 = 0x116;
pub const ERROR_EAS_NOT_SUPPORTED: u32 = 0x11A;
pub const ERROR_NOT_OWNER: u32 = 0x120;
pub const ERROR_TOO_MANY_POSTS: u32 = 0x12A;
pub const ERROR_PARTIAL_COPY: u32 = 0x12B;
pub const ERROR_OPLOCK_NOT_GRANTED: u32 = 0x12C;
pub const ERROR_INVALID_OPLOCK_PROTOCOL: u32 = 0x12D;
pub const ERROR_DISK_TOO_FRAGMENTED: u32 = 0x12E;
pub const ERROR_DELETE_PENDING: u32 = 0x12F;
pub const ERROR_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING: u32 = 0x130;
pub const ERROR_SHORT_NAMES_NOT_ENABLED_ON_VOLUME: u32 = 0x131;
pub const ERROR_SECURITY_STREAM_IS_INCONSISTENT: u32 = 0x132;
pub const ERROR_INVALID_LOCK_RANGE: u32 = 0x133;
pub const ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT: u32 = 0x134;
pub const ERROR_NOTIFICATION_GUID_ALREADY_DEFINED: u32 = 0x135;
pub const ERROR_INVALID_EXCEPTION_HANDLER: u32 = 0x136;
pub const ERROR_DUPLICATE_PRIVILEGES: u32 = 0x137;
pub const ERROR_NO_RANGES_PROCESSED: u32 = 0x138;
pub const ERROR_NOT_ALLOWED_ON_SYSTEM_FILE: u32 = 0x139;
pub const ERROR_DISK_RESOURCES_EXHAUSTED: u32 = 0x13A;
pub const ERROR_INVALID_TOKEN: u32 = 0x13B;
pub const ERROR_DEVICE_FEATURE_NOT_SUPPORTED: u32 = 0x13C;
pub const ERROR_MR_MID_NOT_FOUND: u32 = 0x13D;
pub const ERROR_SCOPE_NOT_FOUND: u32 = 0x13E;
pub const ERROR_UNDEFINED_SCOPE: u32 = 0x13F;
pub const ERROR_INVALID_CAP: u32 = 0x140;
pub const ERROR_DEVICE_UNREACHABLE: u32 = 0x141;
pub const ERROR_DEVICE_NO_RESOURCES: u32 = 0x142;
pub const ERROR_DATA_CHECKSUM_ERROR: u32 = 0x143;
pub const ERROR_INTERMIXED_KERNEL_EA_OPERATION: u32 = 0x144;
pub const ERROR_FILE_LEVEL_TRIM_NOT_SUPPORTED: u32 = 0x146;
pub const ERROR_OFFSET_ALIGNMENT_VIOLATION: u32 = 0x147;
pub const ERROR_INVALID_FIELD_IN_PARAMETER_LIST: u32 = 0x148;
pub const ERROR_OPERATION_IN_PROGRESS: u32 = 0x149;
pub const ERROR_BAD_DEVICE_PATH: u32 = 0x14A;
pub const ERROR_TOO_MANY_DESCRIPTORS: u32 = 0x14B;
pub const ERROR_SCRUB_DATA_DISABLED: u32 = 0x14C;
pub const ERROR_NOT_REDUNDANT_STORAGE: u32 = 0x14D;
pub const ERROR_RESIDENT_FILE_NOT_SUPPORTED: u32 = 0x14E;
pub const ERROR_COMPRESSED_FILE_NOT_SUPPORTED: u32 = 0x14F;
pub const ERROR_DIRECTORY_NOT_SUPPORTED: u32 = 0x150;
pub const ERROR_NOT_READ_FROM_COPY: u32 = 0x151;
pub const ERROR_FT_WRITE_FAILURE: u32 = 0x152;
pub const ERROR_FT_DI_SCAN_REQUIRED: u32 = 0x153;
pub const ERROR_INVALID_KERNEL_INFO_VERSION: u32 = 0x154;
pub const ERROR_INVALID_PEP_INFO_VERSION: u32 = 0x155;
pub const ERROR_OBJECT_NOT_EXTERNALLY_BACKED: u32 = 0x156;
pub const ERROR_EXTERNAL_BACKING_PROVIDER_UNKNOWN: u32 = 0x157;
pub const ERROR_COMPRESSION_NOT_BENEFICIAL: u32 = 0x158;
pub const ERROR_STORAGE_TOPOLOGY_ID_MISMATCH: u32 = 0x159;
pub const ERROR_BLOCKED_BY_PARENTAL_CONTROLS: u32 = 0x15A;
pub const ERROR_BLOCK_TOO_MANY_REFERENCES: u32 = 0x15B;
pub const ERROR_MARKED_TO_DISALLOW_WRITES: u32 = 0x15C;
pub const ERROR_ENCLAVE_FAILURE: u32 = 0x15D;
pub const ERROR_FAIL_NOACTION_REBOOT: u32 = 0x15E;
pub const ERROR_FAIL_SHUTDOWN: u32 = 0x15F;
pub const ERROR_FAIL_RESTART: u32 = 0x160;
pub const ERROR_MAX_SESSIONS_REACHED: u32 = 0x161;
pub const ERROR_NETWORK_ACCESS_DENIED_EDP: u32 = 0x162;
pub const ERROR_DEVICE_HINT_NAME_BUFFER_TOO_SMALL: u32 = 0x163;
pub const ERROR_EDP_POLICY_DENIES_OPERATION: u32 = 0x164;
pub const ERROR_EDP_DPL_POLICY_CANT_BE_SATISFIED: u32 = 0x165;
pub const ERROR_CLOUD_FILE_SYNC_ROOT_METADATA_CORRUPT: u32 = 0x166;
pub const ERROR_DEVICE_IN_MAINTENANCE: u32 = 0x167;
pub const ERROR_NOT_SUPPORTED_ON_DAX: u32 = 0x168;
pub const ERROR_DAX_MAPPING_EXISTS: u32 = 0x169;
pub const ERROR_CLOUD_FILE_PROVIDER_NOT_RUNNING: u32 = 0x16A;
pub const ERROR_CLOUD_FILE_METADATA_CORRUPT: u32 = 0x16B;
pub const ERROR_CLOUD_FILE_METADATA_TOO_LARGE: u32 = 0x16C;
pub const ERROR_CLOUD_FILE_PROPERTY_BLOB_TOO_LARGE: u32 = 0x16D;
pub const ERROR_CLOUD_FILE_PROPERTY_BLOB_CHECKSUM_MISMATCH: u32 = 0x16E;
pub const ERROR_CHILD_PROCESS_BLOCKED: u32 = 0x16F;
pub const ERROR_STORAGE_LOST_DATA_PERSISTENCE: u32 = 0x170;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_UNAVAILABLE: u32 = 0x171;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_METADATA_CORRUPT: u32 = 0x172;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_BUSY: u32 = 0x173;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_PROVIDER_UNKNOWN: u32 = 0x174;
pub const ERROR_GDI_HANDLE_LEAK: u32 = 0x175;
pub const ERROR_CLOUD_FILE_TOO_MANY_PROPERTY_BLOBS: u32 = 0x176;
pub const ERROR_CLOUD_FILE_PROPERTY_VERSION_NOT_SUPPORTED: u32 = 0x177;
pub const ERROR_NOT_A_CLOUD_FILE: u32 = 0x178;
pub const ERROR_CLOUD_FILE_NOT_IN_SYNC: u32 = 0x179;
pub const ERROR_CLOUD_FILE_ALREADY_CONNECTED: u32 = 0x17A;
pub const ERROR_CLOUD_FILE_NOT_SUPPORTED: u32 = 0x17B;
pub const ERROR_CLOUD_FILE_INVALID_REQUEST: u32 = 0x17C;
pub const ERROR_CLOUD_FILE_READ_ONLY_VOLUME: u32 = 0x17D;
pub const ERROR_CLOUD_FILE_CONNECTED_PROVIDER_ONLY: u32 = 0x17E;
pub const ERROR_CLOUD_FILE_VALIDATION_FAILED: u32 = 0x17F;
pub const ERROR_SMB1_NOT_AVAILABLE: u32 = 0x180;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_INVALID_OPERATION: u32 = 0x181;
pub const ERROR_CLOUD_FILE_AUTHENTICATION_FAILED: u32 = 0x182;
pub const ERROR_CLOUD_FILE_INSUFFICIENT_RESOURCES: u32 = 0x183;
pub const ERROR_CLOUD_FILE_NETWORK_UNAVAILABLE: u32 = 0x184;
pub const ERROR_CLOUD_FILE_UNSUCCESSFUL: u32 = 0x185;
pub const ERROR_CLOUD_FILE_NOT_UNDER_SYNC_ROOT: u32 = 0x186;
pub const ERROR_CLOUD_FILE_IN_USE: u32 = 0x187;
pub const ERROR_CLOUD_FILE_PINNED: u32 = 0x188;
pub const ERROR_CLOUD_FILE_REQUEST_ABORTED: u32 = 0x189;
pub const ERROR_CLOUD_FILE_PROPERTY_CORRUPT: u32 = 0x18A;
pub const ERROR_CLOUD_FILE_ACCESS_DENIED: u32 = 0x18B;
pub const ERROR_CLOUD_FILE_INCOMPATIBLE_HARDLINKS: u32 = 0x18C;
pub const ERROR_CLOUD_FILE_PROPERTY_LOCK_CONFLICT: u32 = 0x18D;
pub const ERROR_CLOUD_FILE_REQUEST_CANCELED: u32 = 0x18E;
pub const ERROR_EXTERNAL_SYSKEY_NOT_SUPPORTED: u32 = 0x18F;
pub const ERROR_THREAD_MODE_ALREADY_BACKGROUND: u32 = 0x190;
pub const ERROR_THREAD_MODE_NOT_BACKGROUND: u32 = 0x191;
pub const ERROR_PROCESS_MODE_ALREADY_BACKGROUND: u32 = 0x192;
pub const ERROR_PROCESS_MODE_NOT_BACKGROUND: u32 = 0x193;
pub const ERROR_CLOUD_FILE_PROVIDER_TERMINATED: u32 = 0x194;
pub const ERROR_NOT_A_CLOUD_SYNC_ROOT: u32 = 0x195;
pub const ERROR_FILE_PROTECTED_UNDER_DPL: u32 = 0x196;
pub const ERROR_VOLUME_NOT_CLUSTER_ALIGNED: u32 = 0x197;
pub const ERROR_NO_PHYSICALLY_ALIGNED_FREE_SPACE_FOUND: u32 = 0x198;
pub const ERROR_APPX_FILE_NOT_ENCRYPTED: u32 = 0x199;
pub const ERROR_RWRAW_ENCRYPTED_FILE_NOT_ENCRYPTED: u32 = 0x19A;
pub const ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILEOFFSET: u32 = 0x19B;
pub const ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILERANGE: u32 = 0x19C;
pub const ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_PARAMETER: u32 = 0x19D;
pub const ERROR_LINUX_SUBSYSTEM_NOT_PRESENT: u32 = 0x19E;
pub const ERROR_FT_READ_FAILURE: u32 = 0x19F;
pub const ERROR_STORAGE_RESERVE_ID_INVALID: u32 = 0x1A0;
pub const ERROR_STORAGE_RESERVE_DOES_NOT_EXIST: u32 = 0x1A1;
pub const ERROR_STORAGE_RESERVE_ALREADY_EXISTS: u32 = 0x1A2;
pub const ERROR_STORAGE_RESERVE_NOT_EMPTY: u32 = 0x1A3;
pub const ERROR_NOT_A_DAX_VOLUME: u32 = 0x1A4;
pub const ERROR_NOT_DAX_MAPPABLE: u32 = 0x1A5;
pub const ERROR_TIME_SENSITIVE_THREAD: u32 = 0x1A6;
pub const ERROR_DPL_NOT_SUPPORTED_FOR_USER: u32 = 0x1A7;
pub const ERROR_CASE_DIFFERING_NAMES_IN_DIR: u32 = 0x1A8;
pub const ERROR_FILE_NOT_SUPPORTED: u32 = 0x1A9;
pub const ERROR_CLOUD_FILE_REQUEST_TIMEOUT: u32 = 0x1AA;
pub const ERROR_NO_TASK_QUEUE: u32 = 0x1AB;
pub const ERROR_SRC_SRV_DLL_LOAD_FAILED: u32 = 0x1AC;
pub const ERROR_NOT_SUPPORTED_WITH_BTT: u32 = 0x1AD;
pub const ERROR_ENCRYPTION_DISABLED: u32 = 0x1AE;
pub const ERROR_ENCRYPTING_METADATA_DISALLOWED: u32 = 0x1AF;
pub const ERROR_CANT_CLEAR_ENCRYPTION_FLAG: u32 = 0x1B0;
pub const ERROR_NO_SUCH_DEVICE: u32 = 0x1B1;
pub const ERROR_CLOUD_FILE_DEHYDRATION_DISALLOWED: u32 = 0x1B2;
pub const ERROR_FILE_SNAP_IN_PROGRESS: u32 = 0x1B3;
pub const ERROR_FILE_SNAP_USER_SECTION_NOT_SUPPORTED: u32 = 0x1B4;
pub const ERROR_FILE_SNAP_MODIFY_NOT_SUPPORTED: u32 = 0x1B5;
pub const ERROR_FILE_SNAP_IO_NOT_COORDINATED: u32 = 0x1B6;
pub const ERROR_FILE_SNAP_UNEXPECTED_ERROR: u32 = 0x1B7;
pub const ERROR_FILE_SNAP_INVALID_PARAMETER: u32 = 0x1B8;
pub const ERROR_UNSATISFIED_DEPENDENCIES: u32 = 0x1B9;
pub const ERROR_CASE_SENSITIVE_PATH: u32 = 0x1BA;
pub const ERROR_UNEXPECTED_NTCACHEMANAGER_ERROR: u32 = 0x1BB;
pub const ERROR_LINUX_SUBSYSTEM_UPDATE_REQUIRED: u32 = 0x1BC;
pub const ERROR_DLP_POLICY_WARNS_AGAINST_OPERATION: u32 = 0x1BD;
pub const ERROR_DLP_POLICY_DENIES_OPERATION: u32 = 0x1BE;
pub const ERROR_SECURITY_DENIES_OPERATION: u32 = 0x1BF;
pub const ERROR_UNTRUSTED_MOUNT_POINT: u32 = 0x1C0;
pub const ERROR_DLP_POLICY_SILENTLY_FAIL: u32 = 0x1C1;
pub const ERROR_CAPAUTHZ_NOT_DEVUNLOCKED: u32 = 0x1C2;
pub const ERROR_CAPAUTHZ_CHANGE_TYPE: u32 = 0x1C3;
pub const ERROR_CAPAUTHZ_NOT_PROVISIONED: u32 = 0x1C4;
pub const ERROR_CAPAUTHZ_NOT_AUTHORIZED: u32 = 0x1C5;
pub const ERROR_CAPAUTHZ_NO_POLICY: u32 = 0x1C6;
pub const ERROR_CAPAUTHZ_DB_CORRUPTED: u32 = 0x1C7;
pub const ERROR_CAPAUTHZ_SCCD_INVALID_CATALOG: u32 = 0x1C8;
pub const ERROR_CAPAUTHZ_SCCD_NO_AUTH_ENTITY: u32 = 0x1C9;
pub const ERROR_CAPAUTHZ_SCCD_PARSE_ERROR: u32 = 0x1CA;
pub const ERROR_CAPAUTHZ_SCCD_DEV_MODE_REQUIRED: u32 = 0x1CB;
pub const ERROR_CAPAUTHZ_SCCD_NO_CAPABILITY_MATCH: u32 = 0x1CC;
pub const ERROR_CIMFS_IMAGE_CORRUPT: u32 = 0x1D6;
pub const ERROR_CIMFS_IMAGE_VERSION_NOT_SUPPORTED: u32 = 0x1D7;
pub const ERROR_STORAGE_STACK_ACCESS_DENIED: u32 = 0x1D8;
pub const ERROR_INSUFFICIENT_VIRTUAL_ADDR_RESOURCES: u32 = 0x1D9;
pub const ERROR_INDEX_OUT_OF_BOUNDS: u32 = 0x1DA;
pub const ERROR_PNP_QUERY_REMOVE_DEVICE_TIMEOUT: u32 = 0x1E0;
pub const ERROR_PNP_QUERY_REMOVE_RELATED_DEVICE_TIMEOUT: u32 = 0x1E1;
pub const ERROR_PNP_QUERY_REMOVE_UNRELATED_DEVICE_TIMEOUT: u32 = 0x1E2;
pub const ERROR_DEVICE_HARDWARE_ERROR: u32 = 0x1E3;
pub const ERROR_INVALID_ADDRESS: u32 = 0x1E7;
pub const ERROR_HAS_SYSTEM_CRITICAL_FILES: u32 = 0x1E8;
pub const ERROR_ENCRYPTED_FILE_NOT_SUPPORTED: u32 = 0x1E9;
pub const ERROR_SPARSE_FILE_NOT_SUPPORTED: u32 = 0x1EA;
pub const ERROR_PAGEFILE_NOT_SUPPORTED: u32 = 0x1EB;
pub const ERROR_VOLUME_NOT_SUPPORTED: u32 = 0x1EC;
pub const ERROR_NOT_SUPPORTED_WITH_BYPASSIO: u32 = 0x1ED;
pub const ERROR_NO_BYPASSIO_DRIVER_SUPPORT: u32 = 0x1EE;
pub const ERROR_NOT_SUPPORTED_WITH_ENCRYPTION: u32 = 0x1EF;
pub const ERROR_NOT_SUPPORTED_WITH_COMPRESSION: u32 = 0x1F0;
pub const ERROR_NOT_SUPPORTED_WITH_REPLICATION: u32 = 0x1F1;
pub const ERROR_NOT_SUPPORTED_WITH_DEDUPLICATION: u32 = 0x1F2;
pub const ERROR_NOT_SUPPORTED_WITH_AUDITING: u32 = 0x1F3;
pub const ERROR_USER_PROFILE_LOAD: u32 = 0x1F4;
pub const ERROR_SESSION_KEY_TOO_SHORT: u32 = 0x1F5;
pub const ERROR_ACCESS_DENIED_APPDATA: u32 = 0x1F6;
pub const ERROR_NOT_SUPPORTED_WITH_MONITORING: u32 = 0x1F7;
pub const ERROR_NOT_SUPPORTED_WITH_SNAPSHOT: u32 = 0x1F8;
pub const ERROR_NOT_SUPPORTED_WITH_VIRTUALIZATION: u32 = 0x1F9;
pub const ERROR_BYPASSIO_FLT_NOT_SUPPORTED: u32 = 0x1FA;
pub const ERROR_DEVICE_RESET_REQUIRED: u32 = 0x1FB;
pub const ERROR_VOLUME_WRITE_ACCESS_DENIED: u32 = 0x1FC;
pub const ERROR_ARITHMETIC_OVERFLOW: u32 = 0x216;
pub const ERROR_PIPE_CONNECTED: u32 = 0x217;
pub const ERROR_PIPE_LISTENING: u32 = 0x218;
pub const ERROR_VERIFIER_STOP: u32 = 0x219;
pub const ERROR_ABIOS_ERROR: u32 = 0x21A;
pub const ERROR_WX86_WARNING: u32 = 0x21B;
pub const ERROR_WX86_ERROR: u32 = 0x21C;
pub const ERROR_TIMER_NOT_CANCELED: u32 = 0x21D;
pub const ERROR_UNWIND: u32 = 0x21E;
pub const ERROR_BAD_STACK: u32 = 0x21F;
pub const ERROR_INVALID_UNWIND_TARGET: u32 = 0x220;
pub const ERROR_INVALID_PORT_ATTRIBUTES: u32 = 0x221;
pub const ERROR_PORT_MESSAGE_TOO_LONG: u32 = 0x222;
pub const ERROR_INVALID_QUOTA_LOWER: u32 = 0x223;
pub const ERROR_DEVICE_ALREADY_ATTACHED: u32 = 0x224;
pub const ERROR_INSTRUCTION_MISALIGNMENT: u32 = 0x225;
pub const ERROR_PROFILING_NOT_STARTED: u32 = 0x226;
pub const ERROR_PROFILING_NOT_STOPPED: u32 = 0x227;
pub const ERROR_COULD_NOT_INTERPRET: u32 = 0x228;
pub const ERROR_PROFILING_AT_LIMIT: u32 = 0x229;
pub const ERROR_CANT_WAIT: u32 = 0x22A;
pub const ERROR_CANT_TERMINATE_SELF: u32 = 0x22B;
pub const ERROR_UNEXPECTED_MM_CREATE_ERR: u32 = 0x22C;
pub const ERROR_UNEXPECTED_MM_MAP_ERROR: u32 = 0x22D;
pub const ERROR_UNEXPECTED_MM_EXTEND_ERR: u32 = 0x22E;
pub const ERROR_BAD_FUNCTION_TABLE: u32 = 0x22F;
pub const ERROR_NO_GUID_TRANSLATION: u32 = 0x230;
pub const ERROR_INVALID_LDT_SIZE: u32 = 0x231;
pub const ERROR_INVALID_LDT_OFFSET: u32 = 0x233;
pub const ERROR_INVALID_LDT_DESCRIPTOR: u32 = 0x234;
pub const ERROR_TOO_MANY_THREADS: u32 = 0x235;
pub const ERROR_THREAD_NOT_IN_PROCESS: u32 = 0x236;
pub const ERROR_PAGEFILE_QUOTA_EXCEEDED: u32 = 0x237;
pub const ERROR_LOGON_SERVER_CONFLICT: u32 = 0x238;
pub const ERROR_SYNCHRONIZATION_REQUIRED: u32 = 0x239;
pub const ERROR_NET_OPEN_FAILED: u32 = 0x23A;
pub const ERROR_IO_PRIVILEGE_FAILED: u32 = 0x23B;
pub const ERROR_CONTROL_C_EXIT: u32 = 0x23C;
pub const ERROR_MISSING_SYSTEMFILE: u32 = 0x23D;
pub const ERROR_UNHANDLED_EXCEPTION: u32 = 0x23E;
pub const ERROR_APP_INIT_FAILURE: u32 = 0x23F;
pub const ERROR_PAGEFILE_CREATE_FAILED: u32 = 0x240;
pub const ERROR_INVALID_IMAGE_HASH: u32 = 0x241;
pub const ERROR_NO_PAGEFILE: u32 = 0x242;
pub const ERROR_ILLEGAL_FLOAT_CONTEXT: u32 = 0x243;
pub const ERROR_NO_EVENT_PAIR: u32 = 0x244;
pub const ERROR_DOMAIN_CTRLR_CONFIG_ERROR: u32 = 0x245;
pub const ERROR_ILLEGAL_CHARACTER: u32 = 0x246;
pub const ERROR_UNDEFINED_CHARACTER: u32 = 0x247;
pub const ERROR_FLOPPY_VOLUME: u32 = 0x248;
pub const ERROR_BIOS_FAILED_TO_CONNECT_INTERRUPT: u32 = 0x249;
pub const ERROR_BACKUP_CONTROLLER: u32 = 0x24A;
pub const ERROR_MUTANT_LIMIT_EXCEEDED: u32 = 0x24B;
pub const ERROR_FS_DRIVER_REQUIRED: u32 = 0x24C;
pub const ERROR_CANNOT_LOAD_REGISTRY_FILE: u32 = 0x24D;
pub const ERROR_DEBUG_ATTACH_FAILED: u32 = 0x24E;
pub const ERROR_SYSTEM_PROCESS_TERMINATED: u32 = 0x24F;
pub const ERROR_DATA_NOT_ACCEPTED: u32 = 0x250;
pub const ERROR_VDM_HARD_ERROR: u32 = 0x251;
pub const ERROR_DRIVER_CANCEL_TIMEOUT: u32 = 0x252;
pub const ERROR_REPLY_MESSAGE_MISMATCH: u32 = 0x253;
pub const ERROR_LOST_WRITEBEHIND_DATA: u32 = 0x254;
pub const ERROR_CLIENT_SERVER_PARAMETERS_INVALID: u32 = 0x255;
pub const ERROR_NOT_TINY_STREAM: u32 = 0x256;
pub const ERROR_STACK_OVERFLOW_READ: u32 = 0x257;
pub const ERROR_CONVERT_TO_LARGE: u32 = 0x258;
pub const ERROR_FOUND_OUT_OF_SCOPE: u32 = 0x259;
pub const ERROR_ALLOCATE_BUCKET: u32 = 0x25A;
pub const ERROR_MARSHALL_OVERFLOW: u32 = 0x25B;
pub const ERROR_INVALID_VARIANT: u32 = 0x25C;
pub const ERROR_BAD_COMPRESSION_BUFFER: u32 = 0x25D;
pub const ERROR_AUDIT_FAILED: u32 = 0x25E;
pub const ERROR_TIMER_RESOLUTION_NOT_SET: u32 = 0x25F;
pub const ERROR_INSUFFICIENT_LOGON_INFO: u32 = 0x260;
pub const ERROR_BAD_DLL_ENTRYPOINT: u32 = 0x261;
pub const ERROR_BAD_SERVICE_ENTRYPOINT: u32 = 0x262;
pub const ERROR_IP_ADDRESS_CONFLICT1: u32 = 0x263;
pub const ERROR_IP_ADDRESS_CONFLICT2: u32 = 0x264;
pub const ERROR_REGISTRY_QUOTA_LIMIT: u32 = 0x265;
pub const ERROR_NO_CALLBACK_ACTIVE: u32 = 0x266;
pub const ERROR_PWD_TOO_SHORT: u32 = 0x267;
pub const ERROR_PWD_TOO_RECENT: u32 = 0x268;
pub const ERROR_PWD_HISTORY_CONFLICT: u32 = 0x269;
pub const ERROR_UNSUPPORTED_COMPRESSION: u32 = 0x26A;
pub const ERROR_INVALID_HW_PROFILE: u32 = 0x26B;
pub const ERROR_INVALID_PLUGPLAY_DEVICE_PATH: u32 = 0x26C;
pub const ERROR_QUOTA_LIST_INCONSISTENT: u32 = 0x26D;
pub const ERROR_EVALUATION_EXPIRATION: u32 = 0x26E;
pub const ERROR_ILLEGAL_DLL_RELOCATION: u32 = 0x26F;
pub const ERROR_DLL_INIT_FAILED_LOGOFF: u32 = 0x270;
pub const ERROR_VALIDATE_CONTINUE: u32 = 0x271;
pub const ERROR_NO_MORE_MATCHES: u32 = 0x272;
pub const ERROR_RANGE_LIST_CONFLICT: u32 = 0x273;
pub const ERROR_SERVER_SID_MISMATCH: u32 = 0x274;
pub const ERROR_CANT_ENABLE_DENY_ONLY: u32 = 0x275;
pub const ERROR_FLOAT_MULTIPLE_FAULTS: u32 = 0x276;
pub const ERROR_FLOAT_MULTIPLE_TRAPS: u32 = 0x277;
pub const ERROR_NOINTERFACE: u32 = 0x278;
pub const ERROR_DRIVER_FAILED_SLEEP: u32 = 0x279;
pub const ERROR_CORRUPT_SYSTEM_FILE: u32 = 0x27A;
pub const ERROR_COMMITMENT_MINIMUM: u32 = 0x27B;
pub const ERROR_PNP_RESTART_ENUMERATION: u32 = 0x27C;
pub const ERROR_SYSTEM_IMAGE_BAD_SIGNATURE: u32 = 0x27D;
pub const ERROR_PNP_REBOOT_REQUIRED: u32 = 0x27E;
pub const ERROR_INSUFFICIENT_POWER: u32 = 0x27F;
pub const ERROR_MULTIPLE_FAULT_VIOLATION: u32 = 0x280;
pub const ERROR_SYSTEM_SHUTDOWN: u32 = 0x281;
pub const ERROR_PORT_NOT_SET: u32 = 0x282;
pub const ERROR_DS_VERSION_CHECK_FAILURE: u32 = 0x283;
pub const ERROR_RANGE_NOT_FOUND: u32 = 0x284;
pub const ERROR_NOT_SAFE_MODE_DRIVER: u32 = 0x286;
pub const ERROR_FAILED_DRIVER_ENTRY: u32 = 0x287;
pub const ERROR_DEVICE_ENUMERATION_ERROR: u32 = 0x288;
pub const ERROR_MOUNT_POINT_NOT_RESOLVED: u32 = 0x289;
pub const ERROR_INVALID_DEVICE_OBJECT_PARAMETER: u32 = 0x28A;
pub const ERROR_MCA_OCCURED: u32 = 0x28B;
pub const ERROR_DRIVER_DATABASE_ERROR: u32 = 0x28C;
pub const ERROR_SYSTEM_HIVE_TOO_LARGE: u32 = 0x28D;
pub const ERROR_DRIVER_FAILED_PRIOR_UNLOAD: u32 = 0x28E;
pub const ERROR_VOLSNAP_PREPARE_HIBERNATE: u32 = 0x28F;
pub const ERROR_HIBERNATION_FAILURE: u32 = 0x290;
pub const ERROR_PWD_TOO_LONG: u32 = 0x291;
pub const ERROR_FILE_SYSTEM_LIMITATION: u32 = 0x299;
pub const ERROR_ASSERTION_FAILURE: u32 = 0x29C;
pub const ERROR_ACPI_ERROR: u32 = 0x29D;
pub const ERROR_WOW_ASSERTION: u32 = 0x29E;
pub const ERROR_PNP_BAD_MPS_TABLE: u32 = 0x29F;
pub const ERROR_PNP_TRANSLATION_FAILED: u32 = 0x2A0;
pub const ERROR_PNP_IRQ_TRANSLATION_FAILED: u32 = 0x2A1;
pub const ERROR_PNP_INVALID_ID: u32 = 0x2A2;
pub const ERROR_WAKE_SYSTEM_DEBUGGER: u32 = 0x2A3;
pub const ERROR_HANDLES_CLOSED: u32 = 0x2A4;
pub const ERROR_EXTRANEOUS_INFORMATION: u32 = 0x2A5;
pub const ERROR_RXACT_COMMIT_NECESSARY: u32 = 0x2A6;
pub const ERROR_MEDIA_CHECK: u32 = 0x2A7;
pub const ERROR_GUID_SUBSTITUTION_MADE: u32 = 0x2A8;
pub const ERROR_STOPPED_ON_SYMLINK: u32 = 0x2A9;
pub const ERROR_LONGJUMP: u32 = 0x2AA;
pub const ERROR_PLUGPLAY_QUERY_VETOED: u32 = 0x2AB;
pub const ERROR_UNWIND_CONSOLIDATE: u32 = 0x2AC;
pub const ERROR_REGISTRY_HIVE_RECOVERED: u32 = 0x2AD;
pub const ERROR_DLL_MIGHT_BE_INSECURE: u32 = 0x2AE;
pub const ERROR_DLL_MIGHT_BE_INCOMPATIBLE: u32 = 0x2AF;
pub const ERROR_DBG_EXCEPTION_NOT_HANDLED: u32 = 0x2B0;
pub const ERROR_DBG_REPLY_LATER: u32 = 0x2B1;
pub const ERROR_DBG_UNABLE_TO_PROVIDE_HANDLE: u32 = 0x2B2;
pub const ERROR_DBG_TERMINATE_THREAD: u32 = 0x2B3;
pub const ERROR_DBG_TERMINATE_PROCESS: u32 = 0x2B4;
pub const ERROR_DBG_CONTROL_C: u32 = 0x2B5;
pub const ERROR_DBG_PRINTEXCEPTION_C: u32 = 0x2B6;
pub const ERROR_DBG_RIPEXCEPTION: u32 = 0x2B7;
pub const ERROR_DBG_CONTROL_BREAK: u32 = 0x2B8;
pub const ERROR_DBG_COMMAND_EXCEPTION: u32 = 0x2B9;
pub const ERROR_OBJECT_NAME_EXISTS: u32 = 0x2BA;
pub const ERROR_THREAD_WAS_SUSPENDED: u32 = 0x2BB;
pub const ERROR_IMAGE_NOT_AT_BASE: u32 = 0x2BC;
pub const ERROR_RXACT_STATE_CREATED: u32 = 0x2BD;
pub const ERROR_SEGMENT_NOTIFICATION: u32 = 0x2BE;
pub const ERROR_BAD_CURRENT_DIRECTORY: u32 = 0x2BF;
pub const ERROR_FT_READ_RECOVERY_FROM_BACKUP: u32 = 0x2C0;
pub const ERROR_FT_WRITE_RECOVERY: u32 = 0x2C1;
pub const ERROR_IMAGE_MACHINE_TYPE_MISMATCH: u32 = 0x2C2;
pub const ERROR_RECEIVE_PARTIAL: u32 = 0x2C3;
pub const ERROR_RECEIVE_EXPEDITED: u32 = 0x2C4;
pub const ERROR_RECEIVE_PARTIAL_EXPEDITED: u32 = 0x2C5;
pub const ERROR_EVENT_DONE: u32 = 0x2C6;
pub const ERROR_EVENT_PENDING: u32 = 0x2C7;
pub const ERROR_CHECKING_FILE_SYSTEM: u32 = 0x2C8;
pub const ERROR_FATAL_APP_EXIT: u32 = 0x2C9;
pub const ERROR_PREDEFINED_HANDLE: u32 = 0x2CA;
pub const ERROR_WAS_UNLOCKED: u32 = 0x2CB;
pub const ERROR_SERVICE_NOTIFICATION: u32 = 0x2CC;
pub const ERROR_WAS_LOCKED: u32 = 0x2CD;
pub const ERROR_LOG_HARD_ERROR: u32 = 0x2CE;
pub const ERROR_ALREADY_WIN32: u32 = 0x2CF;
pub const ERROR_IMAGE_MACHINE_TYPE_MISMATCH_EXE: u32 = 0x2D0;
pub const ERROR_NO_YIELD_PERFORMED: u32 = 0x2D1;
pub const ERROR_TIMER_RESUME_IGNORED: u32 = 0x2D2;
pub const ERROR_ARBITRATION_UNHANDLED: u32 = 0x2D3;
pub const ERROR_CARDBUS_NOT_SUPPORTED: u32 = 0x2D4;
pub const ERROR_MP_PROCESSOR_MISMATCH: u32 = 0x2D5;
pub const ERROR_HIBERNATED: u32 = 0x2D6;
pub const ERROR_RESUME_HIBERNATION: u32 = 0x2D7;
pub const ERROR_FIRMWARE_UPDATED: u32 = 0x2D8;
pub const ERROR_DRIVERS_LEAKING_LOCKED_PAGES: u32 = 0x2D9;
pub const ERROR_WAKE_SYSTEM: u32 = 0x2DA;
pub const ERROR_WAIT_1: u32 = 0x2DB;
pub const ERROR_WAIT_2: u32 = 0x2DC;
pub const ERROR_WAIT_3: u32 = 0x2DD;
pub const ERROR_WAIT_63: u32 = 0x2DE;
pub const ERROR_ABANDONED_WAIT_0: u32 = 0x2DF;
pub const ERROR_ABANDONED_WAIT_63: u32 = 0x2E0;
pub const ERROR_USER_APC: u32 = 0x2E1;
pub const ERROR_KERNEL_APC: u32 = 0x2E2;
pub const ERROR_ALERTED: u32 = 0x2E3;
pub const ERROR_ELEVATION_REQUIRED: u32 = 0x2E4;
pub const ERROR_REPARSE: u32 = 0x2E5;
pub const ERROR_OPLOCK_BREAK_IN_PROGRESS: u32 = 0x2E6;
pub const ERROR_VOLUME_MOUNTED: u32 = 0x2E7;
pub const ERROR_RXACT_COMMITTED: u32 = 0x2E8;
pub const ERROR_NOTIFY_CLEANUP: u32 = 0x2E9;
pub const ERROR_PRIMARY_TRANSPORT_CONNECT_FAILED: u32 = 0x2EA;
pub const ERROR_PAGE_FAULT_TRANSITION: u32 = 0x2EB;
pub const ERROR_PAGE_FAULT_DEMAND_ZERO: u32 = 0x2EC;
pub const ERROR_PAGE_FAULT_COPY_ON_WRITE: u32 = 0x2ED;
pub const ERROR_PAGE_FAULT_GUARD_PAGE: u32 = 0x2EE;
pub const ERROR_PAGE_FAULT_PAGING_FILE: u32 = 0x2EF;
pub const ERROR_CACHE_PAGE_LOCKED: u32 = 0x2F0;
pub const ERROR_CRASH_DUMP: u32 = 0x2F1;
pub const ERROR_BUFFER_ALL_ZEROS: u32 = 0x2F2;
pub const ERROR_REPARSE_OBJECT: u32 = 0x2F3;
pub const ERROR_RESOURCE_REQUIREMENTS_CHANGED: u32 = 0x2F4;
pub const ERROR_TRANSLATION_COMPLETE: u32 = 0x2F5;
pub const ERROR_NOTHING_TO_TERMINATE: u32 = 0x2F6;
pub const ERROR_PROCESS_NOT_IN_JOB: u32 = 0x2F7;
pub const ERROR_PROCESS_IN_JOB: u32 = 0x2F8;
pub const ERROR_VOLSNAP_HIBERNATE_READY: u32 = 0x2F9;
pub const ERROR_FSFILTER_OP_COMPLETED_SUCCESSFULLY: u32 = 0x2FA;
pub const ERROR_INTERRUPT_VECTOR_ALREADY_CONNECTED: u32 = 0x2FB;
pub const ERROR_INTERRUPT_STILL_CONNECTED: u32 = 0x2FC;
pub const ERROR_WAIT_FOR_OPLOCK: u32 = 0x2FD;
pub const ERROR_DBG_EXCEPTION_HANDLED: u32 = 0x2FE;
pub const ERROR_DBG_CONTINUE: u32 = 0x2FF;
pub const ERROR_CALLBACK_POP_STACK: u32 = 0x300;
pub const ERROR_COMPRESSION_DISABLED: u32 = 0x301;
pub const ERROR_CANTFETCHBACKWARDS: u32 = 0x302;
pub const ERROR_CANTSCROLLBACKWARDS: u32 = 0x303;
pub const ERROR_ROWSNOTRELEASED: u32 = 0x304;
pub const ERROR_BAD_ACCESSOR_FLAGS: u32 = 0x305;
pub const ERROR_ERRORS_ENCOUNTERED: u32 = 0x306;
pub const ERROR_NOT_CAPABLE: u32 = 0x307;
pub const ERROR_REQUEST_OUT_OF_SEQUENCE: u32 = 0x308;
pub const ERROR_VERSION_PARSE_ERROR: u32 = 0x309;
pub const ERROR_BADSTARTPOSITION: u32 = 0x30A;
pub const ERROR_MEMORY_HARDWARE: u32 = 0x30B;
pub const ERROR_DISK_REPAIR_DISABLED: u32 = 0x30C;
pub const ERROR_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE: u32 = 0x30D;
pub const ERROR_SYSTEM_POWERSTATE_TRANSITION: u32 = 0x30E;
pub const ERROR_SYSTEM_POWERSTATE_COMPLEX_TRANSITION: u32 = 0x30F;
pub const ERROR_MCA_EXCEPTION: u32 = 0x310;
pub const ERROR_ACCESS_AUDIT_BY_POLICY: u32 = 0x311;
pub const ERROR_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY: u32 = 0x312;
pub const ERROR_ABANDON_HIBERFILE: u32 = 0x313;
pub const ERROR_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED: u32 = 0x314;
pub const ERROR_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR: u32 = 0x315;
pub const ERROR_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR: u32 = 0x316;
pub const ERROR_BAD_MCFG_TABLE: u32 = 0x317;
pub const ERROR_DISK_REPAIR_REDIRECTED: u32 = 0x318;
pub const ERROR_DISK_REPAIR_UNSUCCESSFUL: u32 = 0x319;
pub const ERROR_CORRUPT_LOG_OVERFULL: u32 = 0x31A;
pub const ERROR_CORRUPT_LOG_CORRUPTED: u32 = 0x31B;
pub const ERROR_CORRUPT_LOG_UNAVAILABLE: u32 = 0x31C;
pub const ERROR_CORRUPT_LOG_DELETED_FULL: u32 = 0x31D;
pub const ERROR_CORRUPT_LOG_CLEARED: u32 = 0x31E;
pub const ERROR_ORPHAN_NAME_EXHAUSTED: u32 = 0x31F;
pub const ERROR_OPLOCK_SWITCHED_TO_NEW_HANDLE: u32 = 0x320;
pub const ERROR_CANNOT_GRANT_REQUESTED_OPLOCK: u32 = 0x321;
pub const ERROR_CANNOT_BREAK_OPLOCK: u32 = 0x322;
pub const ERROR_OPLOCK_HANDLE_CLOSED: u32 = 0x323;
pub const ERROR_NO_ACE_CONDITION: u32 = 0x324;
pub const ERROR_INVALID_ACE_CONDITION: u32 = 0x325;
pub const ERROR_FILE_HANDLE_REVOKED: u32 = 0x326;
pub const ERROR_IMAGE_AT_DIFFERENT_BASE: u32 = 0x327;
pub const ERROR_ENCRYPTED_IO_NOT_POSSIBLE: u32 = 0x328;
pub const ERROR_FILE_METADATA_OPTIMIZATION_IN_PROGRESS: u32 = 0x329;
pub const ERROR_QUOTA_ACTIVITY: u32 = 0x32A;
pub const ERROR_HANDLE_REVOKED: u32 = 0x32B;
pub const ERROR_CALLBACK_INVOKE_INLINE: u32 = 0x32C;
pub const ERROR_CPU_SET_INVALID: u32 = 0x32D;
pub const ERROR_ENCLAVE_NOT_TERMINATED: u32 = 0x32E;
pub const ERROR_ENCLAVE_VIOLATION: u32 = 0x32F;
pub const ERROR_SERVER_TRANSPORT_CONFLICT: u32 = 0x330;
pub const ERROR_CERTIFICATE_VALIDATION_PREFERENCE_CONFLICT: u32 = 0x331;
pub const ERROR_FT_READ_FROM_COPY_FAILURE: u32 = 0x332;
pub const ERROR_SECTION_DIRECT_MAP_ONLY: u32 = 0x333;
pub const ERROR_EA_ACCESS_DENIED: u32 = 0x3E2;
pub const ERROR_OPERATION_ABORTED: u32 = 0x3E3;
pub const ERROR_IO_INCOMPLETE: u32 = 0x3E4;
pub const ERROR_IO_PENDING: u32 = 0x3E5;
pub const ERROR_NOACCESS: u32 = 0x3E6;
pub const ERROR_SWAPERROR: u32 = 0x3E7;
pub const ERROR_STACK_OVERFLOW: u32 = 0x3E9;
pub const ERROR_INVALID_MESSAGE: u32 = 0x3EA;
pub const ERROR_CAN_NOT_COMPLETE: u32 = 0x3EB;
pub const ERROR_INVALID_FLAGS: u32 = 0x3EC;
pub const ERROR_UNRECOGNIZED_VOLUME: u32 = 0x3ED;
pub const ERROR_FILE_INVALID: u32 = 0x3EE;
pub const ERROR_FULLSCREEN_MODE: u32 = 0x3EF;
pub const ERROR_NO_TOKEN: u32 = 0x3F0;
pub const ERROR_BADDB: u32 = 0x3F1;
pub const ERROR_BADKEY: u32 = 0x3F2;
pub const ERROR_CANTOPEN: u32 = 0x3F3;
pub const ERROR_CANTREAD: u32 = 0x3F4;
pub const ERROR_CANTWRITE: u32 = 0x3F5;
pub const ERROR_REGISTRY_RECOVERED: u32 = 0x3F6;
pub const ERROR_REGISTRY_CORRUPT: u32 = 0x3F7;
pub const ERROR_REGISTRY_IO_FAILED: u32 = 0x3F8;
pub const ERROR_NOT_REGISTRY_FILE: u32 = 0x3F9;
pub const ERROR_KEY_DELETED: u32 = 0x3FA;
pub const ERROR_NO_LOG_SPACE: u32 = 0x3FB;
pub const ERROR_KEY_HAS_CHILDREN: u32 = 0x3FC;
pub const ERROR_CHILD_MUST_BE_VOLATILE: u32 = 0x3FD;
pub const ERROR_NOTIFY_ENUM_DIR: u32 = 0x3FE;
pub const ERROR_DEPENDENT_SERVICES_RUNNING: u32 = 0x41B;
pub const ERROR_INVALID_SERVICE_CONTROL: u32 = 0x41C;
pub const ERROR_SERVICE_REQUEST_TIMEOUT: u32 = 0x41D;
pub const ERROR_SERVICE_NO_THREAD: u32 = 0x41E;
pub const ERROR_SERVICE_DATABASE_LOCKED: u32 = 0x41F;
pub const ERROR_SERVICE_ALREADY_RUNNING: u32 = 0x420;
pub const ERROR_INVALID_SERVICE_ACCOUNT: u32 = 0x421;
pub const ERROR_SERVICE_DISABLED: u32 = 0x422;
pub const ERROR_CIRCULAR_DEPENDENCY: u32 = 0x423;
pub const ERROR_SERVICE_DOES_NOT_EXIST: u32 = 0x424;
pub const ERROR_SERVICE_CANNOT_ACCEPT_CTRL: u32 = 0x425;
pub const ERROR_SERVICE_NOT_ACTIVE: u32 = 0x426;
pub const ERROR_FAILED_SERVICE_CONTROLLER_CONNECT: u32 = 0x427;
pub const ERROR_EXCEPTION_IN_SERVICE: u32 = 0x428;
pub const ERROR_DATABASE_DOES_NOT_EXIST: u32 = 0x429;
pub const ERROR_SERVICE_SPECIFIC_ERROR: u32 = 0x42A;
pub const ERROR_PROCESS_ABORTED: u32 = 0x42B;
pub const ERROR_SERVICE_DEPENDENCY_FAIL: u32 = 0x42C;
pub const ERROR_SERVICE_LOGON_FAILED: u32 = 0x42D;
pub const ERROR_SERVICE_START_HANG: u32 = 0x42E;
pub const ERROR_INVALID_SERVICE_LOCK: u32 = 0x42F;
pub const ERROR_SERVICE_MARKED_FOR_DELETE: u32 = 0x430;
pub const ERROR_SERVICE_EXISTS: u32 = 0x431;
pub const ERROR_ALREADY_RUNNING_LKG: u32 = 0x432;
pub const ERROR_SERVICE_DEPENDENCY_DELETED: u32 = 0x433;
pub const ERROR_BOOT_ALREADY_ACCEPTED: u32 = 0x434;
pub const ERROR_SERVICE_NEVER_STARTED: u32 = 0x435;
pub const ERROR_DUPLICATE_SERVICE_NAME: u32 = 0x436;
pub const ERROR_DIFFERENT_SERVICE_ACCOUNT: u32 = 0x437;
pub const ERROR_CANNOT_DETECT_DRIVER_FAILURE: u32 = 0x438;
pub const ERROR_CANNOT_DETECT_PROCESS_ABORT: u32 = 0x439;
pub const ERROR_NO_RECOVERY_PROGRAM: u32 = 0x43A;
pub const ERROR_SERVICE_NOT_IN_EXE: u32 = 0x43B;
pub const ERROR_NOT_SAFEBOOT_SERVICE: u32 = 0x43C;
pub const ERROR_END_OF_MEDIA: u32 = 0x44C;
pub const ERROR_FILEMARK_DETECTED: u32 = 0x44D;
pub const ERROR_BEGINNING_OF_MEDIA: u32 = 0x44E;
pub const ERROR_SETMARK_DETECTED: u32 = 0x44F;
pub const ERROR_NO_DATA_DETECTED: u32 = 0x450;
pub const ERROR_PARTITION_FAILURE: u32 = 0x451;
pub const ERROR_INVALID_BLOCK_LENGTH: u32 = 0x452;
pub const ERROR_DEVICE_NOT_PARTITIONED: u32 = 0x453;
pub const ERROR_UNABLE_TO_LOCK_MEDIA: u32 = 0x454;
pub const ERROR_UNABLE_TO_UNLOAD_MEDIA: u32 = 0x455;
pub const ERROR_MEDIA_CHANGED: u32 = 0x456;
pub const ERROR_BUS_RESET: u32 = 0x457;
pub const ERROR_NO_MEDIA_IN_DRIVE: u32 = 0x458;
pub const ERROR_NO_UNICODE_TRANSLATION: u32 = 0x459;
pub const ERROR_DLL_INIT_FAILED: u32 = 0x45A;
pub const ERROR_SHUTDOWN_IN_PROGRESS: u32 = 0x45B;
pub const ERROR_NO_SHUTDOWN_IN_PROGRESS: u32 = 0x45C;
pub const ERROR_IO_DEVICE: u32 = 0x45D;
pub const ERROR_SERIAL_NO_DEVICE: u32 = 0x45E;
pub const ERROR_IRQ_BUSY: u32 = 0x45F;
pub const ERROR_MORE_WRITES: u32 = 0x460;
pub const ERROR_COUNTER_TIMEOUT: u32 = 0x461;
pub const ERROR_FLOPPY_ID_MARK_NOT_FOUND: u32 = 0x462;
pub const ERROR_FLOPPY_WRONG_CYLINDER: u32 = 0x463;
pub const ERROR_FLOPPY_UNKNOWN_ERROR: u32 = 0x464;
pub const ERROR_FLOPPY_BAD_REGISTERS: u32 = 0x465;
pub const ERROR_DISK_RECALIBRATE_FAILED: u32 = 0x466;
pub const ERROR_DISK_OPERATION_FAILED: u32 = 0x467;
pub const ERROR_DISK_RESET_FAILED: u32 = 0x468;
pub const ERROR_EOM_OVERFLOW: u32 = 0x469;
pub const ERROR_NOT_ENOUGH_SERVER_MEMORY: u32 = 0x46A;
pub const ERROR_POSSIBLE_DEADLOCK: u32 = 0x46B;
pub const ERROR_MAPPED_ALIGNMENT: u32 = 0x46C;
pub const ERROR_SET_POWER_STATE_VETOED: u32 = 0x474;
pub const ERROR_SET_POWER_STATE_FAILED: u32 = 0x475;
pub const ERROR_TOO_MANY_LINKS: u32 = 0x476;
pub const ERROR_OLD_WIN_VERSION: u32 = 0x47E;
pub const ERROR_APP_WRONG_OS: u32 = 0x47F;
pub const ERROR_SINGLE_INSTANCE_APP: u32 = 0x480;
pub const ERROR_RMODE_APP: u32 = 0x481;
pub const ERROR_INVALID_DLL: u32 = 0x482;
pub const ERROR_NO_ASSOCIATION: u32 = 0x483;
pub const ERROR_DDE_FAIL: u32 = 0x484;
pub const ERROR_DLL_NOT_FOUND: u32 = 0x485;
pub const ERROR_NO_MORE_USER_HANDLES: u32 = 0x486;
pub const ERROR_MESSAGE_SYNC_ONLY: u32 = 0x487;
pub const ERROR_SOURCE_ELEMENT_EMPTY: u32 = 0x488;
pub const ERROR_DESTINATION_ELEMENT_FULL: u32 = 0x489;
pub const ERROR_ILLEGAL_ELEMENT_ADDRESS: u32 = 0x48A;
pub const ERROR_MAGAZINE_NOT_PRESENT: u32 = 0x48B;
pub const ERROR_DEVICE_REINITIALIZATION_NEEDED: u32 = 0x48C;
pub const ERROR_DEVICE_REQUIRES_CLEANING: u32 = 0x48D;
pub const ERROR_DEVICE_DOOR_OPEN: u32 = 0x48E;
pub const ERROR_DEVICE_NOT_CONNECTED: u32 = 0x48F;
pub const ERROR_NOT_FOUND: u32 = 0x490;
pub const ERROR_NO_MATCH: u32 = 0x491;
pub const ERROR_SET_NOT_FOUND: u32 = 0x492;
pub const ERROR_POINT_NOT_FOUND: u32 = 0x493;
pub const ERROR_NO_TRACKING_SERVICE: u32 = 0x494;
pub const ERROR_NO_VOLUME_ID: u32 = 0x495;
pub const ERROR_UNABLE_TO_REMOVE_REPLACED: u32 = 0x497;
pub const ERROR_UNABLE_TO_MOVE_REPLACEMENT: u32 = 0x498;
pub const ERROR_UNABLE_TO_MOVE_REPLACEMENT_2: u32 = 0x499;
pub const ERROR_JOURNAL_DELETE_IN_PROGRESS: u32 = 0x49A;
pub const ERROR_JOURNAL_NOT_ACTIVE: u32 = 0x49B;
pub const ERROR_POTENTIAL_FILE_FOUND: u32 = 0x49C;
pub const ERROR_JOURNAL_ENTRY_DELETED: u32 = 0x49D;
pub const ERROR_PARTITION_TERMINATING: u32 = 0x4A0;
pub const ERROR_SHUTDOWN_IS_SCHEDULED: u32 = 0x4A6;
pub const ERROR_SHUTDOWN_USERS_LOGGED_ON: u32 = 0x4A7;
pub const ERROR_SHUTDOWN_DISKS_NOT_IN_MAINTENANCE_MODE: u32 = 0x4A8;
pub const ERROR_BAD_DEVICE: u32 = 0x4B0;
pub const ERROR_CONNECTION_UNAVAIL: u32 = 0x4B1;
pub const ERROR_DEVICE_ALREADY_REMEMBERED: u32 = 0x4B2;
pub const ERROR_NO_NET_OR_BAD_PATH: u32 = 0x4B3;
pub const ERROR_BAD_PROVIDER: u32 = 0x4B4;
pub const ERROR_CANNOT_OPEN_PROFILE: u32 = 0x4B5;
pub const ERROR_BAD_PROFILE: u32 = 0x4B6;
pub const ERROR_NOT_CONTAINER: u32 = 0x4B7;
pub const ERROR_EXTENDED_ERROR: u32 = 0x4B8;
pub const ERROR_INVALID_GROUPNAME: u32 = 0x4B9;
pub const ERROR_INVALID_COMPUTERNAME: u32 = 0x4BA;
pub const ERROR_INVALID_EVENTNAME: u32 = 0x4BB;
pub const ERROR_INVALID_DOMAINNAME: u32 = 0x4BC;
pub const ERROR_INVALID_SERVICENAME: u32 = 0x4BD;
pub const ERROR_INVALID_NETNAME: u32 = 0x4BE;
pub const ERROR_INVALID_SHARENAME: u32 = 0x4BF;
pub const ERROR_INVALID_PASSWORDNAME: u32 = 0x4C0;
pub const ERROR_INVALID_MESSAGENAME: u32 = 0x4C1;
pub const ERROR_INVALID_MESSAGEDEST: u32 = 0x4C2;
pub const ERROR_SESSION_CREDENTIAL_CONFLICT: u32 = 0x4C3;
pub const ERROR_REMOTE_SESSION_LIMIT_EXCEEDED: u32 = 0x4C4;
pub const ERROR_DUP_DOMAINNAME: u32 = 0x4C5;
pub const ERROR_NO_NETWORK: u32 = 0x4C6;
pub const ERROR_CANCELLED: u32 = 0x4C7;
pub const ERROR_USER_MAPPED_FILE: u32 = 0x4C8;
pub const ERROR_CONNECTION_REFUSED: u32 = 0x4C9;
pub const ERROR_GRACEFUL_DISCONNECT: u32 = 0x4CA;
pub const ERROR_ADDRESS_ALREADY_ASSOCIATED: u32 = 0x4CB;
pub const ERROR_ADDRESS_NOT_ASSOCIATED: u32 = 0x4CC;
pub const ERROR_CONNECTION_INVALID: u32 = 0x4CD;
pub const ERROR_CONNECTION_ACTIVE: u32 = 0x4CE;
pub const ERROR_NETWORK_UNREACHABLE: u32 = 0x4CF;
pub const ERROR_HOST_UNREACHABLE: u32 = 0x4D0;
pub const ERROR_PROTOCOL_UNREACHABLE: u32 = 0x4D1;
pub const ERROR_PORT_UNREACHABLE: u32 = 0x4D2;
pub const ERROR_REQUEST_ABORTED: u32 = 0x4D3;
pub const ERROR_CONNECTION_ABORTED: u32 = 0x4D4;
pub const ERROR_RETRY: u32 = 0x4D5;
pub const ERROR_CONNECTION_COUNT_LIMIT: u32 = 0x4D6;
pub const ERROR_LOGIN_TIME_RESTRICTION: u32 = 0x4D7;
pub const ERROR_LOGIN_WKSTA_RESTRICTION: u32 = 0x4D8;
pub const ERROR_INCORRECT_ADDRESS: u32 = 0x4D9;
pub const ERROR_ALREADY_REGISTERED: u32 = 0x4DA;
pub const ERROR_SERVICE_NOT_FOUND: u32 = 0x4DB;
pub const ERROR_NOT_AUTHENTICATED: u32 = 0x4DC;
pub const ERROR_NOT_LOGGED_ON: u32 = 0x4DD;
pub const ERROR_CONTINUE: u32 = 0x4DE;
pub const ERROR_ALREADY_INITIALIZED: u32 = 0x4DF;
pub const ERROR_NO_MORE_DEVICES: u32 = 0x4E0;
pub const ERROR_NO_SUCH_SITE: u32 = 0x4E1;
pub const ERROR_DOMAIN_CONTROLLER_EXISTS: u32 = 0x4E2;
pub const ERROR_ONLY_IF_CONNECTED: u32 = 0x4E3;
pub const ERROR_OVERRIDE_NOCHANGES: u32 = 0x4E4;
pub const ERROR_BAD_USER_PROFILE: u32 = 0x4E5;
pub const ERROR_NOT_SUPPORTED_ON_SBS: u32 = 0x4E6;
pub const ERROR_SERVER_SHUTDOWN_IN_PROGRESS: u32 = 0x4E7;
pub const ERROR_HOST_DOWN: u32 = 0x4E8;
pub const ERROR_NON_ACCOUNT_SID: u32 = 0x4E9;
pub const ERROR_NON_DOMAIN_SID: u32 = 0x4EA;
pub const ERROR_APPHELP_BLOCK: u32 = 0x4EB;
pub const ERROR_ACCESS_DISABLED_BY_POLICY: u32 = 0x4EC;
pub const ERROR_REG_NAT_CONSUMPTION: u32 = 0x4ED;
pub const ERROR_CSCSHARE_OFFLINE: u32 = 0x4EE;
pub const ERROR_PKINIT_FAILURE: u32 = 0x4EF;
pub const ERROR_SMARTCARD_SUBSYSTEM_FAILURE: u32 = 0x4F0;
pub const ERROR_DOWNGRADE_DETECTED: u32 = 0x4F1;
pub const ERROR_MACHINE_LOCKED: u32 = 0x4F7;
pub const ERROR_SMB_GUEST_LOGON_BLOCKED: u32 = 0x4F8;
pub const ERROR_CALLBACK_SUPPLIED_INVALID_DATA: u32 = 0x4F9;
pub const ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED: u32 = 0x4FA;
pub const ERROR_DRIVER_BLOCKED: u32 = 0x4FB;
pub const ERROR_INVALID_IMPORT_OF_NON_DLL: u32 = 0x4FC;
pub const ERROR_ACCESS_DISABLED_WEBBLADE: u32 = 0x4FD;
pub const ERROR_ACCESS_DISABLED_WEBBLADE_TAMPER: u32 = 0x4FE;
pub const ERROR_RECOVERY_FAILURE: u32 = 0x4FF;
pub const ERROR_ALREADY_FIBER: u32 = 0x500;
pub const ERROR_ALREADY_THREAD: u32 = 0x501;
pub const ERROR_STACK_BUFFER_OVERRUN: u32 = 0x502;
pub const ERROR_PARAMETER_QUOTA_EXCEEDED: u32 = 0x503;
pub const ERROR_DEBUGGER_INACTIVE: u32 = 0x504;
pub const ERROR_DELAY_LOAD_FAILED: u32 = 0x505;
pub const ERROR_VDM_DISALLOWED: u32 = 0x506;
pub const ERROR_UNIDENTIFIED_ERROR: u32 = 0x507;
pub const ERROR_INVALID_CRUNTIME_PARAMETER: u32 = 0x508;
pub const ERROR_BEYOND_VDL: u32 = 0x509;
pub const ERROR_INCOMPATIBLE_SERVICE_SID_TYPE: u32 = 0x50A;
pub const ERROR_DRIVER_PROCESS_TERMINATED: u32 = 0x50B;
pub const ERROR_IMPLEMENTATION_LIMIT: u32 = 0x50C;
pub const ERROR_PROCESS_IS_PROTECTED: u32 = 0x50D;
pub const ERROR_SERVICE_NOTIFY_CLIENT_LAGGING: u32 = 0x50E;
pub const ERROR_DISK_QUOTA_EXCEEDED: u32 = 0x50F;
pub const ERROR_CONTENT_BLOCKED: u32 = 0x510;
pub const ERROR_INCOMPATIBLE_SERVICE_PRIVILEGE: u32 = 0x511;
pub const ERROR_APP_HANG: u32 = 0x512;
pub const ERROR_INVALID_LABEL: u32 = 0x513;
pub const ERROR_NOT_ALL_ASSIGNED: u32 = 0x514;
pub const ERROR_SOME_NOT_MAPPED: u32 = 0x515;
pub const ERROR_NO_QUOTAS_FOR_ACCOUNT: u32 = 0x516;
pub const ERROR_LOCAL_USER_SESSION_KEY: u32 = 0x517;
pub const ERROR_NULL_LM_PASSWORD: u32 = 0x518;
pub const ERROR_UNKNOWN_REVISION: u32 = 0x519;
pub const ERROR_REVISION_MISMATCH: u32 = 0x51A;
pub const ERROR_INVALID_OWNER: u32 = 0x51B;
pub const ERROR_INVALID_PRIMARY_GROUP: u32 = 0x51C;
pub const ERROR_NO_IMPERSONATION_TOKEN: u32 = 0x51D;
pub const ERROR_CANT_DISABLE_MANDATORY: u32 = 0x51E;
pub const ERROR_NO_LOGON_SERVERS: u32 = 0x51F;
pub const ERROR_NO_SUCH_LOGON_SESSION: u32 = 0x520;
pub const ERROR_NO_SUCH_PRIVILEGE: u32 = 0x521;
pub const ERROR_PRIVILEGE_NOT_HELD: u32 = 0x522;
pub const ERROR_INVALID_ACCOUNT_NAME: u32 = 0x523;
pub const ERROR_USER_EXISTS: u32 = 0x524;
pub const ERROR_NO_SUCH_USER: u32 = 0x525;
pub const ERROR_GROUP_EXISTS: u32 = 0x526;
pub const ERROR_NO_SUCH_GROUP: u32 = 0x527;
pub const ERROR_MEMBER_IN_GROUP: u32 = 0x528;
pub const ERROR_MEMBER_NOT_IN_GROUP: u32 = 0x529;
pub const ERROR_LAST_ADMIN: u32 = 0x52A;
pub const ERROR_WRONG_PASSWORD: u32 = 0x52B;
pub const ERROR_ILL_FORMED_PASSWORD: u32 = 0x52C;
pub const ERROR_PASSWORD_RESTRICTION: u32 = 0x52D;
pub const ERROR_LOGON_FAILURE: u32 = 0x52E;
pub const ERROR_ACCOUNT_RESTRICTION: u32 = 0x52F;
pub const ERROR_INVALID_LOGON_HOURS: u32 = 0x530;
pub const ERROR_INVALID_WORKSTATION: u32 = 0x531;
pub const ERROR_PASSWORD_EXPIRED: u32 = 0x532;
pub const ERROR_ACCOUNT_DISABLED: u32 = 0x533;
pub const ERROR_NONE_MAPPED: u32 = 0x534;
pub const ERROR_TOO_MANY_LUIDS_REQUESTED: u32 = 0x535;
pub const ERROR_LUIDS_EXHAUSTED: u32 = 0x536;
pub const ERROR_INVALID_SUB_AUTHORITY: u32 = 0x537;
pub const ERROR_INVALID_ACL: u32 = 0x538;
pub const ERROR_INVALID_SID: u32 = 0x539;
pub const ERROR_INVALID_SECURITY_DESCR: u32 = 0x53A;
pub const ERROR_BAD_INHERITANCE_ACL: u32 = 0x53C;
pub const ERROR_SERVER_DISABLED: u32 = 0x53D;
pub const ERROR_SERVER_NOT_DISABLED: u32 = 0x53E;
pub const ERROR_INVALID_ID_AUTHORITY: u32 = 0x53F;
pub const ERROR_ALLOTTED_SPACE_EXCEEDED: u32 = 0x540;
pub const ERROR_INVALID_GROUP_ATTRIBUTES: u32 = 0x541;
pub const ERROR_BAD_IMPERSONATION_LEVEL: u32 = 0x542;
pub const ERROR_CANT_OPEN_ANONYMOUS: u32 = 0x543;
pub const ERROR_BAD_VALIDATION_CLASS: u32 = 0x544;
pub const ERROR_BAD_TOKEN_TYPE: u32 = 0x545;
pub const ERROR_NO_SECURITY_ON_OBJECT: u32 = 0x546;
pub const ERROR_CANT_ACCESS_DOMAIN_INFO: u32 = 0x547;
pub const ERROR_INVALID_SERVER_STATE: u32 = 0x548;
pub const ERROR_INVALID_DOMAIN_STATE: u32 = 0x549;
pub const ERROR_INVALID_DOMAIN_ROLE: u32 = 0x54A;
pub const ERROR_NO_SUCH_DOMAIN: u32 = 0x54B;
pub const ERROR_DOMAIN_EXISTS: u32 = 0x54C;
pub const ERROR_DOMAIN_LIMIT_EXCEEDED: u32 = 0x54D;
pub const ERROR_INTERNAL_DB_CORRUPTION: u32 = 0x54E;
pub const ERROR_INTERNAL_ERROR: u32 = 0x54F;
pub const ERROR_GENERIC_NOT_MAPPED: u32 = 0x550;
pub const ERROR_BAD_DESCRIPTOR_FORMAT: u32 = 0x551;
pub const ERROR_NOT_LOGON_PROCESS: u32 = 0x552;
pub const ERROR_LOGON_SESSION_EXISTS: u32 = 0x553;
pub const ERROR_NO_SUCH_PACKAGE: u32 = 0x554;
pub const ERROR_BAD_LOGON_SESSION_STATE: u32 = 0x555;
pub const ERROR_LOGON_SESSION_COLLISION: u32 = 0x556;
pub const ERROR_INVALID_LOGON_TYPE: u32 = 0x557;
pub const ERROR_CANNOT_IMPERSONATE: u32 = 0x558;
pub const ERROR_RXACT_INVALID_STATE: u32 = 0x559;
pub const ERROR_RXACT_COMMIT_FAILURE: u32 = 0x55A;
pub const ERROR_SPECIAL_ACCOUNT: u32 = 0x55B;
pub const ERROR_SPECIAL_GROUP: u32 = 0x55C;
pub const ERROR_SPECIAL_USER: u32 = 0x55D;
pub const ERROR_MEMBERS_PRIMARY_GROUP: u32 = 0x55E;
pub const ERROR_TOKEN_ALREADY_IN_USE: u32 = 0x55F;
pub const ERROR_NO_SUCH_ALIAS: u32 = 0x560;
pub const ERROR_MEMBER_NOT_IN_ALIAS: u32 = 0x561;
pub const ERROR_MEMBER_IN_ALIAS: u32 = 0x562;
pub const ERROR_ALIAS_EXISTS: u32 = 0x563;
pub const ERROR_LOGON_NOT_GRANTED: u32 = 0x564;
pub const ERROR_TOO_MANY_SECRETS: u32 = 0x565;
pub const ERROR_SECRET_TOO_LONG: u32 = 0x566;
pub const ERROR_INTERNAL_DB_ERROR: u32 = 0x567;
pub const ERROR_TOO_MANY_CONTEXT_IDS: u32 = 0x568;
pub const ERROR_LOGON_TYPE_NOT_GRANTED: u32 = 0x569;
pub const ERROR_NT_CROSS_ENCRYPTION_REQUIRED: u32 = 0x56A;
pub const ERROR_NO_SUCH_MEMBER: u32 = 0x56B;
pub const ERROR_INVALID_MEMBER: u32 = 0x56C;
pub const ERROR_TOO_MANY_SIDS: u32 = 0x56D;
pub const ERROR_LM_CROSS_ENCRYPTION_REQUIRED: u32 = 0x56E;
pub const ERROR_NO_INHERITANCE: u32 = 0x56F;
pub const ERROR_FILE_CORRUPT: u32 = 0x570;
pub const ERROR_DISK_CORRUPT: u32 = 0x571;
pub const ERROR_NO_USER_SESSION_KEY: u32 = 0x572;
pub const ERROR_LICENSE_QUOTA_EXCEEDED: u32 = 0x573;
pub const ERROR_WRONG_TARGET_NAME: u32 = 0x574;
pub const ERROR_MUTUAL_AUTH_FAILED: u32 = 0x575;
pub const ERROR_TIME_SKEW: u32 = 0x576;
pub const ERROR_CURRENT_DOMAIN_NOT_ALLOWED: u32 = 0x577;
pub const ERROR_INVALID_WINDOW_HANDLE: u32 = 0x578;
pub const ERROR_INVALID_MENU_HANDLE: u32 = 0x579;
pub const ERROR_INVALID_CURSOR_HANDLE: u32 = 0x57A;
pub const ERROR_INVALID_ACCEL_HANDLE: u32 = 0x57B;
pub const ERROR_INVALID_HOOK_HANDLE: u32 = 0x57C;
pub const ERROR_INVALID_DWP_HANDLE: u32 = 0x57D;
pub const ERROR_TLW_WITH_WSCHILD: u32 = 0x57E;
pub const ERROR_CANNOT_FIND_WND_CLASS: u32 = 0x57F;
pub const ERROR_WINDOW_OF_OTHER_THREAD: u32 = 0x580;
pub const ERROR_HOTKEY_ALREADY_REGISTERED: u32 = 0x581;
pub const ERROR_CLASS_ALREADY_EXISTS: u32 = 0x582;
pub const ERROR_CLASS_DOES_NOT_EXIST: u32 = 0x583;
pub const ERROR_CLASS_HAS_WINDOWS: u32 = 0x584;
pub const ERROR_INVALID_INDEX: u32 = 0x585;
pub const ERROR_INVALID_ICON_HANDLE: u32 = 0x586;
pub const ERROR_PRIVATE_DIALOG_INDEX: u32 = 0x587;
pub const ERROR_LISTBOX_ID_NOT_FOUND: u32 = 0x588;
pub const ERROR_NO_WILDCARD_CHARACTERS: u32 = 0x589;
pub const ERROR_CLIPBOARD_NOT_OPEN: u32 = 0x58A;
pub const ERROR_HOTKEY_NOT_REGISTERED: u32 = 0x58B;
pub const ERROR_WINDOW_NOT_DIALOG: u32 = 0x58C;
pub const ERROR_CONTROL_ID_NOT_FOUND: u32 = 0x58D;
pub const ERROR_INVALID_COMBOBOX_MESSAGE: u32 = 0x58E;
pub const ERROR_WINDOW_NOT_COMBOBOX: u32 = 0x58F;
pub const ERROR_INVALID_EDIT_HEIGHT: u32 = 0x590;
pub const ERROR_DC_NOT_FOUND: u32 = 0x591;
pub const ERROR_INVALID_HOOK_FILTER: u32 = 0x592;
pub const ERROR_INVALID_FILTER_PROC: u32 = 0x593;
pub const ERROR_HOOK_NEEDS_HMOD: u32 = 0x594;
pub const ERROR_GLOBAL_ONLY_HOOK: u32 = 0x595;
pub const ERROR_JOURNAL_HOOK_SET: u32 = 0x596;
pub const ERROR_HOOK_NOT_INSTALLED: u32 = 0x597;
pub const ERROR_INVALID_LB_MESSAGE: u32 = 0x598;
pub const ERROR_SETCOUNT_ON_BAD_LB: u32 = 0x599;
pub const ERROR_LB_WITHOUT_TABSTOPS: u32 = 0x59A;
pub const ERROR_DESTROY_OBJECT_OF_OTHER_THREAD: u32 = 0x59B;
pub const ERROR_CHILD_WINDOW_MENU: u32 = 0x59C;
pub const ERROR_NO_SYSTEM_MENU: u32 = 0x59D;
pub const ERROR_INVALID_MSGBOX_STYLE: u32 = 0x59E;
pub const ERROR_INVALID_SPI_VALUE: u32 = 0x59F;
pub const ERROR_SCREEN_ALREADY_LOCKED: u32 = 0x5A0;
pub const ERROR_HWNDS_HAVE_DIFF_PARENT: u32 = 0x5A1;
pub const ERROR_NOT_CHILD_WINDOW: u32 = 0x5A2;
pub const ERROR_INVALID_GW_COMMAND: u32 = 0x5A3;
pub const ERROR_INVALID_THREAD_ID: u32 = 0x5A4;
pub const ERROR_NON_MDICHILD_WINDOW: u32 = 0x5A5;
pub const ERROR_POPUP_ALREADY_ACTIVE: u32 = 0x5A6;
pub const ERROR_NO_SCROLLBARS: u32 = 0x5A7;
pub const ERROR_INVALID_SCROLLBAR_RANGE: u32 = 0x5A8;
pub const ERROR_INVALID_SHOWWIN_COMMAND: u32 = 0x5A9;
pub const ERROR_NO_SYSTEM_RESOURCES: u32 = 0x5AA;
pub const ERROR_NONPAGED_SYSTEM_RESOURCES: u32 = 0x5AB;
pub const ERROR_PAGED_SYSTEM_RESOURCES: u32 = 0x5AC;
pub const ERROR_WORKING_SET_QUOTA: u32 = 0x5AD;
pub const ERROR_PAGEFILE_QUOTA: u32 = 0x5AE;
pub const ERROR_COMMITMENT_LIMIT: u32 = 0x5AF;
pub const ERROR_MENU_ITEM_NOT_FOUND: u32 = 0x5B0;
pub const ERROR_INVALID_KEYBOARD_HANDLE: u32 = 0x5B1;
pub const ERROR_HOOK_TYPE_NOT_ALLOWED: u32 = 0x5B2;
pub const ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION: u32 = 0x5B3;
pub const ERROR_TIMEOUT: u32 = 0x5B4;
pub const ERROR_INVALID_MONITOR_HANDLE: u32 = 0x5B5;
pub const ERROR_INCORRECT_SIZE: u32 = 0x5B6;
pub const ERROR_SYMLINK_CLASS_DISABLED: u32 = 0x5B7;
pub const ERROR_SYMLINK_NOT_SUPPORTED: u32 = 0x5B8;
pub const ERROR_XML_PARSE_ERROR: u32 = 0x5B9;
pub const ERROR_XMLDSIG_ERROR: u32 = 0x5BA;
pub const ERROR_RESTART_APPLICATION: u32 = 0x5BB;
pub const ERROR_WRONG_COMPARTMENT: u32 = 0x5BC;
pub const ERROR_AUTHIP_FAILURE: u32 = 0x5BD;
pub const ERROR_NO_NVRAM_RESOURCES: u32 = 0x5BE;
pub const ERROR_NOT_GUI_PROCESS: u32 = 0x5BF;
pub const ERROR_EVENTLOG_FILE_CORRUPT: u32 = 0x5DC;
pub const ERROR_EVENTLOG_CANT_START: u32 = 0x5DD;
pub const ERROR_LOG_FILE_FULL: u32 = 0x5DE;
pub const ERROR_EVENTLOG_FILE_CHANGED: u32 = 0x5DF;
pub const ERROR_CONTAINER_ASSIGNED: u32 = 0x5E0;
pub const ERROR_JOB_NO_CONTAINER: u32 = 0x5E1;
pub const ERROR_INVALID_TASK_NAME: u32 = 0x60E;
pub const ERROR_INVALID_TASK_INDEX: u32 = 0x60F;
pub const ERROR_THREAD_ALREADY_IN_TASK: u32 = 0x610;
pub const ERROR_INSTALL_SERVICE_FAILURE: u32 = 0x641;
pub const ERROR_INSTALL_USEREXIT: u32 = 0x642;
pub const ERROR_INSTALL_FAILURE: u32 = 0x643;
pub const ERROR_INSTALL_SUSPEND: u32 = 0x644;
pub const ERROR_UNKNOWN_PRODUCT: u32 = 0x645;
pub const ERROR_UNKNOWN_FEATURE: u32 = 0x646;
pub const ERROR_UNKNOWN_COMPONENT: u32 = 0x647;
pub const ERROR_UNKNOWN_PROPERTY: u32 = 0x648;
pub const ERROR_INVALID_HANDLE_STATE: u32 = 0x649;
pub const ERROR_BAD_CONFIGURATION: u32 = 0x64A;
pub const ERROR_INDEX_ABSENT: u32 = 0x64B;
pub const ERROR_INSTALL_SOURCE_ABSENT: u32 = 0x64C;
pub const ERROR_INSTALL_PACKAGE_VERSION: u32 = 0x64D;
pub const ERROR_PRODUCT_UNINSTALLED: u32 = 0x64E;
pub const ERROR_BAD_QUERY_SYNTAX: u32 = 0x64F;
pub const ERROR_INVALID_FIELD: u32 = 0x650;
pub const ERROR_DEVICE_REMOVED: u32 = 0x651;
pub const ERROR_INSTALL_ALREADY_RUNNING: u32 = 0x652;
pub const ERROR_INSTALL_PACKAGE_OPEN_FAILED: u32 = 0x653;
pub const ERROR_INSTALL_PACKAGE_INVALID: u32 = 0x654;
pub const ERROR_INSTALL_UI_FAILURE: u32 = 0x655;
pub const ERROR_INSTALL_LOG_FAILURE: u32 = 0x656;
pub const ERROR_INSTALL_LANGUAGE_UNSUPPORTED: u32 = 0x657;
pub const ERROR_INSTALL_TRANSFORM_FAILURE: u32 = 0x658;
pub const ERROR_INSTALL_PACKAGE_REJECTED: u32 = 0x659;
pub const ERROR_FUNCTION_NOT_CALLED: u32 = 0x65A;
pub const ERROR_FUNCTION_FAILED: u32 = 0x65B;
pub const ERROR_INVALID_TABLE: u32 = 0x65C;
pub const ERROR_DATATYPE_MISMATCH: u32 = 0x65D;
pub const ERROR_UNSUPPORTED_TYPE: u32 = 0x65E;
pub const ERROR_CREATE_FAILED: u32 = 0x65F;
pub const ERROR_INSTALL_TEMP_UNWRITABLE: u32 = 0x660;
pub const ERROR_INSTALL_PLATFORM_UNSUPPORTED: u32 = 0x661;
pub const ERROR_INSTALL_NOTUSED: u32 = 0x662;
pub const ERROR_PATCH_PACKAGE_OPEN_FAILED: u32 = 0x663;
pub const ERROR_PATCH_PACKAGE_INVALID: u32 = 0x664;
pub const ERROR_PATCH_PACKAGE_UNSUPPORTED: u32 = 0x665;
pub const ERROR_PRODUCT_VERSION: u32 = 0x666;
pub const ERROR_INVALID_COMMAND_LINE: u32 = 0x667;
pub const ERROR_INSTALL_REMOTE_DISALLOWED: u32 = 0x668;
pub const ERROR_SUCCESS_REBOOT_INITIATED: u32 = 0x669;
pub const ERROR_PATCH_TARGET_NOT_FOUND: u32 = 0x66A;
pub const ERROR_PATCH_PACKAGE_REJECTED: u32 = 0x66B;
pub const ERROR_INSTALL_TRANSFORM_REJECTED: u32 = 0x66C;
pub const ERROR_INSTALL_REMOTE_PROHIBITED: u32 = 0x66D;
pub const ERROR_PATCH_REMOVAL_UNSUPPORTED: u32 = 0x66E;
pub const ERROR_UNKNOWN_PATCH: u32 = 0x66F;
pub const ERROR_PATCH_NO_SEQUENCE: u32 = 0x670;
pub const ERROR_PATCH_REMOVAL_DISALLOWED: u32 = 0x671;
pub const ERROR_INVALID_PATCH_XML: u32 = 0x672;
pub const ERROR_PATCH_MANAGED_ADVERTISED_PRODUCT: u32 = 0x673;
pub const ERROR_INSTALL_SERVICE_SAFEBOOT: u32 = 0x674;
pub const ERROR_FAIL_FAST_EXCEPTION: u32 = 0x675;
pub const ERROR_INSTALL_REJECTED: u32 = 0x676;
pub const ERROR_DYNAMIC_CODE_BLOCKED: u32 = 0x677;
pub const ERROR_NOT_SAME_OBJECT: u32 = 0x678;
pub const ERROR_STRICT_CFG_VIOLATION: u32 = 0x679;
pub const ERROR_SET_CONTEXT_DENIED: u32 = 0x67C;
pub const ERROR_CROSS_PARTITION_VIOLATION: u32 = 0x67D;
pub const ERROR_RETURN_ADDRESS_HIJACK_ATTEMPT: u32 = 0x67E;
pub const ERROR_INVALID_USER_BUFFER: u32 = 0x6F8;
pub const ERROR_UNRECOGNIZED_MEDIA: u32 = 0x6F9;
pub const ERROR_NO_TRUST_LSA_SECRET: u32 = 0x6FA;
pub const ERROR_NO_TRUST_SAM_ACCOUNT: u32 = 0x6FB;
pub const ERROR_TRUSTED_DOMAIN_FAILURE: u32 = 0x6FC;
pub const ERROR_TRUSTED_RELATIONSHIP_FAILURE: u32 = 0x6FD;
pub const ERROR_TRUST_FAILURE: u32 = 0x6FE;
pub const ERROR_NETLOGON_NOT_STARTED: u32 = 0x700;
pub const ERROR_ACCOUNT_EXPIRED: u32 = 0x701;
pub const ERROR_REDIRECTOR_HAS_OPEN_HANDLES: u32 = 0x702;
pub const ERROR_PRINTER_DRIVER_ALREADY_INSTALLED: u32 = 0x703;
pub const ERROR_UNKNOWN_PORT: u32 = 0x704;
pub const ERROR_UNKNOWN_PRINTER_DRIVER: u32 = 0x705;
pub const ERROR_UNKNOWN_PRINTPROCESSOR: u32 = 0x706;
pub const ERROR_INVALID_SEPARATOR_FILE: u32 = 0x707;
pub const ERROR_INVALID_PRIORITY: u32 = 0x708;
pub const ERROR_INVALID_PRINTER_NAME: u32 = 0x709;
pub const ERROR_PRINTER_ALREADY_EXISTS: u32 = 0x70A;
pub const ERROR_INVALID_PRINTER_COMMAND: u32 = 0x70B;
pub const ERROR_INVALID_DATATYPE: u32 = 0x70C;
pub const ERROR_INVALID_ENVIRONMENT: u32 = 0x70D;
pub const ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT: u32 = 0x70F;
pub const ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT: u32 = 0x710;
pub const ERROR_NOLOGON_SERVER_TRUST_ACCOUNT: u32 = 0x711;
pub const ERROR_DOMAIN_TRUST_INCONSISTENT: u32 = 0x712;
pub const ERROR_SERVER_HAS_OPEN_HANDLES: u32 = 0x713;
pub const ERROR_RESOURCE_DATA_NOT_FOUND: u32 = 0x714;
pub const ERROR_RESOURCE_TYPE_NOT_FOUND: u32 = 0x715;
pub const ERROR_RESOURCE_NAME_NOT_FOUND: u32 = 0x716;
pub const ERROR_RESOURCE_LANG_NOT_FOUND: u32 = 0x717;
pub const ERROR_NOT_ENOUGH_QUOTA: u32 = 0x718;
pub const ERROR_INVALID_TIME: u32 = 0x76D;
pub const ERROR_INVALID_FORM_NAME: u32 = 0x76E;
pub const ERROR_INVALID_FORM_SIZE: u32 = 0x76F;
pub const ERROR_ALREADY_WAITING: u32 = 0x770;
pub const ERROR_PRINTER_DELETED: u32 = 0x771;
pub const ERROR_INVALID_PRINTER_STATE: u32 = 0x772;
pub const ERROR_PASSWORD_MUST_CHANGE: u32 = 0x773;
pub const ERROR_DOMAIN_CONTROLLER_NOT_FOUND: u32 = 0x774;
pub const ERROR_ACCOUNT_LOCKED_OUT: u32 = 0x775;
pub const ERROR_NO_SITENAME: u32 = 0x77F;
pub const ERROR_CANT_ACCESS_FILE: u32 = 0x780;
pub const ERROR_CANT_RESOLVE_FILENAME: u32 = 0x781;
pub const ERROR_KM_DRIVER_BLOCKED: u32 = 0x78A;
pub const ERROR_CONTEXT_EXPIRED: u32 = 0x78B;
pub const ERROR_PER_USER_TRUST_QUOTA_EXCEEDED: u32 = 0x78C;
pub const ERROR_ALL_USER_TRUST_QUOTA_EXCEEDED: u32 = 0x78D;
pub const ERROR_USER_DELETE_TRUST_QUOTA_EXCEEDED: u32 = 0x78E;
pub const ERROR_AUTHENTICATION_FIREWALL_FAILED: u32 = 0x78F;
pub const ERROR_REMOTE_PRINT_CONNECTIONS_BLOCKED: u32 = 0x790;
pub const ERROR_NTLM_BLOCKED: u32 = 0x791;
pub const ERROR_PASSWORD_CHANGE_REQUIRED: u32 = 0x792;
pub const ERROR_LOST_MODE_LOGON_RESTRICTION: u32 = 0x793;
pub const ERROR_INVALID_PIXEL_FORMAT: u32 = 0x7D0;
pub const ERROR_BAD_DRIVER: u32 = 0x7D1;
pub const ERROR_INVALID_WINDOW_STYLE: u32 = 0x7D2;
pub const ERROR_METAFILE_NOT_SUPPORTED: u32 = 0x7D3;
pub const ERROR_TRANSFORM_NOT_SUPPORTED: u32 = 0x7D4;
pub const ERROR_CLIPPING_NOT_SUPPORTED: u32 = 0x7D5;
pub const ERROR_INVALID_CMM: u32 = 0x7DA;
pub const ERROR_INVALID_PROFILE: u32 = 0x7DB;
pub const ERROR_TAG_NOT_FOUND: u32 = 0x7DC;
pub const ERROR_TAG_NOT_PRESENT: u32 = 0x7DD;
pub const ERROR_DUPLICATE_TAG: u32 = 0x7DE;
pub const ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE: u32 = 0x7DF;
pub const ERROR_PROFILE_NOT_FOUND: u32 = 0x7E0;
pub const ERROR_INVALID_COLORSPACE: u32 = 0x7E1;
pub const ERROR_ICM_NOT_ENABLED: u32 = 0x7E2;
pub const ERROR_DELETING_ICM_XFORM: u32 = 0x7E3;
pub const ERROR_INVALID_TRANSFORM: u32 = 0x7E4;
pub const ERROR_COLORSPACE_MISMATCH: u32 = 0x7E5;
pub const ERROR_INVALID_COLORINDEX: u32 = 0x7E6;
pub const ERROR_PROFILE_DOES_NOT_MATCH_DEVICE: u32 = 0x7E7;
pub const ERROR_CONNECTED_OTHER_PASSWORD: u32 = 0x83C;
pub const ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT: u32 = 0x83D;
pub const ERROR_BAD_USERNAME: u32 = 0x89A;
pub const ERROR_NOT_CONNECTED: u32 = 0x8CA;
pub const ERROR_OPEN_FILES: u32 = 0x961;
pub const ERROR_ACTIVE_CONNECTIONS: u32 = 0x962;
pub const ERROR_DEVICE_IN_USE: u32 = 0x964;
pub const ERROR_UNKNOWN_PRINT_MONITOR: u32 = 0xBB8;
pub const ERROR_PRINTER_DRIVER_IN_USE: u32 = 0xBB9;
pub const ERROR_SPOOL_FILE_NOT_FOUND: u32 = 0xBBA;
pub const ERROR_SPL_NO_STARTDOC: u32 = 0xBBB;
pub const ERROR_SPL_NO_ADDJOB: u32 = 0xBBC;
pub const ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED: u32 = 0xBBD;
pub const ERROR_PRINT_MONITOR_ALREADY_INSTALLED: u32 = 0xBBE;
pub const ERROR_INVALID_PRINT_MONITOR: u32 = 0xBBF;
pub const ERROR_PRINT_MONITOR_IN_USE: u32 = 0xBC0;
pub const ERROR_PRINTER_HAS_JOBS_QUEUED: u32 = 0xBC1;
pub const ERROR_SUCCESS_REBOOT_REQUIRED: u32 = 0xBC2;
pub const ERROR_SUCCESS_RESTART_REQUIRED: u32 = 0xBC3;
pub const ERROR_PRINTER_NOT_FOUND: u32 = 0xBC4;
pub const ERROR_PRINTER_DRIVER_WARNED: u32 = 0xBC5;
pub const ERROR_PRINTER_DRIVER_BLOCKED: u32 = 0xBC6;
pub const ERROR_PRINTER_DRIVER_PACKAGE_IN_USE: u32 = 0xBC7;
pub const ERROR_CORE_DRIVER_PACKAGE_NOT_FOUND: u32 = 0xBC8;
pub const ERROR_FAIL_REBOOT_REQUIRED: u32 = 0xBC9;
pub const ERROR_FAIL_REBOOT_INITIATED: u32 = 0xBCA;
pub const ERROR_PRINTER_DRIVER_DOWNLOAD_NEEDED: u32 = 0xBCB;
pub const ERROR_PRINT_JOB_RESTART_REQUIRED: u32 = 0xBCC;
pub const ERROR_INVALID_PRINTER_DRIVER_MANIFEST: u32 = 0xBCD;
pub const ERROR_PRINTER_NOT_SHAREABLE: u32 = 0xBCE;
pub const ERROR_REQUEST_PAUSED: u32 = 0xBEA;
pub const ERROR_APPEXEC_CONDITION_NOT_SATISFIED: u32 = 0xBF4;
pub const ERROR_APPEXEC_HANDLE_INVALIDATED: u32 = 0xBF5;
pub const ERROR_APPEXEC_INVALID_HOST_GENERATION: u32 = 0xBF6;
pub const ERROR_APPEXEC_UNEXPECTED_PROCESS_REGISTRATION: u32 = 0xBF7;
pub const ERROR_APPEXEC_INVALID_HOST_STATE: u32 = 0xBF8;
pub const ERROR_APPEXEC_NO_DONOR: u32 = 0xBF9;
pub const ERROR_APPEXEC_HOST_ID_MISMATCH: u32 = 0xBFA;
pub const ERROR_APPEXEC_UNKNOWN_USER: u32 = 0xBFB;
pub const ERROR_APPEXEC_APP_COMPAT_BLOCK: u32 = 0xBFC;
pub const ERROR_APPEXEC_CALLER_WAIT_TIMEOUT: u32 = 0xBFD;
pub const ERROR_APPEXEC_CALLER_WAIT_TIMEOUT_TERMINATION: u32 = 0xBFE;
pub const ERROR_APPEXEC_CALLER_WAIT_TIMEOUT_LICENSING: u32 = 0xBFF;
pub const ERROR_APPEXEC_CALLER_WAIT_TIMEOUT_RESOURCES: u32 = 0xC00;
pub const ERROR_VRF_VOLATILE_CFG_AND_IO_ENABLED: u32 = 0xC08;
pub const ERROR_VRF_VOLATILE_NOT_STOPPABLE: u32 = 0xC09;
pub const ERROR_VRF_VOLATILE_SAFE_MODE: u32 = 0xC0A;
pub const ERROR_VRF_VOLATILE_NOT_RUNNABLE_SYSTEM: u32 = 0xC0B;
pub const ERROR_VRF_VOLATILE_NOT_SUPPORTED_RULECLASS: u32 = 0xC0C;
pub const ERROR_VRF_VOLATILE_PROTECTED_DRIVER: u32 = 0xC0D;
pub const ERROR_VRF_VOLATILE_NMI_REGISTERED: u32 = 0xC0E;
pub const ERROR_VRF_VOLATILE_SETTINGS_CONFLICT: u32 = 0xC0F;
pub const ERROR_DIF_IOCALLBACK_NOT_REPLACED: u32 = 0xC76;
pub const ERROR_DIF_LIVEDUMP_LIMIT_EXCEEDED: u32 = 0xC77;
pub const ERROR_DIF_VOLATILE_SECTION_NOT_LOCKED: u32 = 0xC78;
pub const ERROR_DIF_VOLATILE_DRIVER_HOTPATCHED: u32 = 0xC79;
pub const ERROR_DIF_VOLATILE_INVALID_INFO: u32 = 0xC7A;
pub const ERROR_DIF_VOLATILE_DRIVER_IS_NOT_RUNNING: u32 = 0xC7B;
pub const ERROR_DIF_VOLATILE_PLUGIN_IS_NOT_RUNNING: u32 = 0xC7C;
pub const ERROR_DIF_VOLATILE_PLUGIN_CHANGE_NOT_ALLOWED: u32 = 0xC7D;
pub const ERROR_DIF_VOLATILE_NOT_ALLOWED: u32 = 0xC7E;
pub const ERROR_DIF_BINDING_API_NOT_FOUND: u32 = 0xC7F;
pub const ERROR_IO_REISSUE_AS_CACHED: u32 = 0xF6E;
pub const ERROR_WINS_INTERNAL: u32 = 0xFA0;
pub const ERROR_CAN_NOT_DEL_LOCAL_WINS: u32 = 0xFA1;
pub const ERROR_STATIC_INIT: u32 = 0xFA2;
pub const ERROR_INC_BACKUP: u32 = 0xFA3;
pub const ERROR_FULL_BACKUP: u32 = 0xFA4;
pub const ERROR_REC_NON_EXISTENT: u32 = 0xFA5;
pub const ERROR_RPL_NOT_ALLOWED: u32 = 0xFA6;
pub const ERROR_DHCP_ADDRESS_CONFLICT: u32 = 0x1004;
pub const ERROR_WMI_GUID_NOT_FOUND: u32 = 0x1068;
pub const ERROR_WMI_INSTANCE_NOT_FOUND: u32 = 0x1069;
pub const ERROR_WMI_ITEMID_NOT_FOUND: u32 = 0x106A;
pub const ERROR_WMI_TRY_AGAIN: u32 = 0x106B;
pub const ERROR_WMI_DP_NOT_FOUND: u32 = 0x106C;
pub const ERROR_WMI_UNRESOLVED_INSTANCE_REF: u32 = 0x106D;
pub const ERROR_WMI_ALREADY_ENABLED: u32 = 0x106E;
pub const ERROR_WMI_GUID_DISCONNECTED: u32 = 0x106F;
pub const ERROR_WMI_SERVER_UNAVAILABLE: u32 = 0x1070;
pub const ERROR_WMI_DP_FAILED: u32 = 0x1071;
pub const ERROR_WMI_INVALID_MOF: u32 = 0x1072;
pub const ERROR_WMI_INVALID_REGINFO: u32 = 0x1073;
pub const ERROR_WMI_ALREADY_DISABLED: u32 = 0x1074;
pub const ERROR_WMI_READ_ONLY: u32 = 0x1075;
pub const ERROR_WMI_SET_FAILURE: u32 = 0x1076;
pub const ERROR_NOT_APPCONTAINER: u32 = 0x109A;
pub const ERROR_APPCONTAINER_REQUIRED: u32 = 0x109B;
pub const ERROR_NOT_SUPPORTED_IN_APPCONTAINER: u32 = 0x109C;
pub const ERROR_INVALID_PACKAGE_SID_LENGTH: u32 = 0x109D;
pub const ERROR_INVALID_MEDIA: u32 = 0x10CC;
pub const ERROR_INVALID_LIBRARY: u32 = 0x10CD;
pub const ERROR_INVALID_MEDIA_POOL: u32 = 0x10CE;
pub const ERROR_DRIVE_MEDIA_MISMATCH: u32 = 0x10CF;
pub const ERROR_MEDIA_OFFLINE: u32 = 0x10D0;
pub const ERROR_LIBRARY_OFFLINE: u32 = 0x10D1;
pub const ERROR_EMPTY: u32 = 0x10D2;
pub const ERROR_NOT_EMPTY: u32 = 0x10D3;
pub const ERROR_MEDIA_UNAVAILABLE: u32 = 0x10D4;
pub const ERROR_RESOURCE_DISABLED: u32 = 0x10D5;
pub const ERROR_INVALID_CLEANER: u32 = 0x10D6;
pub const ERROR_UNABLE_TO_CLEAN: u32 = 0x10D7;
pub const ERROR_OBJECT_NOT_FOUND: u32 = 0x10D8;
pub const ERROR_DATABASE_FAILURE: u32 = 0x10D9;
pub const ERROR_DATABASE_FULL: u32 = 0x10DA;
pub const ERROR_MEDIA_INCOMPATIBLE: u32 = 0x10DB;
pub const ERROR_RESOURCE_NOT_PRESENT: u32 = 0x10DC;
pub const ERROR_INVALID_OPERATION: u32 = 0x10DD;
pub const ERROR_MEDIA_NOT_AVAILABLE: u32 = 0x10DE;
pub const ERROR_DEVICE_NOT_AVAILABLE: u32 = 0x10DF;
pub const ERROR_REQUEST_REFUSED: u32 = 0x10E0;
pub const ERROR_INVALID_DRIVE_OBJECT: u32 = 0x10E1;
pub const ERROR_LIBRARY_FULL: u32 = 0x10E2;
pub const ERROR_MEDIUM_NOT_ACCESSIBLE: u32 = 0x10E3;
pub const ERROR_UNABLE_TO_LOAD_MEDIUM: u32 = 0x10E4;
pub const ERROR_UNABLE_TO_INVENTORY_DRIVE: u32 = 0x10E5;
pub const ERROR_UNABLE_TO_INVENTORY_SLOT: u32 = 0x10E6;
pub const ERROR_UNABLE_TO_INVENTORY_TRANSPORT: u32 = 0x10E7;
pub const ERROR_TRANSPORT_FULL: u32 = 0x10E8;
pub const ERROR_CONTROLLING_IEPORT: u32 = 0x10E9;
pub const ERROR_UNABLE_TO_EJECT_MOUNTED_MEDIA: u32 = 0x10EA;
pub const ERROR_CLEANER_SLOT_SET: u32 = 0x10EB;
pub const ERROR_CLEANER_SLOT_NOT_SET: u32 = 0x10EC;
pub const ERROR_CLEANER_CARTRIDGE_SPENT: u32 = 0x10ED;
pub const ERROR_UNEXPECTED_OMID: u32 = 0x10EE;
pub const ERROR_CANT_DELETE_LAST_ITEM: u32 = 0x10EF;
pub const ERROR_MESSAGE_EXCEEDS_MAX_SIZE: u32 = 0x10F0;
pub const ERROR_VOLUME_CONTAINS_SYS_FILES: u32 = 0x10F1;
pub const ERROR_INDIGENOUS_TYPE: u32 = 0x10F2;
pub const ERROR_NO_SUPPORTING_DRIVES: u32 = 0x10F3;
pub const ERROR_CLEANER_CARTRIDGE_INSTALLED: u32 = 0x10F4;
pub const ERROR_IEPORT_FULL: u32 = 0x10F5;
pub const ERROR_FILE_OFFLINE: u32 = 0x10FE;
pub const ERROR_REMOTE_STORAGE_NOT_ACTIVE: u32 = 0x10FF;
pub const ERROR_REMOTE_STORAGE_MEDIA_ERROR: u32 = 0x1100;
pub const ERROR_NOT_A_REPARSE_POINT: u32 = 0x1126;
pub const ERROR_REPARSE_ATTRIBUTE_CONFLICT: u32 = 0x1127;
pub const ERROR_INVALID_REPARSE_DATA: u32 = 0x1128;
pub const ERROR_REPARSE_TAG_INVALID: u32 = 0x1129;
pub const ERROR_REPARSE_TAG_MISMATCH: u32 = 0x112A;
pub const ERROR_REPARSE_POINT_ENCOUNTERED: u32 = 0x112B;
pub const ERROR_APP_DATA_NOT_FOUND: u32 = 0x1130;
pub const ERROR_APP_DATA_EXPIRED: u32 = 0x1131;
pub const ERROR_APP_DATA_CORRUPT: u32 = 0x1132;
pub const ERROR_APP_DATA_LIMIT_EXCEEDED: u32 = 0x1133;
pub const ERROR_APP_DATA_REBOOT_REQUIRED: u32 = 0x1134;
pub const ERROR_SECUREBOOT_ROLLBACK_DETECTED: u32 = 0x1144;
pub const ERROR_SECUREBOOT_POLICY_VIOLATION: u32 = 0x1145;
pub const ERROR_SECUREBOOT_INVALID_POLICY: u32 = 0x1146;
pub const ERROR_SECUREBOOT_POLICY_PUBLISHER_NOT_FOUND: u32 = 0x1147;
pub const ERROR_SECUREBOOT_POLICY_NOT_SIGNED: u32 = 0x1148;
pub const ERROR_SECUREBOOT_NOT_ENABLED: u32 = 0x1149;
pub const ERROR_SECUREBOOT_FILE_REPLACED: u32 = 0x114A;
pub const ERROR_SECUREBOOT_POLICY_NOT_AUTHORIZED: u32 = 0x114B;
pub const ERROR_SECUREBOOT_POLICY_UNKNOWN: u32 = 0x114C;
pub const ERROR_SECUREBOOT_POLICY_MISSING_ANTIROLLBACKVERSION: u32 = 0x114D;
pub const ERROR_SECUREBOOT_PLATFORM_ID_MISMATCH: u32 = 0x114E;
pub const ERROR_SECUREBOOT_POLICY_ROLLBACK_DETECTED: u32 = 0x114F;
pub const ERROR_SECUREBOOT_POLICY_UPGRADE_MISMATCH: u32 = 0x1150;
pub const ERROR_SECUREBOOT_REQUIRED_POLICY_FILE_MISSING: u32 = 0x1151;
pub const ERROR_SECUREBOOT_NOT_BASE_POLICY: u32 = 0x1152;
pub const ERROR_SECUREBOOT_NOT_SUPPLEMENTAL_POLICY: u32 = 0x1153;
pub const ERROR_OFFLOAD_READ_FLT_NOT_SUPPORTED: u32 = 0x1158;
pub const ERROR_OFFLOAD_WRITE_FLT_NOT_SUPPORTED: u32 = 0x1159;
pub const ERROR_OFFLOAD_READ_FILE_NOT_SUPPORTED: u32 = 0x115A;
pub const ERROR_OFFLOAD_WRITE_FILE_NOT_SUPPORTED: u32 = 0x115B;
pub const ERROR_ALREADY_HAS_STREAM_ID: u32 = 0x115C;
pub const ERROR_SMR_GARBAGE_COLLECTION_REQUIRED: u32 = 0x115D;
pub const ERROR_WOF_WIM_HEADER_CORRUPT: u32 = 0x115E;
pub const ERROR_WOF_WIM_RESOURCE_TABLE_CORRUPT: u32 = 0x115F;
pub const ERROR_WOF_FILE_RESOURCE_TABLE_CORRUPT: u32 = 0x1160;
pub const ERROR_OBJECT_IS_IMMUTABLE: u32 = 0x1161;
pub const ERROR_VOLUME_NOT_SIS_ENABLED: u32 = 0x1194;
pub const ERROR_SYSTEM_INTEGRITY_ROLLBACK_DETECTED: u32 = 0x11C6;
pub const ERROR_SYSTEM_INTEGRITY_POLICY_VIOLATION: u32 = 0x11C7;
pub const ERROR_SYSTEM_INTEGRITY_INVALID_POLICY: u32 = 0x11C8;
pub const ERROR_SYSTEM_INTEGRITY_POLICY_NOT_SIGNED: u32 = 0x11C9;
pub const ERROR_SYSTEM_INTEGRITY_TOO_MANY_POLICIES: u32 = 0x11CA;
pub const ERROR_SYSTEM_INTEGRITY_SUPPLEMENTAL_POLICY_NOT_AUTHORIZED: u32 = 0x11CB;
pub const ERROR_SYSTEM_INTEGRITY_REPUTATION_MALICIOUS: u32 = 0x11CC;
pub const ERROR_SYSTEM_INTEGRITY_REPUTATION_PUA: u32 = 0x11CD;
pub const ERROR_SYSTEM_INTEGRITY_REPUTATION_DANGEROUS_EXT: u32 = 0x11CE;
pub const ERROR_SYSTEM_INTEGRITY_REPUTATION_OFFLINE: u32 = 0x11CF;
pub const ERROR_VSM_NOT_INITIALIZED: u32 = 0x11D0;
pub const ERROR_VSM_DMA_PROTECTION_NOT_IN_USE: u32 = 0x11D1;
pub const ERROR_PLATFORM_MANIFEST_NOT_AUTHORIZED: u32 = 0x11DA;
pub const ERROR_PLATFORM_MANIFEST_INVALID: u32 = 0x11DB;
pub const ERROR_PLATFORM_MANIFEST_FILE_NOT_AUTHORIZED: u32 = 0x11DC;
pub const ERROR_PLATFORM_MANIFEST_CATALOG_NOT_AUTHORIZED: u32 = 0x11DD;
pub const ERROR_PLATFORM_MANIFEST_BINARY_ID_NOT_FOUND: u32 = 0x11DE;
pub const ERROR_PLATFORM_MANIFEST_NOT_ACTIVE: u32 = 0x11DF;
pub const ERROR_PLATFORM_MANIFEST_NOT_SIGNED: u32 = 0x11E0;
pub const ERROR_DEPENDENT_RESOURCE_EXISTS: u32 = 0x1389;
pub const ERROR_DEPENDENCY_NOT_FOUND: u32 = 0x138A;
pub const ERROR_DEPENDENCY_ALREADY_EXISTS: u32 = 0x138B;
pub const ERROR_RESOURCE_NOT_ONLINE: u32 = 0x138C;
pub const ERROR_HOST_NODE_NOT_AVAILABLE: u32 = 0x138D;
pub const ERROR_RESOURCE_NOT_AVAILABLE: u32 = 0x138E;
pub const ERROR_RESOURCE_NOT_FOUND: u32 = 0x138F;
pub const ERROR_SHUTDOWN_CLUSTER: u32 = 0x1390;
pub const ERROR_CANT_EVICT_ACTIVE_NODE: u32 = 0x1391;
pub const ERROR_OBJECT_ALREADY_EXISTS: u32 = 0x1392;
pub const ERROR_OBJECT_IN_LIST: u32 = 0x1393;
pub const ERROR_GROUP_NOT_AVAILABLE: u32 = 0x1394;
pub const ERROR_GROUP_NOT_FOUND: u32 = 0x1395;
pub const ERROR_GROUP_NOT_ONLINE: u32 = 0x1396;
pub const ERROR_HOST_NODE_NOT_RESOURCE_OWNER: u32 = 0x1397;
pub const ERROR_HOST_NODE_NOT_GROUP_OWNER: u32 = 0x1398;
pub const ERROR_RESMON_CREATE_FAILED: u32 = 0x1399;
pub const ERROR_RESMON_ONLINE_FAILED: u32 = 0x139A;
pub const ERROR_RESOURCE_ONLINE: u32 = 0x139B;
pub const ERROR_QUORUM_RESOURCE: u32 = 0x139C;
pub const ERROR_NOT_QUORUM_CAPABLE: u32 = 0x139D;
pub const ERROR_CLUSTER_SHUTTING_DOWN: u32 = 0x139E;
pub const ERROR_INVALID_STATE: u32 = 0x139F;
pub const ERROR_RESOURCE_PROPERTIES_STORED: u32 = 0x13A0;
pub const ERROR_NOT_QUORUM_CLASS: u32 = 0x13A1;
pub const ERROR_CORE_RESOURCE: u32 = 0x13A2;
pub const ERROR_QUORUM_RESOURCE_ONLINE_FAILED: u32 = 0x13A3;
pub const ERROR_QUORUMLOG_OPEN_FAILED: u32 = 0x13A4;
pub const ERROR_CLUSTERLOG_CORRUPT: u32 = 0x13A5;
pub const ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE: u32 = 0x13A6;
pub const ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE: u32 = 0x13A7;
pub const ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND: u32 = 0x13A8;
pub const ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE: u32 = 0x13A9;
pub const ERROR_QUORUM_OWNER_ALIVE: u32 = 0x13AA;
pub const ERROR_NETWORK_NOT_AVAILABLE: u32 = 0x13AB;
pub const ERROR_NODE_NOT_AVAILABLE: u32 = 0x13AC;
pub const ERROR_ALL_NODES_NOT_AVAILABLE: u32 = 0x13AD;
pub const ERROR_RESOURCE_FAILED: u32 = 0x13AE;
pub const ERROR_CLUSTER_INVALID_NODE: u32 = 0x13AF;
pub const ERROR_CLUSTER_NODE_EXISTS: u32 = 0x13B0;
pub const ERROR_CLUSTER_JOIN_IN_PROGRESS: u32 = 0x13B1;
pub const ERROR_CLUSTER_NODE_NOT_FOUND: u32 = 0x13B2;
pub const ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND: u32 = 0x13B3;
pub const ERROR_CLUSTER_NETWORK_EXISTS: u32 = 0x13B4;
pub const ERROR_CLUSTER_NETWORK_NOT_FOUND: u32 = 0x13B5;
pub const ERROR_CLUSTER_NETINTERFACE_EXISTS: u32 = 0x13B6;
pub const ERROR_CLUSTER_NETINTERFACE_NOT_FOUND: u32 = 0x13B7;
pub const ERROR_CLUSTER_INVALID_REQUEST: u32 = 0x13B8;
pub const ERROR_CLUSTER_INVALID_NETWORK_PROVIDER: u32 = 0x13B9;
pub const ERROR_CLUSTER_NODE_DOWN: u32 = 0x13BA;
pub const ERROR_CLUSTER_NODE_UNREACHABLE: u32 = 0x13BB;
pub const ERROR_CLUSTER_NODE_NOT_MEMBER: u32 = 0x13BC;
pub const ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS: u32 = 0x13BD;
pub const ERROR_CLUSTER_INVALID_NETWORK: u32 = 0x13BE;
pub const ERROR_CLUSTER_NODE_UP: u32 = 0x13C0;
pub const ERROR_CLUSTER_IPADDR_IN_USE: u32 = 0x13C1;
pub const ERROR_CLUSTER_NODE_NOT_PAUSED: u32 = 0x13C2;
pub const ERROR_CLUSTER_NO_SECURITY_CONTEXT: u32 = 0x13C3;
pub const ERROR_CLUSTER_NETWORK_NOT_INTERNAL: u32 = 0x13C4;
pub const ERROR_CLUSTER_NODE_ALREADY_UP: u32 = 0x13C5;
pub const ERROR_CLUSTER_NODE_ALREADY_DOWN: u32 = 0x13C6;
pub const ERROR_CLUSTER_NETWORK_ALREADY_ONLINE: u32 = 0x13C7;
pub const ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE: u32 = 0x13C8;
pub const ERROR_CLUSTER_NODE_ALREADY_MEMBER: u32 = 0x13C9;
pub const ERROR_CLUSTER_LAST_INTERNAL_NETWORK: u32 = 0x13CA;
pub const ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS: u32 = 0x13CB;
pub const ERROR_INVALID_OPERATION_ON_QUORUM: u32 = 0x13CC;
pub const ERROR_DEPENDENCY_NOT_ALLOWED: u32 = 0x13CD;
pub const ERROR_CLUSTER_NODE_PAUSED: u32 = 0x13CE;
pub const ERROR_NODE_CANT_HOST_RESOURCE: u32 = 0x13CF;
pub const ERROR_CLUSTER_NODE_NOT_READY: u32 = 0x13D0;
pub const ERROR_CLUSTER_NODE_SHUTTING_DOWN: u32 = 0x13D1;
pub const ERROR_CLUSTER_JOIN_ABORTED: u32 = 0x13D2;
pub const ERROR_CLUSTER_INCOMPATIBLE_VERSIONS: u32 = 0x13D3;
pub const ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED: u32 = 0x13D4;
pub const ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED: u32 = 0x13D5;
pub const ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND: u32 = 0x13D6;
pub const ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED: u32 = 0x13D7;
pub const ERROR_CLUSTER_RESNAME_NOT_FOUND: u32 = 0x13D8;
pub const ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED: u32 = 0x13D9;
pub const ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST: u32 = 0x13DA;
pub const ERROR_CLUSTER_DATABASE_SEQMISMATCH: u32 = 0x13DB;
pub const ERROR_RESMON_INVALID_STATE: u32 = 0x13DC;
pub const ERROR_CLUSTER_GUM_NOT_LOCKER: u32 = 0x13DD;
pub const ERROR_QUORUM_DISK_NOT_FOUND: u32 = 0x13DE;
pub const ERROR_DATABASE_BACKUP_CORRUPT: u32 = 0x13DF;
pub const ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT: u32 = 0x13E0;
pub const ERROR_RESOURCE_PROPERTY_UNCHANGEABLE: u32 = 0x13E1;
pub const ERROR_NO_ADMIN_ACCESS_POINT: u32 = 0x13E2;
pub const ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE: u32 = 0x1702;
pub const ERROR_CLUSTER_QUORUMLOG_NOT_FOUND: u32 = 0x1703;
pub const ERROR_CLUSTER_MEMBERSHIP_HALT: u32 = 0x1704;
pub const ERROR_CLUSTER_INSTANCE_ID_MISMATCH: u32 = 0x1705;
pub const ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP: u32 = 0x1706;
pub const ERROR_CLUSTER_PROPERTY_DATA_TYPE_MISMATCH: u32 = 0x1707;
pub const ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP: u32 = 0x1708;
pub const ERROR_CLUSTER_PARAMETER_MISMATCH: u32 = 0x1709;
pub const ERROR_NODE_CANNOT_BE_CLUSTERED: u32 = 0x170A;
pub const ERROR_CLUSTER_WRONG_OS_VERSION: u32 = 0x170B;
pub const ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME: u32 = 0x170C;
pub const ERROR_CLUSCFG_ALREADY_COMMITTED: u32 = 0x170D;
pub const ERROR_CLUSCFG_ROLLBACK_FAILED: u32 = 0x170E;
pub const ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT: u32 = 0x170F;
pub const ERROR_CLUSTER_OLD_VERSION: u32 = 0x1710;
pub const ERROR_CLUSTER_MISMATCHED_COMPUTER_ACCT_NAME: u32 = 0x1711;
pub const ERROR_CLUSTER_NO_NET_ADAPTERS: u32 = 0x1712;
pub const ERROR_CLUSTER_POISONED: u32 = 0x1713;
pub const ERROR_CLUSTER_GROUP_MOVING: u32 = 0x1714;
pub const ERROR_CLUSTER_RESOURCE_TYPE_BUSY: u32 = 0x1715;
pub const ERROR_RESOURCE_CALL_TIMED_OUT: u32 = 0x1716;
pub const ERROR_INVALID_CLUSTER_IPV6_ADDRESS: u32 = 0x1717;
pub const ERROR_CLUSTER_INTERNAL_INVALID_FUNCTION: u32 = 0x1718;
pub const ERROR_CLUSTER_PARAMETER_OUT_OF_BOUNDS: u32 = 0x1719;
pub const ERROR_CLUSTER_PARTIAL_SEND: u32 = 0x171A;
pub const ERROR_CLUSTER_REGISTRY_INVALID_FUNCTION: u32 = 0x171B;
pub const ERROR_CLUSTER_INVALID_STRING_TERMINATION: u32 = 0x171C;
pub const ERROR_CLUSTER_INVALID_STRING_FORMAT: u32 = 0x171D;
pub const ERROR_CLUSTER_DATABASE_TRANSACTION_IN_PROGRESS: u32 = 0x171E;
pub const ERROR_CLUSTER_DATABASE_TRANSACTION_NOT_IN_PROGRESS: u32 = 0x171F;
pub const ERROR_CLUSTER_NULL_DATA: u32 = 0x1720;
pub const ERROR_CLUSTER_PARTIAL_READ: u32 = 0x1721;
pub const ERROR_CLUSTER_PARTIAL_WRITE: u32 = 0x1722;
pub const ERROR_CLUSTER_CANT_DESERIALIZE_DATA: u32 = 0x1723;
pub const ERROR_DEPENDENT_RESOURCE_PROPERTY_CONFLICT: u32 = 0x1724;
pub const ERROR_CLUSTER_NO_QUORUM: u32 = 0x1725;
pub const ERROR_CLUSTER_INVALID_IPV6_NETWORK: u32 = 0x1726;
pub const ERROR_CLUSTER_INVALID_IPV6_TUNNEL_NETWORK: u32 = 0x1727;
pub const ERROR_QUORUM_NOT_ALLOWED_IN_THIS_GROUP: u32 = 0x1728;
pub const ERROR_DEPENDENCY_TREE_TOO_COMPLEX: u32 = 0x1729;
pub const ERROR_EXCEPTION_IN_RESOURCE_CALL: u32 = 0x172A;
pub const ERROR_CLUSTER_RHS_FAILED_INITIALIZATION: u32 = 0x172B;
pub const ERROR_CLUSTER_NOT_INSTALLED: u32 = 0x172C;
pub const ERROR_CLUSTER_RESOURCES_MUST_BE_ONLINE_ON_THE_SAME_NODE: u32 = 0x172D;
pub const ERROR_CLUSTER_MAX_NODES_IN_CLUSTER: u32 = 0x172E;
pub const ERROR_CLUSTER_TOO_MANY_NODES: u32 = 0x172F;
pub const ERROR_CLUSTER_OBJECT_ALREADY_USED: u32 = 0x1730;
pub const ERROR_NONCORE_GROUPS_FOUND: u32 = 0x1731;
pub const ERROR_FILE_SHARE_RESOURCE_CONFLICT: u32 = 0x1732;
pub const ERROR_CLUSTER_EVICT_INVALID_REQUEST: u32 = 0x1733;
pub const ERROR_CLUSTER_SINGLETON_RESOURCE: u32 = 0x1734;
pub const ERROR_CLUSTER_GROUP_SINGLETON_RESOURCE: u32 = 0x1735;
pub const ERROR_CLUSTER_RESOURCE_PROVIDER_FAILED: u32 = 0x1736;
pub const ERROR_CLUSTER_RESOURCE_CONFIGURATION_ERROR: u32 = 0x1737;
pub const ERROR_CLUSTER_GROUP_BUSY: u32 = 0x1738;
pub const ERROR_CLUSTER_NOT_SHARED_VOLUME: u32 = 0x1739;
pub const ERROR_CLUSTER_INVALID_SECURITY_DESCRIPTOR: u32 = 0x173A;
pub const ERROR_CLUSTER_SHARED_VOLUMES_IN_USE: u32 = 0x173B;
pub const ERROR_CLUSTER_USE_SHARED_VOLUMES_API: u32 = 0x173C;
pub const ERROR_CLUSTER_BACKUP_IN_PROGRESS: u32 = 0x173D;
pub const ERROR_NON_CSV_PATH: u32 = 0x173E;
pub const ERROR_CSV_VOLUME_NOT_LOCAL: u32 = 0x173F;
pub const ERROR_CLUSTER_WATCHDOG_TERMINATING: u32 = 0x1740;
pub const ERROR_CLUSTER_RESOURCE_VETOED_MOVE_INCOMPATIBLE_NODES: u32 = 0x1741;
pub const ERROR_CLUSTER_INVALID_NODE_WEIGHT: u32 = 0x1742;
pub const ERROR_CLUSTER_RESOURCE_VETOED_CALL: u32 = 0x1743;
pub const ERROR_RESMON_SYSTEM_RESOURCES_LACKING: u32 = 0x1744;
pub const ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_DESTINATION: u32 = 0x1745;
pub const ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_SOURCE: u32 = 0x1746;
pub const ERROR_CLUSTER_GROUP_QUEUED: u32 = 0x1747;
pub const ERROR_CLUSTER_RESOURCE_LOCKED_STATUS: u32 = 0x1748;
pub const ERROR_CLUSTER_SHARED_VOLUME_FAILOVER_NOT_ALLOWED: u32 = 0x1749;
pub const ERROR_CLUSTER_NODE_DRAIN_IN_PROGRESS: u32 = 0x174A;
pub const ERROR_CLUSTER_DISK_NOT_CONNECTED: u32 = 0x174B;
pub const ERROR_DISK_NOT_CSV_CAPABLE: u32 = 0x174C;
pub const ERROR_RESOURCE_NOT_IN_AVAILABLE_STORAGE: u32 = 0x174D;
pub const ERROR_CLUSTER_SHARED_VOLUME_REDIRECTED: u32 = 0x174E;
pub const ERROR_CLUSTER_SHARED_VOLUME_NOT_REDIRECTED: u32 = 0x174F;
pub const ERROR_CLUSTER_CANNOT_RETURN_PROPERTIES: u32 = 0x1750;
pub const ERROR_CLUSTER_RESOURCE_CONTAINS_UNSUPPORTED_DIFF_AREA_FOR_SHARED_VOLUMES: u32 = 0x1751;
pub const ERROR_CLUSTER_RESOURCE_IS_IN_MAINTENANCE_MODE: u32 = 0x1752;
pub const ERROR_CLUSTER_AFFINITY_CONFLICT: u32 = 0x1753;
pub const ERROR_CLUSTER_RESOURCE_IS_REPLICA_VIRTUAL_MACHINE: u32 = 0x1754;
pub const ERROR_CLUSTER_UPGRADE_INCOMPATIBLE_VERSIONS: u32 = 0x1755;
pub const ERROR_CLUSTER_UPGRADE_FIX_QUORUM_NOT_SUPPORTED: u32 = 0x1756;
pub const ERROR_CLUSTER_UPGRADE_RESTART_REQUIRED: u32 = 0x1757;
pub const ERROR_CLUSTER_UPGRADE_IN_PROGRESS: u32 = 0x1758;
pub const ERROR_CLUSTER_UPGRADE_INCOMPLETE: u32 = 0x1759;
pub const ERROR_CLUSTER_NODE_IN_GRACE_PERIOD: u32 = 0x175A;
pub const ERROR_CLUSTER_CSV_IO_PAUSE_TIMEOUT: u32 = 0x175B;
pub const ERROR_NODE_NOT_ACTIVE_CLUSTER_MEMBER: u32 = 0x175C;
pub const ERROR_CLUSTER_RESOURCE_NOT_MONITORED: u32 = 0x175D;
pub const ERROR_CLUSTER_RESOURCE_DOES_NOT_SUPPORT_UNMONITORED: u32 = 0x175E;
pub const ERROR_CLUSTER_RESOURCE_IS_REPLICATED: u32 = 0x175F;
pub const ERROR_CLUSTER_NODE_ISOLATED: u32 = 0x1760;
pub const ERROR_CLUSTER_NODE_QUARANTINED: u32 = 0x1761;
pub const ERROR_CLUSTER_DATABASE_UPDATE_CONDITION_FAILED: u32 = 0x1762;
pub const ERROR_CLUSTER_SPACE_DEGRADED: u32 = 0x1763;
pub const ERROR_CLUSTER_TOKEN_DELEGATION_NOT_SUPPORTED: u32 = 0x1764;
pub const ERROR_CLUSTER_CSV_INVALID_HANDLE: u32 = 0x1765;
pub const ERROR_CLUSTER_CSV_SUPPORTED_ONLY_ON_COORDINATOR: u32 = 0x1766;
pub const ERROR_GROUPSET_NOT_AVAILABLE: u32 = 0x1767;
pub const ERROR_GROUPSET_NOT_FOUND: u32 = 0x1768;
pub const ERROR_GROUPSET_CANT_PROVIDE: u32 = 0x1769;
pub const ERROR_CLUSTER_FAULT_DOMAIN_PARENT_NOT_FOUND: u32 = 0x176A;
pub const ERROR_CLUSTER_FAULT_DOMAIN_INVALID_HIERARCHY: u32 = 0x176B;
pub const ERROR_CLUSTER_FAULT_DOMAIN_FAILED_S2D_VALIDATION: u32 = 0x176C;
pub const ERROR_CLUSTER_FAULT_DOMAIN_S2D_CONNECTIVITY_LOSS: u32 = 0x176D;
pub const ERROR_CLUSTER_INVALID_INFRASTRUCTURE_FILESERVER_NAME: u32 = 0x176E;
pub const ERROR_CLUSTERSET_MANAGEMENT_CLUSTER_UNREACHABLE: u32 = 0x176F;
pub const ERROR_ENCRYPTION_FAILED: u32 = 0x1770;
pub const ERROR_DECRYPTION_FAILED: u32 = 0x1771;
pub const ERROR_FILE_ENCRYPTED: u32 = 0x1772;
pub const ERROR_NO_RECOVERY_POLICY: u32 = 0x1773;
pub const ERROR_NO_EFS: u32 = 0x1774;
pub const ERROR_WRONG_EFS: u32 = 0x1775;
pub const ERROR_NO_USER_KEYS: u32 = 0x1776;
pub const ERROR_FILE_NOT_ENCRYPTED: u32 = 0x1777;
pub const ERROR_NOT_EXPORT_FORMAT: u32 = 0x1778;
pub const ERROR_FILE_READ_ONLY: u32 = 0x1779;
pub const ERROR_DIR_EFS_DISALLOWED: u32 = 0x177A;
pub const ERROR_EFS_SERVER_NOT_TRUSTED: u32 = 0x177B;
pub const ERROR_BAD_RECOVERY_POLICY: u32 = 0x177C;
pub const ERROR_EFS_ALG_BLOB_TOO_BIG: u32 = 0x177D;
pub const ERROR_VOLUME_NOT_SUPPORT_EFS: u32 = 0x177E;
pub const ERROR_EFS_DISABLED: u32 = 0x177F;
pub const ERROR_EFS_VERSION_NOT_SUPPORT: u32 = 0x1780;
pub const ERROR_CS_ENCRYPTION_INVALID_SERVER_RESPONSE: u32 = 0x1781;
pub const ERROR_CS_ENCRYPTION_UNSUPPORTED_SERVER: u32 = 0x1782;
pub const ERROR_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE: u32 = 0x1783;
pub const ERROR_CS_ENCRYPTION_NEW_ENCRYPTED_FILE: u32 = 0x1784;
pub const ERROR_CS_ENCRYPTION_FILE_NOT_CSE: u32 = 0x1785;
pub const ERROR_ENCRYPTION_POLICY_DENIES_OPERATION: u32 = 0x1786;
pub const ERROR_WIP_ENCRYPTION_FAILED: u32 = 0x1787;
pub const ERROR_NO_BROWSER_SERVERS_FOUND: u32 = 0x17E6;
pub const ERROR_CLUSTER_OBJECT_IS_CLUSTER_SET_VM: u32 = 0x186A;
pub const ERROR_LOG_SECTOR_INVALID: u32 = 0x19C8;
pub const ERROR_LOG_SECTOR_PARITY_INVALID: u32 = 0x19C9;
pub const ERROR_LOG_SECTOR_REMAPPED: u32 = 0x19CA;
pub const ERROR_LOG_BLOCK_INCOMPLETE: u32 = 0x19CB;
pub const ERROR_LOG_INVALID_RANGE: u32 = 0x19CC;
pub const ERROR_LOG_BLOCKS_EXHAUSTED: u32 = 0x19CD;
pub const ERROR_LOG_READ_CONTEXT_INVALID: u32 = 0x19CE;
pub const ERROR_LOG_RESTART_INVALID: u32 = 0x19CF;
pub const ERROR_LOG_BLOCK_VERSION: u32 = 0x19D0;
pub const ERROR_LOG_BLOCK_INVALID: u32 = 0x19D1;
pub const ERROR_LOG_READ_MODE_INVALID: u32 = 0x19D2;
pub const ERROR_LOG_NO_RESTART: u32 = 0x19D3;
pub const ERROR_LOG_METADATA_CORRUPT: u32 = 0x19D4;
pub const ERROR_LOG_METADATA_INVALID: u32 = 0x19D5;
pub const ERROR_LOG_METADATA_INCONSISTENT: u32 = 0x19D6;
pub const ERROR_LOG_RESERVATION_INVALID: u32 = 0x19D7;
pub const ERROR_LOG_CANT_DELETE: u32 = 0x19D8;
pub const ERROR_LOG_CONTAINER_LIMIT_EXCEEDED: u32 = 0x19D9;
pub const ERROR_LOG_START_OF_LOG: u32 = 0x19DA;
pub const ERROR_LOG_POLICY_ALREADY_INSTALLED: u32 = 0x19DB;
pub const ERROR_LOG_POLICY_NOT_INSTALLED: u32 = 0x19DC;
pub const ERROR_LOG_POLICY_INVALID: u32 = 0x19DD;
pub const ERROR_LOG_POLICY_CONFLICT: u32 = 0x19DE;
pub const ERROR_LOG_PINNED_ARCHIVE_TAIL: u32 = 0x19DF;
pub const ERROR_LOG_RECORD_NONEXISTENT: u32 = 0x19E0;
pub const ERROR_LOG_RECORDS_RESERVED_INVALID: u32 = 0x19E1;
pub const ERROR_LOG_SPACE_RESERVED_INVALID: u32 = 0x19E2;
pub const ERROR_LOG_TAIL_INVALID: u32 = 0x19E3;
pub const ERROR_LOG_FULL: u32 = 0x19E4;
pub const ERROR_COULD_NOT_RESIZE_LOG: u32 = 0x19E5;
pub const ERROR_LOG_MULTIPLEXED: u32 = 0x19E6;
pub const ERROR_LOG_DEDICATED: u32 = 0x19E7;
pub const ERROR_LOG_ARCHIVE_NOT_IN_PROGRESS: u32 = 0x19E8;
pub const ERROR_LOG_ARCHIVE_IN_PROGRESS: u32 = 0x19E9;
pub const ERROR_LOG_EPHEMERAL: u32 = 0x19EA;
pub const ERROR_LOG_NOT_ENOUGH_CONTAINERS: u32 = 0x19EB;
pub const ERROR_LOG_CLIENT_ALREADY_REGISTERED: u32 = 0x19EC;
pub const ERROR_LOG_CLIENT_NOT_REGISTERED: u32 = 0x19ED;
pub const ERROR_LOG_FULL_HANDLER_IN_PROGRESS: u32 = 0x19EE;
pub const ERROR_LOG_CONTAINER_READ_FAILED: u32 = 0x19EF;
pub const ERROR_LOG_CONTAINER_WRITE_FAILED: u32 = 0x19F0;
pub const ERROR_LOG_CONTAINER_OPEN_FAILED: u32 = 0x19F1;
pub const ERROR_LOG_CONTAINER_STATE_INVALID: u32 = 0x19F2;
pub const ERROR_LOG_STATE_INVALID: u32 = 0x19F3;
pub const ERROR_LOG_PINNED: u32 = 0x19F4;
pub const ERROR_LOG_METADATA_FLUSH_FAILED: u32 = 0x19F5;
pub const ERROR_LOG_INCONSISTENT_SECURITY: u32 = 0x19F6;
pub const ERROR_LOG_APPENDED_FLUSH_FAILED: u32 = 0x19F7;
pub const ERROR_LOG_PINNED_RESERVATION: u32 = 0x19F8;
pub const ERROR_INVALID_TRANSACTION: u32 = 0x1A2C;
pub const ERROR_TRANSACTION_NOT_ACTIVE: u32 = 0x1A2D;
pub const ERROR_TRANSACTION_REQUEST_NOT_VALID: u32 = 0x1A2E;
pub const ERROR_TRANSACTION_NOT_REQUESTED: u32 = 0x1A2F;
pub const ERROR_TRANSACTION_ALREADY_ABORTED: u32 = 0x1A30;
pub const ERROR_TRANSACTION_ALREADY_COMMITTED: u32 = 0x1A31;
pub const ERROR_TM_INITIALIZATION_FAILED: u32 = 0x1A32;
pub const ERROR_RESOURCEMANAGER_READ_ONLY: u32 = 0x1A33;
pub const ERROR_TRANSACTION_NOT_JOINED: u32 = 0x1A34;
pub const ERROR_TRANSACTION_SUPERIOR_EXISTS: u32 = 0x1A35;
pub const ERROR_CRM_PROTOCOL_ALREADY_EXISTS: u32 = 0x1A36;
pub const ERROR_TRANSACTION_PROPAGATION_FAILED: u32 = 0x1A37;
pub const ERROR_CRM_PROTOCOL_NOT_FOUND: u32 = 0x1A38;
pub const ERROR_TRANSACTION_INVALID_MARSHALL_BUFFER: u32 = 0x1A39;
pub const ERROR_CURRENT_TRANSACTION_NOT_VALID: u32 = 0x1A3A;
pub const ERROR_TRANSACTION_NOT_FOUND: u32 = 0x1A3B;
pub const ERROR_RESOURCEMANAGER_NOT_FOUND: u32 = 0x1A3C;
pub const ERROR_ENLISTMENT_NOT_FOUND: u32 = 0x1A3D;
pub const ERROR_TRANSACTIONMANAGER_NOT_FOUND: u32 = 0x1A3E;
pub const ERROR_TRANSACTIONMANAGER_NOT_ONLINE: u32 = 0x1A3F;
pub const ERROR_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION: u32 = 0x1A40;
pub const ERROR_TRANSACTION_NOT_ROOT: u32 = 0x1A41;
pub const ERROR_TRANSACTION_OBJECT_EXPIRED: u32 = 0x1A42;
pub const ERROR_TRANSACTION_RESPONSE_NOT_ENLISTED: u32 = 0x1A43;
pub const ERROR_TRANSACTION_RECORD_TOO_LONG: u32 = 0x1A44;
pub const ERROR_IMPLICIT_TRANSACTION_NOT_SUPPORTED: u32 = 0x1A45;
pub const ERROR_TRANSACTION_INTEGRITY_VIOLATED: u32 = 0x1A46;
pub const ERROR_TRANSACTIONMANAGER_IDENTITY_MISMATCH: u32 = 0x1A47;
pub const ERROR_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT: u32 = 0x1A48;
pub const ERROR_TRANSACTION_MUST_WRITETHROUGH: u32 = 0x1A49;
pub const ERROR_TRANSACTION_NO_SUPERIOR: u32 = 0x1A4A;
pub const ERROR_HEURISTIC_DAMAGE_POSSIBLE: u32 = 0x1A4B;
pub const ERROR_TRANSACTIONAL_CONFLICT: u32 = 0x1A90;
pub const ERROR_RM_NOT_ACTIVE: u32 = 0x1A91;
pub const ERROR_RM_METADATA_CORRUPT: u32 = 0x1A92;
pub const ERROR_DIRECTORY_NOT_RM: u32 = 0x1A93;
pub const ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE: u32 = 0x1A95;
pub const ERROR_LOG_RESIZE_INVALID_SIZE: u32 = 0x1A96;
pub const ERROR_OBJECT_NO_LONGER_EXISTS: u32 = 0x1A97;
pub const ERROR_STREAM_MINIVERSION_NOT_FOUND: u32 = 0x1A98;
pub const ERROR_STREAM_MINIVERSION_NOT_VALID: u32 = 0x1A99;
pub const ERROR_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION: u32 = 0x1A9A;
pub const ERROR_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT: u32 = 0x1A9B;
pub const ERROR_CANT_CREATE_MORE_STREAM_MINIVERSIONS: u32 = 0x1A9C;
pub const ERROR_REMOTE_FILE_VERSION_MISMATCH: u32 = 0x1A9E;
pub const ERROR_HANDLE_NO_LONGER_VALID: u32 = 0x1A9F;
pub const ERROR_NO_TXF_METADATA: u32 = 0x1AA0;
pub const ERROR_LOG_CORRUPTION_DETECTED: u32 = 0x1AA1;
pub const ERROR_CANT_RECOVER_WITH_HANDLE_OPEN: u32 = 0x1AA2;
pub const ERROR_RM_DISCONNECTED: u32 = 0x1AA3;
pub const ERROR_ENLISTMENT_NOT_SUPERIOR: u32 = 0x1AA4;
pub const ERROR_RECOVERY_NOT_NEEDED: u32 = 0x1AA5;
pub const ERROR_RM_ALREADY_STARTED: u32 = 0x1AA6;
pub const ERROR_FILE_IDENTITY_NOT_PERSISTENT: u32 = 0x1AA7;
pub const ERROR_CANT_BREAK_TRANSACTIONAL_DEPENDENCY: u32 = 0x1AA8;
pub const ERROR_CANT_CROSS_RM_BOUNDARY: u32 = 0x1AA9;
pub const ERROR_TXF_DIR_NOT_EMPTY: u32 = 0x1AAA;
pub const ERROR_INDOUBT_TRANSACTIONS_EXIST: u32 = 0x1AAB;
pub const ERROR_TM_VOLATILE: u32 = 0x1AAC;
pub const ERROR_ROLLBACK_TIMER_EXPIRED: u32 = 0x1AAD;
pub const ERROR_TXF_ATTRIBUTE_CORRUPT: u32 = 0x1AAE;
pub const ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION: u32 = 0x1AAF;
pub const ERROR_TRANSACTIONAL_OPEN_NOT_ALLOWED: u32 = 0x1AB0;
pub const ERROR_LOG_GROWTH_FAILED: u32 = 0x1AB1;
pub const ERROR_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE: u32 = 0x1AB2;
pub const ERROR_TXF_METADATA_ALREADY_PRESENT: u32 = 0x1AB3;
pub const ERROR_TRANSACTION_SCOPE_CALLBACKS_NOT_SET: u32 = 0x1AB4;
pub const ERROR_TRANSACTION_REQUIRED_PROMOTION: u32 = 0x1AB5;
pub const ERROR_CANNOT_EXECUTE_FILE_IN_TRANSACTION: u32 = 0x1AB6;
pub const ERROR_TRANSACTIONS_NOT_FROZEN: u32 = 0x1AB7;
pub const ERROR_TRANSACTION_FREEZE_IN_PROGRESS: u32 = 0x1AB8;
pub const ERROR_NOT_SNAPSHOT_VOLUME: u32 = 0x1AB9;
pub const ERROR_NO_SAVEPOINT_WITH_OPEN_FILES: u32 = 0x1ABA;
pub const ERROR_DATA_LOST_REPAIR: u32 = 0x1ABB;
pub const ERROR_SPARSE_NOT_ALLOWED_IN_TRANSACTION: u32 = 0x1ABC;
pub const ERROR_TM_IDENTITY_MISMATCH: u32 = 0x1ABD;
pub const ERROR_FLOATED_SECTION: u32 = 0x1ABE;
pub const ERROR_CANNOT_ACCEPT_TRANSACTED_WORK: u32 = 0x1ABF;
pub const ERROR_CANNOT_ABORT_TRANSACTIONS: u32 = 0x1AC0;
pub const ERROR_BAD_CLUSTERS: u32 = 0x1AC1;
pub const ERROR_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION: u32 = 0x1AC2;
pub const ERROR_VOLUME_DIRTY: u32 = 0x1AC3;
pub const ERROR_NO_LINK_TRACKING_IN_TRANSACTION: u32 = 0x1AC4;
pub const ERROR_OPERATION_NOT_SUPPORTED_IN_TRANSACTION: u32 = 0x1AC5;
pub const ERROR_EXPIRED_HANDLE: u32 = 0x1AC6;
pub const ERROR_TRANSACTION_NOT_ENLISTED: u32 = 0x1AC7;
pub const ERROR_CTX_WINSTATION_NAME_INVALID: u32 = 0x1B59;
pub const ERROR_CTX_INVALID_PD: u32 = 0x1B5A;
pub const ERROR_CTX_PD_NOT_FOUND: u32 = 0x1B5B;
pub const ERROR_CTX_WD_NOT_FOUND: u32 = 0x1B5C;
pub const ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY: u32 = 0x1B5D;
pub const ERROR_CTX_SERVICE_NAME_COLLISION: u32 = 0x1B5E;
pub const ERROR_CTX_CLOSE_PENDING: u32 = 0x1B5F;
pub const ERROR_CTX_NO_OUTBUF: u32 = 0x1B60;
pub const ERROR_CTX_MODEM_INF_NOT_FOUND: u32 = 0x1B61;
pub const ERROR_CTX_INVALID_MODEMNAME: u32 = 0x1B62;
pub const ERROR_CTX_MODEM_RESPONSE_ERROR: u32 = 0x1B63;
pub const ERROR_CTX_MODEM_RESPONSE_TIMEOUT: u32 = 0x1B64;
pub const ERROR_CTX_MODEM_RESPONSE_NO_CARRIER: u32 = 0x1B65;
pub const ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE: u32 = 0x1B66;
pub const ERROR_CTX_MODEM_RESPONSE_BUSY: u32 = 0x1B67;
pub const ERROR_CTX_MODEM_RESPONSE_VOICE: u32 = 0x1B68;
pub const ERROR_CTX_TD_ERROR: u32 = 0x1B69;
pub const ERROR_CTX_WINSTATION_NOT_FOUND: u32 = 0x1B6E;
pub const ERROR_CTX_WINSTATION_ALREADY_EXISTS: u32 = 0x1B6F;
pub const ERROR_CTX_WINSTATION_BUSY: u32 = 0x1B70;
pub const ERROR_CTX_BAD_VIDEO_MODE: u32 = 0x1B71;
pub const ERROR_CTX_GRAPHICS_INVALID: u32 = 0x1B7B;
pub const ERROR_CTX_LOGON_DISABLED: u32 = 0x1B7D;
pub const ERROR_CTX_NOT_CONSOLE: u32 = 0x1B7E;
pub const ERROR_CTX_CLIENT_QUERY_TIMEOUT: u32 = 0x1B80;
pub const ERROR_CTX_CONSOLE_DISCONNECT: u32 = 0x1B81;
pub const ERROR_CTX_CONSOLE_CONNECT: u32 = 0x1B82;
pub const ERROR_CTX_SHADOW_DENIED: u32 = 0x1B84;
pub const ERROR_CTX_WINSTATION_ACCESS_DENIED: u32 = 0x1B85;
pub const ERROR_CTX_INVALID_WD: u32 = 0x1B89;
pub const ERROR_CTX_SHADOW_INVALID: u32 = 0x1B8A;
pub const ERROR_CTX_SHADOW_DISABLED: u32 = 0x1B8B;
pub const ERROR_CTX_CLIENT_LICENSE_IN_USE: u32 = 0x1B8C;
pub const ERROR_CTX_CLIENT_LICENSE_NOT_SET: u32 = 0x1B8D;
pub const ERROR_CTX_LICENSE_NOT_AVAILABLE: u32 = 0x1B8E;
pub const ERROR_CTX_LICENSE_CLIENT_INVALID: u32 = 0x1B8F;
pub const ERROR_CTX_LICENSE_EXPIRED: u32 = 0x1B90;
pub const ERROR_CTX_SHADOW_NOT_RUNNING: u32 = 0x1B91;
pub const ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE: u32 = 0x1B92;
pub const ERROR_ACTIVATION_COUNT_EXCEEDED: u32 = 0x1B93;
pub const ERROR_CTX_WINSTATIONS_DISABLED: u32 = 0x1B94;
pub const ERROR_CTX_ENCRYPTION_LEVEL_REQUIRED: u32 = 0x1B95;
pub const ERROR_CTX_SESSION_IN_USE: u32 = 0x1B96;
pub const ERROR_CTX_NO_FORCE_LOGOFF: u32 = 0x1B97;
pub const ERROR_CTX_ACCOUNT_RESTRICTION: u32 = 0x1B98;
pub const ERROR_RDP_PROTOCOL_ERROR: u32 = 0x1B99;
pub const ERROR_CTX_CDM_CONNECT: u32 = 0x1B9A;
pub const ERROR_CTX_CDM_DISCONNECT: u32 = 0x1B9B;
pub const ERROR_CTX_SECURITY_LAYER_ERROR: u32 = 0x1B9C;
pub const ERROR_TS_INCOMPATIBLE_SESSIONS: u32 = 0x1B9D;
pub const ERROR_TS_VIDEO_SUBSYSTEM_ERROR: u32 = 0x1B9E;
pub const ERROR_DS_NOT_INSTALLED: u32 = 0x2008;
pub const ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY: u32 = 0x2009;
pub const ERROR_DS_NO_ATTRIBUTE_OR_VALUE: u32 = 0x200A;
pub const ERROR_DS_INVALID_ATTRIBUTE_SYNTAX: u32 = 0x200B;
pub const ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED: u32 = 0x200C;
pub const ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS: u32 = 0x200D;
pub const ERROR_DS_BUSY: u32 = 0x200E;
pub const ERROR_DS_UNAVAILABLE: u32 = 0x200F;
pub const ERROR_DS_NO_RIDS_ALLOCATED: u32 = 0x2010;
pub const ERROR_DS_NO_MORE_RIDS: u32 = 0x2011;
pub const ERROR_DS_INCORRECT_ROLE_OWNER: u32 = 0x2012;
pub const ERROR_DS_RIDMGR_INIT_ERROR: u32 = 0x2013;
pub const ERROR_DS_OBJ_CLASS_VIOLATION: u32 = 0x2014;
pub const ERROR_DS_CANT_ON_NON_LEAF: u32 = 0x2015;
pub const ERROR_DS_CANT_ON_RDN: u32 = 0x2016;
pub const ERROR_DS_CANT_MOD_OBJ_CLASS: u32 = 0x2017;
pub const ERROR_DS_CROSS_DOM_MOVE_ERROR: u32 = 0x2018;
pub const ERROR_DS_GC_NOT_AVAILABLE: u32 = 0x2019;
pub const ERROR_SHARED_POLICY: u32 = 0x201A;
pub const ERROR_POLICY_OBJECT_NOT_FOUND: u32 = 0x201B;
pub const ERROR_POLICY_ONLY_IN_DS: u32 = 0x201C;
pub const ERROR_PROMOTION_ACTIVE: u32 = 0x201D;
pub const ERROR_NO_PROMOTION_ACTIVE: u32 = 0x201E;
pub const ERROR_DS_OPERATIONS_ERROR: u32 = 0x2020;
pub const ERROR_DS_PROTOCOL_ERROR: u32 = 0x2021;
pub const ERROR_DS_TIMELIMIT_EXCEEDED: u32 = 0x2022;
pub const ERROR_DS_SIZELIMIT_EXCEEDED: u32 = 0x2023;
pub const ERROR_DS_ADMIN_LIMIT_EXCEEDED: u32 = 0x2024;
pub const ERROR_DS_COMPARE_FALSE: u32 = 0x2025;
pub const ERROR_DS_COMPARE_TRUE: u32 = 0x2026;
pub const ERROR_DS_AUTH_METHOD_NOT_SUPPORTED: u32 = 0x2027;
pub const ERROR_DS_STRONG_AUTH_REQUIRED: u32 = 0x2028;
pub const ERROR_DS_INAPPROPRIATE_AUTH: u32 = 0x2029;
pub const ERROR_DS_AUTH_UNKNOWN: u32 = 0x202A;
pub const ERROR_DS_REFERRAL: u32 = 0x202B;
pub const ERROR_DS_UNAVAILABLE_CRIT_EXTENSION: u32 = 0x202C;
pub const ERROR_DS_CONFIDENTIALITY_REQUIRED: u32 = 0x202D;
pub const ERROR_DS_INAPPROPRIATE_MATCHING: u32 = 0x202E;
pub const ERROR_DS_CONSTRAINT_VIOLATION: u32 = 0x202F;
pub const ERROR_DS_NO_SUCH_OBJECT: u32 = 0x2030;
pub const ERROR_DS_ALIAS_PROBLEM: u32 = 0x2031;
pub const ERROR_DS_INVALID_DN_SYNTAX: u32 = 0x2032;
pub const ERROR_DS_IS_LEAF: u32 = 0x2033;
pub const ERROR_DS_ALIAS_DEREF_PROBLEM: u32 = 0x2034;
pub const ERROR_DS_UNWILLING_TO_PERFORM: u32 = 0x2035;
pub const ERROR_DS_LOOP_DETECT: u32 = 0x2036;
pub const ERROR_DS_NAMING_VIOLATION: u32 = 0x2037;
pub const ERROR_DS_OBJECT_RESULTS_TOO_LARGE: u32 = 0x2038;
pub const ERROR_DS_AFFECTS_MULTIPLE_DSAS: u32 = 0x2039;
pub const ERROR_DS_SERVER_DOWN: u32 = 0x203A;
pub const ERROR_DS_LOCAL_ERROR: u32 = 0x203B;
pub const ERROR_DS_ENCODING_ERROR: u32 = 0x203C;
pub const ERROR_DS_DECODING_ERROR: u32 = 0x203D;
pub const ERROR_DS_FILTER_UNKNOWN: u32 = 0x203E;
pub const ERROR_DS_PARAM_ERROR: u32 = 0x203F;
pub const ERROR_DS_NOT_SUPPORTED: u32 = 0x2040;
pub const ERROR_DS_NO_RESULTS_RETURNED: u32 = 0x2041;
pub const ERROR_DS_CONTROL_NOT_FOUND: u32 = 0x2042;
pub const ERROR_DS_CLIENT_LOOP: u32 = 0x2043;
pub const ERROR_DS_REFERRAL_LIMIT_EXCEEDED: u32 = 0x2044;
pub const ERROR_DS_SORT_CONTROL_MISSING: u32 = 0x2045;
pub const ERROR_DS_OFFSET_RANGE_ERROR: u32 = 0x2046;
pub const ERROR_DS_RIDMGR_DISABLED: u32 = 0x2047;
pub const ERROR_DS_ROOT_MUST_BE_NC: u32 = 0x206D;
pub const ERROR_DS_ADD_REPLICA_INHIBITED: u32 = 0x206E;
pub const ERROR_DS_ATT_NOT_DEF_IN_SCHEMA: u32 = 0x206F;
pub const ERROR_DS_MAX_OBJ_SIZE_EXCEEDED: u32 = 0x2070;
pub const ERROR_DS_OBJ_STRING_NAME_EXISTS: u32 = 0x2071;
pub const ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA: u32 = 0x2072;
pub const ERROR_DS_RDN_DOESNT_MATCH_SCHEMA: u32 = 0x2073;
pub const ERROR_DS_NO_REQUESTED_ATTS_FOUND: u32 = 0x2074;
pub const ERROR_DS_USER_BUFFER_TO_SMALL: u32 = 0x2075;
pub const ERROR_DS_ATT_IS_NOT_ON_OBJ: u32 = 0x2076;
pub const ERROR_DS_ILLEGAL_MOD_OPERATION: u32 = 0x2077;
pub const ERROR_DS_OBJ_TOO_LARGE: u32 = 0x2078;
pub const ERROR_DS_BAD_INSTANCE_TYPE: u32 = 0x2079;
pub const ERROR_DS_MASTERDSA_REQUIRED: u32 = 0x207A;
pub const ERROR_DS_OBJECT_CLASS_REQUIRED: u32 = 0x207B;
pub const ERROR_DS_MISSING_REQUIRED_ATT: u32 = 0x207C;
pub const ERROR_DS_ATT_NOT_DEF_FOR_CLASS: u32 = 0x207D;
pub const ERROR_DS_ATT_ALREADY_EXISTS: u32 = 0x207E;
pub const ERROR_DS_CANT_ADD_ATT_VALUES: u32 = 0x2080;
pub const ERROR_DS_SINGLE_VALUE_CONSTRAINT: u32 = 0x2081;
pub const ERROR_DS_RANGE_CONSTRAINT: u32 = 0x2082;
pub const ERROR_DS_ATT_VAL_ALREADY_EXISTS: u32 = 0x2083;
pub const ERROR_DS_CANT_REM_MISSING_ATT: u32 = 0x2084;
pub const ERROR_DS_CANT_REM_MISSING_ATT_VAL: u32 = 0x2085;
pub const ERROR_DS_ROOT_CANT_BE_SUBREF: u32 = 0x2086;
pub const ERROR_DS_NO_CHAINING: u32 = 0x2087;
pub const ERROR_DS_NO_CHAINED_EVAL: u32 = 0x2088;
pub const ERROR_DS_NO_PARENT_OBJECT: u32 = 0x2089;
pub const ERROR_DS_PARENT_IS_AN_ALIAS: u32 = 0x208A;
pub const ERROR_DS_CANT_MIX_MASTER_AND_REPS: u32 = 0x208B;
pub const ERROR_DS_CHILDREN_EXIST: u32 = 0x208C;
pub const ERROR_DS_OBJ_NOT_FOUND: u32 = 0x208D;
pub const ERROR_DS_ALIASED_OBJ_MISSING: u32 = 0x208E;
pub const ERROR_DS_BAD_NAME_SYNTAX: u32 = 0x208F;
pub const ERROR_DS_ALIAS_POINTS_TO_ALIAS: u32 = 0x2090;
pub const ERROR_DS_CANT_DEREF_ALIAS: u32 = 0x2091;
pub const ERROR_DS_OUT_OF_SCOPE: u32 = 0x2092;
pub const ERROR_DS_OBJECT_BEING_REMOVED: u32 = 0x2093;
pub const ERROR_DS_CANT_DELETE_DSA_OBJ: u32 = 0x2094;
pub const ERROR_DS_GENERIC_ERROR: u32 = 0x2095;
pub const ERROR_DS_DSA_MUST_BE_INT_MASTER: u32 = 0x2096;
pub const ERROR_DS_CLASS_NOT_DSA: u32 = 0x2097;
pub const ERROR_DS_INSUFF_ACCESS_RIGHTS: u32 = 0x2098;
pub const ERROR_DS_ILLEGAL_SUPERIOR: u32 = 0x2099;
pub const ERROR_DS_ATTRIBUTE_OWNED_BY_SAM: u32 = 0x209A;
pub const ERROR_DS_NAME_TOO_MANY_PARTS: u32 = 0x209B;
pub const ERROR_DS_NAME_TOO_LONG: u32 = 0x209C;
pub const ERROR_DS_NAME_VALUE_TOO_LONG: u32 = 0x209D;
pub const ERROR_DS_NAME_UNPARSEABLE: u32 = 0x209E;
pub const ERROR_DS_NAME_TYPE_UNKNOWN: u32 = 0x209F;
pub const ERROR_DS_NOT_AN_OBJECT: u32 = 0x20A0;
pub const ERROR_DS_SEC_DESC_TOO_SHORT: u32 = 0x20A1;
pub const ERROR_DS_SEC_DESC_INVALID: u32 = 0x20A2;
pub const ERROR_DS_NO_DELETED_NAME: u32 = 0x20A3;
pub const ERROR_DS_SUBREF_MUST_HAVE_PARENT: u32 = 0x20A4;
pub const ERROR_DS_NCNAME_MUST_BE_NC: u32 = 0x20A5;
pub const ERROR_DS_CANT_ADD_SYSTEM_ONLY: u32 = 0x20A6;
pub const ERROR_DS_CLASS_MUST_BE_CONCRETE: u32 = 0x20A7;
pub const ERROR_DS_INVALID_DMD: u32 = 0x20A8;
pub const ERROR_DS_OBJ_GUID_EXISTS: u32 = 0x20A9;
pub const ERROR_DS_NOT_ON_BACKLINK: u32 = 0x20AA;
pub const ERROR_DS_NO_CROSSREF_FOR_NC: u32 = 0x20AB;
pub const ERROR_DS_SHUTTING_DOWN: u32 = 0x20AC;
pub const ERROR_DS_UNKNOWN_OPERATION: u32 = 0x20AD;
pub const ERROR_DS_INVALID_ROLE_OWNER: u32 = 0x20AE;
pub const ERROR_DS_COULDNT_CONTACT_FSMO: u32 = 0x20AF;
pub const ERROR_DS_CROSS_NC_DN_RENAME: u32 = 0x20B0;
pub const ERROR_DS_CANT_MOD_SYSTEM_ONLY: u32 = 0x20B1;
pub const ERROR_DS_REPLICATOR_ONLY: u32 = 0x20B2;
pub const ERROR_DS_OBJ_CLASS_NOT_DEFINED: u32 = 0x20B3;
pub const ERROR_DS_OBJ_CLASS_NOT_SUBCLASS: u32 = 0x20B4;
pub const ERROR_DS_NAME_REFERENCE_INVALID: u32 = 0x20B5;
pub const ERROR_DS_CROSS_REF_EXISTS: u32 = 0x20B6;
pub const ERROR_DS_CANT_DEL_MASTER_CROSSREF: u32 = 0x20B7;
pub const ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD: u32 = 0x20B8;
pub const ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX: u32 = 0x20B9;
pub const ERROR_DS_DUP_RDN: u32 = 0x20BA;
pub const ERROR_DS_DUP_OID: u32 = 0x20BB;
pub const ERROR_DS_DUP_MAPI_ID: u32 = 0x20BC;
pub const ERROR_DS_DUP_SCHEMA_ID_GUID: u32 = 0x20BD;
pub const ERROR_DS_DUP_LDAP_DISPLAY_NAME: u32 = 0x20BE;
pub const ERROR_DS_SEMANTIC_ATT_TEST: u32 = 0x20BF;
pub const ERROR_DS_SYNTAX_MISMATCH: u32 = 0x20C0;
pub const ERROR_DS_EXISTS_IN_MUST_HAVE: u32 = 0x20C1;
pub const ERROR_DS_EXISTS_IN_MAY_HAVE: u32 = 0x20C2;
pub const ERROR_DS_NONEXISTENT_MAY_HAVE: u32 = 0x20C3;
pub const ERROR_DS_NONEXISTENT_MUST_HAVE: u32 = 0x20C4;
pub const ERROR_DS_AUX_CLS_TEST_FAIL: u32 = 0x20C5;
pub const ERROR_DS_NONEXISTENT_POSS_SUP: u32 = 0x20C6;
pub const ERROR_DS_SUB_CLS_TEST_FAIL: u32 = 0x20C7;
pub const ERROR_DS_BAD_RDN_ATT_ID_SYNTAX: u32 = 0x20C8;
pub const ERROR_DS_EXISTS_IN_AUX_CLS: u32 = 0x20C9;
pub const ERROR_DS_EXISTS_IN_SUB_CLS: u32 = 0x20CA;
pub const ERROR_DS_EXISTS_IN_POSS_SUP: u32 = 0x20CB;
pub const ERROR_DS_RECALCSCHEMA_FAILED: u32 = 0x20CC;
pub const ERROR_DS_TREE_DELETE_NOT_FINISHED: u32 = 0x20CD;
pub const ERROR_DS_CANT_DELETE: u32 = 0x20CE;
pub const ERROR_DS_ATT_SCHEMA_REQ_ID: u32 = 0x20CF;
pub const ERROR_DS_BAD_ATT_SCHEMA_SYNTAX: u32 = 0x20D0;
pub const ERROR_DS_CANT_CACHE_ATT: u32 = 0x20D1;
pub const ERROR_DS_CANT_CACHE_CLASS: u32 = 0x20D2;
pub const ERROR_DS_CANT_REMOVE_ATT_CACHE: u32 = 0x20D3;
pub const ERROR_DS_CANT_REMOVE_CLASS_CACHE: u32 = 0x20D4;
pub const ERROR_DS_CANT_RETRIEVE_DN: u32 = 0x20D5;
pub const ERROR_DS_MISSING_SUPREF: u32 = 0x20D6;
pub const ERROR_DS_CANT_RETRIEVE_INSTANCE: u32 = 0x20D7;
pub const ERROR_DS_CODE_INCONSISTENCY: u32 = 0x20D8;
pub const ERROR_DS_DATABASE_ERROR: u32 = 0x20D9;
pub const ERROR_DS_GOVERNSID_MISSING: u32 = 0x20DA;
pub const ERROR_DS_MISSING_EXPECTED_ATT: u32 = 0x20DB;
pub const ERROR_DS_NCNAME_MISSING_CR_REF: u32 = 0x20DC;
pub const ERROR_DS_SECURITY_CHECKING_ERROR: u32 = 0x20DD;
pub const ERROR_DS_SCHEMA_NOT_LOADED: u32 = 0x20DE;
pub const ERROR_DS_SCHEMA_ALLOC_FAILED: u32 = 0x20DF;
pub const ERROR_DS_ATT_SCHEMA_REQ_SYNTAX: u32 = 0x20E0;
pub const ERROR_DS_GCVERIFY_ERROR: u32 = 0x20E1;
pub const ERROR_DS_DRA_SCHEMA_MISMATCH: u32 = 0x20E2;
pub const ERROR_DS_CANT_FIND_DSA_OBJ: u32 = 0x20E3;
pub const ERROR_DS_CANT_FIND_EXPECTED_NC: u32 = 0x20E4;
pub const ERROR_DS_CANT_FIND_NC_IN_CACHE: u32 = 0x20E5;
pub const ERROR_DS_CANT_RETRIEVE_CHILD: u32 = 0x20E6;
pub const ERROR_DS_SECURITY_ILLEGAL_MODIFY: u32 = 0x20E7;
pub const ERROR_DS_CANT_REPLACE_HIDDEN_REC: u32 = 0x20E8;
pub const ERROR_DS_BAD_HIERARCHY_FILE: u32 = 0x20E9;
pub const ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED: u32 = 0x20EA;
pub const ERROR_DS_CONFIG_PARAM_MISSING: u32 = 0x20EB;
pub const ERROR_DS_COUNTING_AB_INDICES_FAILED: u32 = 0x20EC;
pub const ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED: u32 = 0x20ED;
pub const ERROR_DS_INTERNAL_FAILURE: u32 = 0x20EE;
pub const ERROR_DS_UNKNOWN_ERROR: u32 = 0x20EF;
pub const ERROR_DS_ROOT_REQUIRES_CLASS_TOP: u32 = 0x20F0;
pub const ERROR_DS_REFUSING_FSMO_ROLES: u32 = 0x20F1;
pub const ERROR_DS_MISSING_FSMO_SETTINGS: u32 = 0x20F2;
pub const ERROR_DS_UNABLE_TO_SURRENDER_ROLES: u32 = 0x20F3;
pub const ERROR_DS_DRA_GENERIC: u32 = 0x20F4;
pub const ERROR_DS_DRA_INVALID_PARAMETER: u32 = 0x20F5;
pub const ERROR_DS_DRA_BUSY: u32 = 0x20F6;
pub const ERROR_DS_DRA_BAD_DN: u32 = 0x20F7;
pub const ERROR_DS_DRA_BAD_NC: u32 = 0x20F8;
pub const ERROR_DS_DRA_DN_EXISTS: u32 = 0x20F9;
pub const ERROR_DS_DRA_INTERNAL_ERROR: u32 = 0x20FA;
pub const ERROR_DS_DRA_INCONSISTENT_DIT: u32 = 0x20FB;
pub const ERROR_DS_DRA_CONNECTION_FAILED: u32 = 0x20FC;
pub const ERROR_DS_DRA_BAD_INSTANCE_TYPE: u32 = 0x20FD;
pub const ERROR_DS_DRA_OUT_OF_MEM: u32 = 0x20FE;
pub const ERROR_DS_DRA_MAIL_PROBLEM: u32 = 0x20FF;
pub const ERROR_DS_DRA_REF_ALREADY_EXISTS: u32 = 0x2100;
pub const ERROR_DS_DRA_REF_NOT_FOUND: u32 = 0x2101;
pub const ERROR_DS_DRA_OBJ_IS_REP_SOURCE: u32 = 0x2102;
pub const ERROR_DS_DRA_DB_ERROR: u32 = 0x2103;
pub const ERROR_DS_DRA_NO_REPLICA: u32 = 0x2104;
pub const ERROR_DS_DRA_ACCESS_DENIED: u32 = 0x2105;
pub const ERROR_DS_DRA_NOT_SUPPORTED: u32 = 0x2106;
pub const ERROR_DS_DRA_RPC_CANCELLED: u32 = 0x2107;
pub const ERROR_DS_DRA_SOURCE_DISABLED: u32 = 0x2108;
pub const ERROR_DS_DRA_SINK_DISABLED: u32 = 0x2109;
pub const ERROR_DS_DRA_NAME_COLLISION: u32 = 0x210A;
pub const ERROR_DS_DRA_SOURCE_REINSTALLED: u32 = 0x210B;
pub const ERROR_DS_DRA_MISSING_PARENT: u32 = 0x210C;
pub const ERROR_DS_DRA_PREEMPTED: u32 = 0x210D;
pub const ERROR_DS_DRA_ABANDON_SYNC: u32 = 0x210E;
pub const ERROR_DS_DRA_SHUTDOWN: u32 = 0x210F;
pub const ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET: u32 = 0x2110;
pub const ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA: u32 = 0x2111;
pub const ERROR_DS_DRA_EXTN_CONNECTION_FAILED: u32 = 0x2112;
pub const ERROR_DS_INSTALL_SCHEMA_MISMATCH: u32 = 0x2113;
pub const ERROR_DS_DUP_LINK_ID: u32 = 0x2114;
pub const ERROR_DS_NAME_ERROR_RESOLVING: u32 = 0x2115;
pub const ERROR_DS_NAME_ERROR_NOT_FOUND: u32 = 0x2116;
pub const ERROR_DS_NAME_ERROR_NOT_UNIQUE: u32 = 0x2117;
pub const ERROR_DS_NAME_ERROR_NO_MAPPING: u32 = 0x2118;
pub const ERROR_DS_NAME_ERROR_DOMAIN_ONLY: u32 = 0x2119;
pub const ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING: u32 = 0x211A;
pub const ERROR_DS_CONSTRUCTED_ATT_MOD: u32 = 0x211B;
pub const ERROR_DS_WRONG_OM_OBJ_CLASS: u32 = 0x211C;
pub const ERROR_DS_DRA_REPL_PENDING: u32 = 0x211D;
pub const ERROR_DS_DS_REQUIRED: u32 = 0x211E;
pub const ERROR_DS_INVALID_LDAP_DISPLAY_NAME: u32 = 0x211F;
pub const ERROR_DS_NON_BASE_SEARCH: u32 = 0x2120;
pub const ERROR_DS_CANT_RETRIEVE_ATTS: u32 = 0x2121;
pub const ERROR_DS_BACKLINK_WITHOUT_LINK: u32 = 0x2122;
pub const ERROR_DS_EPOCH_MISMATCH: u32 = 0x2123;
pub const ERROR_DS_SRC_NAME_MISMATCH: u32 = 0x2124;
pub const ERROR_DS_SRC_AND_DST_NC_IDENTICAL: u32 = 0x2125;
pub const ERROR_DS_DST_NC_MISMATCH: u32 = 0x2126;
pub const ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC: u32 = 0x2127;
pub const ERROR_DS_SRC_GUID_MISMATCH: u32 = 0x2128;
pub const ERROR_DS_CANT_MOVE_DELETED_OBJECT: u32 = 0x2129;
pub const ERROR_DS_PDC_OPERATION_IN_PROGRESS: u32 = 0x212A;
pub const ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD: u32 = 0x212B;
pub const ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION: u32 = 0x212C;
pub const ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS: u32 = 0x212D;
pub const ERROR_DS_NC_MUST_HAVE_NC_PARENT: u32 = 0x212E;
pub const ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE: u32 = 0x212F;
pub const ERROR_DS_DST_DOMAIN_NOT_NATIVE: u32 = 0x2130;
pub const ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER: u32 = 0x2131;
pub const ERROR_DS_CANT_MOVE_ACCOUNT_GROUP: u32 = 0x2132;
pub const ERROR_DS_CANT_MOVE_RESOURCE_GROUP: u32 = 0x2133;
pub const ERROR_DS_INVALID_SEARCH_FLAG: u32 = 0x2134;
pub const ERROR_DS_NO_TREE_DELETE_ABOVE_NC: u32 = 0x2135;
pub const ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE: u32 = 0x2136;
pub const ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE: u32 = 0x2137;
pub const ERROR_DS_SAM_INIT_FAILURE: u32 = 0x2138;
pub const ERROR_DS_SENSITIVE_GROUP_VIOLATION: u32 = 0x2139;
pub const ERROR_DS_CANT_MOD_PRIMARYGROUPID: u32 = 0x213A;
pub const ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD: u32 = 0x213B;
pub const ERROR_DS_NONSAFE_SCHEMA_CHANGE: u32 = 0x213C;
pub const ERROR_DS_SCHEMA_UPDATE_DISALLOWED: u32 = 0x213D;
pub const ERROR_DS_CANT_CREATE_UNDER_SCHEMA: u32 = 0x213E;
pub const ERROR_DS_INSTALL_NO_SRC_SCH_VERSION: u32 = 0x213F;
pub const ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE: u32 = 0x2140;
pub const ERROR_DS_INVALID_GROUP_TYPE: u32 = 0x2141;
pub const ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN: u32 = 0x2142;
pub const ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN: u32 = 0x2143;
pub const ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER: u32 = 0x2144;
pub const ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER: u32 = 0x2145;
pub const ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER: u32 = 0x2146;
pub const ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER: u32 = 0x2147;
pub const ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER: u32 = 0x2148;
pub const ERROR_DS_HAVE_PRIMARY_MEMBERS: u32 = 0x2149;
pub const ERROR_DS_STRING_SD_CONVERSION_FAILED: u32 = 0x214A;
pub const ERROR_DS_NAMING_MASTER_GC: u32 = 0x214B;
pub const ERROR_DS_DNS_LOOKUP_FAILURE: u32 = 0x214C;
pub const ERROR_DS_COULDNT_UPDATE_SPNS: u32 = 0x214D;
pub const ERROR_DS_CANT_RETRIEVE_SD: u32 = 0x214E;
pub const ERROR_DS_KEY_NOT_UNIQUE: u32 = 0x214F;
pub const ERROR_DS_WRONG_LINKED_ATT_SYNTAX: u32 = 0x2150;
pub const ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD: u32 = 0x2151;
pub const ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY: u32 = 0x2152;
pub const ERROR_DS_CANT_START: u32 = 0x2153;
pub const ERROR_DS_INIT_FAILURE: u32 = 0x2154;
pub const ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION: u32 = 0x2155;
pub const ERROR_DS_SOURCE_DOMAIN_IN_FOREST: u32 = 0x2156;
pub const ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST: u32 = 0x2157;
pub const ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED: u32 = 0x2158;
pub const ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN: u32 = 0x2159;
pub const ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER: u32 = 0x215A;
pub const ERROR_DS_SRC_SID_EXISTS_IN_FOREST: u32 = 0x215B;
pub const ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH: u32 = 0x215C;
pub const ERROR_SAM_INIT_FAILURE: u32 = 0x215D;
pub const ERROR_DS_DRA_SCHEMA_INFO_SHIP: u32 = 0x215E;
pub const ERROR_DS_DRA_SCHEMA_CONFLICT: u32 = 0x215F;
pub const ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT: u32 = 0x2160;
pub const ERROR_DS_DRA_OBJ_NC_MISMATCH: u32 = 0x2161;
pub const ERROR_DS_NC_STILL_HAS_DSAS: u32 = 0x2162;
pub const ERROR_DS_GC_REQUIRED: u32 = 0x2163;
pub const ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY: u32 = 0x2164;
pub const ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS: u32 = 0x2165;
pub const ERROR_DS_CANT_ADD_TO_GC: u32 = 0x2166;
pub const ERROR_DS_NO_CHECKPOINT_WITH_PDC: u32 = 0x2167;
pub const ERROR_DS_SOURCE_AUDITING_NOT_ENABLED: u32 = 0x2168;
pub const ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC: u32 = 0x2169;
pub const ERROR_DS_INVALID_NAME_FOR_SPN: u32 = 0x216A;
pub const ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS: u32 = 0x216B;
pub const ERROR_DS_UNICODEPWD_NOT_IN_QUOTES: u32 = 0x216C;
pub const ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED: u32 = 0x216D;
pub const ERROR_DS_MUST_BE_RUN_ON_DST_DC: u32 = 0x216E;
pub const ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER: u32 = 0x216F;
pub const ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ: u32 = 0x2170;
pub const ERROR_DS_INIT_FAILURE_CONSOLE: u32 = 0x2171;
pub const ERROR_DS_SAM_INIT_FAILURE_CONSOLE: u32 = 0x2172;
pub const ERROR_DS_FOREST_VERSION_TOO_HIGH: u32 = 0x2173;
pub const ERROR_DS_DOMAIN_VERSION_TOO_HIGH: u32 = 0x2174;
pub const ERROR_DS_FOREST_VERSION_TOO_LOW: u32 = 0x2175;
pub const ERROR_DS_DOMAIN_VERSION_TOO_LOW: u32 = 0x2176;
pub const ERROR_DS_INCOMPATIBLE_VERSION: u32 = 0x2177;
pub const ERROR_DS_LOW_DSA_VERSION: u32 = 0x2178;
pub const ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN: u32 = 0x2179;
pub const ERROR_DS_NOT_SUPPORTED_SORT_ORDER: u32 = 0x217A;
pub const ERROR_DS_NAME_NOT_UNIQUE: u32 = 0x217B;
pub const ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4: u32 = 0x217C;
pub const ERROR_DS_OUT_OF_VERSION_STORE: u32 = 0x217D;
pub const ERROR_DS_INCOMPATIBLE_CONTROLS_USED: u32 = 0x217E;
pub const ERROR_DS_NO_REF_DOMAIN: u32 = 0x217F;
pub const ERROR_DS_RESERVED_LINK_ID: u32 = 0x2180;
pub const ERROR_DS_LINK_ID_NOT_AVAILABLE: u32 = 0x2181;
pub const ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER: u32 = 0x2182;
pub const ERROR_DS_MODIFYDN_DISALLOWED_BY_INSTANCE_TYPE: u32 = 0x2183;
pub const ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC: u32 = 0x2184;
pub const ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG: u32 = 0x2185;
pub const ERROR_DS_MODIFYDN_WRONG_GRANDPARENT: u32 = 0x2186;
pub const ERROR_DS_NAME_ERROR_TRUST_REFERRAL: u32 = 0x2187;
pub const ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER: u32 = 0x2188;
pub const ERROR_DS_CANT_ACCESS_REMOTE_PART_OF_AD: u32 = 0x2189;
pub const ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2: u32 = 0x218A;
pub const ERROR_DS_THREAD_LIMIT_EXCEEDED: u32 = 0x218B;
pub const ERROR_DS_NOT_CLOSEST: u32 = 0x218C;
pub const ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF: u32 = 0x218D;
pub const ERROR_DS_SINGLE_USER_MODE_FAILED: u32 = 0x218E;
pub const ERROR_DS_NTDSCRIPT_SYNTAX_ERROR: u32 = 0x218F;
pub const ERROR_DS_NTDSCRIPT_PROCESS_ERROR: u32 = 0x2190;
pub const ERROR_DS_DIFFERENT_REPL_EPOCHS: u32 = 0x2191;
pub const ERROR_DS_DRS_EXTENSIONS_CHANGED: u32 = 0x2192;
pub const ERROR_DS_REPLICA_SET_CHANGE_NOT_ALLOWED_ON_DISABLED_CR: u32 = 0x2193;
pub const ERROR_DS_NO_MSDS_INTID: u32 = 0x2194;
pub const ERROR_DS_DUP_MSDS_INTID: u32 = 0x2195;
pub const ERROR_DS_EXISTS_IN_RDNATTID: u32 = 0x2196;
pub const ERROR_DS_AUTHORIZATION_FAILED: u32 = 0x2197;
pub const ERROR_DS_INVALID_SCRIPT: u32 = 0x2198;
pub const ERROR_DS_REMOTE_CROSSREF_OP_FAILED: u32 = 0x2199;
pub const ERROR_DS_CROSS_REF_BUSY: u32 = 0x219A;
pub const ERROR_DS_CANT_DERIVE_SPN_FOR_DELETED_DOMAIN: u32 = 0x219B;
pub const ERROR_DS_CANT_DEMOTE_WITH_WRITEABLE_NC: u32 = 0x219C;
pub const ERROR_DS_DUPLICATE_ID_FOUND: u32 = 0x219D;
pub const ERROR_DS_INSUFFICIENT_ATTR_TO_CREATE_OBJECT: u32 = 0x219E;
pub const ERROR_DS_GROUP_CONVERSION_ERROR: u32 = 0x219F;
pub const ERROR_DS_CANT_MOVE_APP_BASIC_GROUP: u32 = 0x21A0;
pub const ERROR_DS_CANT_MOVE_APP_QUERY_GROUP: u32 = 0x21A1;
pub const ERROR_DS_ROLE_NOT_VERIFIED: u32 = 0x21A2;
pub const ERROR_DS_WKO_CONTAINER_CANNOT_BE_SPECIAL: u32 = 0x21A3;
pub const ERROR_DS_DOMAIN_RENAME_IN_PROGRESS: u32 = 0x21A4;
pub const ERROR_DS_EXISTING_AD_CHILD_NC: u32 = 0x21A5;
pub const ERROR_DS_REPL_LIFETIME_EXCEEDED: u32 = 0x21A6;
pub const ERROR_DS_DISALLOWED_IN_SYSTEM_CONTAINER: u32 = 0x21A7;
pub const ERROR_DS_LDAP_SEND_QUEUE_FULL: u32 = 0x21A8;
pub const ERROR_DS_DRA_OUT_SCHEDULE_WINDOW: u32 = 0x21A9;
pub const ERROR_DS_POLICY_NOT_KNOWN: u32 = 0x21AA;
pub const ERROR_NO_SITE_SETTINGS_OBJECT: u32 = 0x21AB;
pub const ERROR_NO_SECRETS: u32 = 0x21AC;
pub const ERROR_NO_WRITABLE_DC_FOUND: u32 = 0x21AD;
pub const ERROR_DS_NO_SERVER_OBJECT: u32 = 0x21AE;
pub const ERROR_DS_NO_NTDSA_OBJECT: u32 = 0x21AF;
pub const ERROR_DS_NON_ASQ_SEARCH: u32 = 0x21B0;
pub const ERROR_DS_AUDIT_FAILURE: u32 = 0x21B1;
pub const ERROR_DS_INVALID_SEARCH_FLAG_SUBTREE: u32 = 0x21B2;
pub const ERROR_DS_INVALID_SEARCH_FLAG_TUPLE: u32 = 0x21B3;
pub const ERROR_DS_HIERARCHY_TABLE_TOO_DEEP: u32 = 0x21B4;
pub const ERROR_DS_DRA_CORRUPT_UTD_VECTOR: u32 = 0x21B5;
pub const ERROR_DS_DRA_SECRETS_DENIED: u32 = 0x21B6;
pub const ERROR_DS_RESERVED_MAPI_ID: u32 = 0x21B7;
pub const ERROR_DS_MAPI_ID_NOT_AVAILABLE: u32 = 0x21B8;
pub const ERROR_DS_DRA_MISSING_KRBTGT_SECRET: u32 = 0x21B9;
pub const ERROR_DS_DOMAIN_NAME_EXISTS_IN_FOREST: u32 = 0x21BA;
pub const ERROR_DS_FLAT_NAME_EXISTS_IN_FOREST: u32 = 0x21BB;
pub const ERROR_INVALID_USER_PRINCIPAL_NAME: u32 = 0x21BC;
pub const ERROR_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS: u32 = 0x21BD;
pub const ERROR_DS_OID_NOT_FOUND: u32 = 0x21BE;
pub const ERROR_DS_DRA_RECYCLED_TARGET: u32 = 0x21BF;
pub const ERROR_DS_DISALLOWED_NC_REDIRECT: u32 = 0x21C0;
pub const ERROR_DS_HIGH_ADLDS_FFL: u32 = 0x21C1;
pub const ERROR_DS_HIGH_DSA_VERSION: u32 = 0x21C2;
pub const ERROR_DS_LOW_ADLDS_FFL: u32 = 0x21C3;
pub const ERROR_DOMAIN_SID_SAME_AS_LOCAL_WORKSTATION: u32 = 0x21C4;
pub const ERROR_DS_UNDELETE_SAM_VALIDATION_FAILED: u32 = 0x21C5;
pub const ERROR_INCORRECT_ACCOUNT_TYPE: u32 = 0x21C6;
pub const ERROR_DS_SPN_VALUE_NOT_UNIQUE_IN_FOREST: u32 = 0x21C7;
pub const ERROR_DS_UPN_VALUE_NOT_UNIQUE_IN_FOREST: u32 = 0x21C8;
pub const ERROR_DS_MISSING_FOREST_TRUST: u32 = 0x21C9;
pub const ERROR_DS_VALUE_KEY_NOT_UNIQUE: u32 = 0x21CA;
pub const ERROR_WEAK_WHFBKEY_BLOCKED: u32 = 0x21CB;
pub const DNS_ERROR_RESPONSE_CODES_BASE: u32 = 0x2328;
pub const DNS_ERROR_RCODE_NO_ERROR: u32 = 0x0;
pub const DNS_ERROR_MASK: u32 = 0x2328;
pub const DNS_ERROR_RCODE_FORMAT_ERROR: u32 = 0x2329;
pub const DNS_ERROR_RCODE_SERVER_FAILURE: u32 = 0x232A;
pub const DNS_ERROR_RCODE_NAME_ERROR: u32 = 0x232B;
pub const DNS_ERROR_RCODE_NOT_IMPLEMENTED: u32 = 0x232C;
pub const DNS_ERROR_RCODE_REFUSED: u32 = 0x232D;
pub const DNS_ERROR_RCODE_YXDOMAIN: u32 = 0x232E;
pub const DNS_ERROR_RCODE_YXRRSET: u32 = 0x232F;
pub const DNS_ERROR_RCODE_NXRRSET: u32 = 0x2330;
pub const DNS_ERROR_RCODE_NOTAUTH: u32 = 0x2331;
pub const DNS_ERROR_RCODE_NOTZONE: u32 = 0x2332;
pub const DNS_ERROR_RCODE_BADSIG: u32 = 0x2338;
pub const DNS_ERROR_RCODE_BADKEY: u32 = 0x2339;
pub const DNS_ERROR_RCODE_BADTIME: u32 = 0x233A;
pub const DNS_ERROR_RCODE_LAST: u32 = 0x233A;
pub const DNS_ERROR_DNSSEC_BASE: u32 = 0x238C;
pub const DNS_ERROR_KEYMASTER_REQUIRED: u32 = 0x238D;
pub const DNS_ERROR_NOT_ALLOWED_ON_SIGNED_ZONE: u32 = 0x238E;
pub const DNS_ERROR_NSEC3_INCOMPATIBLE_WITH_RSA_SHA1: u32 = 0x238F;
pub const DNS_ERROR_NOT_ENOUGH_SIGNING_KEY_DESCRIPTORS: u32 = 0x2390;
pub const DNS_ERROR_UNSUPPORTED_ALGORITHM: u32 = 0x2391;
pub const DNS_ERROR_INVALID_KEY_SIZE: u32 = 0x2392;
pub const DNS_ERROR_SIGNING_KEY_NOT_ACCESSIBLE: u32 = 0x2393;
pub const DNS_ERROR_KSP_DOES_NOT_SUPPORT_PROTECTION: u32 = 0x2394;
pub const DNS_ERROR_UNEXPECTED_DATA_PROTECTION_ERROR: u32 = 0x2395;
pub const DNS_ERROR_UNEXPECTED_CNG_ERROR: u32 = 0x2396;
pub const DNS_ERROR_UNKNOWN_SIGNING_PARAMETER_VERSION: u32 = 0x2397;
pub const DNS_ERROR_KSP_NOT_ACCESSIBLE: u32 = 0x2398;
pub const DNS_ERROR_TOO_MANY_SKDS: u32 = 0x2399;
pub const DNS_ERROR_INVALID_ROLLOVER_PERIOD: u32 = 0x239A;
pub const DNS_ERROR_INVALID_INITIAL_ROLLOVER_OFFSET: u32 = 0x239B;
pub const DNS_ERROR_ROLLOVER_IN_PROGRESS: u32 = 0x239C;
pub const DNS_ERROR_STANDBY_KEY_NOT_PRESENT: u32 = 0x239D;
pub const DNS_ERROR_NOT_ALLOWED_ON_ZSK: u32 = 0x239E;
pub const DNS_ERROR_NOT_ALLOWED_ON_ACTIVE_SKD: u32 = 0x239F;
pub const DNS_ERROR_ROLLOVER_ALREADY_QUEUED: u32 = 0x23A0;
pub const DNS_ERROR_NOT_ALLOWED_ON_UNSIGNED_ZONE: u32 = 0x23A1;
pub const DNS_ERROR_BAD_KEYMASTER: u32 = 0x23A2;
pub const DNS_ERROR_INVALID_SIGNATURE_VALIDITY_PERIOD: u32 = 0x23A3;
pub const DNS_ERROR_INVALID_NSEC3_ITERATION_COUNT: u32 = 0x23A4;
pub const DNS_ERROR_DNSSEC_IS_DISABLED: u32 = 0x23A5;
pub const DNS_ERROR_INVALID_XML: u32 = 0x23A6;
pub const DNS_ERROR_NO_VALID_TRUST_ANCHORS: u32 = 0x23A7;
pub const DNS_ERROR_ROLLOVER_NOT_POKEABLE: u32 = 0x23A8;
pub const DNS_ERROR_NSEC3_NAME_COLLISION: u32 = 0x23A9;
pub const DNS_ERROR_NSEC_INCOMPATIBLE_WITH_NSEC3_RSA_SHA1: u32 = 0x23AA;
pub const DNS_ERROR_PACKET_FMT_BASE: u32 = 0x251C;
pub const DNS_ERROR_BAD_PACKET: u32 = 0x251E;
pub const DNS_ERROR_NO_PACKET: u32 = 0x251F;
pub const DNS_ERROR_RCODE: u32 = 0x2520;
pub const DNS_ERROR_UNSECURE_PACKET: u32 = 0x2521;
pub const DNS_ERROR_NO_MEMORY: u32 = 0xE;
pub const DNS_ERROR_INVALID_NAME: u32 = 0x7B;
pub const DNS_ERROR_INVALID_DATA: u32 = 0xD;
pub const DNS_ERROR_GENERAL_API_BASE: u32 = 0x254E;
pub const DNS_ERROR_INVALID_TYPE: u32 = 0x254F;
pub const DNS_ERROR_INVALID_IP_ADDRESS: u32 = 0x2550;
pub const DNS_ERROR_INVALID_PROPERTY: u32 = 0x2551;
pub const DNS_ERROR_TRY_AGAIN_LATER: u32 = 0x2552;
pub const DNS_ERROR_NOT_UNIQUE: u32 = 0x2553;
pub const DNS_ERROR_NON_RFC_NAME: u32 = 0x2554;
pub const DNS_ERROR_INVALID_NAME_CHAR: u32 = 0x2558;
pub const DNS_ERROR_NUMERIC_NAME: u32 = 0x2559;
pub const DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER: u32 = 0x255A;
pub const DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION: u32 = 0x255B;
pub const DNS_ERROR_CANNOT_FIND_ROOT_HINTS: u32 = 0x255C;
pub const DNS_ERROR_INCONSISTENT_ROOT_HINTS: u32 = 0x255D;
pub const DNS_ERROR_DWORD_VALUE_TOO_SMALL: u32 = 0x255E;
pub const DNS_ERROR_DWORD_VALUE_TOO_LARGE: u32 = 0x255F;
pub const DNS_ERROR_BACKGROUND_LOADING: u32 = 0x2560;
pub const DNS_ERROR_NOT_ALLOWED_ON_RODC: u32 = 0x2561;
pub const DNS_ERROR_NOT_ALLOWED_UNDER_DNAME: u32 = 0x2562;
pub const DNS_ERROR_DELEGATION_REQUIRED: u32 = 0x2563;
pub const DNS_ERROR_INVALID_POLICY_TABLE: u32 = 0x2564;
pub const DNS_ERROR_ADDRESS_REQUIRED: u32 = 0x2565;
pub const DNS_ERROR_ZONE_BASE: u32 = 0x2580;
pub const DNS_ERROR_ZONE_DOES_NOT_EXIST: u32 = 0x2581;
pub const DNS_ERROR_NO_ZONE_INFO: u32 = 0x2582;
pub const DNS_ERROR_INVALID_ZONE_OPERATION: u32 = 0x2583;
pub const DNS_ERROR_ZONE_CONFIGURATION_ERROR: u32 = 0x2584;
pub const DNS_ERROR_ZONE_HAS_NO_SOA_RECORD: u32 = 0x2585;
pub const DNS_ERROR_ZONE_HAS_NO_NS_RECORDS: u32 = 0x2586;
pub const DNS_ERROR_ZONE_LOCKED: u32 = 0x2587;
pub const DNS_ERROR_ZONE_CREATION_FAILED: u32 = 0x2588;
pub const DNS_ERROR_ZONE_ALREADY_EXISTS: u32 = 0x2589;
pub const DNS_ERROR_AUTOZONE_ALREADY_EXISTS: u32 = 0x258A;
pub const DNS_ERROR_INVALID_ZONE_TYPE: u32 = 0x258B;
pub const DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP: u32 = 0x258C;
pub const DNS_ERROR_ZONE_NOT_SECONDARY: u32 = 0x258D;
pub const DNS_ERROR_NEED_SECONDARY_ADDRESSES: u32 = 0x258E;
pub const DNS_ERROR_WINS_INIT_FAILED: u32 = 0x258F;
pub const DNS_ERROR_NEED_WINS_SERVERS: u32 = 0x2590;
pub const DNS_ERROR_NBSTAT_INIT_FAILED: u32 = 0x2591;
pub const DNS_ERROR_SOA_DELETE_INVALID: u32 = 0x2592;
pub const DNS_ERROR_FORWARDER_ALREADY_EXISTS: u32 = 0x2593;
pub const DNS_ERROR_ZONE_REQUIRES_MASTER_IP: u32 = 0x2594;
pub const DNS_ERROR_ZONE_IS_SHUTDOWN: u32 = 0x2595;
pub const DNS_ERROR_ZONE_LOCKED_FOR_SIGNING: u32 = 0x2596;
pub const DNS_ERROR_DATAFILE_BASE: u32 = 0x25B2;
pub const DNS_ERROR_PRIMARY_REQUIRES_DATAFILE: u32 = 0x25B3;
pub const DNS_ERROR_INVALID_DATAFILE_NAME: u32 = 0x25B4;
pub const DNS_ERROR_DATAFILE_OPEN_FAILURE: u32 = 0x25B5;
pub const DNS_ERROR_FILE_WRITEBACK_FAILED: u32 = 0x25B6;
pub const DNS_ERROR_DATAFILE_PARSING: u32 = 0x25B7;
pub const DNS_ERROR_DATABASE_BASE: u32 = 0x25E4;
pub const DNS_ERROR_RECORD_DOES_NOT_EXIST: u32 = 0x25E5;
pub const DNS_ERROR_RECORD_FORMAT: u32 = 0x25E6;
pub const DNS_ERROR_NODE_CREATION_FAILED: u32 = 0x25E7;
pub const DNS_ERROR_UNKNOWN_RECORD_TYPE: u32 = 0x25E8;
pub const DNS_ERROR_RECORD_TIMED_OUT: u32 = 0x25E9;
pub const DNS_ERROR_NAME_NOT_IN_ZONE: u32 = 0x25EA;
pub const DNS_ERROR_CNAME_LOOP: u32 = 0x25EB;
pub const DNS_ERROR_NODE_IS_CNAME: u32 = 0x25EC;
pub const DNS_ERROR_CNAME_COLLISION: u32 = 0x25ED;
pub const DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT: u32 = 0x25EE;
pub const DNS_ERROR_RECORD_ALREADY_EXISTS: u32 = 0x25EF;
pub const DNS_ERROR_SECONDARY_DATA: u32 = 0x25F0;
pub const DNS_ERROR_NO_CREATE_CACHE_DATA: u32 = 0x25F1;
pub const DNS_ERROR_NAME_DOES_NOT_EXIST: u32 = 0x25F2;
pub const DNS_ERROR_DS_UNAVAILABLE: u32 = 0x25F5;
pub const DNS_ERROR_DS_ZONE_ALREADY_EXISTS: u32 = 0x25F6;
pub const DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE: u32 = 0x25F7;
pub const DNS_ERROR_NODE_IS_DNAME: u32 = 0x25F8;
pub const DNS_ERROR_DNAME_COLLISION: u32 = 0x25F9;
pub const DNS_ERROR_ALIAS_LOOP: u32 = 0x25FA;
pub const DNS_ERROR_OPERATION_BASE: u32 = 0x2616;
pub const DNS_ERROR_AXFR: u32 = 0x2618;
pub const DNS_ERROR_SECURE_BASE: u32 = 0x2648;
pub const DNS_ERROR_SETUP_BASE: u32 = 0x267A;
pub const DNS_ERROR_NO_TCPIP: u32 = 0x267B;
pub const DNS_ERROR_NO_DNS_SERVERS: u32 = 0x267C;
pub const DNS_ERROR_DP_BASE: u32 = 0x26AC;
pub const DNS_ERROR_DP_DOES_NOT_EXIST: u32 = 0x26AD;
pub const DNS_ERROR_DP_ALREADY_EXISTS: u32 = 0x26AE;
pub const DNS_ERROR_DP_NOT_ENLISTED: u32 = 0x26AF;
pub const DNS_ERROR_DP_ALREADY_ENLISTED: u32 = 0x26B0;
pub const DNS_ERROR_DP_NOT_AVAILABLE: u32 = 0x26B1;
pub const DNS_ERROR_DP_FSMO_ERROR: u32 = 0x26B2;
pub const DNS_ERROR_RRL_NOT_ENABLED: u32 = 0x26B7;
pub const DNS_ERROR_RRL_INVALID_WINDOW_SIZE: u32 = 0x26B8;
pub const DNS_ERROR_RRL_INVALID_IPV4_PREFIX: u32 = 0x26B9;
pub const DNS_ERROR_RRL_INVALID_IPV6_PREFIX: u32 = 0x26BA;
pub const DNS_ERROR_RRL_INVALID_TC_RATE: u32 = 0x26BB;
pub const DNS_ERROR_RRL_INVALID_LEAK_RATE: u32 = 0x26BC;
pub const DNS_ERROR_RRL_LEAK_RATE_LESSTHAN_TC_RATE: u32 = 0x26BD;
pub const DNS_ERROR_VIRTUALIZATION_INSTANCE_ALREADY_EXISTS: u32 = 0x26C1;
pub const DNS_ERROR_VIRTUALIZATION_INSTANCE_DOES_NOT_EXIST: u32 = 0x26C2;
pub const DNS_ERROR_VIRTUALIZATION_TREE_LOCKED: u32 = 0x26C3;
pub const DNS_ERROR_INVAILD_VIRTUALIZATION_INSTANCE_NAME: u32 = 0x26C4;
pub const DNS_ERROR_DEFAULT_VIRTUALIZATION_INSTANCE: u32 = 0x26C5;
pub const DNS_ERROR_ZONESCOPE_ALREADY_EXISTS: u32 = 0x26DF;
pub const DNS_ERROR_ZONESCOPE_DOES_NOT_EXIST: u32 = 0x26E0;
pub const DNS_ERROR_DEFAULT_ZONESCOPE: u32 = 0x26E1;
pub const DNS_ERROR_INVALID_ZONESCOPE_NAME: u32 = 0x26E2;
pub const DNS_ERROR_NOT_ALLOWED_WITH_ZONESCOPES: u32 = 0x26E3;
pub const DNS_ERROR_LOAD_ZONESCOPE_FAILED: u32 = 0x26E4;
pub const DNS_ERROR_ZONESCOPE_FILE_WRITEBACK_FAILED: u32 = 0x26E5;
pub const DNS_ERROR_INVALID_SCOPE_NAME: u32 = 0x26E6;
pub const DNS_ERROR_SCOPE_DOES_NOT_EXIST: u32 = 0x26E7;
pub const DNS_ERROR_DEFAULT_SCOPE: u32 = 0x26E8;
pub const DNS_ERROR_INVALID_SCOPE_OPERATION: u32 = 0x26E9;
pub const DNS_ERROR_SCOPE_LOCKED: u32 = 0x26EA;
pub const DNS_ERROR_SCOPE_ALREADY_EXISTS: u32 = 0x26EB;
pub const DNS_ERROR_POLICY_ALREADY_EXISTS: u32 = 0x26F3;
pub const DNS_ERROR_POLICY_DOES_NOT_EXIST: u32 = 0x26F4;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA: u32 = 0x26F5;
pub const DNS_ERROR_POLICY_INVALID_SETTINGS: u32 = 0x26F6;
pub const DNS_ERROR_CLIENT_SUBNET_IS_ACCESSED: u32 = 0x26F7;
pub const DNS_ERROR_CLIENT_SUBNET_DOES_NOT_EXIST: u32 = 0x26F8;
pub const DNS_ERROR_CLIENT_SUBNET_ALREADY_EXISTS: u32 = 0x26F9;
pub const DNS_ERROR_SUBNET_DOES_NOT_EXIST: u32 = 0x26FA;
pub const DNS_ERROR_SUBNET_ALREADY_EXISTS: u32 = 0x26FB;
pub const DNS_ERROR_POLICY_LOCKED: u32 = 0x26FC;
pub const DNS_ERROR_POLICY_INVALID_WEIGHT: u32 = 0x26FD;
pub const DNS_ERROR_POLICY_INVALID_NAME: u32 = 0x26FE;
pub const DNS_ERROR_POLICY_MISSING_CRITERIA: u32 = 0x26FF;
pub const DNS_ERROR_INVALID_CLIENT_SUBNET_NAME: u32 = 0x2700;
pub const DNS_ERROR_POLICY_PROCESSING_ORDER_INVALID: u32 = 0x2701;
pub const DNS_ERROR_POLICY_SCOPE_MISSING: u32 = 0x2702;
pub const DNS_ERROR_POLICY_SCOPE_NOT_ALLOWED: u32 = 0x2703;
pub const DNS_ERROR_SERVERSCOPE_IS_REFERENCED: u32 = 0x2704;
pub const DNS_ERROR_ZONESCOPE_IS_REFERENCED: u32 = 0x2705;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_CLIENT_SUBNET: u32 = 0x2706;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_TRANSPORT_PROTOCOL: u32 = 0x2707;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_NETWORK_PROTOCOL: u32 = 0x2708;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_INTERFACE: u32 = 0x2709;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_FQDN: u32 = 0x270A;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_QUERY_TYPE: u32 = 0x270B;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_TIME_OF_DAY: u32 = 0x270C;
pub const ERROR_IPSEC_QM_POLICY_EXISTS: u32 = 0x32C8;
pub const ERROR_IPSEC_QM_POLICY_NOT_FOUND: u32 = 0x32C9;
pub const ERROR_IPSEC_QM_POLICY_IN_USE: u32 = 0x32CA;
pub const ERROR_IPSEC_MM_POLICY_EXISTS: u32 = 0x32CB;
pub const ERROR_IPSEC_MM_POLICY_NOT_FOUND: u32 = 0x32CC;
pub const ERROR_IPSEC_MM_POLICY_IN_USE: u32 = 0x32CD;
pub const ERROR_IPSEC_MM_FILTER_EXISTS: u32 = 0x32CE;
pub const ERROR_IPSEC_MM_FILTER_NOT_FOUND: u32 = 0x32CF;
pub const ERROR_IPSEC_TRANSPORT_FILTER_EXISTS: u32 = 0x32D0;
pub const ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND: u32 = 0x32D1;
pub const ERROR_IPSEC_MM_AUTH_EXISTS: u32 = 0x32D2;
pub const ERROR_IPSEC_MM_AUTH_NOT_FOUND: u32 = 0x32D3;
pub const ERROR_IPSEC_MM_AUTH_IN_USE: u32 = 0x32D4;
pub const ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND: u32 = 0x32D5;
pub const ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND: u32 = 0x32D6;
pub const ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND: u32 = 0x32D7;
pub const ERROR_IPSEC_TUNNEL_FILTER_EXISTS: u32 = 0x32D8;
pub const ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND: u32 = 0x32D9;
pub const ERROR_IPSEC_MM_FILTER_PENDING_DELETION: u32 = 0x32DA;
pub const ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION: u32 = 0x32DB;
pub const ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION: u32 = 0x32DC;
pub const ERROR_IPSEC_MM_POLICY_PENDING_DELETION: u32 = 0x32DD;
pub const ERROR_IPSEC_MM_AUTH_PENDING_DELETION: u32 = 0x32DE;
pub const ERROR_IPSEC_QM_POLICY_PENDING_DELETION: u32 = 0x32DF;
pub const ERROR_IPSEC_IKE_NEG_STATUS_BEGIN: u32 = 0x35E8;
pub const ERROR_IPSEC_IKE_AUTH_FAIL: u32 = 0x35E9;
pub const ERROR_IPSEC_IKE_ATTRIB_FAIL: u32 = 0x35EA;
pub const ERROR_IPSEC_IKE_NEGOTIATION_PENDING: u32 = 0x35EB;
pub const ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR: u32 = 0x35EC;
pub const ERROR_IPSEC_IKE_TIMED_OUT: u32 = 0x35ED;
pub const ERROR_IPSEC_IKE_NO_CERT: u32 = 0x35EE;
pub const ERROR_IPSEC_IKE_SA_DELETED: u32 = 0x35EF;
pub const ERROR_IPSEC_IKE_SA_REAPED: u32 = 0x35F0;
pub const ERROR_IPSEC_IKE_MM_ACQUIRE_DROP: u32 = 0x35F1;
pub const ERROR_IPSEC_IKE_QM_ACQUIRE_DROP: u32 = 0x35F2;
pub const ERROR_IPSEC_IKE_QUEUE_DROP_MM: u32 = 0x35F3;
pub const ERROR_IPSEC_IKE_QUEUE_DROP_NO_MM: u32 = 0x35F4;
pub const ERROR_IPSEC_IKE_DROP_NO_RESPONSE: u32 = 0x35F5;
pub const ERROR_IPSEC_IKE_MM_DELAY_DROP: u32 = 0x35F6;
pub const ERROR_IPSEC_IKE_QM_DELAY_DROP: u32 = 0x35F7;
pub const ERROR_IPSEC_IKE_ERROR: u32 = 0x35F8;
pub const ERROR_IPSEC_IKE_CRL_FAILED: u32 = 0x35F9;
pub const ERROR_IPSEC_IKE_INVALID_KEY_USAGE: u32 = 0x35FA;
pub const ERROR_IPSEC_IKE_INVALID_CERT_TYPE: u32 = 0x35FB;
pub const ERROR_IPSEC_IKE_NO_PRIVATE_KEY: u32 = 0x35FC;
pub const ERROR_IPSEC_IKE_SIMULTANEOUS_REKEY: u32 = 0x35FD;
pub const ERROR_IPSEC_IKE_DH_FAIL: u32 = 0x35FE;
pub const ERROR_IPSEC_IKE_CRITICAL_PAYLOAD_NOT_RECOGNIZED: u32 = 0x35FF;
pub const ERROR_IPSEC_IKE_INVALID_HEADER: u32 = 0x3600;
pub const ERROR_IPSEC_IKE_NO_POLICY: u32 = 0x3601;
pub const ERROR_IPSEC_IKE_INVALID_SIGNATURE: u32 = 0x3602;
pub const ERROR_IPSEC_IKE_KERBEROS_ERROR: u32 = 0x3603;
pub const ERROR_IPSEC_IKE_NO_PUBLIC_KEY: u32 = 0x3604;
pub const ERROR_IPSEC_IKE_PROCESS_ERR: u32 = 0x3605;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_SA: u32 = 0x3606;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_PROP: u32 = 0x3607;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_TRANS: u32 = 0x3608;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_KE: u32 = 0x3609;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_ID: u32 = 0x360A;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_CERT: u32 = 0x360B;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_CERT_REQ: u32 = 0x360C;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_HASH: u32 = 0x360D;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_SIG: u32 = 0x360E;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NONCE: u32 = 0x360F;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NOTIFY: u32 = 0x3610;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_DELETE: u32 = 0x3611;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_VENDOR: u32 = 0x3612;
pub const ERROR_IPSEC_IKE_INVALID_PAYLOAD: u32 = 0x3613;
pub const ERROR_IPSEC_IKE_LOAD_SOFT_SA: u32 = 0x3614;
pub const ERROR_IPSEC_IKE_SOFT_SA_TORN_DOWN: u32 = 0x3615;
pub const ERROR_IPSEC_IKE_INVALID_COOKIE: u32 = 0x3616;
pub const ERROR_IPSEC_IKE_NO_PEER_CERT: u32 = 0x3617;
pub const ERROR_IPSEC_IKE_PEER_CRL_FAILED: u32 = 0x3618;
pub const ERROR_IPSEC_IKE_POLICY_CHANGE: u32 = 0x3619;
pub const ERROR_IPSEC_IKE_NO_MM_POLICY: u32 = 0x361A;
pub const ERROR_IPSEC_IKE_NOTCBPRIV: u32 = 0x361B;
pub const ERROR_IPSEC_IKE_SECLOADFAIL: u32 = 0x361C;
pub const ERROR_IPSEC_IKE_FAILSSPINIT: u32 = 0x361D;
pub const ERROR_IPSEC_IKE_FAILQUERYSSP: u32 = 0x361E;
pub const ERROR_IPSEC_IKE_SRVACQFAIL: u32 = 0x361F;
pub const ERROR_IPSEC_IKE_SRVQUERYCRED: u32 = 0x3620;
pub const ERROR_IPSEC_IKE_GETSPIFAIL: u32 = 0x3621;
pub const ERROR_IPSEC_IKE_INVALID_FILTER: u32 = 0x3622;
pub const ERROR_IPSEC_IKE_OUT_OF_MEMORY: u32 = 0x3623;
pub const ERROR_IPSEC_IKE_ADD_UPDATE_KEY_FAILED: u32 = 0x3624;
pub const ERROR_IPSEC_IKE_INVALID_POLICY: u32 = 0x3625;
pub const ERROR_IPSEC_IKE_UNKNOWN_DOI: u32 = 0x3626;
pub const ERROR_IPSEC_IKE_INVALID_SITUATION: u32 = 0x3627;
pub const ERROR_IPSEC_IKE_DH_FAILURE: u32 = 0x3628;
pub const ERROR_IPSEC_IKE_INVALID_GROUP: u32 = 0x3629;
pub const ERROR_IPSEC_IKE_ENCRYPT: u32 = 0x362A;
pub const ERROR_IPSEC_IKE_DECRYPT: u32 = 0x362B;
pub const ERROR_IPSEC_IKE_POLICY_MATCH: u32 = 0x362C;
pub const ERROR_IPSEC_IKE_UNSUPPORTED_ID: u32 = 0x362D;
pub const ERROR_IPSEC_IKE_INVALID_HASH: u32 = 0x362E;
pub const ERROR_IPSEC_IKE_INVALID_HASH_ALG: u32 = 0x362F;
pub const ERROR_IPSEC_IKE_INVALID_HASH_SIZE: u32 = 0x3630;
pub const ERROR_IPSEC_IKE_INVALID_ENCRYPT_ALG: u32 = 0x3631;
pub const ERROR_IPSEC_IKE_INVALID_AUTH_ALG: u32 = 0x3632;
pub const ERROR_IPSEC_IKE_INVALID_SIG: u32 = 0x3633;
pub const ERROR_IPSEC_IKE_LOAD_FAILED: u32 = 0x3634;
pub const ERROR_IPSEC_IKE_RPC_DELETE: u32 = 0x3635;
pub const ERROR_IPSEC_IKE_BENIGN_REINIT: u32 = 0x3636;
pub const ERROR_IPSEC_IKE_INVALID_RESPONDER_LIFETIME_NOTIFY: u32 = 0x3637;
pub const ERROR_IPSEC_IKE_INVALID_MAJOR_VERSION: u32 = 0x3638;
pub const ERROR_IPSEC_IKE_INVALID_CERT_KEYLEN: u32 = 0x3639;
pub const ERROR_IPSEC_IKE_MM_LIMIT: u32 = 0x363A;
pub const ERROR_IPSEC_IKE_NEGOTIATION_DISABLED: u32 = 0x363B;
pub const ERROR_IPSEC_IKE_QM_LIMIT: u32 = 0x363C;
pub const ERROR_IPSEC_IKE_MM_EXPIRED: u32 = 0x363D;
pub const ERROR_IPSEC_IKE_PEER_MM_ASSUMED_INVALID: u32 = 0x363E;
pub const ERROR_IPSEC_IKE_CERT_CHAIN_POLICY_MISMATCH: u32 = 0x363F;
pub const ERROR_IPSEC_IKE_UNEXPECTED_MESSAGE_ID: u32 = 0x3640;
pub const ERROR_IPSEC_IKE_INVALID_AUTH_PAYLOAD: u32 = 0x3641;
pub const ERROR_IPSEC_IKE_DOS_COOKIE_SENT: u32 = 0x3642;
pub const ERROR_IPSEC_IKE_SHUTTING_DOWN: u32 = 0x3643;
pub const ERROR_IPSEC_IKE_CGA_AUTH_FAILED: u32 = 0x3644;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NATOA: u32 = 0x3645;
pub const ERROR_IPSEC_IKE_INVALID_MM_FOR_QM: u32 = 0x3646;
pub const ERROR_IPSEC_IKE_QM_EXPIRED: u32 = 0x3647;
pub const ERROR_IPSEC_IKE_TOO_MANY_FILTERS: u32 = 0x3648;
pub const ERROR_IPSEC_IKE_NEG_STATUS_END: u32 = 0x3649;
pub const ERROR_IPSEC_IKE_KILL_DUMMY_NAP_TUNNEL: u32 = 0x364A;
pub const ERROR_IPSEC_IKE_INNER_IP_ASSIGNMENT_FAILURE: u32 = 0x364B;
pub const ERROR_IPSEC_IKE_REQUIRE_CP_PAYLOAD_MISSING: u32 = 0x364C;
pub const ERROR_IPSEC_KEY_MODULE_IMPERSONATION_NEGOTIATION_PENDING: u32 = 0x364D;
pub const ERROR_IPSEC_IKE_COEXISTENCE_SUPPRESS: u32 = 0x364E;
pub const ERROR_IPSEC_IKE_RATELIMIT_DROP: u32 = 0x364F;
pub const ERROR_IPSEC_IKE_PEER_DOESNT_SUPPORT_MOBIKE: u32 = 0x3650;
pub const ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE: u32 = 0x3651;
pub const ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_FAILURE: u32 = 0x3652;
pub const ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE_WITH_OPTIONAL_RETRY: u32 = 0x3653;
pub const ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_AND_CERTMAP_FAILURE: u32 = 0x3654;
pub const ERROR_IPSEC_IKE_NEG_STATUS_EXTENDED_END: u32 = 0x3655;
pub const ERROR_IPSEC_BAD_SPI: u32 = 0x3656;
pub const ERROR_IPSEC_SA_LIFETIME_EXPIRED: u32 = 0x3657;
pub const ERROR_IPSEC_WRONG_SA: u32 = 0x3658;
pub const ERROR_IPSEC_REPLAY_CHECK_FAILED: u32 = 0x3659;
pub const ERROR_IPSEC_INVALID_PACKET: u32 = 0x365A;
pub const ERROR_IPSEC_INTEGRITY_CHECK_FAILED: u32 = 0x365B;
pub const ERROR_IPSEC_CLEAR_TEXT_DROP: u32 = 0x365C;
pub const ERROR_IPSEC_AUTH_FIREWALL_DROP: u32 = 0x365D;
pub const ERROR_IPSEC_THROTTLE_DROP: u32 = 0x365E;
pub const ERROR_IPSEC_DOSP_BLOCK: u32 = 0x3665;
pub const ERROR_IPSEC_DOSP_RECEIVED_MULTICAST: u32 = 0x3666;
pub const ERROR_IPSEC_DOSP_INVALID_PACKET: u32 = 0x3667;
pub const ERROR_IPSEC_DOSP_STATE_LOOKUP_FAILED: u32 = 0x3668;
pub const ERROR_IPSEC_DOSP_MAX_ENTRIES: u32 = 0x3669;
pub const ERROR_IPSEC_DOSP_KEYMOD_NOT_ALLOWED: u32 = 0x366A;
pub const ERROR_IPSEC_DOSP_NOT_INSTALLED: u32 = 0x366B;
pub const ERROR_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES: u32 = 0x366C;
pub const ERROR_SXS_SECTION_NOT_FOUND: u32 = 0x36B0;
pub const ERROR_SXS_CANT_GEN_ACTCTX: u32 = 0x36B1;
pub const ERROR_SXS_INVALID_ACTCTXDATA_FORMAT: u32 = 0x36B2;
pub const ERROR_SXS_ASSEMBLY_NOT_FOUND: u32 = 0x36B3;
pub const ERROR_SXS_MANIFEST_FORMAT_ERROR: u32 = 0x36B4;
pub const ERROR_SXS_MANIFEST_PARSE_ERROR: u32 = 0x36B5;
pub const ERROR_SXS_ACTIVATION_CONTEXT_DISABLED: u32 = 0x36B6;
pub const ERROR_SXS_KEY_NOT_FOUND: u32 = 0x36B7;
pub const ERROR_SXS_VERSION_CONFLICT: u32 = 0x36B8;
pub const ERROR_SXS_WRONG_SECTION_TYPE: u32 = 0x36B9;
pub const ERROR_SXS_THREAD_QUERIES_DISABLED: u32 = 0x36BA;
pub const ERROR_SXS_PROCESS_DEFAULT_ALREADY_SET: u32 = 0x36BB;
pub const ERROR_SXS_UNKNOWN_ENCODING_GROUP: u32 = 0x36BC;
pub const ERROR_SXS_UNKNOWN_ENCODING: u32 = 0x36BD;
pub const ERROR_SXS_INVALID_XML_NAMESPACE_URI: u32 = 0x36BE;
pub const ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED: u32 = 0x36BF;
pub const ERROR_SXS_LEAF_MANIFEST_DEPENDENCY_NOT_INSTALLED: u32 = 0x36C0;
pub const ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE: u32 = 0x36C1;
pub const ERROR_SXS_MANIFEST_MISSING_REQUIRED_DEFAULT_NAMESPACE: u32 = 0x36C2;
pub const ERROR_SXS_MANIFEST_INVALID_REQUIRED_DEFAULT_NAMESPACE: u32 = 0x36C3;
pub const ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT: u32 = 0x36C4;
pub const ERROR_SXS_DUPLICATE_DLL_NAME: u32 = 0x36C5;
pub const ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME: u32 = 0x36C6;
pub const ERROR_SXS_DUPLICATE_CLSID: u32 = 0x36C7;
pub const ERROR_SXS_DUPLICATE_IID: u32 = 0x36C8;
pub const ERROR_SXS_DUPLICATE_TLBID: u32 = 0x36C9;
pub const ERROR_SXS_DUPLICATE_PROGID: u32 = 0x36CA;
pub const ERROR_SXS_DUPLICATE_ASSEMBLY_NAME: u32 = 0x36CB;
pub const ERROR_SXS_FILE_HASH_MISMATCH: u32 = 0x36CC;
pub const ERROR_SXS_POLICY_PARSE_ERROR: u32 = 0x36CD;
pub const ERROR_SXS_XML_E_MISSINGQUOTE: u32 = 0x36CE;
pub const ERROR_SXS_XML_E_COMMENTSYNTAX: u32 = 0x36CF;
pub const ERROR_SXS_XML_E_BADSTARTNAMECHAR: u32 = 0x36D0;
pub const ERROR_SXS_XML_E_BADNAMECHAR: u32 = 0x36D1;
pub const ERROR_SXS_XML_E_BADCHARINSTRING: u32 = 0x36D2;
pub const ERROR_SXS_XML_E_XMLDECLSYNTAX: u32 = 0x36D3;
pub const ERROR_SXS_XML_E_BADCHARDATA: u32 = 0x36D4;
pub const ERROR_SXS_XML_E_MISSINGWHITESPACE: u32 = 0x36D5;
pub const ERROR_SXS_XML_E_EXPECTINGTAGEND: u32 = 0x36D6;
pub const ERROR_SXS_XML_E_MISSINGSEMICOLON: u32 = 0x36D7;
pub const ERROR_SXS_XML_E_UNBALANCEDPAREN: u32 = 0x36D8;
pub const ERROR_SXS_XML_E_INTERNALERROR: u32 = 0x36D9;
pub const ERROR_SXS_XML_E_UNEXPECTED_WHITESPACE: u32 = 0x36DA;
pub const ERROR_SXS_XML_E_INCOMPLETE_ENCODING: u32 = 0x36DB;
pub const ERROR_SXS_XML_E_MISSING_PAREN: u32 = 0x36DC;
pub const ERROR_SXS_XML_E_EXPECTINGCLOSEQUOTE: u32 = 0x36DD;
pub const ERROR_SXS_XML_E_MULTIPLE_COLONS: u32 = 0x36DE;
pub const ERROR_SXS_XML_E_INVALID_DECIMAL: u32 = 0x36DF;
pub const ERROR_SXS_XML_E_INVALID_HEXIDECIMAL: u32 = 0x36E0;
pub const ERROR_SXS_XML_E_INVALID_UNICODE: u32 = 0x36E1;
pub const ERROR_SXS_XML_E_WHITESPACEORQUESTIONMARK: u32 = 0x36E2;
pub const ERROR_SXS_XML_E_UNEXPECTEDENDTAG: u32 = 0x36E3;
pub const ERROR_SXS_XML_E_UNCLOSEDTAG: u32 = 0x36E4;
pub const ERROR_SXS_XML_E_DUPLICATEATTRIBUTE: u32 = 0x36E5;
pub const ERROR_SXS_XML_E_MULTIPLEROOTS: u32 = 0x36E6;
pub const ERROR_SXS_XML_E_INVALIDATROOTLEVEL: u32 = 0x36E7;
pub const ERROR_SXS_XML_E_BADXMLDECL: u32 = 0x36E8;
pub const ERROR_SXS_XML_E_MISSINGROOT: u32 = 0x36E9;
pub const ERROR_SXS_XML_E_UNEXPECTEDEOF: u32 = 0x36EA;
pub const ERROR_SXS_XML_E_BADPEREFINSUBSET: u32 = 0x36EB;
pub const ERROR_SXS_XML_E_UNCLOSEDSTARTTAG: u32 = 0x36EC;
pub const ERROR_SXS_XML_E_UNCLOSEDENDTAG: u32 = 0x36ED;
pub const ERROR_SXS_XML_E_UNCLOSEDSTRING: u32 = 0x36EE;
pub const ERROR_SXS_XML_E_UNCLOSEDCOMMENT: u32 = 0x36EF;
pub const ERROR_SXS_XML_E_UNCLOSEDDECL: u32 = 0x36F0;
pub const ERROR_SXS_XML_E_UNCLOSEDCDATA: u32 = 0x36F1;
pub const ERROR_SXS_XML_E_RESERVEDNAMESPACE: u32 = 0x36F2;
pub const ERROR_SXS_XML_E_INVALIDENCODING: u32 = 0x36F3;
pub const ERROR_SXS_XML_E_INVALIDSWITCH: u32 = 0x36F4;
pub const ERROR_SXS_XML_E_BADXMLCASE: u32 = 0x36F5;
pub const ERROR_SXS_XML_E_INVALID_STANDALONE: u32 = 0x36F6;
pub const ERROR_SXS_XML_E_UNEXPECTED_STANDALONE: u32 = 0x36F7;
pub const ERROR_SXS_XML_E_INVALID_VERSION: u32 = 0x36F8;
pub const ERROR_SXS_XML_E_MISSINGEQUALS: u32 = 0x36F9;
pub const ERROR_SXS_PROTECTION_RECOVERY_FAILED: u32 = 0x36FA;
pub const ERROR_SXS_PROTECTION_PUBLIC_KEY_TOO_SHORT: u32 = 0x36FB;
pub const ERROR_SXS_PROTECTION_CATALOG_NOT_VALID: u32 = 0x36FC;
pub const ERROR_SXS_UNTRANSLATABLE_HRESULT: u32 = 0x36FD;
pub const ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING: u32 = 0x36FE;
pub const ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE: u32 = 0x36FF;
pub const ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME: u32 = 0x3700;
pub const ERROR_SXS_ASSEMBLY_MISSING: u32 = 0x3701;
pub const ERROR_SXS_CORRUPT_ACTIVATION_STACK: u32 = 0x3702;
pub const ERROR_SXS_CORRUPTION: u32 = 0x3703;
pub const ERROR_SXS_EARLY_DEACTIVATION: u32 = 0x3704;
pub const ERROR_SXS_INVALID_DEACTIVATION: u32 = 0x3705;
pub const ERROR_SXS_MULTIPLE_DEACTIVATION: u32 = 0x3706;
pub const ERROR_SXS_PROCESS_TERMINATION_REQUESTED: u32 = 0x3707;
pub const ERROR_SXS_RELEASE_ACTIVATION_CONTEXT: u32 = 0x3708;
pub const ERROR_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY: u32 = 0x3709;
pub const ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE: u32 = 0x370A;
pub const ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME: u32 = 0x370B;
pub const ERROR_SXS_IDENTITY_DUPLICATE_ATTRIBUTE: u32 = 0x370C;
pub const ERROR_SXS_IDENTITY_PARSE_ERROR: u32 = 0x370D;
pub const ERROR_MALFORMED_SUBSTITUTION_STRING: u32 = 0x370E;
pub const ERROR_SXS_INCORRECT_PUBLIC_KEY_TOKEN: u32 = 0x370F;
pub const ERROR_UNMAPPED_SUBSTITUTION_STRING: u32 = 0x3710;
pub const ERROR_SXS_ASSEMBLY_NOT_LOCKED: u32 = 0x3711;
pub const ERROR_SXS_COMPONENT_STORE_CORRUPT: u32 = 0x3712;
pub const ERROR_ADVANCED_INSTALLER_FAILED: u32 = 0x3713;
pub const ERROR_XML_ENCODING_MISMATCH: u32 = 0x3714;
pub const ERROR_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT: u32 = 0x3715;
pub const ERROR_SXS_IDENTITIES_DIFFERENT: u32 = 0x3716;
pub const ERROR_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT: u32 = 0x3717;
pub const ERROR_SXS_FILE_NOT_PART_OF_ASSEMBLY: u32 = 0x3718;
pub const ERROR_SXS_MANIFEST_TOO_BIG: u32 = 0x3719;
pub const ERROR_SXS_SETTING_NOT_REGISTERED: u32 = 0x371A;
pub const ERROR_SXS_TRANSACTION_CLOSURE_INCOMPLETE: u32 = 0x371B;
pub const ERROR_SMI_PRIMITIVE_INSTALLER_FAILED: u32 = 0x371C;
pub const ERROR_GENERIC_COMMAND_FAILED: u32 = 0x371D;
pub const ERROR_SXS_FILE_HASH_MISSING: u32 = 0x371E;
pub const ERROR_SXS_DUPLICATE_ACTIVATABLE_CLASS: u32 = 0x371F;
pub const ERROR_EVT_INVALID_CHANNEL_PATH: u32 = 0x3A98;
pub const ERROR_EVT_INVALID_QUERY: u32 = 0x3A99;
pub const ERROR_EVT_PUBLISHER_METADATA_NOT_FOUND: u32 = 0x3A9A;
pub const ERROR_EVT_EVENT_TEMPLATE_NOT_FOUND: u32 = 0x3A9B;
pub const ERROR_EVT_INVALID_PUBLISHER_NAME: u32 = 0x3A9C;
pub const ERROR_EVT_INVALID_EVENT_DATA: u32 = 0x3A9D;
pub const ERROR_EVT_CHANNEL_NOT_FOUND: u32 = 0x3A9F;
pub const ERROR_EVT_MALFORMED_XML_TEXT: u32 = 0x3AA0;
pub const ERROR_EVT_SUBSCRIPTION_TO_DIRECT_CHANNEL: u32 = 0x3AA1;
pub const ERROR_EVT_CONFIGURATION_ERROR: u32 = 0x3AA2;
pub const ERROR_EVT_QUERY_RESULT_STALE: u32 = 0x3AA3;
pub const ERROR_EVT_QUERY_RESULT_INVALID_POSITION: u32 = 0x3AA4;
pub const ERROR_EVT_NON_VALIDATING_MSXML: u32 = 0x3AA5;
pub const ERROR_EVT_FILTER_ALREADYSCOPED: u32 = 0x3AA6;
pub const ERROR_EVT_FILTER_NOTELTSET: u32 = 0x3AA7;
pub const ERROR_EVT_FILTER_INVARG: u32 = 0x3AA8;
pub const ERROR_EVT_FILTER_INVTEST: u32 = 0x3AA9;
pub const ERROR_EVT_FILTER_INVTYPE: u32 = 0x3AAA;
pub const ERROR_EVT_FILTER_PARSEERR: u32 = 0x3AAB;
pub const ERROR_EVT_FILTER_UNSUPPORTEDOP: u32 = 0x3AAC;
pub const ERROR_EVT_FILTER_UNEXPECTEDTOKEN: u32 = 0x3AAD;
pub const ERROR_EVT_INVALID_OPERATION_OVER_ENABLED_DIRECT_CHANNEL: u32 = 0x3AAE;
pub const ERROR_EVT_INVALID_CHANNEL_PROPERTY_VALUE: u32 = 0x3AAF;
pub const ERROR_EVT_INVALID_PUBLISHER_PROPERTY_VALUE: u32 = 0x3AB0;
pub const ERROR_EVT_CHANNEL_CANNOT_ACTIVATE: u32 = 0x3AB1;
pub const ERROR_EVT_FILTER_TOO_COMPLEX: u32 = 0x3AB2;
pub const ERROR_EVT_MESSAGE_NOT_FOUND: u32 = 0x3AB3;
pub const ERROR_EVT_MESSAGE_ID_NOT_FOUND: u32 = 0x3AB4;
pub const ERROR_EVT_UNRESOLVED_VALUE_INSERT: u32 = 0x3AB5;
pub const ERROR_EVT_UNRESOLVED_PARAMETER_INSERT: u32 = 0x3AB6;
pub const ERROR_EVT_MAX_INSERTS_REACHED: u32 = 0x3AB7;
pub const ERROR_EVT_EVENT_DEFINITION_NOT_FOUND: u32 = 0x3AB8;
pub const ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND: u32 = 0x3AB9;
pub const ERROR_EVT_VERSION_TOO_OLD: u32 = 0x3ABA;
pub const ERROR_EVT_VERSION_TOO_NEW: u32 = 0x3ABB;
pub const ERROR_EVT_CANNOT_OPEN_CHANNEL_OF_QUERY: u32 = 0x3ABC;
pub const ERROR_EVT_PUBLISHER_DISABLED: u32 = 0x3ABD;
pub const ERROR_EVT_FILTER_OUT_OF_RANGE: u32 = 0x3ABE;
pub const ERROR_EC_SUBSCRIPTION_CANNOT_ACTIVATE: u32 = 0x3AE8;
pub const ERROR_EC_LOG_DISABLED: u32 = 0x3AE9;
pub const ERROR_EC_CIRCULAR_FORWARDING: u32 = 0x3AEA;
pub const ERROR_EC_CREDSTORE_FULL: u32 = 0x3AEB;
pub const ERROR_EC_CRED_NOT_FOUND: u32 = 0x3AEC;
pub const ERROR_EC_NO_ACTIVE_CHANNEL: u32 = 0x3AED;
pub const ERROR_MUI_FILE_NOT_FOUND: u32 = 0x3AFC;
pub const ERROR_MUI_INVALID_FILE: u32 = 0x3AFD;
pub const ERROR_MUI_INVALID_RC_CONFIG: u32 = 0x3AFE;
pub const ERROR_MUI_INVALID_LOCALE_NAME: u32 = 0x3AFF;
pub const ERROR_MUI_INVALID_ULTIMATEFALLBACK_NAME: u32 = 0x3B00;
pub const ERROR_MUI_FILE_NOT_LOADED: u32 = 0x3B01;
pub const ERROR_RESOURCE_ENUM_USER_STOP: u32 = 0x3B02;
pub const ERROR_MUI_INTLSETTINGS_UILANG_NOT_INSTALLED: u32 = 0x3B03;
pub const ERROR_MUI_INTLSETTINGS_INVALID_LOCALE_NAME: u32 = 0x3B04;
pub const ERROR_MRM_RUNTIME_NO_DEFAULT_OR_NEUTRAL_RESOURCE: u32 = 0x3B06;
pub const ERROR_MRM_INVALID_PRICONFIG: u32 = 0x3B07;
pub const ERROR_MRM_INVALID_FILE_TYPE: u32 = 0x3B08;
pub const ERROR_MRM_UNKNOWN_QUALIFIER: u32 = 0x3B09;
pub const ERROR_MRM_INVALID_QUALIFIER_VALUE: u32 = 0x3B0A;
pub const ERROR_MRM_NO_CANDIDATE: u32 = 0x3B0B;
pub const ERROR_MRM_NO_MATCH_OR_DEFAULT_CANDIDATE: u32 = 0x3B0C;
pub const ERROR_MRM_RESOURCE_TYPE_MISMATCH: u32 = 0x3B0D;
pub const ERROR_MRM_DUPLICATE_MAP_NAME: u32 = 0x3B0E;
pub const ERROR_MRM_DUPLICATE_ENTRY: u32 = 0x3B0F;
pub const ERROR_MRM_INVALID_RESOURCE_IDENTIFIER: u32 = 0x3B10;
pub const ERROR_MRM_FILEPATH_TOO_LONG: u32 = 0x3B11;
pub const ERROR_MRM_UNSUPPORTED_DIRECTORY_TYPE: u32 = 0x3B12;
pub const ERROR_MRM_INVALID_PRI_FILE: u32 = 0x3B16;
pub const ERROR_MRM_NAMED_RESOURCE_NOT_FOUND: u32 = 0x3B17;
pub const ERROR_MRM_MAP_NOT_FOUND: u32 = 0x3B1F;
pub const ERROR_MRM_UNSUPPORTED_PROFILE_TYPE: u32 = 0x3B20;
pub const ERROR_MRM_INVALID_QUALIFIER_OPERATOR: u32 = 0x3B21;
pub const ERROR_MRM_INDETERMINATE_QUALIFIER_VALUE: u32 = 0x3B22;
pub const ERROR_MRM_AUTOMERGE_ENABLED: u32 = 0x3B23;
pub const ERROR_MRM_TOO_MANY_RESOURCES: u32 = 0x3B24;
pub const ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_MERGE: u32 = 0x3B25;
pub const ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_LOAD_UNLOAD_PRI_FILE: u32 = 0x3B26;
pub const ERROR_MRM_NO_CURRENT_VIEW_ON_THREAD: u32 = 0x3B27;
pub const ERROR_DIFFERENT_PROFILE_RESOURCE_MANAGER_EXIST: u32 = 0x3B28;
pub const ERROR_OPERATION_NOT_ALLOWED_FROM_SYSTEM_COMPONENT: u32 = 0x3B29;
pub const ERROR_MRM_DIRECT_REF_TO_NON_DEFAULT_RESOURCE: u32 = 0x3B2A;
pub const ERROR_MRM_GENERATION_COUNT_MISMATCH: u32 = 0x3B2B;
pub const ERROR_PRI_MERGE_VERSION_MISMATCH: u32 = 0x3B2C;
pub const ERROR_PRI_MERGE_MISSING_SCHEMA: u32 = 0x3B2D;
pub const ERROR_PRI_MERGE_LOAD_FILE_FAILED: u32 = 0x3B2E;
pub const ERROR_PRI_MERGE_ADD_FILE_FAILED: u32 = 0x3B2F;
pub const ERROR_PRI_MERGE_WRITE_FILE_FAILED: u32 = 0x3B30;
pub const ERROR_PRI_MERGE_MULTIPLE_PACKAGE_FAMILIES_NOT_ALLOWED: u32 = 0x3B31;
pub const ERROR_PRI_MERGE_MULTIPLE_MAIN_PACKAGES_NOT_ALLOWED: u32 = 0x3B32;
pub const ERROR_PRI_MERGE_BUNDLE_PACKAGES_NOT_ALLOWED: u32 = 0x3B33;
pub const ERROR_PRI_MERGE_MAIN_PACKAGE_REQUIRED: u32 = 0x3B34;
pub const ERROR_PRI_MERGE_RESOURCE_PACKAGE_REQUIRED: u32 = 0x3B35;
pub const ERROR_PRI_MERGE_INVALID_FILE_NAME: u32 = 0x3B36;
pub const ERROR_MRM_PACKAGE_NOT_FOUND: u32 = 0x3B37;
pub const ERROR_MRM_MISSING_DEFAULT_LANGUAGE: u32 = 0x3B38;
pub const ERROR_MCA_INVALID_CAPABILITIES_STRING: u32 = 0x3B60;
pub const ERROR_MCA_INVALID_VCP_VERSION: u32 = 0x3B61;
pub const ERROR_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION: u32 = 0x3B62;
pub const ERROR_MCA_MCCS_VERSION_MISMATCH: u32 = 0x3B63;
pub const ERROR_MCA_UNSUPPORTED_MCCS_VERSION: u32 = 0x3B64;
pub const ERROR_MCA_INTERNAL_ERROR: u32 = 0x3B65;
pub const ERROR_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED: u32 = 0x3B66;
pub const ERROR_MCA_UNSUPPORTED_COLOR_TEMPERATURE: u32 = 0x3B67;
pub const ERROR_AMBIGUOUS_SYSTEM_DEVICE: u32 = 0x3B92;
pub const ERROR_SYSTEM_DEVICE_NOT_FOUND: u32 = 0x3BC3;
pub const ERROR_HASH_NOT_SUPPORTED: u32 = 0x3BC4;
pub const ERROR_HASH_NOT_PRESENT: u32 = 0x3BC5;
pub const ERROR_SECONDARY_IC_PROVIDER_NOT_REGISTERED: u32 = 0x3BD9;
pub const ERROR_GPIO_CLIENT_INFORMATION_INVALID: u32 = 0x3BDA;
pub const ERROR_GPIO_VERSION_NOT_SUPPORTED: u32 = 0x3BDB;
pub const ERROR_GPIO_INVALID_REGISTRATION_PACKET: u32 = 0x3BDC;
pub const ERROR_GPIO_OPERATION_DENIED: u32 = 0x3BDD;
pub const ERROR_GPIO_INCOMPATIBLE_CONNECT_MODE: u32 = 0x3BDE;
pub const ERROR_GPIO_INTERRUPT_ALREADY_UNMASKED: u32 = 0x3BDF;
pub const ERROR_CANNOT_SWITCH_RUNLEVEL: u32 = 0x3C28;
pub const ERROR_INVALID_RUNLEVEL_SETTING: u32 = 0x3C29;
pub const ERROR_RUNLEVEL_SWITCH_TIMEOUT: u32 = 0x3C2A;
pub const ERROR_RUNLEVEL_SWITCH_AGENT_TIMEOUT: u32 = 0x3C2B;
pub const ERROR_RUNLEVEL_SWITCH_IN_PROGRESS: u32 = 0x3C2C;
pub const ERROR_SERVICES_FAILED_AUTOSTART: u32 = 0x3C2D;
pub const ERROR_COM_TASK_STOP_PENDING: u32 = 0x3C8D;
pub const ERROR_INSTALL_OPEN_PACKAGE_FAILED: u32 = 0x3CF0;
pub const ERROR_INSTALL_PACKAGE_NOT_FOUND: u32 = 0x3CF1;
pub const ERROR_INSTALL_INVALID_PACKAGE: u32 = 0x3CF2;
pub const ERROR_INSTALL_RESOLVE_DEPENDENCY_FAILED: u32 = 0x3CF3;
pub const ERROR_INSTALL_OUT_OF_DISK_SPACE: u32 = 0x3CF4;
pub const ERROR_INSTALL_NETWORK_FAILURE: u32 = 0x3CF5;
pub const ERROR_INSTALL_REGISTRATION_FAILURE: u32 = 0x3CF6;
pub const ERROR_INSTALL_DEREGISTRATION_FAILURE: u32 = 0x3CF7;
pub const ERROR_INSTALL_CANCEL: u32 = 0x3CF8;
pub const ERROR_INSTALL_FAILED: u32 = 0x3CF9;
pub const ERROR_REMOVE_FAILED: u32 = 0x3CFA;
pub const ERROR_PACKAGE_ALREADY_EXISTS: u32 = 0x3CFB;
pub const ERROR_NEEDS_REMEDIATION: u32 = 0x3CFC;
pub const ERROR_INSTALL_PREREQUISITE_FAILED: u32 = 0x3CFD;
pub const ERROR_PACKAGE_REPOSITORY_CORRUPTED: u32 = 0x3CFE;
pub const ERROR_INSTALL_POLICY_FAILURE: u32 = 0x3CFF;
pub const ERROR_PACKAGE_UPDATING: u32 = 0x3D00;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_POLICY: u32 = 0x3D01;
pub const ERROR_PACKAGES_IN_USE: u32 = 0x3D02;
pub const ERROR_RECOVERY_FILE_CORRUPT: u32 = 0x3D03;
pub const ERROR_INVALID_STAGED_SIGNATURE: u32 = 0x3D04;
pub const ERROR_DELETING_EXISTING_APPLICATIONDATA_STORE_FAILED: u32 = 0x3D05;
pub const ERROR_INSTALL_PACKAGE_DOWNGRADE: u32 = 0x3D06;
pub const ERROR_SYSTEM_NEEDS_REMEDIATION: u32 = 0x3D07;
pub const ERROR_APPX_INTEGRITY_FAILURE_CLR_NGEN: u32 = 0x3D08;
pub const ERROR_RESILIENCY_FILE_CORRUPT: u32 = 0x3D09;
pub const ERROR_INSTALL_FIREWALL_SERVICE_NOT_RUNNING: u32 = 0x3D0A;
pub const ERROR_PACKAGE_MOVE_FAILED: u32 = 0x3D0B;
pub const ERROR_INSTALL_VOLUME_NOT_EMPTY: u32 = 0x3D0C;
pub const ERROR_INSTALL_VOLUME_OFFLINE: u32 = 0x3D0D;
pub const ERROR_INSTALL_VOLUME_CORRUPT: u32 = 0x3D0E;
pub const ERROR_NEEDS_REGISTRATION: u32 = 0x3D0F;
pub const ERROR_INSTALL_WRONG_PROCESSOR_ARCHITECTURE: u32 = 0x3D10;
pub const ERROR_DEV_SIDELOAD_LIMIT_EXCEEDED: u32 = 0x3D11;
pub const ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE: u32 = 0x3D12;
pub const ERROR_PACKAGE_NOT_SUPPORTED_ON_FILESYSTEM: u32 = 0x3D13;
pub const ERROR_PACKAGE_MOVE_BLOCKED_BY_STREAMING: u32 = 0x3D14;
pub const ERROR_INSTALL_OPTIONAL_PACKAGE_APPLICATIONID_NOT_UNIQUE: u32 = 0x3D15;
pub const ERROR_PACKAGE_STAGING_ONHOLD: u32 = 0x3D16;
pub const ERROR_INSTALL_INVALID_RELATED_SET_UPDATE: u32 = 0x3D17;
pub const ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_FULLTRUST_CAPABILITY: u32 = 0x3D18;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_USER_LOG_OFF: u32 = 0x3D19;
pub const ERROR_PROVISION_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_PROVISIONED: u32 = 0x3D1A;
pub const ERROR_PACKAGES_REPUTATION_CHECK_FAILED: u32 = 0x3D1B;
pub const ERROR_PACKAGES_REPUTATION_CHECK_TIMEDOUT: u32 = 0x3D1C;
pub const ERROR_DEPLOYMENT_OPTION_NOT_SUPPORTED: u32 = 0x3D1D;
pub const ERROR_APPINSTALLER_ACTIVATION_BLOCKED: u32 = 0x3D1E;
pub const ERROR_REGISTRATION_FROM_REMOTE_DRIVE_NOT_SUPPORTED: u32 = 0x3D1F;
pub const ERROR_APPX_RAW_DATA_WRITE_FAILED: u32 = 0x3D20;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_VOLUME_POLICY_PACKAGE: u32 = 0x3D21;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_VOLUME_POLICY_MACHINE: u32 = 0x3D22;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_PROFILE_POLICY: u32 = 0x3D23;
pub const ERROR_DEPLOYMENT_FAILED_CONFLICTING_MUTABLE_PACKAGE_DIRECTORY: u32 = 0x3D24;
pub const ERROR_SINGLETON_RESOURCE_INSTALLED_IN_ACTIVE_USER: u32 = 0x3D25;
pub const ERROR_DIFFERENT_VERSION_OF_PACKAGED_SERVICE_INSTALLED: u32 = 0x3D26;
pub const ERROR_SERVICE_EXISTS_AS_NON_PACKAGED_SERVICE: u32 = 0x3D27;
pub const ERROR_PACKAGED_SERVICE_REQUIRES_ADMIN_PRIVILEGES: u32 = 0x3D28;
pub const ERROR_REDIRECTION_TO_DEFAULT_ACCOUNT_NOT_ALLOWED: u32 = 0x3D29;
pub const ERROR_PACKAGE_LACKS_CAPABILITY_TO_DEPLOY_ON_HOST: u32 = 0x3D2A;
pub const ERROR_UNSIGNED_PACKAGE_INVALID_CONTENT: u32 = 0x3D2B;
pub const ERROR_UNSIGNED_PACKAGE_INVALID_PUBLISHER_NAMESPACE: u32 = 0x3D2C;
pub const ERROR_SIGNED_PACKAGE_INVALID_PUBLISHER_NAMESPACE: u32 = 0x3D2D;
pub const ERROR_PACKAGE_EXTERNAL_LOCATION_NOT_ALLOWED: u32 = 0x3D2E;
pub const ERROR_INSTALL_FULLTRUST_HOSTRUNTIME_REQUIRES_MAIN_PACKAGE_FULLTRUST_CAPABILITY: u32 = 0x3D2F;
pub const ERROR_PACKAGE_LACKS_CAPABILITY_FOR_MANDATORY_STARTUPTASKS: u32 = 0x3D30;
pub const ERROR_INSTALL_RESOLVE_HOSTRUNTIME_DEPENDENCY_FAILED: u32 = 0x3D31;
pub const ERROR_MACHINE_SCOPE_NOT_ALLOWED: u32 = 0x3D32;
pub const ERROR_CLASSIC_COMPAT_MODE_NOT_ALLOWED: u32 = 0x3D33;
pub const ERROR_STAGEFROMUPDATEAGENT_PACKAGE_NOT_APPLICABLE: u32 = 0x3D34;
pub const ERROR_PACKAGE_NOT_REGISTERED_FOR_USER: u32 = 0x3D35;
pub const ERROR_STATE_LOAD_STORE_FAILED: u32 = 0x3DB8;
pub const ERROR_STATE_GET_VERSION_FAILED: u32 = 0x3DB9;
pub const ERROR_STATE_SET_VERSION_FAILED: u32 = 0x3DBA;
pub const ERROR_STATE_STRUCTURED_RESET_FAILED: u32 = 0x3DBB;
pub const ERROR_STATE_OPEN_CONTAINER_FAILED: u32 = 0x3DBC;
pub const ERROR_STATE_CREATE_CONTAINER_FAILED: u32 = 0x3DBD;
pub const ERROR_STATE_DELETE_CONTAINER_FAILED: u32 = 0x3DBE;
pub const ERROR_STATE_READ_SETTING_FAILED: u32 = 0x3DBF;
pub const ERROR_STATE_WRITE_SETTING_FAILED: u32 = 0x3DC0;
pub const ERROR_STATE_DELETE_SETTING_FAILED: u32 = 0x3DC1;
pub const ERROR_STATE_QUERY_SETTING_FAILED: u32 = 0x3DC2;
pub const ERROR_STATE_READ_COMPOSITE_SETTING_FAILED: u32 = 0x3DC3;
pub const ERROR_STATE_WRITE_COMPOSITE_SETTING_FAILED: u32 = 0x3DC4;
pub const ERROR_STATE_ENUMERATE_CONTAINER_FAILED: u32 = 0x3DC5;
pub const ERROR_STATE_ENUMERATE_SETTINGS_FAILED: u32 = 0x3DC6;
pub const ERROR_STATE_COMPOSITE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED: u32 = 0x3DC7;
pub const ERROR_STATE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED: u32 = 0x3DC8;
pub const ERROR_STATE_SETTING_NAME_SIZE_LIMIT_EXCEEDED: u32 = 0x3DC9;
pub const ERROR_STATE_CONTAINER_NAME_SIZE_LIMIT_EXCEEDED: u32 = 0x3DCA;
pub const ERROR_API_UNAVAILABLE: u32 = 0x3DE1;
pub const ERROR_NDIS_INTERFACE_CLOSING: u32 = 0x80340002;
pub const ERROR_NDIS_BAD_VERSION: u32 = 0x80340004;
pub const ERROR_NDIS_BAD_CHARACTERISTICS: u32 = 0x80340005;
pub const ERROR_NDIS_ADAPTER_NOT_FOUND: u32 = 0x80340006;
pub const ERROR_NDIS_OPEN_FAILED: u32 = 0x80340007;
pub const ERROR_NDIS_DEVICE_FAILED: u32 = 0x80340008;
pub const ERROR_NDIS_MULTICAST_FULL: u32 = 0x80340009;
pub const ERROR_NDIS_MULTICAST_EXISTS: u32 = 0x8034000A;
pub const ERROR_NDIS_MULTICAST_NOT_FOUND: u32 = 0x8034000B;
pub const ERROR_NDIS_REQUEST_ABORTED: u32 = 0x8034000C;
pub const ERROR_NDIS_RESET_IN_PROGRESS: u32 = 0x8034000D;
pub const ERROR_NDIS_NOT_SUPPORTED: u32 = 0x803400BB;
pub const ERROR_NDIS_INVALID_PACKET: u32 = 0x8034000F;
pub const ERROR_NDIS_ADAPTER_NOT_READY: u32 = 0x80340011;
pub const ERROR_NDIS_INVALID_LENGTH: u32 = 0x80340014;
pub const ERROR_NDIS_INVALID_DATA: u32 = 0x80340015;
pub const ERROR_NDIS_BUFFER_TOO_SHORT: u32 = 0x80340016;
pub const ERROR_NDIS_INVALID_OID: u32 = 0x80340017;
pub const ERROR_NDIS_ADAPTER_REMOVED: u32 = 0x80340018;
pub const ERROR_NDIS_UNSUPPORTED_MEDIA: u32 = 0x80340019;
pub const ERROR_NDIS_GROUP_ADDRESS_IN_USE: u32 = 0x8034001A;
pub const ERROR_NDIS_FILE_NOT_FOUND: u32 = 0x8034001B;
pub const ERROR_NDIS_ERROR_READING_FILE: u32 = 0x8034001C;
pub const ERROR_NDIS_ALREADY_MAPPED: u32 = 0x8034001D;
pub const ERROR_NDIS_RESOURCE_CONFLICT: u32 = 0x8034001E;
pub const ERROR_NDIS_MEDIA_DISCONNECTED: u32 = 0x8034001F;
pub const ERROR_NDIS_INVALID_ADDRESS: u32 = 0x80340022;
pub const ERROR_NDIS_INVALID_DEVICE_REQUEST: u32 = 0x80340010;
pub const ERROR_NDIS_PAUSED: u32 = 0x8034002A;
pub const ERROR_NDIS_INTERFACE_NOT_FOUND: u32 = 0x8034002B;
pub const ERROR_NDIS_UNSUPPORTED_REVISION: u32 = 0x8034002C;
pub const ERROR_NDIS_INVALID_PORT: u32 = 0x8034002D;
pub const ERROR_NDIS_INVALID_PORT_STATE: u32 = 0x8034002E;
pub const ERROR_NDIS_LOW_POWER_STATE: u32 = 0x8034002F;
pub const ERROR_NDIS_REINIT_REQUIRED: u32 = 0x80340030;
pub const ERROR_NDIS_NO_QUEUES: u32 = 0x80340031;
pub const ERROR_NDIS_DOT11_AUTO_CONFIG_ENABLED: u32 = 0x80342000;
pub const ERROR_NDIS_DOT11_MEDIA_IN_USE: u32 = 0x80342001;
pub const ERROR_NDIS_DOT11_POWER_STATE_INVALID: u32 = 0x80342002;
pub const ERROR_NDIS_PM_WOL_PATTERN_LIST_FULL: u32 = 0x80342003;
pub const ERROR_NDIS_PM_PROTOCOL_OFFLOAD_LIST_FULL: u32 = 0x80342004;
pub const ERROR_NDIS_DOT11_AP_CHANNEL_CURRENTLY_NOT_AVAILABLE: u32 = 0x80342005;
pub const ERROR_NDIS_DOT11_AP_BAND_CURRENTLY_NOT_AVAILABLE: u32 = 0x80342006;
pub const ERROR_NDIS_DOT11_AP_CHANNEL_NOT_ALLOWED: u32 = 0x80342007;
pub const ERROR_NDIS_DOT11_AP_BAND_NOT_ALLOWED: u32 = 0x80342008;
pub const ERROR_NDIS_INDICATION_REQUIRED: u32 = 0x340001;
pub const ERROR_NDIS_OFFLOAD_POLICY: u32 = 0xC034100F;
pub const ERROR_NDIS_OFFLOAD_CONNECTION_REJECTED: u32 = 0xC0341012;
pub const ERROR_NDIS_OFFLOAD_PATH_REJECTED: u32 = 0xC0341013;
pub const ERROR_HV_INVALID_HYPERCALL_CODE: u32 = 0xC0350002;
pub const ERROR_HV_INVALID_HYPERCALL_INPUT: u32 = 0xC0350003;
pub const ERROR_HV_INVALID_ALIGNMENT: u32 = 0xC0350004;
pub const ERROR_HV_INVALID_PARAMETER: u32 = 0xC0350005;
pub const ERROR_HV_ACCESS_DENIED: u32 = 0xC0350006;
pub const ERROR_HV_INVALID_PARTITION_STATE: u32 = 0xC0350007;
pub const ERROR_HV_OPERATION_DENIED: u32 = 0xC0350008;
pub const ERROR_HV_UNKNOWN_PROPERTY: u32 = 0xC0350009;
pub const ERROR_HV_PROPERTY_VALUE_OUT_OF_RANGE: u32 = 0xC035000A;
pub const ERROR_HV_INSUFFICIENT_MEMORY: u32 = 0xC035000B;
pub const ERROR_HV_PARTITION_TOO_DEEP: u32 = 0xC035000C;
pub const ERROR_HV_INVALID_PARTITION_ID: u32 = 0xC035000D;
pub const ERROR_HV_INVALID_VP_INDEX: u32 = 0xC035000E;
pub const ERROR_HV_INVALID_PORT_ID: u32 = 0xC0350011;
pub const ERROR_HV_INVALID_CONNECTION_ID: u32 = 0xC0350012;
pub const ERROR_HV_INSUFFICIENT_BUFFERS: u32 = 0xC0350013;
pub const ERROR_HV_NOT_ACKNOWLEDGED: u32 = 0xC0350014;
pub const ERROR_HV_INVALID_VP_STATE: u32 = 0xC0350015;
pub const ERROR_HV_ACKNOWLEDGED: u32 = 0xC0350016;
pub const ERROR_HV_INVALID_SAVE_RESTORE_STATE: u32 = 0xC0350017;
pub const ERROR_HV_INVALID_SYNIC_STATE: u32 = 0xC0350018;
pub const ERROR_HV_OBJECT_IN_USE: u32 = 0xC0350019;
pub const ERROR_HV_INVALID_PROXIMITY_DOMAIN_INFO: u32 = 0xC035001A;
pub const ERROR_HV_NO_DATA: u32 = 0xC035001B;
pub const ERROR_HV_INACTIVE: u32 = 0xC035001C;
pub const ERROR_HV_NO_RESOURCES: u32 = 0xC035001D;
pub const ERROR_HV_FEATURE_UNAVAILABLE: u32 = 0xC035001E;
pub const ERROR_HV_INSUFFICIENT_BUFFER: u32 = 0xC0350033;
pub const ERROR_HV_INSUFFICIENT_DEVICE_DOMAINS: u32 = 0xC0350038;
pub const ERROR_HV_CPUID_FEATURE_VALIDATION: u32 = 0xC035003C;
pub const ERROR_HV_CPUID_XSAVE_FEATURE_VALIDATION: u32 = 0xC035003D;
pub const ERROR_HV_PROCESSOR_STARTUP_TIMEOUT: u32 = 0xC035003E;
pub const ERROR_HV_SMX_ENABLED: u32 = 0xC035003F;
pub const ERROR_HV_INVALID_LP_INDEX: u32 = 0xC0350041;
pub const ERROR_HV_INVALID_REGISTER_VALUE: u32 = 0xC0350050;
pub const ERROR_HV_INVALID_VTL_STATE: u32 = 0xC0350051;
pub const ERROR_HV_NX_NOT_DETECTED: u32 = 0xC0350055;
pub const ERROR_HV_INVALID_DEVICE_ID: u32 = 0xC0350057;
pub const ERROR_HV_INVALID_DEVICE_STATE: u32 = 0xC0350058;
pub const ERROR_HV_PENDING_PAGE_REQUESTS: u32 = 0x350059;
pub const ERROR_HV_PAGE_REQUEST_INVALID: u32 = 0xC0350060;
pub const ERROR_HV_INVALID_CPU_GROUP_ID: u32 = 0xC035006F;
pub const ERROR_HV_INVALID_CPU_GROUP_STATE: u32 = 0xC0350070;
pub const ERROR_HV_OPERATION_FAILED: u32 = 0xC0350071;
pub const ERROR_HV_NOT_ALLOWED_WITH_NESTED_VIRT_ACTIVE: u32 = 0xC0350072;
pub const ERROR_HV_INSUFFICIENT_ROOT_MEMORY: u32 = 0xC0350073;
pub const ERROR_HV_EVENT_BUFFER_ALREADY_FREED: u32 = 0xC0350074;
pub const ERROR_HV_INSUFFICIENT_CONTIGUOUS_MEMORY: u32 = 0xC0350075;
pub const ERROR_HV_DEVICE_NOT_IN_DOMAIN: u32 = 0xC0350076;
pub const ERROR_HV_NESTED_VM_EXIT: u32 = 0xC0350077;
pub const ERROR_HV_MSR_ACCESS_FAILED: u32 = 0xC0350080;
pub const ERROR_HV_NOT_PRESENT: u32 = 0xC0351000;
pub const ERROR_VID_DUPLICATE_HANDLER: u32 = 0xC0370001;
pub const ERROR_VID_TOO_MANY_HANDLERS: u32 = 0xC0370002;
pub const ERROR_VID_QUEUE_FULL: u32 = 0xC0370003;
pub const ERROR_VID_HANDLER_NOT_PRESENT: u32 = 0xC0370004;
pub const ERROR_VID_INVALID_OBJECT_NAME: u32 = 0xC0370005;
pub const ERROR_VID_PARTITION_NAME_TOO_LONG: u32 = 0xC0370006;
pub const ERROR_VID_MESSAGE_QUEUE_NAME_TOO_LONG: u32 = 0xC0370007;
pub const ERROR_VID_PARTITION_ALREADY_EXISTS: u32 = 0xC0370008;
pub const ERROR_VID_PARTITION_DOES_NOT_EXIST: u32 = 0xC0370009;
pub const ERROR_VID_PARTITION_NAME_NOT_FOUND: u32 = 0xC037000A;
pub const ERROR_VID_MESSAGE_QUEUE_ALREADY_EXISTS: u32 = 0xC037000B;
pub const ERROR_VID_EXCEEDED_MBP_ENTRY_MAP_LIMIT: u32 = 0xC037000C;
pub const ERROR_VID_MB_STILL_REFERENCED: u32 = 0xC037000D;
pub const ERROR_VID_CHILD_GPA_PAGE_SET_CORRUPTED: u32 = 0xC037000E;
pub const ERROR_VID_INVALID_NUMA_SETTINGS: u32 = 0xC037000F;
pub const ERROR_VID_INVALID_NUMA_NODE_INDEX: u32 = 0xC0370010;
pub const ERROR_VID_NOTIFICATION_QUEUE_ALREADY_ASSOCIATED: u32 = 0xC0370011;
pub const ERROR_VID_INVALID_MEMORY_BLOCK_HANDLE: u32 = 0xC0370012;
pub const ERROR_VID_PAGE_RANGE_OVERFLOW: u32 = 0xC0370013;
pub const ERROR_VID_INVALID_MESSAGE_QUEUE_HANDLE: u32 = 0xC0370014;
pub const ERROR_VID_INVALID_GPA_RANGE_HANDLE: u32 = 0xC0370015;
pub const ERROR_VID_NO_MEMORY_BLOCK_NOTIFICATION_QUEUE: u32 = 0xC0370016;
pub const ERROR_VID_MEMORY_BLOCK_LOCK_COUNT_EXCEEDED: u32 = 0xC0370017;
pub const ERROR_VID_INVALID_PPM_HANDLE: u32 = 0xC0370018;
pub const ERROR_VID_MBPS_ARE_LOCKED: u32 = 0xC0370019;
pub const ERROR_VID_MESSAGE_QUEUE_CLOSED: u32 = 0xC037001A;
pub const ERROR_VID_VIRTUAL_PROCESSOR_LIMIT_EXCEEDED: u32 = 0xC037001B;
pub const ERROR_VID_STOP_PENDING: u32 = 0xC037001C;
pub const ERROR_VID_INVALID_PROCESSOR_STATE: u32 = 0xC037001D;
pub const ERROR_VID_EXCEEDED_KM_CONTEXT_COUNT_LIMIT: u32 = 0xC037001E;
pub const ERROR_VID_KM_INTERFACE_ALREADY_INITIALIZED: u32 = 0xC037001F;
pub const ERROR_VID_MB_PROPERTY_ALREADY_SET_RESET: u32 = 0xC0370020;
pub const ERROR_VID_MMIO_RANGE_DESTROYED: u32 = 0xC0370021;
pub const ERROR_VID_INVALID_CHILD_GPA_PAGE_SET: u32 = 0xC0370022;
pub const ERROR_VID_RESERVE_PAGE_SET_IS_BEING_USED: u32 = 0xC0370023;
pub const ERROR_VID_RESERVE_PAGE_SET_TOO_SMALL: u32 = 0xC0370024;
pub const ERROR_VID_MBP_ALREADY_LOCKED_USING_RESERVED_PAGE: u32 = 0xC0370025;
pub const ERROR_VID_MBP_COUNT_EXCEEDED_LIMIT: u32 = 0xC0370026;
pub const ERROR_VID_SAVED_STATE_CORRUPT: u32 = 0xC0370027;
pub const ERROR_VID_SAVED_STATE_UNRECOGNIZED_ITEM: u32 = 0xC0370028;
pub const ERROR_VID_SAVED_STATE_INCOMPATIBLE: u32 = 0xC0370029;
pub const ERROR_VID_VTL_ACCESS_DENIED: u32 = 0xC037002A;
pub const ERROR_VMCOMPUTE_TERMINATED_DURING_START: u32 = 0xC0370100;
pub const ERROR_VMCOMPUTE_IMAGE_MISMATCH: u32 = 0xC0370101;
pub const ERROR_VMCOMPUTE_HYPERV_NOT_INSTALLED: u32 = 0xC0370102;
pub const ERROR_VMCOMPUTE_OPERATION_PENDING: u32 = 0xC0370103;
pub const ERROR_VMCOMPUTE_TOO_MANY_NOTIFICATIONS: u32 = 0xC0370104;
pub const ERROR_VMCOMPUTE_INVALID_STATE: u32 = 0xC0370105;
pub const ERROR_VMCOMPUTE_UNEXPECTED_EXIT: u32 = 0xC0370106;
pub const ERROR_VMCOMPUTE_TERMINATED: u32 = 0xC0370107;
pub const ERROR_VMCOMPUTE_CONNECT_FAILED: u32 = 0xC0370108;
pub const ERROR_VMCOMPUTE_TIMEOUT: u32 = 0xC0370109;
pub const ERROR_VMCOMPUTE_CONNECTION_CLOSED: u32 = 0xC037010A;
pub const ERROR_VMCOMPUTE_UNKNOWN_MESSAGE: u32 = 0xC037010B;
pub const ERROR_VMCOMPUTE_UNSUPPORTED_PROTOCOL_VERSION: u32 = 0xC037010C;
pub const ERROR_VMCOMPUTE_INVALID_JSON: u32 = 0xC037010D;
pub const ERROR_VMCOMPUTE_SYSTEM_NOT_FOUND: u32 = 0xC037010E;
pub const ERROR_VMCOMPUTE_SYSTEM_ALREADY_EXISTS: u32 = 0xC037010F;
pub const ERROR_VMCOMPUTE_SYSTEM_ALREADY_STOPPED: u32 = 0xC0370110;
pub const ERROR_VMCOMPUTE_PROTOCOL_ERROR: u32 = 0xC0370111;
pub const ERROR_VMCOMPUTE_INVALID_LAYER: u32 = 0xC0370112;
pub const ERROR_VMCOMPUTE_WINDOWS_INSIDER_REQUIRED: u32 = 0xC0370113;
pub const ERROR_VNET_VIRTUAL_SWITCH_NAME_NOT_FOUND: u32 = 0xC0370200;
pub const ERROR_VID_REMOTE_NODE_PARENT_GPA_PAGES_USED: u32 = 0x80370001;
pub const ERROR_VSMB_SAVED_STATE_FILE_NOT_FOUND: u32 = 0xC0370400;
pub const ERROR_VSMB_SAVED_STATE_CORRUPT: u32 = 0xC0370401;
pub const ERROR_VOLMGR_INCOMPLETE_REGENERATION: u32 = 0x80380001;
pub const ERROR_VOLMGR_INCOMPLETE_DISK_MIGRATION: u32 = 0x80380002;
pub const ERROR_VOLMGR_DATABASE_FULL: u32 = 0xC0380001;
pub const ERROR_VOLMGR_DISK_CONFIGURATION_CORRUPTED: u32 = 0xC0380002;
pub const ERROR_VOLMGR_DISK_CONFIGURATION_NOT_IN_SYNC: u32 = 0xC0380003;
pub const ERROR_VOLMGR_PACK_CONFIG_UPDATE_FAILED: u32 = 0xC0380004;
pub const ERROR_VOLMGR_DISK_CONTAINS_NON_SIMPLE_VOLUME: u32 = 0xC0380005;
pub const ERROR_VOLMGR_DISK_DUPLICATE: u32 = 0xC0380006;
pub const ERROR_VOLMGR_DISK_DYNAMIC: u32 = 0xC0380007;
pub const ERROR_VOLMGR_DISK_ID_INVALID: u32 = 0xC0380008;
pub const ERROR_VOLMGR_DISK_INVALID: u32 = 0xC0380009;
pub const ERROR_VOLMGR_DISK_LAST_VOTER: u32 = 0xC038000A;
pub const ERROR_VOLMGR_DISK_LAYOUT_INVALID: u32 = 0xC038000B;
pub const ERROR_VOLMGR_DISK_LAYOUT_NON_BASIC_BETWEEN_BASIC_PARTITIONS: u32 = 0xC038000C;
pub const ERROR_VOLMGR_DISK_LAYOUT_NOT_CYLINDER_ALIGNED: u32 = 0xC038000D;
pub const ERROR_VOLMGR_DISK_LAYOUT_PARTITIONS_TOO_SMALL: u32 = 0xC038000E;
pub const ERROR_VOLMGR_DISK_LAYOUT_PRIMARY_BETWEEN_LOGICAL_PARTITIONS: u32 = 0xC038000F;
pub const ERROR_VOLMGR_DISK_LAYOUT_TOO_MANY_PARTITIONS: u32 = 0xC0380010;
pub const ERROR_VOLMGR_DISK_MISSING: u32 = 0xC0380011;
pub const ERROR_VOLMGR_DISK_NOT_EMPTY: u32 = 0xC0380012;
pub const ERROR_VOLMGR_DISK_NOT_ENOUGH_SPACE: u32 = 0xC0380013;
pub const ERROR_VOLMGR_DISK_REVECTORING_FAILED: u32 = 0xC0380014;
pub const ERROR_VOLMGR_DISK_SECTOR_SIZE_INVALID: u32 = 0xC0380015;
pub const ERROR_VOLMGR_DISK_SET_NOT_CONTAINED: u32 = 0xC0380016;
pub const ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_MEMBERS: u32 = 0xC0380017;
pub const ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_PLEXES: u32 = 0xC0380018;
pub const ERROR_VOLMGR_DYNAMIC_DISK_NOT_SUPPORTED: u32 = 0xC0380019;
pub const ERROR_VOLMGR_EXTENT_ALREADY_USED: u32 = 0xC038001A;
pub const ERROR_VOLMGR_EXTENT_NOT_CONTIGUOUS: u32 = 0xC038001B;
pub const ERROR_VOLMGR_EXTENT_NOT_IN_PUBLIC_REGION: u32 = 0xC038001C;
pub const ERROR_VOLMGR_EXTENT_NOT_SECTOR_ALIGNED: u32 = 0xC038001D;
pub const ERROR_VOLMGR_EXTENT_OVERLAPS_EBR_PARTITION: u32 = 0xC038001E;
pub const ERROR_VOLMGR_EXTENT_VOLUME_LENGTHS_DO_NOT_MATCH: u32 = 0xC038001F;
pub const ERROR_VOLMGR_FAULT_TOLERANT_NOT_SUPPORTED: u32 = 0xC0380020;
pub const ERROR_VOLMGR_INTERLEAVE_LENGTH_INVALID: u32 = 0xC0380021;
pub const ERROR_VOLMGR_MAXIMUM_REGISTERED_USERS: u32 = 0xC0380022;
pub const ERROR_VOLMGR_MEMBER_IN_SYNC: u32 = 0xC0380023;
pub const ERROR_VOLMGR_MEMBER_INDEX_DUPLICATE: u32 = 0xC0380024;
pub const ERROR_VOLMGR_MEMBER_INDEX_INVALID: u32 = 0xC0380025;
pub const ERROR_VOLMGR_MEMBER_MISSING: u32 = 0xC0380026;
pub const ERROR_VOLMGR_MEMBER_NOT_DETACHED: u32 = 0xC0380027;
pub const ERROR_VOLMGR_MEMBER_REGENERATING: u32 = 0xC0380028;
pub const ERROR_VOLMGR_ALL_DISKS_FAILED: u32 = 0xC0380029;
pub const ERROR_VOLMGR_NO_REGISTERED_USERS: u32 = 0xC038002A;
pub const ERROR_VOLMGR_NO_SUCH_USER: u32 = 0xC038002B;
pub const ERROR_VOLMGR_NOTIFICATION_RESET: u32 = 0xC038002C;
pub const ERROR_VOLMGR_NUMBER_OF_MEMBERS_INVALID: u32 = 0xC038002D;
pub const ERROR_VOLMGR_NUMBER_OF_PLEXES_INVALID: u32 = 0xC038002E;
pub const ERROR_VOLMGR_PACK_DUPLICATE: u32 = 0xC038002F;
pub const ERROR_VOLMGR_PACK_ID_INVALID: u32 = 0xC0380030;
pub const ERROR_VOLMGR_PACK_INVALID: u32 = 0xC0380031;
pub const ERROR_VOLMGR_PACK_NAME_INVALID: u32 = 0xC0380032;
pub const ERROR_VOLMGR_PACK_OFFLINE: u32 = 0xC0380033;
pub const ERROR_VOLMGR_PACK_HAS_QUORUM: u32 = 0xC0380034;
pub const ERROR_VOLMGR_PACK_WITHOUT_QUORUM: u32 = 0xC0380035;
pub const ERROR_VOLMGR_PARTITION_STYLE_INVALID: u32 = 0xC0380036;
pub const ERROR_VOLMGR_PARTITION_UPDATE_FAILED: u32 = 0xC0380037;
pub const ERROR_VOLMGR_PLEX_IN_SYNC: u32 = 0xC0380038;
pub const ERROR_VOLMGR_PLEX_INDEX_DUPLICATE: u32 = 0xC0380039;
pub const ERROR_VOLMGR_PLEX_INDEX_INVALID: u32 = 0xC038003A;
pub const ERROR_VOLMGR_PLEX_LAST_ACTIVE: u32 = 0xC038003B;
pub const ERROR_VOLMGR_PLEX_MISSING: u32 = 0xC038003C;
pub const ERROR_VOLMGR_PLEX_REGENERATING: u32 = 0xC038003D;
pub const ERROR_VOLMGR_PLEX_TYPE_INVALID: u32 = 0xC038003E;
pub const ERROR_VOLMGR_PLEX_NOT_RAID5: u32 = 0xC038003F;
pub const ERROR_VOLMGR_PLEX_NOT_SIMPLE: u32 = 0xC0380040;
pub const ERROR_VOLMGR_STRUCTURE_SIZE_INVALID: u32 = 0xC0380041;
pub const ERROR_VOLMGR_TOO_MANY_NOTIFICATION_REQUESTS: u32 = 0xC0380042;
pub const ERROR_VOLMGR_TRANSACTION_IN_PROGRESS: u32 = 0xC0380043;
pub const ERROR_VOLMGR_UNEXPECTED_DISK_LAYOUT_CHANGE: u32 = 0xC0380044;
pub const ERROR_VOLMGR_VOLUME_CONTAINS_MISSING_DISK: u32 = 0xC0380045;
pub const ERROR_VOLMGR_VOLUME_ID_INVALID: u32 = 0xC0380046;
pub const ERROR_VOLMGR_VOLUME_LENGTH_INVALID: u32 = 0xC0380047;
pub const ERROR_VOLMGR_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE: u32 = 0xC0380048;
pub const ERROR_VOLMGR_VOLUME_NOT_MIRRORED: u32 = 0xC0380049;
pub const ERROR_VOLMGR_VOLUME_NOT_RETAINED: u32 = 0xC038004A;
pub const ERROR_VOLMGR_VOLUME_OFFLINE: u32 = 0xC038004B;
pub const ERROR_VOLMGR_VOLUME_RETAINED: u32 = 0xC038004C;
pub const ERROR_VOLMGR_NUMBER_OF_EXTENTS_INVALID: u32 = 0xC038004D;
pub const ERROR_VOLMGR_DIFFERENT_SECTOR_SIZE: u32 = 0xC038004E;
pub const ERROR_VOLMGR_BAD_BOOT_DISK: u32 = 0xC038004F;
pub const ERROR_VOLMGR_PACK_CONFIG_OFFLINE: u32 = 0xC0380050;
pub const ERROR_VOLMGR_PACK_CONFIG_ONLINE: u32 = 0xC0380051;
pub const ERROR_VOLMGR_NOT_PRIMARY_PACK: u32 = 0xC0380052;
pub const ERROR_VOLMGR_PACK_LOG_UPDATE_FAILED: u32 = 0xC0380053;
pub const ERROR_VOLMGR_NUMBER_OF_DISKS_IN_PLEX_INVALID: u32 = 0xC0380054;
pub const ERROR_VOLMGR_NUMBER_OF_DISKS_IN_MEMBER_INVALID: u32 = 0xC0380055;
pub const ERROR_VOLMGR_VOLUME_MIRRORED: u32 = 0xC0380056;
pub const ERROR_VOLMGR_PLEX_NOT_SIMPLE_SPANNED: u32 = 0xC0380057;
pub const ERROR_VOLMGR_NO_VALID_LOG_COPIES: u32 = 0xC0380058;
pub const ERROR_VOLMGR_PRIMARY_PACK_PRESENT: u32 = 0xC0380059;
pub const ERROR_VOLMGR_NUMBER_OF_DISKS_INVALID: u32 = 0xC038005A;
pub const ERROR_VOLMGR_MIRROR_NOT_SUPPORTED: u32 = 0xC038005B;
pub const ERROR_VOLMGR_RAID5_NOT_SUPPORTED: u32 = 0xC038005C;
pub const ERROR_BCD_NOT_ALL_ENTRIES_IMPORTED: u32 = 0x80390001;
pub const ERROR_BCD_TOO_MANY_ELEMENTS: u32 = 0xC0390002;
pub const ERROR_BCD_NOT_ALL_ENTRIES_SYNCHRONIZED: u32 = 0x80390003;
pub const ERROR_VHD_DRIVE_FOOTER_MISSING: u32 = 0xC03A0001;
pub const ERROR_VHD_DRIVE_FOOTER_CHECKSUM_MISMATCH: u32 = 0xC03A0002;
pub const ERROR_VHD_DRIVE_FOOTER_CORRUPT: u32 = 0xC03A0003;
pub const ERROR_VHD_FORMAT_UNKNOWN: u32 = 0xC03A0004;
pub const ERROR_VHD_FORMAT_UNSUPPORTED_VERSION: u32 = 0xC03A0005;
pub const ERROR_VHD_SPARSE_HEADER_CHECKSUM_MISMATCH: u32 = 0xC03A0006;
pub const ERROR_VHD_SPARSE_HEADER_UNSUPPORTED_VERSION: u32 = 0xC03A0007;
pub const ERROR_VHD_SPARSE_HEADER_CORRUPT: u32 = 0xC03A0008;
pub const ERROR_VHD_BLOCK_ALLOCATION_FAILURE: u32 = 0xC03A0009;
pub const ERROR_VHD_BLOCK_ALLOCATION_TABLE_CORRUPT: u32 = 0xC03A000A;
pub const ERROR_VHD_INVALID_BLOCK_SIZE: u32 = 0xC03A000B;
pub const ERROR_VHD_BITMAP_MISMATCH: u32 = 0xC03A000C;
pub const ERROR_VHD_PARENT_VHD_NOT_FOUND: u32 = 0xC03A000D;
pub const ERROR_VHD_CHILD_PARENT_ID_MISMATCH: u32 = 0xC03A000E;
pub const ERROR_VHD_CHILD_PARENT_TIMESTAMP_MISMATCH: u32 = 0xC03A000F;
pub const ERROR_VHD_METADATA_READ_FAILURE: u32 = 0xC03A0010;
pub const ERROR_VHD_METADATA_WRITE_FAILURE: u32 = 0xC03A0011;
pub const ERROR_VHD_INVALID_SIZE: u32 = 0xC03A0012;
pub const ERROR_VHD_INVALID_FILE_SIZE: u32 = 0xC03A0013;
pub const ERROR_VIRTDISK_PROVIDER_NOT_FOUND: u32 = 0xC03A0014;
pub const ERROR_VIRTDISK_NOT_VIRTUAL_DISK: u32 = 0xC03A0015;
pub const ERROR_VHD_PARENT_VHD_ACCESS_DENIED: u32 = 0xC03A0016;
pub const ERROR_VHD_CHILD_PARENT_SIZE_MISMATCH: u32 = 0xC03A0017;
pub const ERROR_VHD_DIFFERENCING_CHAIN_CYCLE_DETECTED: u32 = 0xC03A0018;
pub const ERROR_VHD_DIFFERENCING_CHAIN_ERROR_IN_PARENT: u32 = 0xC03A0019;
pub const ERROR_VIRTUAL_DISK_LIMITATION: u32 = 0xC03A001A;
pub const ERROR_VHD_INVALID_TYPE: u32 = 0xC03A001B;
pub const ERROR_VHD_INVALID_STATE: u32 = 0xC03A001C;
pub const ERROR_VIRTDISK_UNSUPPORTED_DISK_SECTOR_SIZE: u32 = 0xC03A001D;
pub const ERROR_VIRTDISK_DISK_ALREADY_OWNED: u32 = 0xC03A001E;
pub const ERROR_VIRTDISK_DISK_ONLINE_AND_WRITABLE: u32 = 0xC03A001F;
pub const ERROR_CTLOG_TRACKING_NOT_INITIALIZED: u32 = 0xC03A0020;
pub const ERROR_CTLOG_LOGFILE_SIZE_EXCEEDED_MAXSIZE: u32 = 0xC03A0021;
pub const ERROR_CTLOG_VHD_CHANGED_OFFLINE: u32 = 0xC03A0022;
pub const ERROR_CTLOG_INVALID_TRACKING_STATE: u32 = 0xC03A0023;
pub const ERROR_CTLOG_INCONSISTENT_TRACKING_FILE: u32 = 0xC03A0024;
pub const ERROR_VHD_RESIZE_WOULD_TRUNCATE_DATA: u32 = 0xC03A0025;
pub const ERROR_VHD_COULD_NOT_COMPUTE_MINIMUM_VIRTUAL_SIZE: u32 = 0xC03A0026;
pub const ERROR_VHD_ALREADY_AT_OR_BELOW_MINIMUM_VIRTUAL_SIZE: u32 = 0xC03A0027;
pub const ERROR_VHD_METADATA_FULL: u32 = 0xC03A0028;
pub const ERROR_VHD_INVALID_CHANGE_TRACKING_ID: u32 = 0xC03A0029;
pub const ERROR_VHD_CHANGE_TRACKING_DISABLED: u32 = 0xC03A002A;
pub const ERROR_VHD_MISSING_CHANGE_TRACKING_INFORMATION: u32 = 0xC03A0030;
pub const ERROR_QUERY_STORAGE_ERROR: u32 = 0x803A0001;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Windowinfo {
    pub cb_size: u32,
    pub rc_window: Rect,
    pub rc_client: Rect,
    pub dw_style: u32,
    pub dw_ex_style: u32,
    pub dw_window_status: u32,
    pub cx_window_borders: u32,
    pub cy_window_borders: u32,
    pub atom_window_type: u16,
    pub w_creator_version: u16,
}
impl Windowinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::WINDOWINFO {
        let Self { cb_size, rc_window, rc_client, dw_style, dw_ex_style, dw_window_status, cx_window_borders, cy_window_borders, atom_window_type, w_creator_version } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::WINDOWINFO>() as _;
        let rcWindow = rc_window.to_win32();
        let rcClient = rc_client.to_win32();
        let dwStyle = *dw_style;
        let dwExStyle = *dw_ex_style;
        let dwWindowStatus = *dw_window_status;
        let cxWindowBorders = *cx_window_borders;
        let cyWindowBorders = *cy_window_borders;
        let atomWindowType = *atom_window_type;
        let wCreatorVersion = *w_creator_version;
        windows_sys::Win32::UI::WindowsAndMessaging::WINDOWINFO { cbSize, rcWindow, rcClient, dwStyle, dwExStyle, dwWindowStatus, cxWindowBorders, cyWindowBorders, atomWindowType, wCreatorVersion }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::WINDOWINFO) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::WINDOWINFO { cbSize, rcWindow, rcClient, dwStyle, dwExStyle, dwWindowStatus, cxWindowBorders, cyWindowBorders, atomWindowType, wCreatorVersion } = win32;
        let cb_size = cbSize;
        let rc_window = unsafe { RECT::from_win32(rcWindow) };
        let rc_client = unsafe { RECT::from_win32(rcClient) };
        let dw_style = dwStyle;
        let dw_ex_style = dwExStyle;
        let dw_window_status = dwWindowStatus;
        let cx_window_borders = cxWindowBorders;
        let cy_window_borders = cyWindowBorders;
        let atom_window_type = atomWindowType;
        let w_creator_version = wCreatorVersion;
        Self { cb_size, rc_window, rc_client, dw_style, dw_ex_style, dw_window_status, cx_window_borders, cy_window_borders, atom_window_type, w_creator_version }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Windowplacement {
    pub length: u32,
    pub flags: u32,
    pub show_cmd: u32,
    pub pt_min_position: Point,
    pub pt_max_position: Point,
    pub rc_normal_position: Rect,
}
impl Windowplacement {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::WINDOWPLACEMENT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::WINDOWPLACEMENT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const WPF_ASYNCWINDOWPLACEMENT: u32 = 0x4;
pub const WPF_RESTORETOMAXIMIZED: u32 = 0x2;
pub const WPF_SETMINPOSITION: u32 = 0x1;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Windowpos {
    pub hwnd: Option<Hwnd>,
    pub hwnd_insert_after: Option<Hwnd>,
    pub x: i32,
    pub y: i32,
    pub cx: i32,
    pub cy: i32,
    pub flags: u32,
}
impl Windowpos {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::WINDOWPOS {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::WINDOWPOS) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const WH_CALLWNDPROC: i32 = 0x4;
pub const WH_CALLWNDPROCRET: i32 = 0xC;
pub const WH_CBT: i32 = 0x5;
pub const WH_DEBUG: i32 = 0x9;
pub const WH_FOREGROUNDIDLE: i32 = 0xB;
pub const WH_GETMESSAGE: i32 = 0x3;
pub const WH_JOURNALPLAYBACK: i32 = 0x1;
pub const WH_JOURNALRECORD: i32 = 0x0;
pub const WH_KEYBOARD: i32 = 0x2;
pub const WH_KEYBOARD_LL: i32 = 0xD;
pub const WH_MOUSE: i32 = 0x7;
pub const WH_MOUSE_LL: i32 = 0xE;
pub const WH_MSGFILTER: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
pub const WH_SHELL: i32 = 0xA;
pub const WH_SYSMSGFILTER: i32 = 0x6;
pub const WTA_NONCLIENT: i32 = 0x1;
pub const WDA_NONE: u32 = 0x0;
pub const WDA_MONITOR: u32 = 0x1;
pub const WDA_EXCLUDEFROMCAPTURE: u32 = 0x11;
pub const WS_EX_DLGMODALFRAME: u32 = 0x1;
pub const WS_EX_NOPARENTNOTIFY: u32 = 0x4;
pub const WS_EX_TOPMOST: u32 = 0x8;
pub const WS_EX_ACCEPTFILES: u32 = 0x10;
pub const WS_EX_TRANSPARENT: u32 = 0x20;
pub const WS_EX_MDICHILD: u32 = 0x40;
pub const WS_EX_TOOLWINDOW: u32 = 0x80;
pub const WS_EX_WINDOWEDGE: u32 = 0x100;
pub const WS_EX_CLIENTEDGE: u32 = 0x200;
pub const WS_EX_CONTEXTHELP: u32 = 0x400;
pub const WS_EX_RIGHT: u32 = 0x1000;
pub const WS_EX_LEFT: u32 = 0x0;
pub const WS_EX_RTLREADING: u32 = 0x2000;
pub const WS_EX_LTRREADING: u32 = 0x0;
pub const WS_EX_LEFTSCROLLBAR: u32 = 0x4000;
pub const WS_EX_RIGHTSCROLLBAR: u32 = 0x0;
pub const WS_EX_CONTROLPARENT: u32 = 0x10000;
pub const WS_EX_STATICEDGE: u32 = 0x20000;
pub const WS_EX_APPWINDOW: u32 = 0x40000;
pub const WS_EX_OVERLAPPEDWINDOW: u32 = 0x300;
pub const WS_EX_PALETTEWINDOW: u32 = 0x188;
pub const WS_EX_LAYERED: u32 = 0x80000;
pub const WS_EX_NOINHERITLAYOUT: u32 = 0x100000;
pub const WS_EX_NOREDIRECTIONBITMAP: u32 = 0x200000;
pub const WS_EX_LAYOUTRTL: u32 = 0x400000;
pub const WS_EX_COMPOSITED: u32 = 0x2000000;
pub const WS_EX_NOACTIVATE: u32 = 0x8000000;
pub const GWL_EXSTYLE: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEC;
pub const GWLP_HINSTANCE: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA;
pub const GWLP_HWNDPARENT: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8;
pub const GWLP_ID: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4;
pub const GWL_STYLE: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0;
pub const GWLP_USERDATA: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEB;
pub const GWLP_WNDPROC: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC;
pub const GWL_HINSTANCE: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA;
pub const GWL_ID: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4;
pub const GWL_USERDATA: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEB;
pub const GWL_WNDPROC: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC;
pub const GWL_HWNDPARENT: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8;
pub const MSGFLT_ALLOW: u32 = 0x1;
pub const MSGFLT_DISALLOW: u32 = 0x2;
pub const MSGFLT_RESET: u32 = 0x0;
pub const WS_OVERLAPPED: u32 = 0x0;
pub const WS_POPUP: u32 = 0x80000000;
pub const WS_CHILD: u32 = 0x40000000;
pub const WS_MINIMIZE: u32 = 0x20000000;
pub const WS_VISIBLE: u32 = 0x10000000;
pub const WS_DISABLED: u32 = 0x8000000;
pub const WS_CLIPSIBLINGS: u32 = 0x4000000;
pub const WS_CLIPCHILDREN: u32 = 0x2000000;
pub const WS_MAXIMIZE: u32 = 0x1000000;
pub const WS_CAPTION: u32 = 0xC00000;
pub const WS_BORDER: u32 = 0x800000;
pub const WS_DLGFRAME: u32 = 0x400000;
pub const WS_VSCROLL: u32 = 0x200000;
pub const WS_HSCROLL: u32 = 0x100000;
pub const WS_SYSMENU: u32 = 0x80000;
pub const WS_THICKFRAME: u32 = 0x40000;
pub const WS_GROUP: u32 = 0x20000;
pub const WS_TABSTOP: u32 = 0x10000;
pub const WS_MINIMIZEBOX: u32 = 0x20000;
pub const WS_MAXIMIZEBOX: u32 = 0x10000;
pub const WS_TILED: u32 = 0x0;
pub const WS_ICONIC: u32 = 0x20000000;
pub const WS_SIZEBOX: u32 = 0x40000;
pub const WS_TILEDWINDOW: u32 = 0xCF0000;
pub const WS_OVERLAPPEDWINDOW: u32 = 0xCF0000;
pub const WS_POPUPWINDOW: u32 = 0x80880000;
pub const WS_CHILDWINDOW: u32 = 0x40000000;
pub const WS_ACTIVECAPTION: u32 = 0x1;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Wndclassa<'a> {
    pub style: u32,
    pub lpfn_wnd_proc: Option<unsafe extern "system" fn(HWND, u32, WPARAM, LPARAM) -> LRESULT>,
    pub cb_cls_extra: i32,
    pub cb_wnd_extra: i32,
    pub h_instance: Option<Hinstance>,
    pub h_icon: Option<Hicon>,
    pub h_cursor: Option<Hcursor>,
    pub hbr_background: Option<Hbrush>,
    pub lpsz_menu_name: Cow<'a, CStr>,
    pub lpsz_class_name: Cow<'a, CStr>,
}
impl Wndclassa {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSA {
        let Self { style, lpfn_wnd_proc, cb_cls_extra, cb_wnd_extra, h_instance, h_icon, h_cursor, hbr_background, lpsz_menu_name, lpsz_class_name } = self;
        let style = style;
        let lpfnWndProc = Some(lpfn_wnd_proc);
        let cbClsExtra = *cb_cls_extra;
        let cbWndExtra = *cb_wnd_extra;
        let hInstance = h_instance.map_or(0, Hinstance::into_raw);
        let hIcon = h_icon.map_or(0, Hicon::into_raw);
        let hCursor = h_cursor.map_or(0, Hcursor::into_raw);
        let hbrBackground = hbr_background.map_or(0, Hbrush::into_raw);
        let lpszMenuName = lpsz_menu_name.as_ptr();
        let lpszClassName = lpsz_class_name.as_ptr();
        windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSA { style, lpfnWndProc, cbClsExtra, cbWndExtra, hInstance, hIcon, hCursor, hbrBackground, lpszMenuName, lpszClassName }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSA) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSA { style, lpfnWndProc, cbClsExtra, cbWndExtra, hInstance, hIcon, hCursor, hbrBackground, lpszMenuName, lpszClassName } = win32;
        let style = style;
        let lpfn_wnd_proc = lpfnWndProc;
        let cb_cls_extra = cbClsExtra;
        let cb_wnd_extra = cbWndExtra;
        let h_instance = unsafe { Hinstance::new_optional(hInstance) };
        let h_icon = unsafe { Hicon::new_optional(hIcon) };
        let h_cursor = unsafe { Hcursor::new_optional(hCursor) };
        let hbr_background = unsafe { Hbrush::new_optional(hbrBackground) };
        let lpszMenuName = unsafe { CStr::from_ptr(lpszMenuName) };
        let lpszMenuName = lpszMenuName.to_bytes_with_nul().to_vec();
        let lpsz_menu_name = Cow::Owned(unsafe { CString::from_vec_unchecked(lpszMenuName) });
        let lpszClassName = unsafe { CStr::from_ptr(lpszClassName) };
        let lpszClassName = lpszClassName.to_bytes_with_nul().to_vec();
        let lpsz_class_name = Cow::Owned(unsafe { CString::from_vec_unchecked(lpszClassName) });
        Self { style, lpfn_wnd_proc, cb_cls_extra, cb_wnd_extra, h_instance, h_icon, h_cursor, hbr_background, lpsz_menu_name, lpsz_class_name }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Wndclassexa<'a> {
    pub cb_size: u32,
    pub style: u32,
    pub lpfn_wnd_proc: Option<unsafe extern "system" fn(HWND, u32, WPARAM, LPARAM) -> LRESULT>,
    pub cb_cls_extra: i32,
    pub cb_wnd_extra: i32,
    pub h_instance: Option<Hinstance>,
    pub h_icon: Option<Hicon>,
    pub h_cursor: Option<Hcursor>,
    pub hbr_background: Option<Hbrush>,
    pub lpsz_menu_name: Cow<'a, CStr>,
    pub lpsz_class_name: Cow<'a, CStr>,
    pub h_icon_sm: Option<Hicon>,
}
impl Wndclassexa {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSEXA {
        let Self { cb_size, style, lpfn_wnd_proc, cb_cls_extra, cb_wnd_extra, h_instance, h_icon, h_cursor, hbr_background, lpsz_menu_name, lpsz_class_name, h_icon_sm } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSEXA>() as _;
        let style = style;
        let lpfnWndProc = Some(lpfn_wnd_proc);
        let cbClsExtra = *cb_cls_extra;
        let cbWndExtra = *cb_wnd_extra;
        let hInstance = h_instance.map_or(0, Hinstance::into_raw);
        let hIcon = h_icon.map_or(0, Hicon::into_raw);
        let hCursor = h_cursor.map_or(0, Hcursor::into_raw);
        let hbrBackground = hbr_background.map_or(0, Hbrush::into_raw);
        let lpszMenuName = lpsz_menu_name.as_ptr();
        let lpszClassName = lpsz_class_name.as_ptr();
        let hIconSm = h_icon_sm.map_or(0, Hicon::into_raw);
        windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSEXA { cbSize, style, lpfnWndProc, cbClsExtra, cbWndExtra, hInstance, hIcon, hCursor, hbrBackground, lpszMenuName, lpszClassName, hIconSm }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSEXA) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSEXA { cbSize, style, lpfnWndProc, cbClsExtra, cbWndExtra, hInstance, hIcon, hCursor, hbrBackground, lpszMenuName, lpszClassName, hIconSm } = win32;
        let cb_size = cbSize;
        let style = style;
        let lpfn_wnd_proc = lpfnWndProc;
        let cb_cls_extra = cbClsExtra;
        let cb_wnd_extra = cbWndExtra;
        let h_instance = unsafe { Hinstance::new_optional(hInstance) };
        let h_icon = unsafe { Hicon::new_optional(hIcon) };
        let h_cursor = unsafe { Hcursor::new_optional(hCursor) };
        let hbr_background = unsafe { Hbrush::new_optional(hbrBackground) };
        let lpszMenuName = unsafe { CStr::from_ptr(lpszMenuName) };
        let lpszMenuName = lpszMenuName.to_bytes_with_nul().to_vec();
        let lpsz_menu_name = Cow::Owned(unsafe { CString::from_vec_unchecked(lpszMenuName) });
        let lpszClassName = unsafe { CStr::from_ptr(lpszClassName) };
        let lpszClassName = lpszClassName.to_bytes_with_nul().to_vec();
        let lpsz_class_name = Cow::Owned(unsafe { CString::from_vec_unchecked(lpszClassName) });
        let h_icon_sm = unsafe { Hicon::new_optional(hIconSm) };
        Self { cb_size, style, lpfn_wnd_proc, cb_cls_extra, cb_wnd_extra, h_instance, h_icon, h_cursor, hbr_background, lpsz_menu_name, lpsz_class_name, h_icon_sm }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Wndclassexw<'a> {
    pub cb_size: u32,
    pub style: u32,
    pub lpfn_wnd_proc: Option<unsafe extern "system" fn(HWND, u32, WPARAM, LPARAM) -> LRESULT>,
    pub cb_cls_extra: i32,
    pub cb_wnd_extra: i32,
    pub h_instance: Option<Hinstance>,
    pub h_icon: Option<Hicon>,
    pub h_cursor: Option<Hcursor>,
    pub hbr_background: Option<Hbrush>,
    pub lpsz_menu_name: Cow<'a, [u16]>,
    pub lpsz_class_name: Cow<'a, [u16]>,
    pub h_icon_sm: Option<Hicon>,
}
impl Wndclassexw {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSEXW {
        let Self { cb_size, style, lpfn_wnd_proc, cb_cls_extra, cb_wnd_extra, h_instance, h_icon, h_cursor, hbr_background, lpsz_menu_name, lpsz_class_name, h_icon_sm } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSEXW>() as _;
        let style = style;
        let lpfnWndProc = Some(lpfn_wnd_proc);
        let cbClsExtra = *cb_cls_extra;
        let cbWndExtra = *cb_wnd_extra;
        let hInstance = h_instance.map_or(0, Hinstance::into_raw);
        let hIcon = h_icon.map_or(0, Hicon::into_raw);
        let hCursor = h_cursor.map_or(0, Hcursor::into_raw);
        let hbrBackground = hbr_background.map_or(0, Hbrush::into_raw);
        assert_eq!(lpsz_menu_name.last(), Some(0));
        let lpszMenuName = lpsz_menu_name.as_ptr();
        assert_eq!(lpsz_class_name.last(), Some(0));
        let lpszClassName = lpsz_class_name.as_ptr();
        let hIconSm = h_icon_sm.map_or(0, Hicon::into_raw);
        windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSEXW { cbSize, style, lpfnWndProc, cbClsExtra, cbWndExtra, hInstance, hIcon, hCursor, hbrBackground, lpszMenuName, lpszClassName, hIconSm }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSEXW) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSEXW { cbSize, style, lpfnWndProc, cbClsExtra, cbWndExtra, hInstance, hIcon, hCursor, hbrBackground, lpszMenuName, lpszClassName, hIconSm } = win32;
        let cb_size = cbSize;
        let style = style;
        let lpfn_wnd_proc = lpfnWndProc;
        let cb_cls_extra = cbClsExtra;
        let cb_wnd_extra = cbWndExtra;
        let h_instance = unsafe { Hinstance::new_optional(hInstance) };
        let h_icon = unsafe { Hicon::new_optional(hIcon) };
        let h_cursor = unsafe { Hcursor::new_optional(hCursor) };
        let hbr_background = unsafe { Hbrush::new_optional(hbrBackground) };
        let slen = unsafe { wide_strlen(lpszMenuName as *const u16) };
        let lpszMenuName = unsafe { slice::from_raw_parts(lpszMenuName, slen + 1) };
        let lpsz_menu_name = lpszMenuName.to_vec();
        let slen = unsafe { wide_strlen(lpszClassName as *const u16) };
        let lpszClassName = unsafe { slice::from_raw_parts(lpszClassName, slen + 1) };
        let lpsz_class_name = lpszClassName.to_vec();
        let h_icon_sm = unsafe { Hicon::new_optional(hIconSm) };
        Self { cb_size, style, lpfn_wnd_proc, cb_cls_extra, cb_wnd_extra, h_instance, h_icon, h_cursor, hbr_background, lpsz_menu_name, lpsz_class_name, h_icon_sm }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Wndclassw<'a> {
    pub style: u32,
    pub lpfn_wnd_proc: Option<unsafe extern "system" fn(HWND, u32, WPARAM, LPARAM) -> LRESULT>,
    pub cb_cls_extra: i32,
    pub cb_wnd_extra: i32,
    pub h_instance: Option<Hinstance>,
    pub h_icon: Option<Hicon>,
    pub h_cursor: Option<Hcursor>,
    pub hbr_background: Option<Hbrush>,
    pub lpsz_menu_name: Cow<'a, [u16]>,
    pub lpsz_class_name: Cow<'a, [u16]>,
}
impl Wndclassw {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSW {
        let Self { style, lpfn_wnd_proc, cb_cls_extra, cb_wnd_extra, h_instance, h_icon, h_cursor, hbr_background, lpsz_menu_name, lpsz_class_name } = self;
        let style = style;
        let lpfnWndProc = Some(lpfn_wnd_proc);
        let cbClsExtra = *cb_cls_extra;
        let cbWndExtra = *cb_wnd_extra;
        let hInstance = h_instance.map_or(0, Hinstance::into_raw);
        let hIcon = h_icon.map_or(0, Hicon::into_raw);
        let hCursor = h_cursor.map_or(0, Hcursor::into_raw);
        let hbrBackground = hbr_background.map_or(0, Hbrush::into_raw);
        assert_eq!(lpsz_menu_name.last(), Some(0));
        let lpszMenuName = lpsz_menu_name.as_ptr();
        assert_eq!(lpsz_class_name.last(), Some(0));
        let lpszClassName = lpsz_class_name.as_ptr();
        windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSW { style, lpfnWndProc, cbClsExtra, cbWndExtra, hInstance, hIcon, hCursor, hbrBackground, lpszMenuName, lpszClassName }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSW) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSW { style, lpfnWndProc, cbClsExtra, cbWndExtra, hInstance, hIcon, hCursor, hbrBackground, lpszMenuName, lpszClassName } = win32;
        let style = style;
        let lpfn_wnd_proc = lpfnWndProc;
        let cb_cls_extra = cbClsExtra;
        let cb_wnd_extra = cbWndExtra;
        let h_instance = unsafe { Hinstance::new_optional(hInstance) };
        let h_icon = unsafe { Hicon::new_optional(hIcon) };
        let h_cursor = unsafe { Hcursor::new_optional(hCursor) };
        let hbr_background = unsafe { Hbrush::new_optional(hbrBackground) };
        let slen = unsafe { wide_strlen(lpszMenuName as *const u16) };
        let lpszMenuName = unsafe { slice::from_raw_parts(lpszMenuName, slen + 1) };
        let lpsz_menu_name = lpszMenuName.to_vec();
        let slen = unsafe { wide_strlen(lpszClassName as *const u16) };
        let lpszClassName = unsafe { slice::from_raw_parts(lpszClassName, slen + 1) };
        let lpsz_class_name = lpszClassName.to_vec();
        Self { style, lpfn_wnd_proc, cb_cls_extra, cb_wnd_extra, h_instance, h_icon, h_cursor, hbr_background, lpsz_menu_name, lpsz_class_name }
    }
}
pub const CS_VREDRAW: u32 = 0x1;
pub const CS_HREDRAW: u32 = 0x2;
pub const CS_DBLCLKS: u32 = 0x8;
pub const CS_OWNDC: u32 = 0x20;
pub const CS_CLASSDC: u32 = 0x40;
pub const CS_PARENTDC: u32 = 0x80;
pub const CS_NOCLOSE: u32 = 0x200;
pub const CS_SAVEBITS: u32 = 0x800;
pub const CS_BYTEALIGNCLIENT: u32 = 0x1000;
pub const CS_BYTEALIGNWINDOW: u32 = 0x2000;
pub const CS_GLOBALCLASS: u32 = 0x4000;
pub const CS_IME: u32 = 0x10000;
pub const CS_DROPSHADOW: u32 = 0x20000;
pub const WB_CLASSIFY: u32 = 0x3;
pub const WB_ISDELIMITER: u32 = 0x2;
pub const WB_LEFT: u32 = 0x0;
pub const WB_LEFTBREAK: u32 = 0x6;
pub const WB_MOVEWORDLEFT: u32 = 0x4;
pub const WB_MOVEWORDRIGHT: u32 = 0x5;
pub const WB_RIGHT: u32 = 0x1;
pub const WB_RIGHTBREAK: u32 = 0x7;
pub const WSB_PROP_CXHSCROLL: i32 = 0x2;
pub const WSB_PROP_CXHTHUMB: i32 = 0x10;
pub const WSB_PROP_CXVSCROLL: i32 = 0x8;
pub const WSB_PROP_CYHSCROLL: i32 = 0x4;
pub const WSB_PROP_CYVSCROLL: i32 = 0x1;
pub const WSB_PROP_CYVTHUMB: i32 = 0x20;
pub const WSB_PROP_HBKGCOLOR: i32 = 0x80;
pub const WSB_PROP_HSTYLE: i32 = 0x200;
pub const WSB_PROP_PALETTE: i32 = 0x800;
pub const WSB_PROP_VBKGCOLOR: i32 = 0x40;
pub const WSB_PROP_VSTYLE: i32 = 0x100;
pub const WSB_PROP_WINSTYLE: i32 = 0x400;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct WtaOptions {
    pub dw_flags: u32,
    pub dw_mask: u32,
}
impl WtaOptions {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::WTA_OPTIONS {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::WTA_OPTIONS) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const WTSAT_UNKNOWN: i32 = 0x0;
pub const WTSAT_RGB: i32 = 0x1;
pub const WTSAT_ARGB: i32 = 0x2;
pub const WTS_DEFAULT: i32 = 0x0;
pub const WTS_LOWQUALITY: i32 = 0x1;
pub const WTS_CACHED: i32 = 0x2;
pub const WTSCF_DEFAULT: i32 = 0x0;
pub const WTSCF_APPSTYLE: i32 = 0x1;
pub const WTSCF_SQUARE: i32 = 0x2;
pub const WTSCF_WIDE: i32 = 0x4;
pub const WTSCF_FAST: i32 = 0x8;
pub const WTS_NONE: i32 = 0x0;
pub const WTS_EXTRACT: i32 = 0x0;
pub const WTS_INCACHEONLY: i32 = 0x1;
pub const WTS_FASTEXTRACT: i32 = 0x2;
pub const WTS_FORCEEXTRACTION: i32 = 0x4;
pub const WTS_SLOWRECLAIM: i32 = 0x8;
pub const WTS_EXTRACTDONOTCACHE: i32 = 0x20;
pub const WTS_SCALETOREQUESTEDSIZE: i32 = 0x40;
pub const WTS_SKIPFASTEXTRACT: i32 = 0x80;
pub const WTS_EXTRACTINPROC: i32 = 0x100;
pub const WTS_CROPTOSQUARE: i32 = 0x200;
pub const WTS_INSTANCESURROGATE: i32 = 0x400;
pub const WTS_REQUIRESURROGATE: i32 = 0x800;
pub const WTS_APPSTYLE: i32 = 0x2000;
pub const WTS_WIDETHUMBNAILS: i32 = 0x4000;
pub const WTS_IDEALCACHESIZEONLY: i32 = 0x8000;
pub const WTS_SCALEUP: i32 = 0x10000;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct WtsThumbnailid {
    pub rgb_key: [u8; 16],
}
impl WtsThumbnailid {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::WTS_THUMBNAILID {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::WTS_THUMBNAILID) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Xform {
    pub e_m11: f32,
    pub e_m12: f32,
    pub e_m21: f32,
    pub e_m22: f32,
    pub e_dx: f32,
    pub e_dy: f32,
}
impl Xform {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::XFORM {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::XFORM) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[repr(C)]
pub union Anonymous2EStruct1 {
    pub field0: u32,
    pub field1: u32,
}
impl Anonymous2EStruct1 {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::_Anonymous2_e__Struct_1 {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::_Anonymous2_e__Struct_1) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[repr(C)]
pub union Anonymous2EStruct3 {
    pub field0: u32,
    pub field1: u32,
}
impl Anonymous2EStruct3 {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::_Anonymous2_e__Struct_3 {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::_Anonymous2_e__Struct_3) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
pub const CDBE_TYPE_MUSIC: i32 = 0x1;
pub const CDBE_TYPE_DATA: i32 = 0x2;
pub const CDBE_TYPE_ALL: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
pub const ECF_DEFAULT: i32 = 0x0;
pub const ECF_HASSUBCOMMANDS: i32 = 0x1;
pub const ECF_HASSPLITBUTTON: i32 = 0x2;
pub const ECF_HIDELABEL: i32 = 0x4;
pub const ECF_ISSEPARATOR: i32 = 0x8;
pub const ECF_HASLUASHIELD: i32 = 0x10;
pub const ECF_SEPARATORBEFORE: i32 = 0x20;
pub const ECF_SEPARATORAFTER: i32 = 0x40;
pub const ECF_ISDROPDOWN: i32 = 0x80;
pub const ECF_TOGGLEABLE: i32 = 0x100;
pub const ECF_AUTOMENUICONS: i32 = 0x200;
pub const ECS_ENABLED: i32 = 0x0;
pub const ECS_DISABLED: i32 = 0x1;
pub const ECS_HIDDEN: i32 = 0x2;
pub const ECS_CHECKBOX: i32 = 0x4;
pub const ECS_CHECKED: i32 = 0x8;
pub const ECS_RADIOCHECK: i32 = 0x10;
pub const EPS_DONTCARE: i32 = 0x0;
pub const EPS_DEFAULT_ON: i32 = 0x1;
pub const EPS_DEFAULT_OFF: i32 = 0x2;
pub const EPS_STATEMASK: i32 = 0xFFFF;
pub const EPS_INITIALSTATE: i32 = 0x10000;
pub const EPS_FORCE: i32 = 0x20000;
pub const EXPPS_FILETYPES: i32 = 0x1;
pub const HLSHORTCUTF_DEFAULT: i32 = 0x0;
pub const HLSHORTCUTF_DONTACTUALLYCREATE: i32 = 0x1;
pub const HLSHORTCUTF_USEFILENAMEFROMFRIENDLYNAME: i32 = 0x2;
pub const HLSHORTCUTF_USEUNIQUEFILENAME: i32 = 0x4;
pub const HLSHORTCUTF_MAYUSEEXISTINGSHORTCUT: i32 = 0x8;
pub const HLSR_HOME: i32 = 0x0;
pub const HLSR_SEARCHPAGE: i32 = 0x1;
pub const HLSR_HISTORYFOLDER: i32 = 0x2;
pub const HLTRANSLATEF_DEFAULT: i32 = 0x0;
pub const HLTRANSLATEF_DONTAPPLYDEFAULTPREFIX: i32 = 0x1;
pub const KFDF_LOCAL_REDIRECT_ONLY: i32 = 0x2;
pub const KFDF_ROAMABLE: i32 = 0x4;
pub const KFDF_PRECREATE: i32 = 0x8;
pub const KFDF_STREAM: i32 = 0x10;
pub const KFDF_PUBLISHEXPANDEDPATH: i32 = 0x20;
pub const KFDF_NO_REDIRECT_UI: i32 = 0x40;
pub const KF_REDIRECTION_CAPABILITIES_ALLOW_ALL: i32 = 0xFF;
pub const KF_REDIRECTION_CAPABILITIES_REDIRECTABLE: i32 = 0x1;
pub const KF_REDIRECTION_CAPABILITIES_DENY_ALL: i32 = 0xFFF00;
pub const KF_REDIRECTION_CAPABILITIES_DENY_POLICY_REDIRECTED: i32 = 0x100;
pub const KF_REDIRECTION_CAPABILITIES_DENY_POLICY: i32 = 0x200;
pub const KF_REDIRECTION_CAPABILITIES_DENY_PERMISSIONS: i32 = 0x400;
pub const KF_REDIRECT_USER_EXCLUSIVE: i32 = 0x1;
pub const KF_REDIRECT_COPY_SOURCE_DACL: i32 = 0x2;
pub const KF_REDIRECT_OWNER_USER: i32 = 0x4;
pub const KF_REDIRECT_SET_OWNER_EXPLICIT: i32 = 0x8;
pub const KF_REDIRECT_CHECK_ONLY: i32 = 0x10;
pub const KF_REDIRECT_WITH_UI: i32 = 0x20;
pub const KF_REDIRECT_UNPIN: i32 = 0x40;
pub const KF_REDIRECT_PIN: i32 = 0x80;
pub const KF_REDIRECT_COPY_CONTENTS: i32 = 0x200;
pub const KF_REDIRECT_DEL_SOURCE_CONTENTS: i32 = 0x400;
pub const KF_REDIRECT_EXCLUDE_ALL_KNOWN_SUBFOLDERS: i32 = 0x800;
pub const LIM_SMALL: i32 = 0x0;
pub const LIM_LARGE: i32 = 0x1;
pub const NMCII_NONE: i32 = 0x0;
pub const NMCII_ITEMS: i32 = 0x1;
pub const NMCII_FOLDERS: i32 = 0x2;
pub const NMCSAEI_SELECT: i32 = 0x0;
pub const NMCSAEI_EDIT: i32 = 0x1;
pub const NSTCECT_LBUTTON: i32 = 0x1;
pub const NSTCECT_MBUTTON: i32 = 0x2;
pub const NSTCECT_RBUTTON: i32 = 0x3;
pub const NSTCECT_BUTTON: i32 = 0x3;
pub const NSTCECT_DBLCLICK: i32 = 0x4;
pub const NSTCEHT_NOWHERE: i32 = 0x1;
pub const NSTCEHT_ONITEMICON: i32 = 0x2;
pub const NSTCEHT_ONITEMLABEL: i32 = 0x4;
pub const NSTCEHT_ONITEMINDENT: i32 = 0x8;
pub const NSTCEHT_ONITEMBUTTON: i32 = 0x10;
pub const NSTCEHT_ONITEMRIGHT: i32 = 0x20;
pub const NSTCEHT_ONITEMSTATEICON: i32 = 0x40;
pub const NSTCEHT_ONITEM: i32 = 0x46;
pub const NSTCEHT_ONITEMTABBUTTON: i32 = 0x1000;
pub const NSTCIS_NONE: i32 = 0x0;
pub const NSTCIS_SELECTED: i32 = 0x1;
pub const NSTCIS_EXPANDED: i32 = 0x2;
pub const NSTCIS_BOLD: i32 = 0x4;
pub const NSTCIS_DISABLED: i32 = 0x8;
pub const NSTCIS_SELECTEDNOEXPAND: i32 = 0x10;
pub const NSTCRS_VISIBLE: i32 = 0x0;
pub const NSTCRS_HIDDEN: i32 = 0x1;
pub const NSTCRS_EXPANDED: i32 = 0x2;
pub const NSTCS_HASEXPANDOS: i32 = 0x1;
pub const NSTCS_HASLINES: i32 = 0x2;
pub const NSTCS_SINGLECLICKEXPAND: i32 = 0x4;
pub const NSTCS_FULLROWSELECT: i32 = 0x8;
pub const NSTCS_SPRINGEXPAND: i32 = 0x10;
pub const NSTCS_HORIZONTALSCROLL: i32 = 0x20;
pub const NSTCS_ROOTHASEXPANDO: i32 = 0x40;
pub const NSTCS_SHOWSELECTIONALWAYS: i32 = 0x80;
pub const NSTCS_NOINFOTIP: i32 = 0x200;
pub const NSTCS_EVENHEIGHT: i32 = 0x400;
pub const NSTCS_NOREPLACEOPEN: i32 = 0x800;
pub const NSTCS_DISABLEDRAGDROP: i32 = 0x1000;
pub const NSTCS_NOORDERSTREAM: i32 = 0x2000;
pub const NSTCS_RICHTOOLTIP: i32 = 0x4000;
pub const NSTCS_BORDER: i32 = 0x8000;
pub const NSTCS_NOEDITLABELS: i32 = 0x10000;
pub const NSTCS_TABSTOP: i32 = 0x20000;
pub const NSTCS_FAVORITESMODE: i32 = 0x80000;
pub const NSTCS_AUTOHSCROLL: i32 = 0x100000;
pub const NSTCS_FADEINOUTEXPANDOS: i32 = 0x200000;
pub const NSTCS_EMPTYTEXT: i32 = 0x400000;
pub const NSTCS_CHECKBOXES: i32 = 0x800000;
pub const NSTCS_PARTIALCHECKBOXES: i32 = 0x1000000;
pub const NSTCS_EXCLUSIONCHECKBOXES: i32 = 0x2000000;
pub const NSTCS_DIMMEDCHECKBOXES: i32 = 0x4000000;
pub const NSTCS_NOINDENTCHECKS: i32 = 0x8000000;
pub const NSTCS_ALLOWJUNCTIONS: i32 = 0x10000000;
pub const NSTCS_SHOWTABSBUTTON: i32 = 0x20000000;
pub const NSTCS_SHOWDELETEBUTTON: i32 = 0x40000000;
pub const NSTCS_SHOWREFRESHBUTTON: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFF80000000;
pub const OPPROGDLG_DEFAULT: i32 = 0x0;
pub const OPPROGDLG_ENABLEPAUSE: i32 = 0x80;
pub const OPPROGDLG_ALLOWUNDO: i32 = 0x100;
pub const OPPROGDLG_DONTDISPLAYSOURCEPATH: i32 = 0x200;
pub const OPPROGDLG_DONTDISPLAYDESTPATH: i32 = 0x400;
pub const OPPROGDLG_NOMULTIDAYESTIMATES: i32 = 0x800;
pub const OPPROGDLG_DONTDISPLAYLOCATIONS: i32 = 0x1000;
pub const PDM_DEFAULT: i32 = 0x0;
pub const PDM_RUN: i32 = 0x1;
pub const PDM_PREFLIGHT: i32 = 0x2;
pub const PDM_UNDOING: i32 = 0x4;
pub const PDM_ERRORSBLOCKING: i32 = 0x8;
pub const PDM_INDETERMINATE: i32 = 0x10;
pub const SHCONTF_CHECKING_FOR_CHILDREN: i32 = 0x10;
pub const SHCONTF_FOLDERS: i32 = 0x20;
pub const SHCONTF_NONFOLDERS: i32 = 0x40;
pub const SHCONTF_INCLUDEHIDDEN: i32 = 0x80;
pub const SHCONTF_INIT_ON_FIRST_NEXT: i32 = 0x100;
pub const SHCONTF_NETPRINTERSRCH: i32 = 0x200;
pub const SHCONTF_SHAREABLE: i32 = 0x400;
pub const SHCONTF_STORAGE: i32 = 0x800;
pub const SHCONTF_NAVIGATION_ENUM: i32 = 0x1000;
pub const SHCONTF_FASTITEMS: i32 = 0x2000;
pub const SHCONTF_FLATLIST: i32 = 0x4000;
pub const SHCONTF_ENABLE_ASYNC: i32 = 0x8000;
pub const SHCONTF_INCLUDESUPERHIDDEN: i32 = 0x10000;
pub const SHGDN_NORMAL: i32 = 0x0;
pub const SHGDN_INFOLDER: i32 = 0x1;
pub const SHGDN_FOREDITING: i32 = 0x1000;
pub const SHGDN_FORADDRESSBAR: i32 = 0x4000;
pub const SHGDN_FORPARSING: i32 = 0x8000;
pub const SICHINT_DISPLAY: i32 = 0x0;
pub const SICHINT_ALLFIELDS: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFF80000000;
pub const SICHINT_CANONICAL: i32 = 0x10000000;
pub const SICHINT_TEST_FILESYSPATH_IF_NOT_EQUAL: i32 = 0x20000000;
pub const SPBEGINF_NORMAL: i32 = 0x0;
pub const SPBEGINF_AUTOTIME: i32 = 0x2;
pub const SPBEGINF_NOPROGRESSBAR: i32 = 0x10;
pub const SPBEGINF_MARQUEEPROGRESS: i32 = 0x20;
pub const SPBEGINF_NOCANCELBUTTON: i32 = 0x40;
pub const SPINITF_NORMAL: i32 = 0x0;
pub const SPINITF_MODAL: i32 = 0x1;
pub const SPINITF_NOMINIMIZE: i32 = 0x8;
pub const SV3CVW3_DEFAULT: i32 = 0x0;
pub const SV3CVW3_NONINTERACTIVE: i32 = 0x1;
pub const SV3CVW3_FORCEVIEWMODE: i32 = 0x2;
pub const SV3CVW3_FORCEFOLDERFLAGS: i32 = 0x4;
pub const SVGIO_BACKGROUND: i32 = 0x0;
pub const SVGIO_SELECTION: i32 = 0x1;
pub const SVGIO_ALLVIEW: i32 = 0x2;
pub const SVGIO_CHECKED: i32 = 0x3;
pub const SVGIO_TYPE_MASK: i32 = 0xF;
pub const SVGIO_FLAG_VIEWORDER: i32 = 0xFFFFFFFFFFFFFFFFFFFFFFFF80000000;
pub const SVSI_DESELECT: i32 = 0x0;
pub const SVSI_SELECT: i32 = 0x1;
pub const SVSI_EDIT: i32 = 0x3;
pub const SVSI_DESELECTOTHERS: i32 = 0x4;
pub const SVSI_ENSUREVISIBLE: i32 = 0x8;
pub const SVSI_FOCUSED: i32 = 0x10;
pub const SVSI_TRANSLATEPT: i32 = 0x20;
pub const SVSI_SELECTIONMARK: i32 = 0x40;
pub const SVSI_POSITIONITEM: i32 = 0x80;
pub const SVSI_CHECK: i32 = 0x100;
pub const SVSI_CHECK2: i32 = 0x200;
pub const SVSI_KEYBOARDSELECT: i32 = 0x401;
pub const SVSI_NOTAKEFOCUS: i32 = 0x40000000;
pub const TS_NONE: i32 = 0x0;
pub const TS_PERFORMING: i32 = 0x1;
pub const TS_PREPARING: i32 = 0x2;
pub const TS_INDETERMINATE: i32 = 0x4;
pub const TSF_NORMAL: i32 = 0x0;
pub const TSF_FAIL_EXIST: i32 = 0x0;
pub const TSF_RENAME_EXIST: i32 = 0x1;
pub const TSF_OVERWRITE_EXIST: i32 = 0x2;
pub const TSF_ALLOW_DECRYPTION: i32 = 0x4;
pub const TSF_NO_SECURITY: i32 = 0x8;
pub const TSF_COPY_CREATION_TIME: i32 = 0x10;
pub const TSF_COPY_WRITE_TIME: i32 = 0x20;
pub const TSF_USE_FULL_ACCESS: i32 = 0x40;
pub const TSF_DELETE_RECYCLE_IF_POSSIBLE: i32 = 0x80;
pub const TSF_COPY_HARD_LINK: i32 = 0x100;
pub const TSF_COPY_LOCALIZED_NAME: i32 = 0x200;
pub const TSF_MOVE_AS_COPY_DELETE: i32 = 0x400;
pub const TSF_SUSPEND_SHELLEVENTS: i32 = 0x800;
pub const IURL_INVOKECOMMAND_FL_ALLOW_UI: i32 = 0x1;
pub const IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB: i32 = 0x2;
pub const IURL_INVOKECOMMAND_FL_DDEWAIT: i32 = 0x4;
pub const IURL_INVOKECOMMAND_FL_ASYNCOK: i32 = 0x8;
pub const IURL_INVOKECOMMAND_FL_LOG_USAGE: i32 = 0x10;
pub const IURL_SETURL_FL_GUESS_PROTOCOL: i32 = 0x1;
pub const IURL_SETURL_FL_USE_DEFAULT_PROTOCOL: i32 = 0x2;
pub const MIMEASSOCDLG_FL_REGISTER_ASSOC: i32 = 0x1;
//  Not generated due to containing a void type
//  #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct ProviderInfo<'a> {
//      pub pi_r0_1val: Option<unsafe extern "system" fn(*mut c_void, *mut val_context, u32, *mut c_void, *mut u32, u32) -> u32>,
//      pub pi_r0_allvals: Option<unsafe extern "system" fn(*mut c_void, *mut val_context, u32, *mut c_void, *mut u32, u32) -> u32>,
//      pub pi_r3_1val: Option<unsafe extern "system" fn(*mut c_void, *mut val_context, u32, *mut c_void, *mut u32, u32) -> u32>,
//      pub pi_r3_allvals: Option<unsafe extern "system" fn(*mut c_void, *mut val_context, u32, *mut c_void, *mut u32, u32) -> u32>,
//      pub pi_flags: u32,
//      pub pi_key_context: &'a mut todo_void,
//  }
//  impl ProviderInfo {
//      fn to_win32(&self) -> windows_sys::Win32::System::Registry::provider_info {
//          let Self { pi_r0_1val, pi_r0_allvals, pi_r3_1val, pi_r3_allvals, pi_flags, pi_key_context } = self;
//          let pi_R0_1val = Some(pi_r0_1val);
//          let pi_R0_allvals = Some(pi_r0_allvals);
//          let pi_R3_1val = Some(pi_r3_1val);
//          let pi_R3_allvals = Some(pi_r3_allvals);
//          let pi_flags = *pi_flags;
//          let pi_key_context = unsafe { &mut *(pi_key_context as *mut _ as *mut _) };
//          windows_sys::Win32::System::Registry::provider_info { pi_R0_1val, pi_R0_allvals, pi_R3_1val, pi_R3_allvals, pi_flags, pi_key_context }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::System::Registry::provider_info) -> Self {
//          let windows_sys::Win32::System::Registry::provider_info { pi_R0_1val, pi_R0_allvals, pi_R3_1val, pi_R3_allvals, pi_flags, pi_key_context } = win32;
//          let pi_r0_1val = pi_R0_1val;
//          let pi_r0_allvals = pi_R0_allvals;
//          let pi_r3_1val = pi_R3_1val;
//          let pi_r3_allvals = pi_R3_allvals;
//          let pi_flags = pi_flags;
//          let pi_key_context = unsafe { &mut *(pi_key_context as *mut _ as *mut _) };
//          Self { pi_r0_1val, pi_r0_allvals, pi_r3_1val, pi_r3_allvals, pi_flags, pi_key_context }
//      }
//  }
//  Not generated due to containing a void type
//  #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct PvalueA<'a> {
//      pub pv_valuename: Cow<'a, CStr>,
//      pub pv_valuelen: i32,
//      pub pv_value_context: &'a mut todo_void,
//      pub pv_type: u32,
//  }
//  impl PvalueA {
//      fn to_win32(&self) -> windows_sys::Win32::System::Registry::pvalueA {
//          let Self { pv_valuename, pv_valuelen, pv_value_context, pv_type } = self;
//          let pv_valuename = pv_valuename.as_ptr();
//          let pv_valuelen = *pv_valuelen;
//          let pv_value_context = unsafe { &mut *(pv_value_context as *mut _ as *mut _) };
//          let pv_type = *pv_type;
//          windows_sys::Win32::System::Registry::pvalueA { pv_valuename, pv_valuelen, pv_value_context, pv_type }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::System::Registry::pvalueA) -> Self {
//          let windows_sys::Win32::System::Registry::pvalueA { pv_valuename, pv_valuelen, pv_value_context, pv_type } = win32;
//          let pv_valuename = unsafe { CStr::from_ptr(pv_valuename) };
//          let pv_valuename = pv_valuename.to_bytes_with_nul().to_vec();
//          let pv_valuename = Cow::Owned(unsafe { CString::from_vec_unchecked(pv_valuename) });
//          let pv_valuelen = pv_valuelen;
//          let pv_value_context = unsafe { &mut *(pv_value_context as *mut _ as *mut _) };
//          let pv_type = pv_type;
//          Self { pv_valuename, pv_valuelen, pv_value_context, pv_type }
//      }
//  }
//  Not generated due to containing a void type
//  #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct PvalueW<'a> {
//      pub pv_valuename: Cow<'a, [u16]>,
//      pub pv_valuelen: i32,
//      pub pv_value_context: &'a mut todo_void,
//      pub pv_type: u32,
//  }
//  impl PvalueW {
//      fn to_win32(&self) -> windows_sys::Win32::System::Registry::pvalueW {
//          let Self { pv_valuename, pv_valuelen, pv_value_context, pv_type } = self;
//          assert_eq!(pv_valuename.last(), Some(0));
//          let pv_valuename = pv_valuename.as_ptr();
//          let pv_valuelen = *pv_valuelen;
//          let pv_value_context = unsafe { &mut *(pv_value_context as *mut _ as *mut _) };
//          let pv_type = *pv_type;
//          windows_sys::Win32::System::Registry::pvalueW { pv_valuename, pv_valuelen, pv_value_context, pv_type }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::System::Registry::pvalueW) -> Self {
//          let windows_sys::Win32::System::Registry::pvalueW { pv_valuename, pv_valuelen, pv_value_context, pv_type } = win32;
//          let slen = unsafe { wide_strlen(pv_valuename as *const u16) };
//          let pv_valuename = unsafe { slice::from_raw_parts(pv_valuename, slen + 1) };
//          let pv_valuename = pv_valuename.to_vec();
//          let pv_valuelen = pv_valuelen;
//          let pv_value_context = unsafe { &mut *(pv_value_context as *mut _ as *mut _) };
//          let pv_type = pv_type;
//          Self { pv_valuename, pv_valuelen, pv_value_context, pv_type }
//      }
//  }
pub const TRANSLATEURL_FL_GUESS_PROTOCOL: i32 = 0x1;
pub const TRANSLATEURL_FL_USE_DEFAULT_PROTOCOL: i32 = 0x2;
pub const URLASSOCDLG_FL_USE_DEFAULT_NAME: i32 = 0x1;
pub const URLASSOCDLG_FL_REGISTER_ASSOC: i32 = 0x2;
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct UrlinvokecommandinfoA<'a> {
    pub dwcb_size: u32,
    pub dw_flags: u32,
    pub hwnd_parent: Option<Hwnd>,
    pub pcsz_verb: Cow<'a, CStr>,
}
impl UrlinvokecommandinfoA {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::urlinvokecommandinfoA {
        let Self { dwcb_size, dw_flags, hwnd_parent, pcsz_verb } = self;
        let dwcbSize = mem::size_of::<windows_sys::Win32::UI::Shell::urlinvokecommandinfoA>() as _;
        let dwFlags = *dw_flags;
        let hwndParent = hwnd_parent.map_or(0, Hwnd::into_raw);
        let pcszVerb = pcsz_verb.as_ptr();
        windows_sys::Win32::UI::Shell::urlinvokecommandinfoA { dwcbSize, dwFlags, hwndParent, pcszVerb }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::urlinvokecommandinfoA) -> Self {
        let windows_sys::Win32::UI::Shell::urlinvokecommandinfoA { dwcbSize, dwFlags, hwndParent, pcszVerb } = win32;
        let dwcb_size = dwcbSize;
        let dw_flags = dwFlags;
        let hwnd_parent = unsafe { Hwnd::new_optional(hwndParent) };
        let pcszVerb = unsafe { CStr::from_ptr(pcszVerb) };
        let pcszVerb = pcszVerb.to_bytes_with_nul().to_vec();
        let pcsz_verb = Cow::Owned(unsafe { CString::from_vec_unchecked(pcszVerb) });
        Self { dwcb_size, dw_flags, hwnd_parent, pcsz_verb }
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct UrlinvokecommandinfoW<'a> {
    pub dwcb_size: u32,
    pub dw_flags: u32,
    pub hwnd_parent: Option<Hwnd>,
    pub pcsz_verb: Cow<'a, [u16]>,
}
impl UrlinvokecommandinfoW {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::urlinvokecommandinfoW {
        let Self { dwcb_size, dw_flags, hwnd_parent, pcsz_verb } = self;
        let dwcbSize = mem::size_of::<windows_sys::Win32::UI::Shell::urlinvokecommandinfoW>() as _;
        let dwFlags = *dw_flags;
        let hwndParent = hwnd_parent.map_or(0, Hwnd::into_raw);
        assert_eq!(pcsz_verb.last(), Some(0));
        let pcszVerb = pcsz_verb.as_ptr();
        windows_sys::Win32::UI::Shell::urlinvokecommandinfoW { dwcbSize, dwFlags, hwndParent, pcszVerb }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::urlinvokecommandinfoW) -> Self {
        let windows_sys::Win32::UI::Shell::urlinvokecommandinfoW { dwcbSize, dwFlags, hwndParent, pcszVerb } = win32;
        let dwcb_size = dwcbSize;
        let dw_flags = dwFlags;
        let hwnd_parent = unsafe { Hwnd::new_optional(hwndParent) };
        let slen = unsafe { wide_strlen(pcszVerb as *const u16) };
        let pcszVerb = unsafe { slice::from_raw_parts(pcszVerb, slen + 1) };
        let pcsz_verb = pcszVerb.to_vec();
        Self { dwcb_size, dw_flags, hwnd_parent, pcsz_verb }
    }
}
//  Not generated due to containing a void type
//  #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct ValContext<'a> {
//      pub valuelen: i32,
//      pub value_context: &'a mut todo_void,
//      pub val_buff_ptr: &'a mut todo_void,
//  }
//  impl ValContext {
//      fn to_win32(&self) -> windows_sys::Win32::System::Registry::val_context {
//          let Self { valuelen, value_context, val_buff_ptr } = self;
//          let valuelen = *valuelen;
//          let value_context = unsafe { &mut *(value_context as *mut _ as *mut _) };
//          let val_buff_ptr = unsafe { &mut *(val_buff_ptr as *mut _ as *mut _) };
//          windows_sys::Win32::System::Registry::val_context { valuelen, value_context, val_buff_ptr }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::System::Registry::val_context) -> Self {
//          let windows_sys::Win32::System::Registry::val_context { valuelen, value_context, val_buff_ptr } = win32;
//          let valuelen = valuelen;
//          let value_context = unsafe { &mut *(value_context as *mut _ as *mut _) };
//          let val_buff_ptr = unsafe { &mut *(val_buff_ptr as *mut _ as *mut _) };
//          Self { valuelen, value_context, val_buff_ptr }
//      }
//  }
#[inline]
pub fn close_handle(h_object: Handle) -> Result<BOOL> {
    let hObject = h_object.into_raw();
    let return_value = unsafe { windows_sys::Win32::Foundation::CloseHandle(hObject) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn compare_object_handles(h_first_object_handle: Handle, h_second_object_handle: Handle) -> Result<BOOL> {
    let hFirstObjectHandle = h_first_object_handle.into_raw();
    let hSecondObjectHandle = h_second_object_handle.into_raw();
    let return_value = unsafe { windows_sys::Win32::Foundation::CompareObjectHandles(hFirstObjectHandle, hSecondObjectHandle) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn duplicate_handle(h_source_process_handle: Handle, h_source_handle: Handle, h_target_process_handle: Handle, dw_desired_access: u32, b_inherit_handle: BOOL, dw_options: u32) -> Result<(BOOL, Handle)> {
    let mut lp_target_handle = mem::MaybeUninit::zeroed();
    let lpTargetHandle = lp_target_handle.as_mut_ptr();
    let hSourceProcessHandle = h_source_process_handle.into_raw();
    let hSourceHandle = h_source_handle.into_raw();
    let hTargetProcessHandle = h_target_process_handle.into_raw();
    let dwDesiredAccess = dw_desired_access;
    let bInheritHandle = b_inherit_handle;
    let dwOptions = dw_options;
    let return_value = unsafe { windows_sys::Win32::Foundation::DuplicateHandle(hSourceProcessHandle, hSourceHandle, hTargetProcessHandle, lpTargetHandle, dwDesiredAccess, bInheritHandle, dwOptions) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_target_handle = unsafe { Handle::new(unsafe { lpTargetHandle.assume_init() }) };
    Ok((return_value,lpTargetHandle))
}
#[inline]
pub fn get_handle_information(h_object: Handle, ) -> Result<(BOOL, u32)> {
    let mut lpdw_flags = mem::MaybeUninit::zeroed();
    let lpdwFlags = lpdw_flags.as_mut_ptr();
    let hObject = h_object.into_raw();
    let return_value = unsafe { windows_sys::Win32::Foundation::GetHandleInformation(hObject, lpdwFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpdw_flags = unsafe { lpdwFlags.assume_init() };
    Ok((return_value,lpdwFlags))
}
#[inline]
pub fn get_last_error() -> u32 {
    let return_value = unsafe { windows_sys::Win32::Foundation::GetLastError() };
    return_value
}
#[inline]
pub fn rtl_nt_status_to_dos_error(status: NTSTATUS) -> u32 {
    let Status = status;
    let return_value = unsafe { windows_sys::Win32::Foundation::RtlNtStatusToDosError(Status) };
    return_value
}
#[inline]
pub fn set_handle_information(h_object: Handle, dw_mask: u32, dw_flags: u32) -> Result<BOOL> {
    let hObject = h_object.into_raw();
    let dwMask = dw_mask;
    let dwFlags = dw_flags;
    let return_value = unsafe { windows_sys::Win32::Foundation::SetHandleInformation(hObject, dwMask, dwFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_last_error(dw_err_code: u32) -> () {
    let dwErrCode = dw_err_code;
    let return_value = unsafe { windows_sys::Win32::Foundation::SetLastError(dwErrCode) };
    let _ = return_value;
}
#[inline]
pub fn set_last_error_ex(dw_err_code: u32, dw_type: u32) -> () {
    let dwErrCode = dw_err_code;
    let dwType = dw_type;
    let return_value = unsafe { windows_sys::Win32::Foundation::SetLastErrorEx(dwErrCode, dwType) };
    let _ = return_value;
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn get_registry_value_with_fallback_w(hkey_primary: Option<Hkey>, pwsz_primary_sub_key: Option<&OsStr>, hkey_fallback: Option<Hkey>, pwsz_fallback_sub_key: Option<&OsStr>, pwsz_value: &OsStr, dw_flags: u32, pv_data: Option<todo_void>, cb_data_in: u32, ) -> (u32, u32, todo_void_ret, u32) {
//      let mut pdw_type = mem::MaybeUninit::zeroed();
//      let pdwType = pdw_type.as_mut_ptr();
//      let mut pcb_data_out = mem::MaybeUninit::zeroed();
//      let pcbDataOut = pcb_data_out.as_mut_ptr();
//      let hkeyPrimary = hkey_primary.map_or(0, Hkey::into_raw);
//      let temp0 = pwsz_primary_sub_key.map(|val| {
//          let mut temp0: Vec<u16> = val.encode_wide().collect();
//          temp0.push(0);
//          temp0
//      });
//      let pwszPrimarySubKey = temp0.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let hkeyFallback = hkey_fallback.map_or(0, Hkey::into_raw);
//      let temp1 = pwsz_fallback_sub_key.map(|val| {
//          let mut temp1: Vec<u16> = val.encode_wide().collect();
//          temp1.push(0);
//          temp1
//      });
//      let pwszFallbackSubKey = temp1.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let mut temp2: Vec<u16> = pwsz_value.encode_wide().collect();
//      temp2.push(0);
//      let pwszValue = temp2.as_ptr() as _;
//      let dwFlags = dw_flags;
//      let mut pvData = todo_void;
//      let cbDataIn = cb_data_in;
//      let return_value = unsafe { windows_sys::Win32::System::Registry::GetRegistryValueWithFallbackW(hkeyPrimary, pwszPrimarySubKey, hkeyFallback, pwszFallbackSubKey, pwszValue, dwFlags, pdwType, &mut pvData, cbDataIn, pcbDataOut) };
//      let pcb_data_out = unsafe { pcbDataOut.assume_init() };
//      let pv_data = todo_void;
//      let pdw_type = unsafe { pdwType.assume_init() };
//      (return_value,pdwType, pvData, pcbDataOut)
//  }
#[inline]
pub fn abort_path(hdc: Hdc) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::AbortPath(hdc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn add_font_mem_resource_ex(p_file_view: &todo_void, pv_resrved: todo_void, p_num_fonts: &[u32]) -> Result<(Handle, todo_void_ret)> {
//      // SAFETY: type is a thin type
//      let pFileView = unsafe { &*(p_file_view as *const _ as *const _) };
//      let mut pvResrved = todo_void;
//      let pNumFonts = p_num_fonts.as_ptr() as _;
//      let cjSize = p_num_fonts.len() as _;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::AddFontMemResourceEx(pFileView, cjSize, &mut pvResrved, pNumFonts) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let pv_resrved = todo_void;
//      Ok((return_value,pvResrved))
//  }
#[inline]
pub fn add_font_resource_a(param0: &CStr) -> Result<i32> {
    let param0 = param0.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::AddFontResourceA(param0) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn add_font_resource_ex_a(name: &CStr, fl: u32, res: todo_void) -> Result<(i32, todo_void_ret)> {
//      let name = name.as_ptr() as _;
//      let fl = fl;
//      let mut res = todo_void;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::AddFontResourceExA(name, fl, &mut res) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let res = todo_void;
//      Ok((return_value,res))
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn add_font_resource_ex_w(name: &OsStr, fl: u32, res: todo_void) -> Result<(i32, todo_void_ret)> {
//      let mut temp3: Vec<u16> = name.encode_wide().collect();
//      temp3.push(0);
//      let name = temp3.as_ptr() as _;
//      let fl = fl;
//      let mut res = todo_void;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::AddFontResourceExW(name, fl, &mut res) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let res = todo_void;
//      Ok((return_value,res))
//  }
#[inline]
pub fn add_font_resource_w(param0: &OsStr) -> Result<i32> {
    let mut temp4: Vec<u16> = param0.encode_wide().collect();
    temp4.push(0);
    let param0 = temp4.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::AddFontResourceW(param0) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn alpha_blend(hdc_dest: Hdc, xorigin_dest: i32, yorigin_dest: i32, w_dest: i32, h_dest: i32, hdc_src: Hdc, xorigin_src: i32, yorigin_src: i32, w_src: i32, h_src: i32, ftn: Blendfunction) -> Result<BOOL> {
    let hdcDest = hdc_dest.into_raw();
    let xoriginDest = xorigin_dest;
    let yoriginDest = yorigin_dest;
    let wDest = w_dest;
    let hDest = h_dest;
    let hdcSrc = hdc_src.into_raw();
    let xoriginSrc = xorigin_src;
    let yoriginSrc = yorigin_src;
    let wSrc = w_src;
    let hSrc = h_src;
    let ftn = ftn.to_win32();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::AlphaBlend(hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, ftn) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn angle_arc(hdc: Hdc, x: i32, y: i32, r: u32, start_angle: f32, sweep_angle: f32) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    let r = r;
    let StartAngle = start_angle;
    let SweepAngle = sweep_angle;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::AngleArc(hdc, x, y, r, StartAngle, SweepAngle) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn animate_palette(h_pal: Hpalette, i_start_index: u32, ppe: &[Paletteentry]) -> Result<BOOL> {
    let hPal = h_pal.into_raw();
    let iStartIndex = i_start_index;
    let ppe = ppe.as_ptr() as _;
    let cEntries = ppe.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::AnimatePalette(hPal, iStartIndex, cEntries, ppe) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn arc(hdc: Hdc, x1: i32, y1: i32, x2: i32, y2: i32, x3: i32, y3: i32, x4: i32, y4: i32) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let x1 = x1;
    let y1 = y1;
    let x2 = x2;
    let y2 = y2;
    let x3 = x3;
    let y3 = y3;
    let x4 = x4;
    let y4 = y4;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::Arc(hdc, x1, y1, x2, y2, x3, y3, x4, y4) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn arc_to(hdc: Hdc, left: i32, top: i32, right: i32, bottom: i32, xr1: i32, yr1: i32, xr2: i32, yr2: i32) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let left = left;
    let top = top;
    let right = right;
    let bottom = bottom;
    let xr1 = xr1;
    let yr1 = yr1;
    let xr2 = xr2;
    let yr2 = yr2;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ArcTo(hdc, left, top, right, bottom, xr1, yr1, xr2, yr2) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn begin_paint(h_wnd: Hwnd, ) -> Result<(Hdc, Paintstruct)> {
    let mut lp_paint = mem::MaybeUninit::zeroed();
    let lpPaint = lp_paint.as_mut_ptr();
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::BeginPaint(hWnd, lpPaint) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_paint = unsafe { Paintstruct::from_win32(unsafe { lpPaint.assume_init() }) };
    Ok((return_value,lpPaint))
}
#[inline]
pub fn begin_path(hdc: Hdc) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::BeginPath(hdc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn bit_blt(hdc: Hdc, x: i32, y: i32, cx: i32, cy: i32, hdc_src: Option<Hdc>, x1: i32, y1: i32, rop: u32) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    let cx = cx;
    let cy = cy;
    let hdcSrc = hdc_src.map_or(0, Hdc::into_raw);
    let x1 = x1;
    let y1 = y1;
    let rop = rop;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::BitBlt(hdc, x, y, cx, cy, hdcSrc, x1, y1, rop) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn cancel_dc(hdc: Hdc) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CancelDC(hdc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn change_display_settings_a(lp_dev_mode: Option<&Devmodea>, dw_flags: u32) -> i32 {
    // SAFETY: type is a thin type
    let lpDevMode = lp_dev_mode.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let dwFlags = dw_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ChangeDisplaySettingsA(lpDevMode, dwFlags) };
    return_value
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn change_display_settings_ex_a(lpsz_device_name: Option<&CStr>, lp_dev_mode: Option<&Devmodea>, hwnd: Hwnd, dwflags: u32, l_param: Option<&todo_void>) -> i32 {
//      let lpszDeviceName = lpsz_device_name.map_or(ptr::null(), |v| v.as_ptr() as _);
//      // SAFETY: type is a thin type
//      let lpDevMode = lp_dev_mode.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      let hwnd = hwnd.into_raw();
//      let dwflags = dwflags;
//      // SAFETY: type is a thin type
//      let lParam = l_param.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ChangeDisplaySettingsExA(lpszDeviceName, lpDevMode, hwnd, dwflags, lParam) };
//      return_value
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn change_display_settings_ex_w(lpsz_device_name: Option<&OsStr>, lp_dev_mode: Option<&Devmodew>, hwnd: Hwnd, dwflags: u32, l_param: Option<&todo_void>) -> i32 {
//      let temp5 = lpsz_device_name.map(|val| {
//          let mut temp5: Vec<u16> = val.encode_wide().collect();
//          temp5.push(0);
//          temp5
//      });
//      let lpszDeviceName = temp5.map_or(ptr::null(), |v| v.as_ptr() as _);
//      // SAFETY: type is a thin type
//      let lpDevMode = lp_dev_mode.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      let hwnd = hwnd.into_raw();
//      let dwflags = dwflags;
//      // SAFETY: type is a thin type
//      let lParam = l_param.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ChangeDisplaySettingsExW(lpszDeviceName, lpDevMode, hwnd, dwflags, lParam) };
//      return_value
//  }
#[inline]
pub fn change_display_settings_w(lp_dev_mode: Option<&Devmodew>, dw_flags: u32) -> i32 {
    // SAFETY: type is a thin type
    let lpDevMode = lp_dev_mode.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let dwFlags = dw_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ChangeDisplaySettingsW(lpDevMode, dwFlags) };
    return_value
}
#[inline]
pub fn chord(hdc: Hdc, x1: i32, y1: i32, x2: i32, y2: i32, x3: i32, y3: i32, x4: i32, y4: i32) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let x1 = x1;
    let y1 = y1;
    let x2 = x2;
    let y2 = y2;
    let x3 = x3;
    let y3 = y3;
    let x4 = x4;
    let y4 = y4;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::Chord(hdc, x1, y1, x2, y2, x3, y3, x4, y4) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn client_to_screen(h_wnd: Hwnd, lp_point: Point) -> Result<(BOOL, Point)> {
    let hWnd = h_wnd.into_raw();
    let mut lpPoint = lp_point.to_win32();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ClientToScreen(hWnd, &mut lpPoint) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_point = unsafe { Point::from_win32(lpPoint) };
    Ok((return_value,lpPoint))
}
#[inline]
pub fn close_enh_meta_file(hdc: Hdc) -> Result<Henhmetafile> {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CloseEnhMetaFile(hdc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn close_figure(hdc: Hdc) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CloseFigure(hdc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn close_meta_file(hdc: Hdc) -> Result<Hmetafile> {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CloseMetaFile(hdc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn combine_rgn(hrgn_dst: Option<Hrgn>, hrgn_src1: Option<Hrgn>, hrgn_src2: Option<Hrgn>, i_mode: i32) -> Result<i32> {
    let hrgnDst = hrgn_dst.map_or(0, Hrgn::into_raw);
    let hrgnSrc1 = hrgn_src1.map_or(0, Hrgn::into_raw);
    let hrgnSrc2 = hrgn_src2.map_or(0, Hrgn::into_raw);
    let iMode = i_mode;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CombineRgn(hrgnDst, hrgnSrc1, hrgnSrc2, iMode) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn combine_transform(lpxf1: &Xform, lpxf2: &Xform) -> Result<(BOOL, Xform)> {
    let mut lpxf_out = mem::MaybeUninit::zeroed();
    let lpxfOut = lpxf_out.as_mut_ptr();
    // SAFETY: type is a thin type
    let lpxf1 = unsafe { &*(lpxf1 as *const _ as *const _) };
    // SAFETY: type is a thin type
    let lpxf2 = unsafe { &*(lpxf2 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CombineTransform(lpxfOut, lpxf1, lpxf2) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpxf_out = unsafe { Xform::from_win32(unsafe { lpxfOut.assume_init() }) };
    Ok((return_value,lpxfOut))
}
#[inline]
pub fn copy_enh_meta_file_a(h_enh: Henhmetafile, lp_file_name: Option<&CStr>) -> Result<Henhmetafile> {
    let hEnh = h_enh.into_raw();
    let lpFileName = lp_file_name.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CopyEnhMetaFileA(hEnh, lpFileName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn copy_enh_meta_file_w(h_enh: Henhmetafile, lp_file_name: Option<&OsStr>) -> Result<Henhmetafile> {
    let hEnh = h_enh.into_raw();
    let temp6 = lp_file_name.map(|val| {
        let mut temp6: Vec<u16> = val.encode_wide().collect();
        temp6.push(0);
        temp6
    });
    let lpFileName = temp6.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CopyEnhMetaFileW(hEnh, lpFileName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn copy_meta_file_a(param0: Hmetafile, param1: Option<&CStr>) -> Result<Hmetafile> {
    let param0 = param0.into_raw();
    let param1 = param1.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CopyMetaFileA(param0, param1) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn copy_meta_file_w(param0: Hmetafile, param1: Option<&OsStr>) -> Result<Hmetafile> {
    let param0 = param0.into_raw();
    let temp7 = param1.map(|val| {
        let mut temp7: Vec<u16> = val.encode_wide().collect();
        temp7.push(0);
        temp7
    });
    let param1 = temp7.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CopyMetaFileW(param0, param1) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn copy_rect(lprc_src: &Rect) -> Result<(BOOL, Rect)> {
    let mut lprc_dst = mem::MaybeUninit::zeroed();
    let lprcDst = lprc_dst.as_mut_ptr();
    // SAFETY: type is a thin type
    let lprcSrc = unsafe { &*(lprc_src as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CopyRect(lprcDst, lprcSrc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lprc_dst = unsafe { Rect::from_win32(unsafe { lprcDst.assume_init() }) };
    Ok((return_value,lprcDst))
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn create_bitmap(n_width: i32, n_height: i32, n_planes: u32, lp_bits: Option<&[todo_void]>) -> Result<Hbitmap> {
//      let nWidth = n_width;
//      let nHeight = n_height;
//      let nPlanes = n_planes;
//      let lpBits = lp_bits.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let nBitCount = lp_bits.len() as _;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateBitmap(nWidth, nHeight, nPlanes, nBitCount, lpBits) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn create_bitmap_indirect(pbm: &Bitmap<'_>) -> Result<Hbitmap> {
//      let temp8 = pbm.to_win32();
//      let pbm = &temp8;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateBitmapIndirect(pbm) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
#[inline]
pub fn create_brush_indirect(plbrush: &Logbrush) -> Result<Hbrush> {
    // SAFETY: type is a thin type
    let plbrush = unsafe { &*(plbrush as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateBrushIndirect(plbrush) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_compatible_bitmap(hdc: Hdc, cx: i32, cy: i32) -> Result<Hbitmap> {
    let hdc = hdc.into_raw();
    let cx = cx;
    let cy = cy;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateCompatibleBitmap(hdc, cx, cy) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_compatible_dc(hdc: Option<Hdc>) -> Result<CreatedHdc> {
    let hdc = hdc.map_or(0, Hdc::into_raw);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateCompatibleDC(hdc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_dca(pwsz_driver: Option<&CStr>, pwsz_device: Option<&CStr>, psz_port: Option<&CStr>, pdm: Option<&Devmodea>) -> Result<CreatedHdc> {
    let pwszDriver = pwsz_driver.map_or(ptr::null(), |v| v.as_ptr() as _);
    let pwszDevice = pwsz_device.map_or(ptr::null(), |v| v.as_ptr() as _);
    let pszPort = psz_port.map_or(ptr::null(), |v| v.as_ptr() as _);
    // SAFETY: type is a thin type
    let pdm = pdm.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateDCA(pwszDriver, pwszDevice, pszPort, pdm) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_dcw(pwsz_driver: Option<&OsStr>, pwsz_device: Option<&OsStr>, psz_port: Option<&OsStr>, pdm: Option<&Devmodew>) -> Result<CreatedHdc> {
    let temp9 = pwsz_driver.map(|val| {
        let mut temp9: Vec<u16> = val.encode_wide().collect();
        temp9.push(0);
        temp9
    });
    let pwszDriver = temp9.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp10 = pwsz_device.map(|val| {
        let mut temp10: Vec<u16> = val.encode_wide().collect();
        temp10.push(0);
        temp10
    });
    let pwszDevice = temp10.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp11 = psz_port.map(|val| {
        let mut temp11: Vec<u16> = val.encode_wide().collect();
        temp11.push(0);
        temp11
    });
    let pszPort = temp11.map_or(ptr::null(), |v| v.as_ptr() as _);
    // SAFETY: type is a thin type
    let pdm = pdm.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateDCW(pwszDriver, pwszDevice, pszPort, pdm) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_dib_pattern_brush(h: isize, i_usage: u32) -> Result<Hbrush> {
    let h = h;
    let iUsage = i_usage;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateDIBPatternBrush(h, iUsage) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn create_dib_pattern_brush_pt(lp_packed_dib: &todo_void, i_usage: u32) -> Result<Hbrush> {
//      // SAFETY: type is a thin type
//      let lpPackedDIB = unsafe { &*(lp_packed_dib as *const _ as *const _) };
//      let iUsage = i_usage;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateDIBPatternBrushPt(lpPackedDIB, iUsage) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn create_dib_section(hdc: Option<Hdc>, pbmi: &Bitmapinfo, usage: u32, h_section: Option<Handle>, offset: u32) -> Result<(Hbitmap, &mut todo_void_ret)> {
//      let mut ppv_bits = mem::MaybeUninit::zeroed();
//      let ppvBits = ppv_bits.as_mut_ptr();
//      let hdc = hdc.map_or(0, Hdc::into_raw);
//      let temp12 = pbmi.to_win32();
//      let pbmi = &temp12;
//      let usage = usage;
//      let hSection = h_section.map_or(0, Handle::into_raw);
//      let offset = offset;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateDIBSection(hdc, pbmi, usage, ppvBits, hSection, offset) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let ppv_bits = unsafe { &mut *(unsafe { ppvBits.assume_init() } as *mut _) };
//      Ok((return_value,ppvBits))
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn create_di_bitmap(hdc: Hdc, pbmih: Option<&Bitmapinfoheader>, fl_init: u32, pj_bits: Option<&todo_void>, pbmi: Option<&Bitmapinfo>, i_usage: u32) -> Result<Hbitmap> {
//      let hdc = hdc.into_raw();
//      let temp13 = pbmih.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
//      let pbmih = temp13.as_ref();
//      let flInit = fl_init;
//      // SAFETY: type is a thin type
//      let pjBits = pj_bits.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      let temp14 = pbmi.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
//      let pbmi = temp14.as_ref();
//      let iUsage = i_usage;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateDIBitmap(hdc, pbmih, flInit, pjBits, pbmi, iUsage) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
#[inline]
pub fn create_discardable_bitmap(hdc: Hdc, cx: i32, cy: i32) -> Result<Hbitmap> {
    let hdc = hdc.into_raw();
    let cx = cx;
    let cy = cy;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateDiscardableBitmap(hdc, cx, cy) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_elliptic_rgn(x1: i32, y1: i32, x2: i32, y2: i32) -> Result<Hrgn> {
    let x1 = x1;
    let y1 = y1;
    let x2 = x2;
    let y2 = y2;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateEllipticRgn(x1, y1, x2, y2) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_elliptic_rgn_indirect(lprect: &Rect) -> Result<Hrgn> {
    // SAFETY: type is a thin type
    let lprect = unsafe { &*(lprect as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateEllipticRgnIndirect(lprect) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_enh_meta_file_a(hdc: Option<Hdc>, lp_filename: Option<&CStr>, lprc: Option<&Rect>, lp_desc: Option<&CStr>) -> Result<HdcMetdataEnhFileHandle> {
    let hdc = hdc.map_or(0, Hdc::into_raw);
    let lpFilename = lp_filename.map_or(ptr::null(), |v| v.as_ptr() as _);
    // SAFETY: type is a thin type
    let lprc = lprc.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let lpDesc = lp_desc.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateEnhMetaFileA(hdc, lpFilename, lprc, lpDesc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_enh_meta_file_w(hdc: Option<Hdc>, lp_filename: Option<&OsStr>, lprc: Option<&Rect>, lp_desc: Option<&OsStr>) -> Result<HdcMetdataEnhFileHandle> {
    let hdc = hdc.map_or(0, Hdc::into_raw);
    let temp15 = lp_filename.map(|val| {
        let mut temp15: Vec<u16> = val.encode_wide().collect();
        temp15.push(0);
        temp15
    });
    let lpFilename = temp15.map_or(ptr::null(), |v| v.as_ptr() as _);
    // SAFETY: type is a thin type
    let lprc = lprc.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let temp16 = lp_desc.map(|val| {
        let mut temp16: Vec<u16> = val.encode_wide().collect();
        temp16.push(0);
        temp16
    });
    let lpDesc = temp16.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateEnhMetaFileW(hdc, lpFilename, lprc, lpDesc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_font_a(c_height: i32, c_width: i32, c_escapement: i32, c_orientation: i32, c_weight: i32, b_italic: u32, b_underline: u32, b_strike_out: u32, i_char_set: u32, i_out_precision: u32, i_clip_precision: u32, i_quality: u32, i_pitch_and_family: u32, psz_face_name: Option<&CStr>) -> Result<Hfont> {
    let cHeight = c_height;
    let cWidth = c_width;
    let cEscapement = c_escapement;
    let cOrientation = c_orientation;
    let cWeight = c_weight;
    let bItalic = b_italic;
    let bUnderline = b_underline;
    let bStrikeOut = b_strike_out;
    let iCharSet = i_char_set;
    let iOutPrecision = i_out_precision;
    let iClipPrecision = i_clip_precision;
    let iQuality = i_quality;
    let iPitchAndFamily = i_pitch_and_family;
    let pszFaceName = psz_face_name.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateFontA(cHeight, cWidth, cEscapement, cOrientation, cWeight, bItalic, bUnderline, bStrikeOut, iCharSet, iOutPrecision, iClipPrecision, iQuality, iPitchAndFamily, pszFaceName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_font_indirect_a(lplf: &Logfonta) -> Result<Hfont> {
    // SAFETY: type is a thin type
    let lplf = unsafe { &*(lplf as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateFontIndirectA(lplf) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_font_indirect_ex_a(param0: &Enumlogfontexdva) -> Result<Hfont> {
    // SAFETY: type is a thin type
    let param0 = unsafe { &*(param0 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateFontIndirectExA(param0) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_font_indirect_ex_w(param0: &Enumlogfontexdvw) -> Result<Hfont> {
    // SAFETY: type is a thin type
    let param0 = unsafe { &*(param0 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateFontIndirectExW(param0) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_font_indirect_w(lplf: &Logfontw) -> Result<Hfont> {
    // SAFETY: type is a thin type
    let lplf = unsafe { &*(lplf as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateFontIndirectW(lplf) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn create_font_package(puch_src_buffer: &u8, ppuch_font_package_buffer: &mut u8, pul_font_package_buffer_size: u32, pul_bytes_written: u32, us_flag: u16, us_ttc_index: u16, us_subset_format: u16, us_subset_language: u16, us_subset_platform: u32, us_subset_encoding: u32, pus_subset_keep_list: &[u16], us_subset_list_count: u16, lpfn_allocate: Option<unsafe extern "system" fn(usize) -> *mut c_void>, lpfn_re_allocate: Option<unsafe extern "system" fn(*mut c_void, usize) -> *mut c_void>, lpfn_free: Option<unsafe extern "system" fn(*mut c_void)>, lpv_reserved: todo_void) -> (u32, &mut u8, u32, u32, todo_void_ret) {
//      // SAFETY: type is a thin type
//      let puchSrcBuffer = unsafe { &*(puch_src_buffer as *const _ as *const _) };
//      let mut temp17 = ppuch_font_package_buffer;
//      let mut ppuchFontPackageBuffer = &mut temp17;
//      let mut pulFontPackageBufferSize = pul_font_package_buffer_size;
//      let mut pulBytesWritten = pul_bytes_written;
//      let usFlag = us_flag;
//      let usTTCIndex = us_ttc_index;
//      let usSubsetFormat = us_subset_format;
//      let usSubsetLanguage = us_subset_language;
//      let usSubsetPlatform = us_subset_platform;
//      let usSubsetEncoding = us_subset_encoding;
//      let pusSubsetKeepList = pus_subset_keep_list.as_ptr() as _;
//      let ulSrcBufferSize = pus_subset_keep_list.len() as _;
//      let usSubsetListCount = us_subset_list_count;
//      let lpfnAllocate = lpfn_allocate;
//      let lpfnReAllocate = lpfn_re_allocate;
//      let lpfnFree = lpfn_free;
//      let mut lpvReserved = todo_void;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateFontPackage(puchSrcBuffer, ulSrcBufferSize, &mut ppuchFontPackageBuffer, &mut pulFontPackageBufferSize, &mut pulBytesWritten, usFlag, usTTCIndex, usSubsetFormat, usSubsetLanguage, usSubsetPlatform, usSubsetEncoding, pusSubsetKeepList, usSubsetListCount, lpfnAllocate, lpfnReAllocate, lpfnFree, &mut lpvReserved) };
//      let lpv_reserved = todo_void;
//      let pul_bytes_written = pulBytesWritten;
//      let pul_font_package_buffer_size = pulFontPackageBufferSize;
//      let ppuch_font_package_buffer = unsafe { &mut *(ppuchFontPackageBuffer as *mut _) };
//      (return_value,ppuchFontPackageBuffer, pulFontPackageBufferSize, pulBytesWritten, lpvReserved)
//  }
#[inline]
pub fn create_font_w(c_height: i32, c_width: i32, c_escapement: i32, c_orientation: i32, c_weight: i32, b_italic: u32, b_underline: u32, b_strike_out: u32, i_char_set: u32, i_out_precision: u32, i_clip_precision: u32, i_quality: u32, i_pitch_and_family: u32, psz_face_name: Option<&OsStr>) -> Result<Hfont> {
    let cHeight = c_height;
    let cWidth = c_width;
    let cEscapement = c_escapement;
    let cOrientation = c_orientation;
    let cWeight = c_weight;
    let bItalic = b_italic;
    let bUnderline = b_underline;
    let bStrikeOut = b_strike_out;
    let iCharSet = i_char_set;
    let iOutPrecision = i_out_precision;
    let iClipPrecision = i_clip_precision;
    let iQuality = i_quality;
    let iPitchAndFamily = i_pitch_and_family;
    let temp18 = psz_face_name.map(|val| {
        let mut temp18: Vec<u16> = val.encode_wide().collect();
        temp18.push(0);
        temp18
    });
    let pszFaceName = temp18.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateFontW(cHeight, cWidth, cEscapement, cOrientation, cWeight, bItalic, bUnderline, bStrikeOut, iCharSet, iOutPrecision, iClipPrecision, iQuality, iPitchAndFamily, pszFaceName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_halftone_palette(hdc: Option<Hdc>) -> Result<Hpalette> {
    let hdc = hdc.map_or(0, Hdc::into_raw);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateHalftonePalette(hdc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_hatch_brush(i_hatch: u32, color: u32) -> Result<Hbrush> {
    let iHatch = i_hatch;
    let color = color;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateHatchBrush(iHatch, color) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_ica(psz_driver: Option<&CStr>, psz_device: Option<&CStr>, psz_port: Option<&CStr>, pdm: Option<&Devmodea>) -> Result<CreatedHdc> {
    let pszDriver = psz_driver.map_or(ptr::null(), |v| v.as_ptr() as _);
    let pszDevice = psz_device.map_or(ptr::null(), |v| v.as_ptr() as _);
    let pszPort = psz_port.map_or(ptr::null(), |v| v.as_ptr() as _);
    // SAFETY: type is a thin type
    let pdm = pdm.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateICA(pszDriver, pszDevice, pszPort, pdm) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_icw(psz_driver: Option<&OsStr>, psz_device: Option<&OsStr>, psz_port: Option<&OsStr>, pdm: Option<&Devmodew>) -> Result<CreatedHdc> {
    let temp19 = psz_driver.map(|val| {
        let mut temp19: Vec<u16> = val.encode_wide().collect();
        temp19.push(0);
        temp19
    });
    let pszDriver = temp19.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp20 = psz_device.map(|val| {
        let mut temp20: Vec<u16> = val.encode_wide().collect();
        temp20.push(0);
        temp20
    });
    let pszDevice = temp20.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp21 = psz_port.map(|val| {
        let mut temp21: Vec<u16> = val.encode_wide().collect();
        temp21.push(0);
        temp21
    });
    let pszPort = temp21.map_or(ptr::null(), |v| v.as_ptr() as _);
    // SAFETY: type is a thin type
    let pdm = pdm.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateICW(pszDriver, pszDevice, pszPort, pdm) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_meta_file_a(psz_file: Option<&CStr>) -> Result<HdcMetdataFileHandle> {
    let pszFile = psz_file.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateMetaFileA(pszFile) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_meta_file_w(psz_file: Option<&OsStr>) -> Result<HdcMetdataFileHandle> {
    let temp22 = psz_file.map(|val| {
        let mut temp22: Vec<u16> = val.encode_wide().collect();
        temp22.push(0);
        temp22
    });
    let pszFile = temp22.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateMetaFileW(pszFile) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_palette(plpal: &Logpalette) -> Result<Hpalette> {
    // SAFETY: type is a thin type
    let plpal = unsafe { &*(plpal as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreatePalette(plpal) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_pattern_brush(hbm: Hbitmap) -> Result<Hbrush> {
    let hbm = hbm.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreatePatternBrush(hbm) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_pen(i_style: u32, c_width: i32, color: u32) -> Result<Hpen> {
    let iStyle = i_style;
    let cWidth = c_width;
    let color = color;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreatePen(iStyle, cWidth, color) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_pen_indirect(plpen: &Logpen) -> Result<Hpen> {
    // SAFETY: type is a thin type
    let plpen = unsafe { &*(plpen as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreatePenIndirect(plpen) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_poly_polygon_rgn(pptl: &Point, pc: &[i32], i_mode: u32) -> Result<Hrgn> {
    // SAFETY: type is a thin type
    let pptl = unsafe { &*(pptl as *const _ as *const _) };
    let pc = pc.as_ptr() as _;
    let cPoly = pc.len() as _;
    let iMode = i_mode;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreatePolyPolygonRgn(pptl, pc, cPoly, iMode) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_polygon_rgn(pptl: &[Point], i_mode: u32) -> Result<Hrgn> {
    let pptl = pptl.as_ptr() as _;
    let cPoint = pptl.len() as _;
    let iMode = i_mode;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreatePolygonRgn(pptl, cPoint, iMode) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_rect_rgn(x1: i32, y1: i32, x2: i32, y2: i32) -> Result<Hrgn> {
    let x1 = x1;
    let y1 = y1;
    let x2 = x2;
    let y2 = y2;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateRectRgn(x1, y1, x2, y2) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_rect_rgn_indirect(lprect: &Rect) -> Result<Hrgn> {
    // SAFETY: type is a thin type
    let lprect = unsafe { &*(lprect as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateRectRgnIndirect(lprect) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_round_rect_rgn(x1: i32, y1: i32, x2: i32, y2: i32, w: i32, h: i32) -> Result<Hrgn> {
    let x1 = x1;
    let y1 = y1;
    let x2 = x2;
    let y2 = y2;
    let w = w;
    let h = h;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateRoundRectRgn(x1, y1, x2, y2, w, h) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_scalable_font_resource_a(fdw_hidden: u32, lpsz_font: &CStr, lpsz_file: &CStr, lpsz_path: Option<&CStr>) -> Result<BOOL> {
    let fdwHidden = fdw_hidden;
    let lpszFont = lpsz_font.as_ptr() as _;
    let lpszFile = lpsz_file.as_ptr() as _;
    let lpszPath = lpsz_path.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateScalableFontResourceA(fdwHidden, lpszFont, lpszFile, lpszPath) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_scalable_font_resource_w(fdw_hidden: u32, lpsz_font: &OsStr, lpsz_file: &OsStr, lpsz_path: Option<&OsStr>) -> Result<BOOL> {
    let fdwHidden = fdw_hidden;
    let mut temp23: Vec<u16> = lpsz_font.encode_wide().collect();
    temp23.push(0);
    let lpszFont = temp23.as_ptr() as _;
    let mut temp24: Vec<u16> = lpsz_file.encode_wide().collect();
    temp24.push(0);
    let lpszFile = temp24.as_ptr() as _;
    let temp25 = lpsz_path.map(|val| {
        let mut temp25: Vec<u16> = val.encode_wide().collect();
        temp25.push(0);
        temp25
    });
    let lpszPath = temp25.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateScalableFontResourceW(fdwHidden, lpszFont, lpszFile, lpszPath) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_solid_brush(color: u32) -> Result<Hbrush> {
    let color = color;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateSolidBrush(color) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn d_pto_lp(hdc: Hdc, lppt: Point, c: i32) -> Result<(BOOL, Point)> {
    let hdc = hdc.into_raw();
    let mut lppt = lppt.to_win32();
    let c = c;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DPtoLP(hdc, &mut lppt, c) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lppt = unsafe { Point::from_win32(lppt) };
    Ok((return_value,lppt))
}
#[inline]
pub fn delete_dc(hdc: CreatedHdc) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DeleteDC(hdc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn delete_enh_meta_file(hmf: Option<Henhmetafile>) -> Result<BOOL> {
    let hmf = hmf.map_or(0, Henhmetafile::into_raw);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DeleteEnhMetaFile(hmf) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn delete_meta_file(hmf: Hmetafile) -> Result<BOOL> {
    let hmf = hmf.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DeleteMetaFile(hmf) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn delete_object(ho: Hgdiobj) -> Result<BOOL> {
    let ho = ho.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DeleteObject(ho) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn draw_animated_rects(hwnd: Option<Hwnd>, id_ani: i32, lprc_from: &Rect, lprc_to: &Rect) -> Result<BOOL> {
    let hwnd = hwnd.map_or(0, Hwnd::into_raw);
    let idAni = id_ani;
    // SAFETY: type is a thin type
    let lprcFrom = unsafe { &*(lprc_from as *const _ as *const _) };
    // SAFETY: type is a thin type
    let lprcTo = unsafe { &*(lprc_to as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DrawAnimatedRects(hwnd, idAni, lprcFrom, lprcTo) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn draw_caption(hwnd: Hwnd, hdc: Hdc, lprect: &Rect, flags: u32) -> Result<BOOL> {
    let hwnd = hwnd.into_raw();
    let hdc = hdc.into_raw();
    // SAFETY: type is a thin type
    let lprect = unsafe { &*(lprect as *const _ as *const _) };
    let flags = flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DrawCaption(hwnd, hdc, lprect, flags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn draw_edge(hdc: Hdc, qrc: Rect, edge: u32, grf_flags: u32) -> Result<(BOOL, Rect)> {
    let hdc = hdc.into_raw();
    let mut qrc = qrc.to_win32();
    let edge = edge;
    let grfFlags = grf_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DrawEdge(hdc, &mut qrc, edge, grfFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let qrc = unsafe { Rect::from_win32(qrc) };
    Ok((return_value,qrc))
}
#[inline]
pub fn draw_escape(hdc: Hdc, i_escape: i32, cj_in: i32, lp_in: Option<&CStr>) -> Result<i32> {
    let hdc = hdc.into_raw();
    let iEscape = i_escape;
    let cjIn = cj_in;
    let lpIn = lp_in.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DrawEscape(hdc, iEscape, cjIn, lpIn) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn draw_focus_rect(h_dc: Hdc, lprc: &Rect) -> Result<BOOL> {
    let hDC = h_dc.into_raw();
    // SAFETY: type is a thin type
    let lprc = unsafe { &*(lprc as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DrawFocusRect(hDC, lprc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn draw_frame_control(param0: Hdc, param1: Rect, param2: u32, param3: u32) -> Result<(BOOL, Rect)> {
    let param0 = param0.into_raw();
    let mut param1 = param1.to_win32();
    let param2 = param2;
    let param3 = param3;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DrawFrameControl(param0, &mut param1, param2, param3) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let param1 = unsafe { Rect::from_win32(param1) };
    Ok((return_value,param1))
}
#[inline]
pub fn draw_state_a<Drawstateproc: FnMut(Hdc, Lparam, i32, i32) -> BOOL>(hdc: Hdc, hbr_fore: Option<Hbrush>, qfn_call_back: Option<Drawstateproc>, l_data: Lparam, x: i32, y: i32, cx: i32, cy: i32, u_flags: u32) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let hbrFore = hbr_fore.map_or(0, Hbrush::into_raw);
    unsafe extern "system" fn drawstateproc_impl(param0: HDC, param1: LPARAM, param2: WPARAM, param3: i32, param4: i32) -> BOOL {
        abort_on_panic(move || {
            let input0 = unsafe { Hdc::new(param0) };
            let input1 = unsafe { Lparam::from_inner(param1) };
            let input3 = param3;
            let input4 = param4;
            let closure = unsafe {
                &mut *(param2 as usize as *mut Drawstateproc)
            };
            let return_value = closure(input0, input1, input3, input4);
            let real_return_value = return_value;
            real_return_value
        })
    }
    let qfnCallBack = Some(drawstateproc_impl);
    let mut qfn_call_back = qfn_call_back;
    let wData = unsafe { Wparam::from_ptr((&mut qfn_call_back) as *mut _ as *mut _) };
    let lData = l_data.into_inner();
    let x = x;
    let y = y;
    let cx = cx;
    let cy = cy;
    let uFlags = u_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DrawStateA(hdc, hbrFore, qfnCallBack, lData, wData, x, y, cx, cy, uFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn draw_state_w<Drawstateproc: FnMut(Hdc, Lparam, i32, i32) -> BOOL>(hdc: Hdc, hbr_fore: Option<Hbrush>, qfn_call_back: Option<Drawstateproc>, l_data: Lparam, x: i32, y: i32, cx: i32, cy: i32, u_flags: u32) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let hbrFore = hbr_fore.map_or(0, Hbrush::into_raw);
    unsafe extern "system" fn drawstateproc_impl(param0: HDC, param1: LPARAM, param2: WPARAM, param3: i32, param4: i32) -> BOOL {
        abort_on_panic(move || {
            let input0 = unsafe { Hdc::new(param0) };
            let input1 = unsafe { Lparam::from_inner(param1) };
            let input3 = param3;
            let input4 = param4;
            let closure = unsafe {
                &mut *(param2 as usize as *mut Drawstateproc)
            };
            let return_value = closure(input0, input1, input3, input4);
            let real_return_value = return_value;
            real_return_value
        })
    }
    let qfnCallBack = Some(drawstateproc_impl);
    let mut qfn_call_back = qfn_call_back;
    let wData = unsafe { Wparam::from_ptr((&mut qfn_call_back) as *mut _ as *mut _) };
    let lData = l_data.into_inner();
    let x = x;
    let y = y;
    let cx = cx;
    let cy = cy;
    let uFlags = u_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DrawStateW(hdc, hbrFore, qfnCallBack, lData, wData, x, y, cx, cy, uFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn draw_text_a(hdc: Hdc, lpch_text: &CStr, cch_text: i32, lprc: Rect, format: u32) -> Result<(i32, Rect)> {
    let hdc = hdc.into_raw();
    let lpchText = lpch_text.as_ptr() as _;
    let cchText = cch_text;
    let mut lprc = lprc.to_win32();
    let format = format;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DrawTextA(hdc, lpchText, cchText, &mut lprc, format) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lprc = unsafe { Rect::from_win32(lprc) };
    Ok((return_value,lprc))
}
#[inline]
pub fn draw_text_ex_a(hdc: Hdc, lpch_text: &CStr, cch_text: i32, lprc: Rect, format: u32, lpdtp: Option<&Drawtextparams>) -> Result<(i32, CString, Rect)> {
    let hdc = hdc.into_raw();
    let mut lpchText = lpch_text.as_ptr() as _;
    let cchText = cch_text;
    let mut lprc = lprc.to_win32();
    let format = format;
    let temp26 = lpdtp.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
    let lpdtp = temp26.as_ref();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DrawTextExA(hdc, &mut lpchText, cchText, &mut lprc, format, lpdtp) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lprc = unsafe { Rect::from_win32(lprc) };
    let out0 = unsafe {
        slice::from_raw_parts(lpchText, return_value as usize)
    };
    let mut out0 = out0.to_vec();
    out0.push(0);
    let lpch_text = unsafe { CString::from_vec_unchecked(out0) };
    Ok((return_value,lpchText, lprc))
}
#[inline]
pub fn draw_text_ex_w(hdc: Hdc, lpch_text: &OsStr, cch_text: i32, lprc: Rect, format: u32, lpdtp: Option<&Drawtextparams>) -> Result<(i32, OsString, Rect)> {
    let hdc = hdc.into_raw();
    let mut temp27: Vec<u16> = lpch_text.encode_wide().collect();
    temp27.push(0);
    let mut lpchText = temp27.as_ptr() as _;
    let cchText = cch_text;
    let mut lprc = lprc.to_win32();
    let format = format;
    let temp28 = lpdtp.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
    let lpdtp = temp28.as_ref();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DrawTextExW(hdc, &mut lpchText, cchText, &mut lprc, format, lpdtp) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lprc = unsafe { Rect::from_win32(lprc) };
    let out1 = unsafe {
        slice::from_raw_parts(lpchText, return_value as usize)
    };
    let out1 = out1.to_vec();
    let lpch_text = OsStringExt::from_wide(out1);
    Ok((return_value,lpchText, lprc))
}
#[inline]
pub fn draw_text_w(hdc: Hdc, lpch_text: &OsStr, cch_text: i32, lprc: Rect, format: u32) -> Result<(i32, Rect)> {
    let hdc = hdc.into_raw();
    let mut temp29: Vec<u16> = lpch_text.encode_wide().collect();
    temp29.push(0);
    let lpchText = temp29.as_ptr() as _;
    let cchText = cch_text;
    let mut lprc = lprc.to_win32();
    let format = format;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DrawTextW(hdc, lpchText, cchText, &mut lprc, format) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lprc = unsafe { Rect::from_win32(lprc) };
    Ok((return_value,lprc))
}
#[inline]
pub fn ellipse(hdc: Hdc, left: i32, top: i32, right: i32, bottom: i32) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let left = left;
    let top = top;
    let right = right;
    let bottom = bottom;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::Ellipse(hdc, left, top, right, bottom) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn end_paint(h_wnd: Hwnd, lp_paint: &Paintstruct) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    // SAFETY: type is a thin type
    let lpPaint = unsafe { &*(lp_paint as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EndPaint(hWnd, lpPaint) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn end_path(hdc: Hdc) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EndPath(hdc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_display_devices_a(lp_device: Option<&CStr>, i_dev_num: u32, lp_display_device: DisplayDevicea, dw_flags: u32) -> Result<(BOOL, DisplayDevicea)> {
    let lpDevice = lp_device.map_or(ptr::null(), |v| v.as_ptr() as _);
    let iDevNum = i_dev_num;
    let mut lpDisplayDevice = lp_display_device.to_win32();
    let dwFlags = dw_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumDisplayDevicesA(lpDevice, iDevNum, &mut lpDisplayDevice, dwFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_display_device = unsafe { DisplayDevicea::from_win32(lpDisplayDevice) };
    Ok((return_value,lpDisplayDevice))
}
#[inline]
pub fn enum_display_devices_w(lp_device: Option<&OsStr>, i_dev_num: u32, lp_display_device: DisplayDevicew, dw_flags: u32) -> Result<(BOOL, DisplayDevicew)> {
    let temp30 = lp_device.map(|val| {
        let mut temp30: Vec<u16> = val.encode_wide().collect();
        temp30.push(0);
        temp30
    });
    let lpDevice = temp30.map_or(ptr::null(), |v| v.as_ptr() as _);
    let iDevNum = i_dev_num;
    let mut lpDisplayDevice = lp_display_device.to_win32();
    let dwFlags = dw_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumDisplayDevicesW(lpDevice, iDevNum, &mut lpDisplayDevice, dwFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_display_device = unsafe { DisplayDevicew::from_win32(lpDisplayDevice) };
    Ok((return_value,lpDisplayDevice))
}
#[inline]
pub fn enum_display_monitors<Monitorenumproc: FnMut(Hmonitor, Hdc, &mut Rect, ) -> BOOL>(hdc: Option<Hdc>, lprc_clip: Option<&Rect>, lpfn_enum: Monitorenumproc, ) -> Result<BOOL> {
    let hdc = hdc.map_or(0, Hdc::into_raw);
    // SAFETY: type is a thin type
    let lprcClip = lprc_clip.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    unsafe extern "system" fn monitorenumproc_impl(param0: HMONITOR, param1: HDC, param2: *mut RECT, param3: LPARAM) -> BOOL {
        abort_on_panic(move || {
            let input0 = unsafe { Hmonitor::new(param0) };
            let input1 = unsafe { Hdc::new(param1) };
            let input2 = unsafe { &mut *(param2 as *mut _) };
            let closure = unsafe {
                &mut *(param3 as usize as *mut Monitorenumproc)
            };
            let return_value = closure(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpfnEnum = Some(monitorenumproc_impl);
    let mut lpfn_enum = lpfn_enum;
    let dwData = unsafe { Lparam::from_ptr((&mut lpfn_enum) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumDisplayMonitors(hdc, lprcClip, lpfnEnum, dwData) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_display_settings_a(lpsz_device_name: Option<&CStr>, i_mode_num: u32, lp_dev_mode: Devmodea) -> Result<(BOOL, Devmodea)> {
    let lpszDeviceName = lpsz_device_name.map_or(ptr::null(), |v| v.as_ptr() as _);
    let iModeNum = i_mode_num;
    let mut lpDevMode = lp_dev_mode.to_win32();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumDisplaySettingsA(lpszDeviceName, iModeNum, &mut lpDevMode) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_dev_mode = unsafe { Devmodea::from_win32(lpDevMode) };
    Ok((return_value,lpDevMode))
}
#[inline]
pub fn enum_display_settings_ex_a(lpsz_device_name: Option<&CStr>, i_mode_num: u32, lp_dev_mode: Devmodea, dw_flags: u32) -> Result<(BOOL, Devmodea)> {
    let lpszDeviceName = lpsz_device_name.map_or(ptr::null(), |v| v.as_ptr() as _);
    let iModeNum = i_mode_num;
    let mut lpDevMode = lp_dev_mode.to_win32();
    let dwFlags = dw_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumDisplaySettingsExA(lpszDeviceName, iModeNum, &mut lpDevMode, dwFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_dev_mode = unsafe { Devmodea::from_win32(lpDevMode) };
    Ok((return_value,lpDevMode))
}
#[inline]
pub fn enum_display_settings_ex_w(lpsz_device_name: Option<&OsStr>, i_mode_num: u32, lp_dev_mode: Devmodew, dw_flags: u32) -> Result<(BOOL, Devmodew)> {
    let temp31 = lpsz_device_name.map(|val| {
        let mut temp31: Vec<u16> = val.encode_wide().collect();
        temp31.push(0);
        temp31
    });
    let lpszDeviceName = temp31.map_or(ptr::null(), |v| v.as_ptr() as _);
    let iModeNum = i_mode_num;
    let mut lpDevMode = lp_dev_mode.to_win32();
    let dwFlags = dw_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumDisplaySettingsExW(lpszDeviceName, iModeNum, &mut lpDevMode, dwFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_dev_mode = unsafe { Devmodew::from_win32(lpDevMode) };
    Ok((return_value,lpDevMode))
}
#[inline]
pub fn enum_display_settings_w(lpsz_device_name: Option<&OsStr>, i_mode_num: u32, lp_dev_mode: Devmodew) -> Result<(BOOL, Devmodew)> {
    let temp32 = lpsz_device_name.map(|val| {
        let mut temp32: Vec<u16> = val.encode_wide().collect();
        temp32.push(0);
        temp32
    });
    let lpszDeviceName = temp32.map_or(ptr::null(), |v| v.as_ptr() as _);
    let iModeNum = i_mode_num;
    let mut lpDevMode = lp_dev_mode.to_win32();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumDisplaySettingsW(lpszDeviceName, iModeNum, &mut lpDevMode) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_dev_mode = unsafe { Devmodew::from_win32(lpDevMode) };
    Ok((return_value,lpDevMode))
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn enum_enh_meta_file(hdc: Option<Hdc>, hmf: Henhmetafile, proc: Option<unsafe extern "system" fn(HDC, *const HANDLETABLE, *const ENHMETARECORD, i32, LPARAM) -> i32>, param3: Option<&todo_void>, lp_rect: Option<&Rect>) -> Result<BOOL> {
//      let hdc = hdc.map_or(0, Hdc::into_raw);
//      let hmf = hmf.into_raw();
//      let proc = proc;
//      // SAFETY: type is a thin type
//      let param3 = param3.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      // SAFETY: type is a thin type
//      let lpRect = lp_rect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumEnhMetaFile(hdc, hmf, proc, param3, lpRect) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
#[inline]
pub fn enum_font_families_a<Fontenumproca: FnMut(&Logfonta, &Textmetrica, u32, ) -> i32>(hdc: Hdc, lp_logfont: Option<&CStr>, lp_proc: Fontenumproca, ) -> Result<i32> {
    let hdc = hdc.into_raw();
    let lpLogfont = lp_logfont.map_or(ptr::null(), |v| v.as_ptr() as _);
    unsafe extern "system" fn fontenumproca_impl(param0: *const LOGFONTA, param1: *const TEXTMETRICA, param2: u32, param3: LPARAM) -> i32 {
        abort_on_panic(move || {
            let input0 = unsafe { &*(param0 as *const _) };
            let input1 = unsafe { &*(param1 as *const _) };
            let input2 = param2;
            let closure = unsafe {
                &mut *(param3 as usize as *mut Fontenumproca)
            };
            let return_value = closure(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpProc = Some(fontenumproca_impl);
    let mut lp_proc = lp_proc;
    let lParam = unsafe { Lparam::from_ptr((&mut lp_proc) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumFontFamiliesA(hdc, lpLogfont, lpProc, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_font_families_ex_a<Fontenumproca: FnMut(&Logfonta, &Textmetrica, u32, ) -> i32>(hdc: Hdc, lp_logfont: &Logfonta, lp_proc: Fontenumproca, dw_flags: u32) -> Result<i32> {
    let hdc = hdc.into_raw();
    // SAFETY: type is a thin type
    let lpLogfont = unsafe { &*(lp_logfont as *const _ as *const _) };
    unsafe extern "system" fn fontenumproca_impl(param0: *const LOGFONTA, param1: *const TEXTMETRICA, param2: u32, param3: LPARAM) -> i32 {
        abort_on_panic(move || {
            let input0 = unsafe { &*(param0 as *const _) };
            let input1 = unsafe { &*(param1 as *const _) };
            let input2 = param2;
            let closure = unsafe {
                &mut *(param3 as usize as *mut Fontenumproca)
            };
            let return_value = closure(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpProc = Some(fontenumproca_impl);
    let mut lp_proc = lp_proc;
    let lParam = unsafe { Lparam::from_ptr((&mut lp_proc) as *mut _ as *mut _) };
    let dwFlags = dw_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumFontFamiliesExA(hdc, lpLogfont, lpProc, lParam, dwFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_font_families_ex_w<Fontenumprocw: FnMut(&Logfontw, &Textmetricw, u32, ) -> i32>(hdc: Hdc, lp_logfont: &Logfontw, lp_proc: Fontenumprocw, dw_flags: u32) -> Result<i32> {
    let hdc = hdc.into_raw();
    // SAFETY: type is a thin type
    let lpLogfont = unsafe { &*(lp_logfont as *const _ as *const _) };
    unsafe extern "system" fn fontenumprocw_impl(param0: *const LOGFONTW, param1: *const TEXTMETRICW, param2: u32, param3: LPARAM) -> i32 {
        abort_on_panic(move || {
            let input0 = unsafe { &*(param0 as *const _) };
            let input1 = unsafe { &*(param1 as *const _) };
            let input2 = param2;
            let closure = unsafe {
                &mut *(param3 as usize as *mut Fontenumprocw)
            };
            let return_value = closure(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpProc = Some(fontenumprocw_impl);
    let mut lp_proc = lp_proc;
    let lParam = unsafe { Lparam::from_ptr((&mut lp_proc) as *mut _ as *mut _) };
    let dwFlags = dw_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumFontFamiliesExW(hdc, lpLogfont, lpProc, lParam, dwFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_font_families_w<Fontenumprocw: FnMut(&Logfontw, &Textmetricw, u32, ) -> i32>(hdc: Hdc, lp_logfont: Option<&OsStr>, lp_proc: Fontenumprocw, ) -> Result<i32> {
    let hdc = hdc.into_raw();
    let temp33 = lp_logfont.map(|val| {
        let mut temp33: Vec<u16> = val.encode_wide().collect();
        temp33.push(0);
        temp33
    });
    let lpLogfont = temp33.map_or(ptr::null(), |v| v.as_ptr() as _);
    unsafe extern "system" fn fontenumprocw_impl(param0: *const LOGFONTW, param1: *const TEXTMETRICW, param2: u32, param3: LPARAM) -> i32 {
        abort_on_panic(move || {
            let input0 = unsafe { &*(param0 as *const _) };
            let input1 = unsafe { &*(param1 as *const _) };
            let input2 = param2;
            let closure = unsafe {
                &mut *(param3 as usize as *mut Fontenumprocw)
            };
            let return_value = closure(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpProc = Some(fontenumprocw_impl);
    let mut lp_proc = lp_proc;
    let lParam = unsafe { Lparam::from_ptr((&mut lp_proc) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumFontFamiliesW(hdc, lpLogfont, lpProc, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_fonts_a<Fontenumproca: FnMut(&Logfonta, &Textmetrica, u32, ) -> i32>(hdc: Hdc, lp_logfont: Option<&CStr>, lp_proc: Fontenumproca, ) -> Result<i32> {
    let hdc = hdc.into_raw();
    let lpLogfont = lp_logfont.map_or(ptr::null(), |v| v.as_ptr() as _);
    unsafe extern "system" fn fontenumproca_impl(param0: *const LOGFONTA, param1: *const TEXTMETRICA, param2: u32, param3: LPARAM) -> i32 {
        abort_on_panic(move || {
            let input0 = unsafe { &*(param0 as *const _) };
            let input1 = unsafe { &*(param1 as *const _) };
            let input2 = param2;
            let closure = unsafe {
                &mut *(param3 as usize as *mut Fontenumproca)
            };
            let return_value = closure(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpProc = Some(fontenumproca_impl);
    let mut lp_proc = lp_proc;
    let lParam = unsafe { Lparam::from_ptr((&mut lp_proc) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumFontsA(hdc, lpLogfont, lpProc, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_fonts_w<Fontenumprocw: FnMut(&Logfontw, &Textmetricw, u32, ) -> i32>(hdc: Hdc, lp_logfont: Option<&OsStr>, lp_proc: Fontenumprocw, ) -> Result<i32> {
    let hdc = hdc.into_raw();
    let temp34 = lp_logfont.map(|val| {
        let mut temp34: Vec<u16> = val.encode_wide().collect();
        temp34.push(0);
        temp34
    });
    let lpLogfont = temp34.map_or(ptr::null(), |v| v.as_ptr() as _);
    unsafe extern "system" fn fontenumprocw_impl(param0: *const LOGFONTW, param1: *const TEXTMETRICW, param2: u32, param3: LPARAM) -> i32 {
        abort_on_panic(move || {
            let input0 = unsafe { &*(param0 as *const _) };
            let input1 = unsafe { &*(param1 as *const _) };
            let input2 = param2;
            let closure = unsafe {
                &mut *(param3 as usize as *mut Fontenumprocw)
            };
            let return_value = closure(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpProc = Some(fontenumprocw_impl);
    let mut lp_proc = lp_proc;
    let lParam = unsafe { Lparam::from_ptr((&mut lp_proc) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumFontsW(hdc, lpLogfont, lpProc, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn enum_objects<Gobjenumproc: FnMut(&mut todo_void, ) -> i32>(hdc: Hdc, n_type: i32, lp_func: Gobjenumproc, ) -> Result<i32> {
//      let hdc = hdc.into_raw();
//      let nType = n_type;
//      unsafe extern "system" fn gobjenumproc_impl(param0: *mut c_void, param1: LPARAM) -> i32 {
//          abort_on_panic(move || {
//              let input0 = unsafe { &mut *(param0 as *mut _) };
//              let closure = unsafe {
//                  &mut *(param1 as usize as *mut Gobjenumproc)
//              };
//              let return_value = closure(input0, );
//              let real_return_value = return_value;
//              real_return_value
//          })
//      }
//      let lpFunc = Some(gobjenumproc_impl);
//      let mut lp_func = lp_func;
//      let lParam = unsafe { Lparam::from_ptr((&mut lp_func) as *mut _ as *mut _) };
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumObjects(hdc, nType, lpFunc, lParam) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
#[inline]
pub fn equal_rect(lprc1: &Rect, lprc2: &Rect) -> BOOL {
    // SAFETY: type is a thin type
    let lprc1 = unsafe { &*(lprc1 as *const _ as *const _) };
    // SAFETY: type is a thin type
    let lprc2 = unsafe { &*(lprc2 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EqualRect(lprc1, lprc2) };
    return_value
}
#[inline]
pub fn equal_rgn(hrgn1: Hrgn, hrgn2: Hrgn) -> BOOL {
    let hrgn1 = hrgn1.into_raw();
    let hrgn2 = hrgn2.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EqualRgn(hrgn1, hrgn2) };
    return_value
}
#[inline]
pub fn exclude_clip_rect(hdc: Hdc, left: i32, top: i32, right: i32, bottom: i32) -> Result<i32> {
    let hdc = hdc.into_raw();
    let left = left;
    let top = top;
    let right = right;
    let bottom = bottom;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ExcludeClipRect(hdc, left, top, right, bottom) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn exclude_update_rgn(h_dc: Hdc, h_wnd: Hwnd) -> Result<i32> {
    let hDC = h_dc.into_raw();
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ExcludeUpdateRgn(hDC, hWnd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn ext_create_pen(i_pen_style: u32, c_width: u32, plbrush: &Logbrush, pstyle: Option<&[u32]>) -> Result<Hpen> {
    let iPenStyle = i_pen_style;
    let cWidth = c_width;
    // SAFETY: type is a thin type
    let plbrush = unsafe { &*(plbrush as *const _ as *const _) };
    let pstyle = pstyle.map_or(ptr::null(), |v| v.as_ptr() as _);
    let cStyle = pstyle.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ExtCreatePen(iPenStyle, cWidth, plbrush, cStyle, pstyle) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn ext_create_region(lpx: Option<&Xform>, lp_data: &[Rgndata]) -> Result<Hrgn> {
    // SAFETY: type is a thin type
    let lpx = lpx.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let lpData = lp_data.as_ptr() as _;
    let nCount = lp_data.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ExtCreateRegion(lpx, nCount, lpData) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn ext_flood_fill(hdc: Hdc, x: i32, y: i32, color: u32, r#type: u32) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    let color = color;
    let r#type = r#type;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ExtFloodFill(hdc, x, y, color, r#type) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn ext_select_clip_rgn(hdc: Hdc, hrgn: Option<Hrgn>, mode: i32) -> Result<i32> {
    let hdc = hdc.into_raw();
    let hrgn = hrgn.map_or(0, Hrgn::into_raw);
    let mode = mode;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ExtSelectClipRgn(hdc, hrgn, mode) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn ext_text_out_a(hdc: Hdc, x: i32, y: i32, options: u32, lprect: Option<&Rect>, lp_string: Option<&CStr>, lp_dx: Option<&[i32]>) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    let options = options;
    // SAFETY: type is a thin type
    let lprect = lprect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let lpString = lp_string.map_or(ptr::null(), |v| v.as_ptr() as _);
    let lpDx = lp_dx.map_or(ptr::null(), |v| v.as_ptr() as _);
    let c = lp_dx.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ExtTextOutA(hdc, x, y, options, lprect, lpString, c, lpDx) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn ext_text_out_w(hdc: Hdc, x: i32, y: i32, options: u32, lprect: Option<&Rect>, lp_string: Option<&OsStr>, lp_dx: Option<&[i32]>) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    let options = options;
    // SAFETY: type is a thin type
    let lprect = lprect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let temp35 = lp_string.map(|val| {
        let mut temp35: Vec<u16> = val.encode_wide().collect();
        temp35.push(0);
        temp35
    });
    let lpString = temp35.map_or(ptr::null(), |v| v.as_ptr() as _);
    let lpDx = lp_dx.map_or(ptr::null(), |v| v.as_ptr() as _);
    let c = lp_dx.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ExtTextOutW(hdc, x, y, options, lprect, lpString, c, lpDx) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn fill_path(hdc: Hdc) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::FillPath(hdc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn fill_rect(h_dc: Hdc, lprc: &Rect, hbr: Hbrush) -> Result<i32> {
    let hDC = h_dc.into_raw();
    // SAFETY: type is a thin type
    let lprc = unsafe { &*(lprc as *const _ as *const _) };
    let hbr = hbr.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::FillRect(hDC, lprc, hbr) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn fill_rgn(hdc: Hdc, hrgn: Hrgn, hbr: Hbrush) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let hrgn = hrgn.into_raw();
    let hbr = hbr.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::FillRgn(hdc, hrgn, hbr) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn fix_brush_org_ex(hdc: Hdc, x: i32, y: i32, ptl: Option<&Point>) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    // SAFETY: type is a thin type
    let ptl = ptl.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::FixBrushOrgEx(hdc, x, y, ptl) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn flatten_path(hdc: Hdc) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::FlattenPath(hdc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn flood_fill(hdc: Hdc, x: i32, y: i32, color: u32) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    let color = color;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::FloodFill(hdc, x, y, color) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn frame_rect(h_dc: Hdc, lprc: &Rect, hbr: Hbrush) -> Result<i32> {
    let hDC = h_dc.into_raw();
    // SAFETY: type is a thin type
    let lprc = unsafe { &*(lprc as *const _ as *const _) };
    let hbr = hbr.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::FrameRect(hDC, lprc, hbr) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn frame_rgn(hdc: Hdc, hrgn: Hrgn, hbr: Hbrush, w: i32, h: i32) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let hrgn = hrgn.into_raw();
    let hbr = hbr.into_raw();
    let w = w;
    let h = h;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::FrameRgn(hdc, hrgn, hbr, w, h) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn gdi_alpha_blend(hdc_dest: Hdc, xorigin_dest: i32, yorigin_dest: i32, w_dest: i32, h_dest: i32, hdc_src: Hdc, xorigin_src: i32, yorigin_src: i32, w_src: i32, h_src: i32, ftn: Blendfunction) -> Result<BOOL> {
    let hdcDest = hdc_dest.into_raw();
    let xoriginDest = xorigin_dest;
    let yoriginDest = yorigin_dest;
    let wDest = w_dest;
    let hDest = h_dest;
    let hdcSrc = hdc_src.into_raw();
    let xoriginSrc = xorigin_src;
    let yoriginSrc = yorigin_src;
    let wSrc = w_src;
    let hSrc = h_src;
    let ftn = ftn.to_win32();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GdiAlphaBlend(hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, ftn) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn gdi_comment(hdc: Hdc, lp_data: &[u8]) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let lpData = lp_data.as_ptr() as _;
    let nSize = lp_data.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GdiComment(hdc, nSize, lpData) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn gdi_flush() -> Result<BOOL> {
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GdiFlush() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn gdi_get_batch_limit() -> u32 {
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GdiGetBatchLimit() };
    return_value
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn gdi_gradient_fill(hdc: Hdc, p_vertex: &[Trivertex], p_mesh: &[todo_void], ul_mode: u32) -> Result<BOOL> {
//      let hdc = hdc.into_raw();
//      let pVertex = p_vertex.as_ptr() as _;
//      let nVertex = p_vertex.len() as _;
//      let pMesh = p_mesh.as_ptr() as _;
//      let nCount = p_mesh.len() as _;
//      let ulMode = ul_mode;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GdiGradientFill(hdc, pVertex, nVertex, pMesh, nCount, ulMode) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
#[inline]
pub fn gdi_set_batch_limit(dw: u32) -> u32 {
    let dw = dw;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GdiSetBatchLimit(dw) };
    return_value
}
#[inline]
pub fn gdi_transparent_blt(hdc_dest: Hdc, xorigin_dest: i32, yorigin_dest: i32, w_dest: i32, h_dest: i32, hdc_src: Hdc, xorigin_src: i32, yorigin_src: i32, w_src: i32, h_src: i32, cr_transparent: u32) -> Result<BOOL> {
    let hdcDest = hdc_dest.into_raw();
    let xoriginDest = xorigin_dest;
    let yoriginDest = yorigin_dest;
    let wDest = w_dest;
    let hDest = h_dest;
    let hdcSrc = hdc_src.into_raw();
    let xoriginSrc = xorigin_src;
    let yoriginSrc = yorigin_src;
    let wSrc = w_src;
    let hSrc = h_src;
    let crTransparent = cr_transparent;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GdiTransparentBlt(hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, crTransparent) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_arc_direction(hdc: Hdc) -> Result<i32> {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetArcDirection(hdc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_aspect_ratio_filter_ex(hdc: Hdc, ) -> Result<(BOOL, Size)> {
    let mut lpsize = mem::MaybeUninit::zeroed();
    let lpsize = lpsize.as_mut_ptr();
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetAspectRatioFilterEx(hdc, lpsize) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpsize = unsafe { Size::from_win32(unsafe { lpsize.assume_init() }) };
    Ok((return_value,lpsize))
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn get_bitmap_bits(hbit: Hbitmap, cb: i32, ) -> Result<(i32, todo_void_ret)> {
//      let mut lpv_bits = mem::MaybeUninit::zeroed();
//      let lpvBits = lpv_bits.as_mut_ptr();
//      let hbit = hbit.into_raw();
//      let cb = cb;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetBitmapBits(hbit, cb, lpvBits) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let lpv_bits = todo_void;
//      Ok((return_value,lpvBits))
//  }
#[inline]
pub fn get_bitmap_dimension_ex(hbit: Hbitmap, ) -> Result<(BOOL, Size)> {
    let mut lpsize = mem::MaybeUninit::zeroed();
    let lpsize = lpsize.as_mut_ptr();
    let hbit = hbit.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetBitmapDimensionEx(hbit, lpsize) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpsize = unsafe { Size::from_win32(unsafe { lpsize.assume_init() }) };
    Ok((return_value,lpsize))
}
#[inline]
pub fn get_bk_color(hdc: Hdc) -> u32 {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetBkColor(hdc) };
    return_value
}
#[inline]
pub fn get_bk_mode(hdc: Hdc) -> Result<i32> {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetBkMode(hdc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_bounds_rect(hdc: Hdc, flags: u32) -> (u32, Rect) {
    let mut lprect = mem::MaybeUninit::zeroed();
    let lprect = lprect.as_mut_ptr();
    let hdc = hdc.into_raw();
    let flags = flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetBoundsRect(hdc, lprect, flags) };
    let lprect = unsafe { Rect::from_win32(unsafe { lprect.assume_init() }) };
    (return_value,lprect)
}
#[inline]
pub fn get_brush_org_ex(hdc: Hdc, ) -> Result<(BOOL, Point)> {
    let mut lppt = mem::MaybeUninit::zeroed();
    let lppt = lppt.as_mut_ptr();
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetBrushOrgEx(hdc, lppt) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lppt = unsafe { Point::from_win32(unsafe { lppt.assume_init() }) };
    Ok((return_value,lppt))
}
#[inline]
pub fn get_clip_box(hdc: Hdc, ) -> Result<(i32, Rect)> {
    let mut lprect = mem::MaybeUninit::zeroed();
    let lprect = lprect.as_mut_ptr();
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetClipBox(hdc, lprect) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lprect = unsafe { Rect::from_win32(unsafe { lprect.assume_init() }) };
    Ok((return_value,lprect))
}
#[inline]
pub fn get_clip_rgn(hdc: Hdc, hrgn: Hrgn) -> Result<i32> {
    let hdc = hdc.into_raw();
    let hrgn = hrgn.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetClipRgn(hdc, hrgn) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_color_adjustment(hdc: Hdc, ) -> Result<(BOOL, Coloradjustment)> {
    let mut lpca = mem::MaybeUninit::zeroed();
    let lpca = lpca.as_mut_ptr();
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetColorAdjustment(hdc, lpca) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpca = unsafe { Coloradjustment::from_win32(unsafe { lpca.assume_init() }) };
    Ok((return_value,lpca))
}
#[inline]
pub fn get_current_object(hdc: Hdc, r#type: i32) -> Result<Hgdiobj> {
    let hdc = hdc.into_raw();
    let r#type = r#type;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetCurrentObject(hdc, r#type) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_current_position_ex(hdc: Hdc, ) -> Result<(BOOL, Point)> {
    let mut lppt = mem::MaybeUninit::zeroed();
    let lppt = lppt.as_mut_ptr();
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetCurrentPositionEx(hdc, lppt) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lppt = unsafe { Point::from_win32(unsafe { lppt.assume_init() }) };
    Ok((return_value,lppt))
}
#[inline]
pub fn get_dc(h_wnd: Option<Hwnd>) -> Result<Hdc> {
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetDC(hWnd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_dc_brush_color(hdc: Hdc) -> u32 {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetDCBrushColor(hdc) };
    return_value
}
#[inline]
pub fn get_dc_ex(h_wnd: Option<Hwnd>, hrgn_clip: Option<Hrgn>, flags: u32) -> Result<Hdc> {
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let hrgnClip = hrgn_clip.map_or(0, Hrgn::into_raw);
    let flags = flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetDCEx(hWnd, hrgnClip, flags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_dc_org_ex(hdc: Hdc, ) -> Result<(BOOL, Point)> {
    let mut lppt = mem::MaybeUninit::zeroed();
    let lppt = lppt.as_mut_ptr();
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetDCOrgEx(hdc, lppt) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lppt = unsafe { Point::from_win32(unsafe { lppt.assume_init() }) };
    Ok((return_value,lppt))
}
#[inline]
pub fn get_dc_pen_color(hdc: Hdc) -> u32 {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetDCPenColor(hdc) };
    return_value
}
#[inline]
pub fn get_dib_color_table(hdc: Hdc, i_start: u32, c_entries: u32, ) -> (u32, Rgbquad) {
    let mut prgbq = mem::MaybeUninit::zeroed();
    let prgbq = prgbq.as_mut_ptr();
    let hdc = hdc.into_raw();
    let iStart = i_start;
    let cEntries = c_entries;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetDIBColorTable(hdc, iStart, cEntries, prgbq) };
    let prgbq = unsafe { Rgbquad::from_win32(unsafe { prgbq.assume_init() }) };
    (return_value,prgbq)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn get_di_bits(hdc: Hdc, hbm: Hbitmap, start: u32, c_lines: u32, lpbmi: Bitmapinfo, usage: u32) -> Result<(i32, todo_void_ret, Bitmapinfo)> {
//      let mut lpv_bits = mem::MaybeUninit::zeroed();
//      let lpvBits = lpv_bits.as_mut_ptr();
//      let hdc = hdc.into_raw();
//      let hbm = hbm.into_raw();
//      let start = start;
//      let cLines = c_lines;
//      let mut lpbmi = lpbmi.to_win32();
//      let usage = usage;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetDIBits(hdc, hbm, start, cLines, lpvBits, &mut lpbmi, usage) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let lpbmi = unsafe { Bitmapinfo::from_win32(lpbmi) };
//      let lpv_bits = todo_void;
//      Ok((return_value,lpvBits, lpbmi))
//  }
#[inline]
pub fn get_device_caps(hdc: Option<Hdc>, index: u32) -> Result<i32> {
    let hdc = hdc.map_or(0, Hdc::into_raw);
    let index = index;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetDeviceCaps(hdc, index) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_enh_meta_file_a(lp_name: &CStr) -> Result<Henhmetafile> {
    let lpName = lp_name.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetEnhMetaFileA(lpName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_enh_meta_file_bits(h_emf: Henhmetafile, n_size: u32, ) -> (u32, u8) {
    let mut lp_data = mem::MaybeUninit::zeroed();
    let lpData = lp_data.as_mut_ptr();
    let hEMF = h_emf.into_raw();
    let nSize = n_size;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetEnhMetaFileBits(hEMF, nSize, lpData) };
    let lp_data = unsafe { lpData.assume_init() };
    (return_value,lpData)
}
#[inline]
pub fn get_enh_meta_file_description_a(hemf: Henhmetafile, cch_buffer: u32, ) -> (u32, CString) {
    let mut lp_description = Vec::<u8>::with_capacity(cch_buffer as usize + 1);
    let lpDescription = lp_description.as_mut_ptr();
    let hemf = hemf.into_raw();
    let cchBuffer = cch_buffer;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetEnhMetaFileDescriptionA(hemf, cchBuffer, lpDescription) };
    let out2 = unsafe {
        slice::from_raw_parts(unsafe { lpDescription.assume_init() }, return_value as usize)
    };
    let mut out2 = out2.to_vec();
    out2.push(0);
    let lp_description = unsafe { CString::from_vec_unchecked(out2) };
    (return_value,lpDescription)
}
#[inline]
pub fn get_enh_meta_file_description_w(hemf: Henhmetafile, cch_buffer: u32, ) -> (u32, OsString) {
    let mut lp_description = Vec::<u16>::with_capacity(cch_buffer as usize + 1);
    let lpDescription = lp_description.as_mut_ptr();
    let hemf = hemf.into_raw();
    let cchBuffer = cch_buffer;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetEnhMetaFileDescriptionW(hemf, cchBuffer, lpDescription) };
    let out3 = unsafe {
        slice::from_raw_parts(unsafe { lpDescription.assume_init() }, return_value as usize)
    };
    let out3 = out3.to_vec();
    let lp_description = OsStringExt::from_wide(out3);
    (return_value,lpDescription)
}
#[inline]
pub fn get_enh_meta_file_header(hemf: Henhmetafile, n_size: u32, ) -> (u32, Enhmetaheader) {
    let mut lp_enh_meta_header = mem::MaybeUninit::zeroed();
    let lpEnhMetaHeader = lp_enh_meta_header.as_mut_ptr();
    let hemf = hemf.into_raw();
    let nSize = n_size;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetEnhMetaFileHeader(hemf, nSize, lpEnhMetaHeader) };
    let lp_enh_meta_header = unsafe { Enhmetaheader::from_win32(unsafe { lpEnhMetaHeader.assume_init() }) };
    (return_value,lpEnhMetaHeader)
}
#[inline]
pub fn get_enh_meta_file_palette_entries(hemf: Henhmetafile, n_num_entries: u32, ) -> (u32, Paletteentry) {
    let mut lp_palette_entries = mem::MaybeUninit::zeroed();
    let lpPaletteEntries = lp_palette_entries.as_mut_ptr();
    let hemf = hemf.into_raw();
    let nNumEntries = n_num_entries;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetEnhMetaFilePaletteEntries(hemf, nNumEntries, lpPaletteEntries) };
    let lp_palette_entries = unsafe { Paletteentry::from_win32(unsafe { lpPaletteEntries.assume_init() }) };
    (return_value,lpPaletteEntries)
}
#[inline]
pub fn get_enh_meta_file_w(lp_name: &OsStr) -> Result<Henhmetafile> {
    let mut temp36: Vec<u16> = lp_name.encode_wide().collect();
    temp36.push(0);
    let lpName = temp36.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetEnhMetaFileW(lpName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn get_font_data(hdc: Hdc, dw_table: u32, dw_offset: u32, cj_buffer: u32) -> (u32, todo_void_ret) {
//      let mut pv_buffer = mem::MaybeUninit::zeroed();
//      let pvBuffer = pv_buffer.as_mut_ptr();
//      let hdc = hdc.into_raw();
//      let dwTable = dw_table;
//      let dwOffset = dw_offset;
//      let cjBuffer = cj_buffer;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetFontData(hdc, dwTable, dwOffset, pvBuffer, cjBuffer) };
//      let pv_buffer = todo_void;
//      (return_value,pvBuffer)
//  }
#[inline]
pub fn get_font_language_info(hdc: Hdc) -> u32 {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetFontLanguageInfo(hdc) };
    return_value
}
#[inline]
pub fn get_font_unicode_ranges(hdc: Hdc, ) -> (u32, Glyphset) {
    let mut lpgs = mem::MaybeUninit::zeroed();
    let lpgs = lpgs.as_mut_ptr();
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetFontUnicodeRanges(hdc, lpgs) };
    let lpgs = unsafe { Glyphset::from_win32(unsafe { lpgs.assume_init() }) };
    (return_value,lpgs)
}
#[inline]
pub fn get_glyph_indices_a(hdc: Hdc, lpstr: &CStr, c: i32, fl: u32) -> (u32, u16) {
    let mut pgi = mem::MaybeUninit::zeroed();
    let pgi = pgi.as_mut_ptr();
    let hdc = hdc.into_raw();
    let lpstr = lpstr.as_ptr() as _;
    let c = c;
    let fl = fl;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetGlyphIndicesA(hdc, lpstr, c, pgi, fl) };
    let pgi = unsafe { pgi.assume_init() };
    (return_value,pgi)
}
#[inline]
pub fn get_glyph_indices_w(hdc: Hdc, lpstr: &OsStr, c: i32, fl: u32) -> (u32, u16) {
    let mut pgi = mem::MaybeUninit::zeroed();
    let pgi = pgi.as_mut_ptr();
    let hdc = hdc.into_raw();
    let mut temp37: Vec<u16> = lpstr.encode_wide().collect();
    temp37.push(0);
    let lpstr = temp37.as_ptr() as _;
    let c = c;
    let fl = fl;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetGlyphIndicesW(hdc, lpstr, c, pgi, fl) };
    let pgi = unsafe { pgi.assume_init() };
    (return_value,pgi)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn get_glyph_outline_a(hdc: Hdc, u_char: u32, fu_format: u32, lpmat2: &[Mat2]) -> (u32, Glyphmetrics, todo_void_ret) {
//      let mut lpgm = mem::MaybeUninit::zeroed();
//      let lpgm = lpgm.as_mut_ptr();
//      let mut pv_buffer = mem::MaybeUninit::zeroed();
//      let pvBuffer = pv_buffer.as_mut_ptr();
//      let hdc = hdc.into_raw();
//      let uChar = u_char;
//      let fuFormat = fu_format;
//      let lpmat2 = lpmat2.as_ptr() as _;
//      let cjBuffer = lpmat2.len() as _;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetGlyphOutlineA(hdc, uChar, fuFormat, lpgm, cjBuffer, pvBuffer, lpmat2) };
//      let pv_buffer = todo_void;
//      let lpgm = unsafe { Glyphmetrics::from_win32(unsafe { lpgm.assume_init() }) };
//      (return_value,lpgm, pvBuffer)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn get_glyph_outline_w(hdc: Hdc, u_char: u32, fu_format: u32, lpmat2: &[Mat2]) -> (u32, Glyphmetrics, todo_void_ret) {
//      let mut lpgm = mem::MaybeUninit::zeroed();
//      let lpgm = lpgm.as_mut_ptr();
//      let mut pv_buffer = mem::MaybeUninit::zeroed();
//      let pvBuffer = pv_buffer.as_mut_ptr();
//      let hdc = hdc.into_raw();
//      let uChar = u_char;
//      let fuFormat = fu_format;
//      let lpmat2 = lpmat2.as_ptr() as _;
//      let cjBuffer = lpmat2.len() as _;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetGlyphOutlineW(hdc, uChar, fuFormat, lpgm, cjBuffer, pvBuffer, lpmat2) };
//      let pv_buffer = todo_void;
//      let lpgm = unsafe { Glyphmetrics::from_win32(unsafe { lpgm.assume_init() }) };
//      (return_value,lpgm, pvBuffer)
//  }
#[inline]
pub fn get_graphics_mode(hdc: Hdc) -> Result<i32> {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetGraphicsMode(hdc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_kerning_pairs_a(hdc: Hdc, n_pairs: u32, ) -> (u32, Kerningpair) {
    let mut lp_kern_pair = mem::MaybeUninit::zeroed();
    let lpKernPair = lp_kern_pair.as_mut_ptr();
    let hdc = hdc.into_raw();
    let nPairs = n_pairs;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetKerningPairsA(hdc, nPairs, lpKernPair) };
    let lp_kern_pair = unsafe { Kerningpair::from_win32(unsafe { lpKernPair.assume_init() }) };
    (return_value,lpKernPair)
}
#[inline]
pub fn get_kerning_pairs_w(hdc: Hdc, n_pairs: u32, ) -> (u32, Kerningpair) {
    let mut lp_kern_pair = mem::MaybeUninit::zeroed();
    let lpKernPair = lp_kern_pair.as_mut_ptr();
    let hdc = hdc.into_raw();
    let nPairs = n_pairs;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetKerningPairsW(hdc, nPairs, lpKernPair) };
    let lp_kern_pair = unsafe { Kerningpair::from_win32(unsafe { lpKernPair.assume_init() }) };
    (return_value,lpKernPair)
}
#[inline]
pub fn get_layout(hdc: Hdc) -> u32 {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetLayout(hdc) };
    return_value
}
#[inline]
pub fn get_map_mode(hdc: Hdc) -> Result<i32> {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetMapMode(hdc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_meta_file_a(lp_name: &CStr) -> Result<Hmetafile> {
    let lpName = lp_name.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetMetaFileA(lpName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn get_meta_file_bits_ex(h_mf: Hmetafile, cb_buffer: u32, ) -> (u32, todo_void_ret) {
//      let mut lp_data = mem::MaybeUninit::zeroed();
//      let lpData = lp_data.as_mut_ptr();
//      let hMF = h_mf.into_raw();
//      let cbBuffer = cb_buffer;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetMetaFileBitsEx(hMF, cbBuffer, lpData) };
//      let lp_data = todo_void;
//      (return_value,lpData)
//  }
#[inline]
pub fn get_meta_file_w(lp_name: &OsStr) -> Result<Hmetafile> {
    let mut temp38: Vec<u16> = lp_name.encode_wide().collect();
    temp38.push(0);
    let lpName = temp38.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetMetaFileW(lpName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_meta_rgn(hdc: Hdc, hrgn: Hrgn) -> Result<i32> {
    let hdc = hdc.into_raw();
    let hrgn = hrgn.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetMetaRgn(hdc, hrgn) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_miter_limit(hdc: Hdc, ) -> Result<(BOOL, f32)> {
    let mut plimit = mem::MaybeUninit::zeroed();
    let plimit = plimit.as_mut_ptr();
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetMiterLimit(hdc, plimit) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let plimit = unsafe { plimit.assume_init() };
    Ok((return_value,plimit))
}
#[inline]
pub fn get_monitor_info_a(h_monitor: Hmonitor, lpmi: Monitorinfo) -> Result<(BOOL, Monitorinfo)> {
    let hMonitor = h_monitor.into_raw();
    let mut lpmi = lpmi.to_win32();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetMonitorInfoA(hMonitor, &mut lpmi) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpmi = unsafe { Monitorinfo::from_win32(lpmi) };
    Ok((return_value,lpmi))
}
#[inline]
pub fn get_monitor_info_w(h_monitor: Hmonitor, lpmi: Monitorinfo) -> Result<(BOOL, Monitorinfo)> {
    let hMonitor = h_monitor.into_raw();
    let mut lpmi = lpmi.to_win32();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetMonitorInfoW(hMonitor, &mut lpmi) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpmi = unsafe { Monitorinfo::from_win32(lpmi) };
    Ok((return_value,lpmi))
}
#[inline]
pub fn get_nearest_color(hdc: Hdc, color: u32) -> u32 {
    let hdc = hdc.into_raw();
    let color = color;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetNearestColor(hdc, color) };
    return_value
}
#[inline]
pub fn get_nearest_palette_index(h: Hpalette, color: u32) -> u32 {
    let h = h.into_raw();
    let color = color;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetNearestPaletteIndex(h, color) };
    return_value
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn get_object_a(h: Hgdiobj, c: i32, ) -> Result<(i32, todo_void_ret)> {
//      let mut pv = mem::MaybeUninit::zeroed();
//      let pv = pv.as_mut_ptr();
//      let h = h.into_raw();
//      let c = c;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetObjectA(h, c, pv) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let pv = todo_void;
//      Ok((return_value,pv))
//  }
#[inline]
pub fn get_object_type(h: Hgdiobj) -> u32 {
    let h = h.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetObjectType(h) };
    return_value
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn get_object_w(h: Hgdiobj, c: i32, ) -> Result<(i32, todo_void_ret)> {
//      let mut pv = mem::MaybeUninit::zeroed();
//      let pv = pv.as_mut_ptr();
//      let h = h.into_raw();
//      let c = c;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetObjectW(h, c, pv) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let pv = todo_void;
//      Ok((return_value,pv))
//  }
#[inline]
pub fn get_outline_text_metrics_a(hdc: Hdc, cj_copy: u32, ) -> (u32, Outlinetextmetrica<'_>) {
    let mut potm = mem::MaybeUninit::zeroed();
    let potm = potm.as_mut_ptr();
    let hdc = hdc.into_raw();
    let cjCopy = cj_copy;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetOutlineTextMetricsA(hdc, cjCopy, potm) };
    let potm = unsafe { Outlinetextmetrica::from_win32(unsafe { potm.assume_init() }) };
    (return_value,potm)
}
#[inline]
pub fn get_outline_text_metrics_w(hdc: Hdc, cj_copy: u32, ) -> (u32, Outlinetextmetricw<'_>) {
    let mut potm = mem::MaybeUninit::zeroed();
    let potm = potm.as_mut_ptr();
    let hdc = hdc.into_raw();
    let cjCopy = cj_copy;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetOutlineTextMetricsW(hdc, cjCopy, potm) };
    let potm = unsafe { Outlinetextmetricw::from_win32(unsafe { potm.assume_init() }) };
    (return_value,potm)
}
#[inline]
pub fn get_palette_entries(hpal: Hpalette, i_start: u32, c_entries: u32, ) -> (u32, Paletteentry) {
    let mut p_pal_entries = mem::MaybeUninit::zeroed();
    let pPalEntries = p_pal_entries.as_mut_ptr();
    let hpal = hpal.into_raw();
    let iStart = i_start;
    let cEntries = c_entries;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetPaletteEntries(hpal, iStart, cEntries, pPalEntries) };
    let p_pal_entries = unsafe { Paletteentry::from_win32(unsafe { pPalEntries.assume_init() }) };
    (return_value,pPalEntries)
}
#[inline]
pub fn get_path(hdc: Hdc, cpt: i32) -> Result<(i32, Point, u8)> {
    let mut apt = mem::MaybeUninit::zeroed();
    let apt = apt.as_mut_ptr();
    let mut aj = mem::MaybeUninit::zeroed();
    let aj = aj.as_mut_ptr();
    let hdc = hdc.into_raw();
    let cpt = cpt;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetPath(hdc, apt, aj, cpt) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let aj = unsafe { aj.assume_init() };
    let apt = unsafe { Point::from_win32(unsafe { apt.assume_init() }) };
    Ok((return_value,apt, aj))
}
#[inline]
pub fn get_pixel(hdc: Hdc, x: i32, y: i32) -> u32 {
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetPixel(hdc, x, y) };
    return_value
}
#[inline]
pub fn get_poly_fill_mode(hdc: Hdc) -> Result<i32> {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetPolyFillMode(hdc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_rop2(hdc: Hdc) -> Result<i32> {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetROP2(hdc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_random_rgn(hdc: Hdc, hrgn: Hrgn, i: i32) -> Result<i32> {
    let hdc = hdc.into_raw();
    let hrgn = hrgn.into_raw();
    let i = i;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetRandomRgn(hdc, hrgn, i) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_rasterizer_caps(cj_bytes: u32) -> Result<(BOOL, RasterizerStatus)> {
    let mut lpraststat = mem::MaybeUninit::zeroed();
    let lpraststat = lpraststat.as_mut_ptr();
    let cjBytes = cj_bytes;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetRasterizerCaps(lpraststat, cjBytes) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpraststat = unsafe { RasterizerStatus::from_win32(unsafe { lpraststat.assume_init() }) };
    Ok((return_value,lpraststat))
}
#[inline]
pub fn get_region_data(hrgn: Hrgn, n_count: u32, ) -> (u32, Rgndata) {
    let mut lp_rgn_data = mem::MaybeUninit::zeroed();
    let lpRgnData = lp_rgn_data.as_mut_ptr();
    let hrgn = hrgn.into_raw();
    let nCount = n_count;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetRegionData(hrgn, nCount, lpRgnData) };
    let lp_rgn_data = unsafe { Rgndata::from_win32(unsafe { lpRgnData.assume_init() }) };
    (return_value,lpRgnData)
}
#[inline]
pub fn get_rgn_box(hrgn: Hrgn, ) -> Result<(i32, Rect)> {
    let mut lprc = mem::MaybeUninit::zeroed();
    let lprc = lprc.as_mut_ptr();
    let hrgn = hrgn.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetRgnBox(hrgn, lprc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lprc = unsafe { Rect::from_win32(unsafe { lprc.assume_init() }) };
    Ok((return_value,lprc))
}
#[inline]
pub fn get_stock_object(i: u32) -> Result<Hgdiobj> {
    let i = i;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetStockObject(i) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_stretch_blt_mode(hdc: Hdc) -> Result<i32> {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetStretchBltMode(hdc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_sys_color_brush(n_index: i32) -> Result<Hbrush> {
    let nIndex = n_index;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetSysColorBrush(nIndex) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_system_palette_entries(hdc: Hdc, i_start: u32, c_entries: u32, ) -> (u32, Paletteentry) {
    let mut p_pal_entries = mem::MaybeUninit::zeroed();
    let pPalEntries = p_pal_entries.as_mut_ptr();
    let hdc = hdc.into_raw();
    let iStart = i_start;
    let cEntries = c_entries;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetSystemPaletteEntries(hdc, iStart, cEntries, pPalEntries) };
    let p_pal_entries = unsafe { Paletteentry::from_win32(unsafe { pPalEntries.assume_init() }) };
    (return_value,pPalEntries)
}
#[inline]
pub fn get_system_palette_use(hdc: Hdc) -> u32 {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetSystemPaletteUse(hdc) };
    return_value
}
#[inline]
pub fn get_tabbed_text_extent_a(hdc: Hdc, lp_string: &CStr, ch_count: i32, lpn_tab_stop_positions: Option<&[i32]>) -> u32 {
    let hdc = hdc.into_raw();
    let lpString = lp_string.as_ptr() as _;
    let chCount = ch_count;
    let lpnTabStopPositions = lpn_tab_stop_positions.map_or(ptr::null(), |v| v.as_ptr() as _);
    let nTabPositions = lpn_tab_stop_positions.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTabbedTextExtentA(hdc, lpString, chCount, nTabPositions, lpnTabStopPositions) };
    return_value
}
#[inline]
pub fn get_tabbed_text_extent_w(hdc: Hdc, lp_string: &OsStr, ch_count: i32, lpn_tab_stop_positions: Option<&[i32]>) -> u32 {
    let hdc = hdc.into_raw();
    let mut temp39: Vec<u16> = lp_string.encode_wide().collect();
    temp39.push(0);
    let lpString = temp39.as_ptr() as _;
    let chCount = ch_count;
    let lpnTabStopPositions = lpn_tab_stop_positions.map_or(ptr::null(), |v| v.as_ptr() as _);
    let nTabPositions = lpn_tab_stop_positions.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTabbedTextExtentW(hdc, lpString, chCount, nTabPositions, lpnTabStopPositions) };
    return_value
}
#[inline]
pub fn get_text_align(hdc: Hdc) -> u32 {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextAlign(hdc) };
    return_value
}
#[inline]
pub fn get_text_color(hdc: Hdc) -> u32 {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextColor(hdc) };
    return_value
}
#[inline]
pub fn get_text_extent_ex_point_a(hdc: Hdc, lpsz_string: &CStr, cch_string: i32, n_max_extent: i32, ) -> Result<(BOOL, i32, i32, Size)> {
    let mut lpn_fit = mem::MaybeUninit::zeroed();
    let lpnFit = lpn_fit.as_mut_ptr();
    let mut lpn_dx = mem::MaybeUninit::zeroed();
    let lpnDx = lpn_dx.as_mut_ptr();
    let mut lp_size = mem::MaybeUninit::zeroed();
    let lpSize = lp_size.as_mut_ptr();
    let hdc = hdc.into_raw();
    let lpszString = lpsz_string.as_ptr() as _;
    let cchString = cch_string;
    let nMaxExtent = n_max_extent;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextExtentExPointA(hdc, lpszString, cchString, nMaxExtent, lpnFit, lpnDx, lpSize) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_size = unsafe { Size::from_win32(unsafe { lpSize.assume_init() }) };
    let lpn_dx = unsafe { lpnDx.assume_init() };
    let lpn_fit = unsafe { lpnFit.assume_init() };
    Ok((return_value,lpnFit, lpnDx, lpSize))
}
#[inline]
pub fn get_text_extent_ex_point_i(hdc: Hdc, lpwsz_string: &[u16], cwch_string: i32, ) -> Result<(BOOL, i32, i32, Size)> {
    let mut lpn_fit = mem::MaybeUninit::zeroed();
    let lpnFit = lpn_fit.as_mut_ptr();
    let mut lpn_dx = mem::MaybeUninit::zeroed();
    let lpnDx = lpn_dx.as_mut_ptr();
    let mut lp_size = mem::MaybeUninit::zeroed();
    let lpSize = lp_size.as_mut_ptr();
    let hdc = hdc.into_raw();
    let lpwszString = lpwsz_string.as_ptr() as _;
    let nMaxExtent = lpwsz_string.len() as _;
    let cwchString = cwch_string;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextExtentExPointI(hdc, lpwszString, cwchString, nMaxExtent, lpnFit, lpnDx, lpSize) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_size = unsafe { Size::from_win32(unsafe { lpSize.assume_init() }) };
    let lpn_dx = unsafe { lpnDx.assume_init() };
    let lpn_fit = unsafe { lpnFit.assume_init() };
    Ok((return_value,lpnFit, lpnDx, lpSize))
}
#[inline]
pub fn get_text_extent_ex_point_w(hdc: Hdc, lpsz_string: &OsStr, cch_string: i32, n_max_extent: i32, ) -> Result<(BOOL, i32, i32, Size)> {
    let mut lpn_fit = mem::MaybeUninit::zeroed();
    let lpnFit = lpn_fit.as_mut_ptr();
    let mut lpn_dx = mem::MaybeUninit::zeroed();
    let lpnDx = lpn_dx.as_mut_ptr();
    let mut lp_size = mem::MaybeUninit::zeroed();
    let lpSize = lp_size.as_mut_ptr();
    let hdc = hdc.into_raw();
    let mut temp40: Vec<u16> = lpsz_string.encode_wide().collect();
    temp40.push(0);
    let lpszString = temp40.as_ptr() as _;
    let cchString = cch_string;
    let nMaxExtent = n_max_extent;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextExtentExPointW(hdc, lpszString, cchString, nMaxExtent, lpnFit, lpnDx, lpSize) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_size = unsafe { Size::from_win32(unsafe { lpSize.assume_init() }) };
    let lpn_dx = unsafe { lpnDx.assume_init() };
    let lpn_fit = unsafe { lpnFit.assume_init() };
    Ok((return_value,lpnFit, lpnDx, lpSize))
}
#[inline]
pub fn get_text_extent_point32_a(hdc: Hdc, lp_string: &CStr, c: i32, ) -> Result<(BOOL, Size)> {
    let mut psizl = mem::MaybeUninit::zeroed();
    let psizl = psizl.as_mut_ptr();
    let hdc = hdc.into_raw();
    let lpString = lp_string.as_ptr() as _;
    let c = c;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextExtentPoint32A(hdc, lpString, c, psizl) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let psizl = unsafe { Size::from_win32(unsafe { psizl.assume_init() }) };
    Ok((return_value,psizl))
}
#[inline]
pub fn get_text_extent_point32_w(hdc: Hdc, lp_string: &OsStr, c: i32, ) -> Result<(BOOL, Size)> {
    let mut psizl = mem::MaybeUninit::zeroed();
    let psizl = psizl.as_mut_ptr();
    let hdc = hdc.into_raw();
    let mut temp41: Vec<u16> = lp_string.encode_wide().collect();
    temp41.push(0);
    let lpString = temp41.as_ptr() as _;
    let c = c;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextExtentPoint32W(hdc, lpString, c, psizl) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let psizl = unsafe { Size::from_win32(unsafe { psizl.assume_init() }) };
    Ok((return_value,psizl))
}
#[inline]
pub fn get_text_extent_point_a(hdc: Hdc, lp_string: &CStr, c: i32, ) -> Result<(BOOL, Size)> {
    let mut lpsz = mem::MaybeUninit::zeroed();
    let lpsz = lpsz.as_mut_ptr();
    let hdc = hdc.into_raw();
    let lpString = lp_string.as_ptr() as _;
    let c = c;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextExtentPointA(hdc, lpString, c, lpsz) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpsz = unsafe { Size::from_win32(unsafe { lpsz.assume_init() }) };
    Ok((return_value,lpsz))
}
#[inline]
pub fn get_text_extent_point_i(hdc: Hdc, pgi_in: &[u16], ) -> Result<(BOOL, Size)> {
    let mut psize = mem::MaybeUninit::zeroed();
    let psize = psize.as_mut_ptr();
    let hdc = hdc.into_raw();
    let pgiIn = pgi_in.as_ptr() as _;
    let cgi = pgi_in.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextExtentPointI(hdc, pgiIn, cgi, psize) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let psize = unsafe { Size::from_win32(unsafe { psize.assume_init() }) };
    Ok((return_value,psize))
}
#[inline]
pub fn get_text_extent_point_w(hdc: Hdc, lp_string: &OsStr, c: i32, ) -> Result<(BOOL, Size)> {
    let mut lpsz = mem::MaybeUninit::zeroed();
    let lpsz = lpsz.as_mut_ptr();
    let hdc = hdc.into_raw();
    let mut temp42: Vec<u16> = lp_string.encode_wide().collect();
    temp42.push(0);
    let lpString = temp42.as_ptr() as _;
    let c = c;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextExtentPointW(hdc, lpString, c, lpsz) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpsz = unsafe { Size::from_win32(unsafe { lpsz.assume_init() }) };
    Ok((return_value,lpsz))
}
#[inline]
pub fn get_text_face_a(hdc: Hdc, c: i32, ) -> Result<(i32, CString)> {
    let mut lp_name = Vec::<u8>::with_capacity(c as usize + 1);
    let lpName = lp_name.as_mut_ptr();
    let hdc = hdc.into_raw();
    let c = c;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextFaceA(hdc, c, lpName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let out4 = unsafe {
        slice::from_raw_parts(unsafe { lpName.assume_init() }, return_value as usize)
    };
    let mut out4 = out4.to_vec();
    out4.push(0);
    let lp_name = unsafe { CString::from_vec_unchecked(out4) };
    Ok((return_value,lpName))
}
#[inline]
pub fn get_text_face_w(hdc: Hdc, c: i32, ) -> Result<(i32, OsString)> {
    let mut lp_name = Vec::<u16>::with_capacity(c as usize + 1);
    let lpName = lp_name.as_mut_ptr();
    let hdc = hdc.into_raw();
    let c = c;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextFaceW(hdc, c, lpName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let out5 = unsafe {
        slice::from_raw_parts(unsafe { lpName.assume_init() }, return_value as usize)
    };
    let out5 = out5.to_vec();
    let lp_name = OsStringExt::from_wide(out5);
    Ok((return_value,lpName))
}
#[inline]
pub fn get_text_metrics_a(hdc: Hdc, ) -> Result<(BOOL, Textmetrica)> {
    let mut lptm = mem::MaybeUninit::zeroed();
    let lptm = lptm.as_mut_ptr();
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextMetricsA(hdc, lptm) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lptm = unsafe { Textmetrica::from_win32(unsafe { lptm.assume_init() }) };
    Ok((return_value,lptm))
}
#[inline]
pub fn get_text_metrics_w(hdc: Hdc, ) -> Result<(BOOL, Textmetricw)> {
    let mut lptm = mem::MaybeUninit::zeroed();
    let lptm = lptm.as_mut_ptr();
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextMetricsW(hdc, lptm) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lptm = unsafe { Textmetricw::from_win32(unsafe { lptm.assume_init() }) };
    Ok((return_value,lptm))
}
#[inline]
pub fn get_update_rect(h_wnd: Hwnd, b_erase: BOOL) -> Result<(BOOL, Rect)> {
    let mut lp_rect = mem::MaybeUninit::zeroed();
    let lpRect = lp_rect.as_mut_ptr();
    let hWnd = h_wnd.into_raw();
    let bErase = b_erase;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetUpdateRect(hWnd, lpRect, bErase) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_rect = unsafe { Rect::from_win32(unsafe { lpRect.assume_init() }) };
    Ok((return_value,lpRect))
}
#[inline]
pub fn get_update_rgn(h_wnd: Hwnd, h_rgn: Hrgn, b_erase: BOOL) -> Result<i32> {
    let hWnd = h_wnd.into_raw();
    let hRgn = h_rgn.into_raw();
    let bErase = b_erase;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetUpdateRgn(hWnd, hRgn, bErase) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_viewport_ext_ex(hdc: Hdc, ) -> Result<(BOOL, Size)> {
    let mut lpsize = mem::MaybeUninit::zeroed();
    let lpsize = lpsize.as_mut_ptr();
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetViewportExtEx(hdc, lpsize) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpsize = unsafe { Size::from_win32(unsafe { lpsize.assume_init() }) };
    Ok((return_value,lpsize))
}
#[inline]
pub fn get_viewport_org_ex(hdc: Hdc, ) -> Result<(BOOL, Point)> {
    let mut lppoint = mem::MaybeUninit::zeroed();
    let lppoint = lppoint.as_mut_ptr();
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetViewportOrgEx(hdc, lppoint) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lppoint = unsafe { Point::from_win32(unsafe { lppoint.assume_init() }) };
    Ok((return_value,lppoint))
}
#[inline]
pub fn get_win_meta_file_bits(hemf: Henhmetafile, cb_data16: u32, i_map_mode: i32, hdc_ref: Hdc) -> (u32, u8) {
    let mut p_data16 = mem::MaybeUninit::zeroed();
    let pData16 = p_data16.as_mut_ptr();
    let hemf = hemf.into_raw();
    let cbData16 = cb_data16;
    let iMapMode = i_map_mode;
    let hdcRef = hdc_ref.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetWinMetaFileBits(hemf, cbData16, pData16, iMapMode, hdcRef) };
    let p_data16 = unsafe { pData16.assume_init() };
    (return_value,pData16)
}
#[inline]
pub fn get_window_dc(h_wnd: Option<Hwnd>) -> Result<Hdc> {
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetWindowDC(hWnd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_window_ext_ex(hdc: Hdc, ) -> Result<(BOOL, Size)> {
    let mut lpsize = mem::MaybeUninit::zeroed();
    let lpsize = lpsize.as_mut_ptr();
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetWindowExtEx(hdc, lpsize) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpsize = unsafe { Size::from_win32(unsafe { lpsize.assume_init() }) };
    Ok((return_value,lpsize))
}
#[inline]
pub fn get_window_org_ex(hdc: Hdc, ) -> Result<(BOOL, Point)> {
    let mut lppoint = mem::MaybeUninit::zeroed();
    let lppoint = lppoint.as_mut_ptr();
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetWindowOrgEx(hdc, lppoint) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lppoint = unsafe { Point::from_win32(unsafe { lppoint.assume_init() }) };
    Ok((return_value,lppoint))
}
#[inline]
pub fn get_window_rgn(h_wnd: Hwnd, h_rgn: Hrgn) -> Result<i32> {
    let hWnd = h_wnd.into_raw();
    let hRgn = h_rgn.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetWindowRgn(hWnd, hRgn) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_window_rgn_box(h_wnd: Hwnd, ) -> Result<(i32, Rect)> {
    let mut lprc = mem::MaybeUninit::zeroed();
    let lprc = lprc.as_mut_ptr();
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetWindowRgnBox(hWnd, lprc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lprc = unsafe { Rect::from_win32(unsafe { lprc.assume_init() }) };
    Ok((return_value,lprc))
}
#[inline]
pub fn get_world_transform(hdc: Hdc, ) -> Result<(BOOL, Xform)> {
    let mut lpxf = mem::MaybeUninit::zeroed();
    let lpxf = lpxf.as_mut_ptr();
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetWorldTransform(hdc, lpxf) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpxf = unsafe { Xform::from_win32(unsafe { lpxf.assume_init() }) };
    Ok((return_value,lpxf))
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn gradient_fill(hdc: Hdc, p_vertex: &[Trivertex], p_mesh: &[todo_void], ul_mode: u32) -> Result<BOOL> {
//      let hdc = hdc.into_raw();
//      let pVertex = p_vertex.as_ptr() as _;
//      let nVertex = p_vertex.len() as _;
//      let pMesh = p_mesh.as_ptr() as _;
//      let nMesh = p_mesh.len() as _;
//      let ulMode = ul_mode;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GradientFill(hdc, pVertex, nVertex, pMesh, nMesh, ulMode) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
#[inline]
pub fn gray_string_a<Graystringproc: FnMut(Hdc, i32) -> BOOL>(h_dc: Hdc, h_brush: Option<Hbrush>, lp_output_func: Option<Graystringproc>, n_count: i32, x: i32, y: i32, n_width: i32, n_height: i32) -> Result<BOOL> {
    let hDC = h_dc.into_raw();
    let hBrush = h_brush.map_or(0, Hbrush::into_raw);
    unsafe extern "system" fn graystringproc_impl(param0: HDC, param1: LPARAM, param2: i32) -> BOOL {
        abort_on_panic(move || {
            let input0 = unsafe { Hdc::new(param0) };
            let input2 = param2;
            let closure = unsafe {
                &mut *(param1 as usize as *mut Graystringproc)
            };
            let return_value = closure(input0, input2);
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpOutputFunc = Some(graystringproc_impl);
    let mut lp_output_func = lp_output_func;
    let lpData = unsafe { Lparam::from_ptr((&mut lp_output_func) as *mut _ as *mut _) };
    let nCount = n_count;
    let X = x;
    let Y = y;
    let nWidth = n_width;
    let nHeight = n_height;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GrayStringA(hDC, hBrush, lpOutputFunc, lpData, nCount, X, Y, nWidth, nHeight) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn gray_string_w<Graystringproc: FnMut(Hdc, i32) -> BOOL>(h_dc: Hdc, h_brush: Option<Hbrush>, lp_output_func: Option<Graystringproc>, n_count: i32, x: i32, y: i32, n_width: i32, n_height: i32) -> Result<BOOL> {
    let hDC = h_dc.into_raw();
    let hBrush = h_brush.map_or(0, Hbrush::into_raw);
    unsafe extern "system" fn graystringproc_impl(param0: HDC, param1: LPARAM, param2: i32) -> BOOL {
        abort_on_panic(move || {
            let input0 = unsafe { Hdc::new(param0) };
            let input2 = param2;
            let closure = unsafe {
                &mut *(param1 as usize as *mut Graystringproc)
            };
            let return_value = closure(input0, input2);
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpOutputFunc = Some(graystringproc_impl);
    let mut lp_output_func = lp_output_func;
    let lpData = unsafe { Lparam::from_ptr((&mut lp_output_func) as *mut _ as *mut _) };
    let nCount = n_count;
    let X = x;
    let Y = y;
    let nWidth = n_width;
    let nHeight = n_height;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GrayStringW(hDC, hBrush, lpOutputFunc, lpData, nCount, X, Y, nWidth, nHeight) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn inflate_rect(lprc: Rect, dx: i32, dy: i32) -> Result<(BOOL, Rect)> {
    let mut lprc = lprc.to_win32();
    let dx = dx;
    let dy = dy;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::InflateRect(&mut lprc, dx, dy) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lprc = unsafe { Rect::from_win32(lprc) };
    Ok((return_value,lprc))
}
#[inline]
pub fn intersect_clip_rect(hdc: Hdc, left: i32, top: i32, right: i32, bottom: i32) -> Result<i32> {
    let hdc = hdc.into_raw();
    let left = left;
    let top = top;
    let right = right;
    let bottom = bottom;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::IntersectClipRect(hdc, left, top, right, bottom) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn intersect_rect(lprc_src1: &Rect, lprc_src2: &Rect) -> Result<(BOOL, Rect)> {
    let mut lprc_dst = mem::MaybeUninit::zeroed();
    let lprcDst = lprc_dst.as_mut_ptr();
    // SAFETY: type is a thin type
    let lprcSrc1 = unsafe { &*(lprc_src1 as *const _ as *const _) };
    // SAFETY: type is a thin type
    let lprcSrc2 = unsafe { &*(lprc_src2 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::IntersectRect(lprcDst, lprcSrc1, lprcSrc2) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lprc_dst = unsafe { Rect::from_win32(unsafe { lprcDst.assume_init() }) };
    Ok((return_value,lprcDst))
}
#[inline]
pub fn invalidate_rect(h_wnd: Option<Hwnd>, lp_rect: Option<&Rect>, b_erase: BOOL) -> Result<BOOL> {
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    // SAFETY: type is a thin type
    let lpRect = lp_rect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let bErase = b_erase;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::InvalidateRect(hWnd, lpRect, bErase) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn invalidate_rgn(h_wnd: Hwnd, h_rgn: Option<Hrgn>, b_erase: BOOL) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let hRgn = h_rgn.map_or(0, Hrgn::into_raw);
    let bErase = b_erase;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::InvalidateRgn(hWnd, hRgn, bErase) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn invert_rect(h_dc: Hdc, lprc: &Rect) -> Result<BOOL> {
    let hDC = h_dc.into_raw();
    // SAFETY: type is a thin type
    let lprc = unsafe { &*(lprc as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::InvertRect(hDC, lprc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn invert_rgn(hdc: Hdc, hrgn: Hrgn) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let hrgn = hrgn.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::InvertRgn(hdc, hrgn) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn is_rect_empty(lprc: &Rect) -> BOOL {
    // SAFETY: type is a thin type
    let lprc = unsafe { &*(lprc as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::IsRectEmpty(lprc) };
    return_value
}
#[inline]
pub fn l_pto_dp(hdc: Hdc, lppt: Point, c: i32) -> Result<(BOOL, Point)> {
    let hdc = hdc.into_raw();
    let mut lppt = lppt.to_win32();
    let c = c;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::LPtoDP(hdc, &mut lppt, c) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lppt = unsafe { Point::from_win32(lppt) };
    Ok((return_value,lppt))
}
#[inline]
pub fn line_dda<Lineddaproc: FnMut(i32, i32, )>(x_start: i32, y_start: i32, x_end: i32, y_end: i32, lp_proc: Lineddaproc, ) -> Result<BOOL> {
    let xStart = x_start;
    let yStart = y_start;
    let xEnd = x_end;
    let yEnd = y_end;
    unsafe extern "system" fn lineddaproc_impl(param0: i32, param1: i32, param2: LPARAM) -> () {
        abort_on_panic(move || {
            let input0 = param0;
            let input1 = param1;
            let closure = unsafe {
                &mut *(param2 as usize as *mut Lineddaproc)
            };
            let return_value = closure(input0, input1, );
        })
    }
    let lpProc = Some(lineddaproc_impl);
    let mut lp_proc = lp_proc;
    let data = unsafe { Lparam::from_ptr((&mut lp_proc) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::LineDDA(xStart, yStart, xEnd, yEnd, lpProc, data) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn line_to(hdc: Hdc, x: i32, y: i32) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::LineTo(hdc, x, y) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn load_bitmap_a(h_instance: Option<Hinstance>, lp_bitmap_name: &CStr) -> Result<Hbitmap> {
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    let lpBitmapName = lp_bitmap_name.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::LoadBitmapA(hInstance, lpBitmapName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn load_bitmap_w(h_instance: Option<Hinstance>, lp_bitmap_name: &OsStr) -> Result<Hbitmap> {
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    let mut temp43: Vec<u16> = lp_bitmap_name.encode_wide().collect();
    temp43.push(0);
    let lpBitmapName = temp43.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::LoadBitmapW(hInstance, lpBitmapName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn lock_window_update(h_wnd_lock: Option<Hwnd>) -> Result<BOOL> {
    let hWndLock = h_wnd_lock.map_or(0, Hwnd::into_raw);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::LockWindowUpdate(hWndLock) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn map_window_points(h_wnd_from: Option<Hwnd>, h_wnd_to: Option<Hwnd>, lp_points: Point, c_points: u32) -> Result<(i32, Point)> {
    let hWndFrom = h_wnd_from.map_or(0, Hwnd::into_raw);
    let hWndTo = h_wnd_to.map_or(0, Hwnd::into_raw);
    let mut lpPoints = lp_points.to_win32();
    let cPoints = c_points;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::MapWindowPoints(hWndFrom, hWndTo, &mut lpPoints, cPoints) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_points = unsafe { Point::from_win32(lpPoints) };
    Ok((return_value,lpPoints))
}
#[inline]
pub fn mask_blt(hdc_dest: Hdc, x_dest: i32, y_dest: i32, width: i32, height: i32, hdc_src: Hdc, x_src: i32, y_src: i32, hbm_mask: Hbitmap, x_mask: i32, y_mask: i32, rop: u32) -> Result<BOOL> {
    let hdcDest = hdc_dest.into_raw();
    let xDest = x_dest;
    let yDest = y_dest;
    let width = width;
    let height = height;
    let hdcSrc = hdc_src.into_raw();
    let xSrc = x_src;
    let ySrc = y_src;
    let hbmMask = hbm_mask.into_raw();
    let xMask = x_mask;
    let yMask = y_mask;
    let rop = rop;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::MaskBlt(hdcDest, xDest, yDest, width, height, hdcSrc, xSrc, ySrc, hbmMask, xMask, yMask, rop) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn merge_font_package(puch_merge_font_buffer: &[u8], puch_font_package_buffer: &[u8], ppuch_dest_buffer: &mut u8, pul_dest_buffer_size: u32, pul_bytes_written: u32, us_mode: u16, lpfn_allocate: Option<unsafe extern "system" fn(usize) -> *mut c_void>, lpfn_re_allocate: Option<unsafe extern "system" fn(*mut c_void, usize) -> *mut c_void>, lpfn_free: Option<unsafe extern "system" fn(*mut c_void)>, lpv_reserved: todo_void) -> (u32, &mut u8, u32, u32, todo_void_ret) {
//      let puchMergeFontBuffer = puch_merge_font_buffer.as_ptr() as _;
//      let ulMergeFontBufferSize = puch_merge_font_buffer.len() as _;
//      let puchFontPackageBuffer = puch_font_package_buffer.as_ptr() as _;
//      let ulFontPackageBufferSize = puch_font_package_buffer.len() as _;
//      let mut temp44 = ppuch_dest_buffer;
//      let mut ppuchDestBuffer = &mut temp44;
//      let mut pulDestBufferSize = pul_dest_buffer_size;
//      let mut pulBytesWritten = pul_bytes_written;
//      let usMode = us_mode;
//      let lpfnAllocate = lpfn_allocate;
//      let lpfnReAllocate = lpfn_re_allocate;
//      let lpfnFree = lpfn_free;
//      let mut lpvReserved = todo_void;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::MergeFontPackage(puchMergeFontBuffer, ulMergeFontBufferSize, puchFontPackageBuffer, ulFontPackageBufferSize, &mut ppuchDestBuffer, &mut pulDestBufferSize, &mut pulBytesWritten, usMode, lpfnAllocate, lpfnReAllocate, lpfnFree, &mut lpvReserved) };
//      let lpv_reserved = todo_void;
//      let pul_bytes_written = pulBytesWritten;
//      let pul_dest_buffer_size = pulDestBufferSize;
//      let ppuch_dest_buffer = unsafe { &mut *(ppuchDestBuffer as *mut _) };
//      (return_value,ppuchDestBuffer, pulDestBufferSize, pulBytesWritten, lpvReserved)
//  }
#[inline]
pub fn modify_world_transform(hdc: Hdc, lpxf: Option<&Xform>, mode: u32) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    // SAFETY: type is a thin type
    let lpxf = lpxf.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let mode = mode;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ModifyWorldTransform(hdc, lpxf, mode) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn monitor_from_point(pt: Point, dw_flags: u32) -> Result<Hmonitor> {
    let pt = pt.to_win32();
    let dwFlags = dw_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::MonitorFromPoint(pt, dwFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn monitor_from_rect(lprc: &Rect, dw_flags: u32) -> Result<Hmonitor> {
    // SAFETY: type is a thin type
    let lprc = unsafe { &*(lprc as *const _ as *const _) };
    let dwFlags = dw_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::MonitorFromRect(lprc, dwFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn monitor_from_window(hwnd: Hwnd, dw_flags: u32) -> Result<Hmonitor> {
    let hwnd = hwnd.into_raw();
    let dwFlags = dw_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::MonitorFromWindow(hwnd, dwFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn move_to_ex(hdc: Hdc, x: i32, y: i32, ) -> Result<(BOOL, Point)> {
    let mut lppt = mem::MaybeUninit::zeroed();
    let lppt = lppt.as_mut_ptr();
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::MoveToEx(hdc, x, y, lppt) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lppt = unsafe { Point::from_win32(unsafe { lppt.assume_init() }) };
    Ok((return_value,lppt))
}
#[inline]
pub fn offset_clip_rgn(hdc: Hdc, x: i32, y: i32) -> Result<i32> {
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::OffsetClipRgn(hdc, x, y) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn offset_rect(lprc: Rect, dx: i32, dy: i32) -> Result<(BOOL, Rect)> {
    let mut lprc = lprc.to_win32();
    let dx = dx;
    let dy = dy;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::OffsetRect(&mut lprc, dx, dy) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lprc = unsafe { Rect::from_win32(lprc) };
    Ok((return_value,lprc))
}
#[inline]
pub fn offset_rgn(hrgn: Hrgn, x: i32, y: i32) -> Result<i32> {
    let hrgn = hrgn.into_raw();
    let x = x;
    let y = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::OffsetRgn(hrgn, x, y) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn offset_viewport_org_ex(hdc: Hdc, x: i32, y: i32, ) -> Result<(BOOL, Point)> {
    let mut lppt = mem::MaybeUninit::zeroed();
    let lppt = lppt.as_mut_ptr();
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::OffsetViewportOrgEx(hdc, x, y, lppt) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lppt = unsafe { Point::from_win32(unsafe { lppt.assume_init() }) };
    Ok((return_value,lppt))
}
#[inline]
pub fn offset_window_org_ex(hdc: Hdc, x: i32, y: i32, ) -> Result<(BOOL, Point)> {
    let mut lppt = mem::MaybeUninit::zeroed();
    let lppt = lppt.as_mut_ptr();
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::OffsetWindowOrgEx(hdc, x, y, lppt) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lppt = unsafe { Point::from_win32(unsafe { lppt.assume_init() }) };
    Ok((return_value,lppt))
}
#[inline]
pub fn paint_desktop(hdc: Hdc) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PaintDesktop(hdc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn paint_rgn(hdc: Hdc, hrgn: Hrgn) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let hrgn = hrgn.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PaintRgn(hdc, hrgn) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn pat_blt(hdc: Hdc, x: i32, y: i32, w: i32, h: i32, rop: u32) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    let w = w;
    let h = h;
    let rop = rop;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PatBlt(hdc, x, y, w, h, rop) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn pie(hdc: Hdc, left: i32, top: i32, right: i32, bottom: i32, xr1: i32, yr1: i32, xr2: i32, yr2: i32) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let left = left;
    let top = top;
    let right = right;
    let bottom = bottom;
    let xr1 = xr1;
    let yr1 = yr1;
    let xr2 = xr2;
    let yr2 = yr2;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::Pie(hdc, left, top, right, bottom, xr1, yr1, xr2, yr2) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn play_enh_meta_file(hdc: Hdc, hmf: Henhmetafile, lprect: &Rect) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let hmf = hmf.into_raw();
    // SAFETY: type is a thin type
    let lprect = unsafe { &*(lprect as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PlayEnhMetaFile(hdc, hmf, lprect) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn play_enh_meta_file_record(hdc: Hdc, pht: &Handletable, pmr: &[Enhmetarecord], ) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    // SAFETY: type is a thin type
    let pht = unsafe { &*(pht as *const _ as *const _) };
    let pmr = pmr.as_ptr() as _;
    let cht = pmr.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PlayEnhMetaFileRecord(hdc, pht, pmr, cht) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn play_meta_file(hdc: Hdc, hmf: Hmetafile) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let hmf = hmf.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PlayMetaFile(hdc, hmf) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn play_meta_file_record(hdc: Hdc, lp_handle_table: &Handletable, lp_mr: &[Metarecord], ) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    // SAFETY: type is a thin type
    let lpHandleTable = unsafe { &*(lp_handle_table as *const _ as *const _) };
    let lpMR = lp_mr.as_ptr() as _;
    let noObjs = lp_mr.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PlayMetaFileRecord(hdc, lpHandleTable, lpMR, noObjs) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn plg_blt(hdc_dest: Hdc, lp_point: &Point, hdc_src: Hdc, x_src: i32, y_src: i32, width: i32, height: i32, hbm_mask: Option<Hbitmap>, x_mask: i32, y_mask: i32) -> Result<BOOL> {
    let hdcDest = hdc_dest.into_raw();
    // SAFETY: type is a thin type
    let lpPoint = unsafe { &*(lp_point as *const _ as *const _) };
    let hdcSrc = hdc_src.into_raw();
    let xSrc = x_src;
    let ySrc = y_src;
    let width = width;
    let height = height;
    let hbmMask = hbm_mask.map_or(0, Hbitmap::into_raw);
    let xMask = x_mask;
    let yMask = y_mask;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PlgBlt(hdcDest, lpPoint, hdcSrc, xSrc, ySrc, width, height, hbmMask, xMask, yMask) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn poly_bezier(hdc: Hdc, apt: &[Point], ) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let apt = apt.as_ptr() as _;
    let cpt = apt.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PolyBezier(hdc, apt, cpt) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn poly_bezier_to(hdc: Hdc, apt: &[Point], ) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let apt = apt.as_ptr() as _;
    let cpt = apt.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PolyBezierTo(hdc, apt, cpt) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn poly_draw(hdc: Hdc, apt: &Point, aj: &[u8], ) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    // SAFETY: type is a thin type
    let apt = unsafe { &*(apt as *const _ as *const _) };
    let aj = aj.as_ptr() as _;
    let cpt = aj.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PolyDraw(hdc, apt, aj, cpt) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn poly_polygon(hdc: Hdc, apt: &Point, asz: &[i32], ) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    // SAFETY: type is a thin type
    let apt = unsafe { &*(apt as *const _ as *const _) };
    let asz = asz.as_ptr() as _;
    let csz = asz.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PolyPolygon(hdc, apt, asz, csz) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn poly_polyline(hdc: Hdc, apt: &Point, asz: &[u32], ) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    // SAFETY: type is a thin type
    let apt = unsafe { &*(apt as *const _ as *const _) };
    let asz = asz.as_ptr() as _;
    let csz = asz.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PolyPolyline(hdc, apt, asz, csz) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn poly_text_out_a(hdc: Hdc, ppt: &[Polytexta<'_>], ) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let ppt = ppt.as_ptr() as _;
    let nstrings = ppt.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PolyTextOutA(hdc, ppt, nstrings) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn poly_text_out_w(hdc: Hdc, ppt: &[Polytextw<'_>], ) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let ppt = ppt.as_ptr() as _;
    let nstrings = ppt.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PolyTextOutW(hdc, ppt, nstrings) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn polygon(hdc: Hdc, apt: &[Point], ) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let apt = apt.as_ptr() as _;
    let cpt = apt.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::Polygon(hdc, apt, cpt) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn polyline(hdc: Hdc, apt: &[Point], ) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let apt = apt.as_ptr() as _;
    let cpt = apt.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::Polyline(hdc, apt, cpt) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn polyline_to(hdc: Hdc, apt: &[Point], ) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let apt = apt.as_ptr() as _;
    let cpt = apt.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PolylineTo(hdc, apt, cpt) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn pt_in_rect(lprc: &Rect, pt: Point) -> BOOL {
    // SAFETY: type is a thin type
    let lprc = unsafe { &*(lprc as *const _ as *const _) };
    let pt = pt.to_win32();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PtInRect(lprc, pt) };
    return_value
}
#[inline]
pub fn pt_in_region(hrgn: Hrgn, x: i32, y: i32) -> BOOL {
    let hrgn = hrgn.into_raw();
    let x = x;
    let y = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PtInRegion(hrgn, x, y) };
    return_value
}
#[inline]
pub fn pt_visible(hdc: Hdc, x: i32, y: i32) -> BOOL {
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PtVisible(hdc, x, y) };
    return_value
}
#[inline]
pub fn realize_palette(hdc: Hdc) -> u32 {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::RealizePalette(hdc) };
    return_value
}
#[inline]
pub fn rect_in_region(hrgn: Hrgn, lprect: &Rect) -> BOOL {
    let hrgn = hrgn.into_raw();
    // SAFETY: type is a thin type
    let lprect = unsafe { &*(lprect as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::RectInRegion(hrgn, lprect) };
    return_value
}
#[inline]
pub fn rect_visible(hdc: Hdc, lprect: &Rect) -> BOOL {
    let hdc = hdc.into_raw();
    // SAFETY: type is a thin type
    let lprect = unsafe { &*(lprect as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::RectVisible(hdc, lprect) };
    return_value
}
#[inline]
pub fn rectangle(hdc: Hdc, left: i32, top: i32, right: i32, bottom: i32) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let left = left;
    let top = top;
    let right = right;
    let bottom = bottom;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::Rectangle(hdc, left, top, right, bottom) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn redraw_window(h_wnd: Option<Hwnd>, lprc_update: Option<&Rect>, hrgn_update: Option<Hrgn>, flags: u32) -> Result<BOOL> {
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    // SAFETY: type is a thin type
    let lprcUpdate = lprc_update.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let hrgnUpdate = hrgn_update.map_or(0, Hrgn::into_raw);
    let flags = flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::RedrawWindow(hWnd, lprcUpdate, hrgnUpdate, flags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn release_dc(h_wnd: Option<Hwnd>, h_dc: Hdc) -> Result<i32> {
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let hDC = h_dc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ReleaseDC(hWnd, hDC) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn remove_font_mem_resource_ex(h: Handle) -> Result<BOOL> {
    let h = h.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::RemoveFontMemResourceEx(h) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn remove_font_resource_a(lp_file_name: &CStr) -> Result<BOOL> {
    let lpFileName = lp_file_name.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::RemoveFontResourceA(lpFileName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn remove_font_resource_ex_a(name: &CStr, fl: u32, pdv: todo_void) -> Result<(BOOL, todo_void_ret)> {
//      let name = name.as_ptr() as _;
//      let fl = fl;
//      let mut pdv = todo_void;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::RemoveFontResourceExA(name, fl, &mut pdv) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let pdv = todo_void;
//      Ok((return_value,pdv))
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn remove_font_resource_ex_w(name: &OsStr, fl: u32, pdv: todo_void) -> Result<(BOOL, todo_void_ret)> {
//      let mut temp45: Vec<u16> = name.encode_wide().collect();
//      temp45.push(0);
//      let name = temp45.as_ptr() as _;
//      let fl = fl;
//      let mut pdv = todo_void;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::RemoveFontResourceExW(name, fl, &mut pdv) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let pdv = todo_void;
//      Ok((return_value,pdv))
//  }
#[inline]
pub fn remove_font_resource_w(lp_file_name: &OsStr) -> Result<BOOL> {
    let mut temp46: Vec<u16> = lp_file_name.encode_wide().collect();
    temp46.push(0);
    let lpFileName = temp46.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::RemoveFontResourceW(lpFileName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn reset_dca(hdc: Hdc, lpdm: &Devmodea) -> Result<Hdc> {
    let hdc = hdc.into_raw();
    // SAFETY: type is a thin type
    let lpdm = unsafe { &*(lpdm as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ResetDCA(hdc, lpdm) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn reset_dcw(hdc: Hdc, lpdm: &Devmodew) -> Result<Hdc> {
    let hdc = hdc.into_raw();
    // SAFETY: type is a thin type
    let lpdm = unsafe { &*(lpdm as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ResetDCW(hdc, lpdm) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn resize_palette(hpal: Hpalette, n: u32) -> Result<BOOL> {
    let hpal = hpal.into_raw();
    let n = n;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ResizePalette(hpal, n) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn restore_dc(hdc: Hdc, n_saved_dc: i32) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let nSavedDC = n_saved_dc;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::RestoreDC(hdc, nSavedDC) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn round_rect(hdc: Hdc, left: i32, top: i32, right: i32, bottom: i32, width: i32, height: i32) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let left = left;
    let top = top;
    let right = right;
    let bottom = bottom;
    let width = width;
    let height = height;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::RoundRect(hdc, left, top, right, bottom, width, height) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn save_dc(hdc: Hdc) -> Result<i32> {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SaveDC(hdc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn scale_viewport_ext_ex(hdc: Hdc, xn: i32, dx: i32, yn: i32, yd: i32, ) -> Result<(BOOL, Size)> {
    let mut lpsz = mem::MaybeUninit::zeroed();
    let lpsz = lpsz.as_mut_ptr();
    let hdc = hdc.into_raw();
    let xn = xn;
    let dx = dx;
    let yn = yn;
    let yd = yd;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ScaleViewportExtEx(hdc, xn, dx, yn, yd, lpsz) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpsz = unsafe { Size::from_win32(unsafe { lpsz.assume_init() }) };
    Ok((return_value,lpsz))
}
#[inline]
pub fn scale_window_ext_ex(hdc: Hdc, xn: i32, xd: i32, yn: i32, yd: i32, ) -> Result<(BOOL, Size)> {
    let mut lpsz = mem::MaybeUninit::zeroed();
    let lpsz = lpsz.as_mut_ptr();
    let hdc = hdc.into_raw();
    let xn = xn;
    let xd = xd;
    let yn = yn;
    let yd = yd;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ScaleWindowExtEx(hdc, xn, xd, yn, yd, lpsz) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpsz = unsafe { Size::from_win32(unsafe { lpsz.assume_init() }) };
    Ok((return_value,lpsz))
}
#[inline]
pub fn screen_to_client(h_wnd: Hwnd, lp_point: Point) -> Result<(BOOL, Point)> {
    let hWnd = h_wnd.into_raw();
    let mut lpPoint = lp_point.to_win32();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ScreenToClient(hWnd, &mut lpPoint) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_point = unsafe { Point::from_win32(lpPoint) };
    Ok((return_value,lpPoint))
}
#[inline]
pub fn select_clip_path(hdc: Hdc, mode: i32) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let mode = mode;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SelectClipPath(hdc, mode) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn select_clip_rgn(hdc: Hdc, hrgn: Option<Hrgn>) -> Result<i32> {
    let hdc = hdc.into_raw();
    let hrgn = hrgn.map_or(0, Hrgn::into_raw);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SelectClipRgn(hdc, hrgn) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn select_object(hdc: Hdc, h: Hgdiobj) -> Result<Hgdiobj> {
    let hdc = hdc.into_raw();
    let h = h.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SelectObject(hdc, h) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn select_palette(hdc: Hdc, h_pal: Hpalette, b_force_bkgd: BOOL) -> Result<Hpalette> {
    let hdc = hdc.into_raw();
    let hPal = h_pal.into_raw();
    let bForceBkgd = b_force_bkgd;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SelectPalette(hdc, hPal, bForceBkgd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_arc_direction(hdc: Hdc, dir: u32) -> Result<i32> {
    let hdc = hdc.into_raw();
    let dir = dir;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetArcDirection(hdc, dir) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn set_bitmap_bits(hbm: Hbitmap, pv_bits: &[todo_void]) -> Result<i32> {
//      let hbm = hbm.into_raw();
//      let pvBits = pv_bits.as_ptr() as _;
//      let cb = pv_bits.len() as _;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetBitmapBits(hbm, cb, pvBits) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
#[inline]
pub fn set_bitmap_dimension_ex(hbm: Hbitmap, w: i32, h: i32, ) -> Result<(BOOL, Size)> {
    let mut lpsz = mem::MaybeUninit::zeroed();
    let lpsz = lpsz.as_mut_ptr();
    let hbm = hbm.into_raw();
    let w = w;
    let h = h;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetBitmapDimensionEx(hbm, w, h, lpsz) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpsz = unsafe { Size::from_win32(unsafe { lpsz.assume_init() }) };
    Ok((return_value,lpsz))
}
#[inline]
pub fn set_bk_color(hdc: Hdc, color: u32) -> u32 {
    let hdc = hdc.into_raw();
    let color = color;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetBkColor(hdc, color) };
    return_value
}
#[inline]
pub fn set_bk_mode(hdc: Hdc, mode: u32) -> Result<i32> {
    let hdc = hdc.into_raw();
    let mode = mode;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetBkMode(hdc, mode) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_bounds_rect(hdc: Hdc, lprect: Option<&Rect>, flags: u32) -> u32 {
    let hdc = hdc.into_raw();
    // SAFETY: type is a thin type
    let lprect = lprect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let flags = flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetBoundsRect(hdc, lprect, flags) };
    return_value
}
#[inline]
pub fn set_brush_org_ex(hdc: Hdc, x: i32, y: i32, ) -> Result<(BOOL, Point)> {
    let mut lppt = mem::MaybeUninit::zeroed();
    let lppt = lppt.as_mut_ptr();
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetBrushOrgEx(hdc, x, y, lppt) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lppt = unsafe { Point::from_win32(unsafe { lppt.assume_init() }) };
    Ok((return_value,lppt))
}
#[inline]
pub fn set_color_adjustment(hdc: Hdc, lpca: &Coloradjustment) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let temp47 = lpca.to_win32();
    let lpca = &temp47;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetColorAdjustment(hdc, lpca) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_dc_brush_color(hdc: Hdc, color: u32) -> u32 {
    let hdc = hdc.into_raw();
    let color = color;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetDCBrushColor(hdc, color) };
    return_value
}
#[inline]
pub fn set_dc_pen_color(hdc: Hdc, color: u32) -> u32 {
    let hdc = hdc.into_raw();
    let color = color;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetDCPenColor(hdc, color) };
    return_value
}
#[inline]
pub fn set_dib_color_table(hdc: Hdc, i_start: u32, prgbq: &[Rgbquad]) -> u32 {
    let hdc = hdc.into_raw();
    let iStart = i_start;
    let prgbq = prgbq.as_ptr() as _;
    let cEntries = prgbq.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetDIBColorTable(hdc, iStart, cEntries, prgbq) };
    return_value
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn set_di_bits(hdc: Option<Hdc>, hbm: Hbitmap, start: u32, lp_bits: &todo_void, lpbmi: &[Bitmapinfo], color_use: u32) -> Result<i32> {
//      let hdc = hdc.map_or(0, Hdc::into_raw);
//      let hbm = hbm.into_raw();
//      let start = start;
//      // SAFETY: type is a thin type
//      let lpBits = unsafe { &*(lp_bits as *const _ as *const _) };
//      let lpbmi = lpbmi.as_ptr() as _;
//      let cLines = lpbmi.len() as _;
//      let ColorUse = color_use;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetDIBits(hdc, hbm, start, cLines, lpBits, lpbmi, ColorUse) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn set_di_bits_to_device(hdc: Hdc, x_dest: i32, y_dest: i32, w: u32, h: u32, x_src: i32, y_src: i32, start_scan: u32, lpv_bits: &todo_void, lpbmi: &[Bitmapinfo], color_use: u32) -> Result<i32> {
//      let hdc = hdc.into_raw();
//      let xDest = x_dest;
//      let yDest = y_dest;
//      let w = w;
//      let h = h;
//      let xSrc = x_src;
//      let ySrc = y_src;
//      let StartScan = start_scan;
//      // SAFETY: type is a thin type
//      let lpvBits = unsafe { &*(lpv_bits as *const _ as *const _) };
//      let lpbmi = lpbmi.as_ptr() as _;
//      let cLines = lpbmi.len() as _;
//      let ColorUse = color_use;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetDIBitsToDevice(hdc, xDest, yDest, w, h, xSrc, ySrc, StartScan, cLines, lpvBits, lpbmi, ColorUse) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
#[inline]
pub fn set_enh_meta_file_bits(pb: &[u8]) -> Result<Henhmetafile> {
    let pb = pb.as_ptr() as _;
    let nSize = pb.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetEnhMetaFileBits(nSize, pb) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_graphics_mode(hdc: Hdc, i_mode: u32) -> Result<i32> {
    let hdc = hdc.into_raw();
    let iMode = i_mode;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetGraphicsMode(hdc, iMode) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_layout(hdc: Hdc, l: u32) -> u32 {
    let hdc = hdc.into_raw();
    let l = l;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetLayout(hdc, l) };
    return_value
}
#[inline]
pub fn set_map_mode(hdc: Hdc, i_mode: u32) -> Result<i32> {
    let hdc = hdc.into_raw();
    let iMode = i_mode;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetMapMode(hdc, iMode) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_mapper_flags(hdc: Hdc, flags: u32) -> u32 {
    let hdc = hdc.into_raw();
    let flags = flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetMapperFlags(hdc, flags) };
    return_value
}
#[inline]
pub fn set_meta_file_bits_ex(lp_data: &[u8]) -> Result<Hmetafile> {
    let lpData = lp_data.as_ptr() as _;
    let cbBuffer = lp_data.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetMetaFileBitsEx(cbBuffer, lpData) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_meta_rgn(hdc: Hdc) -> Result<i32> {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetMetaRgn(hdc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_miter_limit(hdc: Hdc, limit: f32, ) -> Result<(BOOL, f32)> {
    let mut old = mem::MaybeUninit::zeroed();
    let old = old.as_mut_ptr();
    let hdc = hdc.into_raw();
    let limit = limit;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetMiterLimit(hdc, limit, old) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let old = unsafe { old.assume_init() };
    Ok((return_value,old))
}
#[inline]
pub fn set_palette_entries(hpal: Hpalette, i_start: u32, p_pal_entries: &[Paletteentry]) -> u32 {
    let hpal = hpal.into_raw();
    let iStart = i_start;
    let pPalEntries = p_pal_entries.as_ptr() as _;
    let cEntries = p_pal_entries.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetPaletteEntries(hpal, iStart, cEntries, pPalEntries) };
    return_value
}
#[inline]
pub fn set_pixel(hdc: Hdc, x: i32, y: i32, color: u32) -> u32 {
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    let color = color;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetPixel(hdc, x, y, color) };
    return_value
}
#[inline]
pub fn set_pixel_v(hdc: Hdc, x: i32, y: i32, color: u32) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    let color = color;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetPixelV(hdc, x, y, color) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_poly_fill_mode(hdc: Hdc, mode: u32) -> Result<i32> {
    let hdc = hdc.into_raw();
    let mode = mode;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetPolyFillMode(hdc, mode) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_rop2(hdc: Hdc, rop2: i32) -> Result<i32> {
    let hdc = hdc.into_raw();
    let rop2 = rop2;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetROP2(hdc, rop2) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_rect(x_left: i32, y_top: i32, x_right: i32, y_bottom: i32) -> Result<(BOOL, Rect)> {
    let mut lprc = mem::MaybeUninit::zeroed();
    let lprc = lprc.as_mut_ptr();
    let xLeft = x_left;
    let yTop = y_top;
    let xRight = x_right;
    let yBottom = y_bottom;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetRect(lprc, xLeft, yTop, xRight, yBottom) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lprc = unsafe { Rect::from_win32(unsafe { lprc.assume_init() }) };
    Ok((return_value,lprc))
}
#[inline]
pub fn set_rect_empty() -> Result<(BOOL, Rect)> {
    let mut lprc = mem::MaybeUninit::zeroed();
    let lprc = lprc.as_mut_ptr();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetRectEmpty(lprc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lprc = unsafe { Rect::from_win32(unsafe { lprc.assume_init() }) };
    Ok((return_value,lprc))
}
#[inline]
pub fn set_rect_rgn(hrgn: Hrgn, left: i32, top: i32, right: i32, bottom: i32) -> Result<BOOL> {
    let hrgn = hrgn.into_raw();
    let left = left;
    let top = top;
    let right = right;
    let bottom = bottom;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetRectRgn(hrgn, left, top, right, bottom) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_stretch_blt_mode(hdc: Hdc, mode: u32) -> Result<i32> {
    let hdc = hdc.into_raw();
    let mode = mode;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetStretchBltMode(hdc, mode) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_system_palette_use(hdc: Hdc, r#use: u32) -> u32 {
    let hdc = hdc.into_raw();
    let r#use = r#use;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetSystemPaletteUse(hdc, r#use) };
    return_value
}
#[inline]
pub fn set_text_align(hdc: Hdc, align: u32) -> u32 {
    let hdc = hdc.into_raw();
    let align = align;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetTextAlign(hdc, align) };
    return_value
}
#[inline]
pub fn set_text_color(hdc: Hdc, color: u32) -> u32 {
    let hdc = hdc.into_raw();
    let color = color;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetTextColor(hdc, color) };
    return_value
}
#[inline]
pub fn set_text_justification(hdc: Hdc, extra: i32, count: i32) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let extra = extra;
    let count = count;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetTextJustification(hdc, extra, count) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_viewport_ext_ex(hdc: Hdc, x: i32, y: i32, ) -> Result<(BOOL, Size)> {
    let mut lpsz = mem::MaybeUninit::zeroed();
    let lpsz = lpsz.as_mut_ptr();
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetViewportExtEx(hdc, x, y, lpsz) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpsz = unsafe { Size::from_win32(unsafe { lpsz.assume_init() }) };
    Ok((return_value,lpsz))
}
#[inline]
pub fn set_viewport_org_ex(hdc: Hdc, x: i32, y: i32, ) -> Result<(BOOL, Point)> {
    let mut lppt = mem::MaybeUninit::zeroed();
    let lppt = lppt.as_mut_ptr();
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetViewportOrgEx(hdc, x, y, lppt) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lppt = unsafe { Point::from_win32(unsafe { lppt.assume_init() }) };
    Ok((return_value,lppt))
}
#[inline]
pub fn set_window_ext_ex(hdc: Hdc, x: i32, y: i32, ) -> Result<(BOOL, Size)> {
    let mut lpsz = mem::MaybeUninit::zeroed();
    let lpsz = lpsz.as_mut_ptr();
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetWindowExtEx(hdc, x, y, lpsz) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpsz = unsafe { Size::from_win32(unsafe { lpsz.assume_init() }) };
    Ok((return_value,lpsz))
}
#[inline]
pub fn set_window_org_ex(hdc: Hdc, x: i32, y: i32, ) -> Result<(BOOL, Point)> {
    let mut lppt = mem::MaybeUninit::zeroed();
    let lppt = lppt.as_mut_ptr();
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetWindowOrgEx(hdc, x, y, lppt) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lppt = unsafe { Point::from_win32(unsafe { lppt.assume_init() }) };
    Ok((return_value,lppt))
}
#[inline]
pub fn set_window_rgn(h_wnd: Hwnd, h_rgn: Option<Hrgn>, b_redraw: BOOL) -> Result<i32> {
    let hWnd = h_wnd.into_raw();
    let hRgn = h_rgn.map_or(0, Hrgn::into_raw);
    let bRedraw = b_redraw;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetWindowRgn(hWnd, hRgn, bRedraw) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_world_transform(hdc: Hdc, lpxf: &Xform) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    // SAFETY: type is a thin type
    let lpxf = unsafe { &*(lpxf as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetWorldTransform(hdc, lpxf) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn subtract_rect(lprc_src1: &Rect, lprc_src2: &Rect) -> Result<(BOOL, Rect)> {
    let mut lprc_dst = mem::MaybeUninit::zeroed();
    let lprcDst = lprc_dst.as_mut_ptr();
    // SAFETY: type is a thin type
    let lprcSrc1 = unsafe { &*(lprc_src1 as *const _ as *const _) };
    // SAFETY: type is a thin type
    let lprcSrc2 = unsafe { &*(lprc_src2 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SubtractRect(lprcDst, lprcSrc1, lprcSrc2) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lprc_dst = unsafe { Rect::from_win32(unsafe { lprcDst.assume_init() }) };
    Ok((return_value,lprcDst))
}
#[inline]
pub fn tt_delete_embedded_font(h_font_reference: Handle, ul_flags: u32, ) -> Result<(i32, u32)> {
    let mut pul_status = mem::MaybeUninit::zeroed();
    let pulStatus = pul_status.as_mut_ptr();
    let hFontReference = h_font_reference.into_raw();
    let ulFlags = ul_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTDeleteEmbeddedFont(hFontReference, ulFlags, pulStatus) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pul_status = unsafe { pulStatus.assume_init() };
    Ok((return_value,pulStatus))
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn tt_embed_font<Writeembedproc: FnMut(&mut todo_void, u32) -> u32>(h_dc: Hdc, ul_flags: u32, ul_char_set: u32, lpfn_write_to_stream: Writeembedproc, pus_char_code_set: &u16, us_char_code_count: u16, us_language: u16, p_tt_embed_info: Option<&Ttembedinfo<'_>>) -> Result<(i32, u32, u32)> {
//      let mut pul_priv_status = mem::MaybeUninit::zeroed();
//      let pulPrivStatus = pul_priv_status.as_mut_ptr();
//      let mut pul_status = mem::MaybeUninit::zeroed();
//      let pulStatus = pul_status.as_mut_ptr();
//      let hDC = h_dc.into_raw();
//      let ulFlags = ul_flags;
//      let ulCharSet = ul_char_set;
//      unsafe extern "system" fn writeembedproc_impl(param0: *mut c_void, param1: *const c_void, param2: u32) -> u32 {
//          abort_on_panic(move || {
//              let input0 = unsafe { &mut *(param0 as *mut _) };
//              let input2 = param2;
//              let closure = unsafe {
//                  &mut *(param1 as usize as *mut Writeembedproc)
//              };
//              let return_value = closure(input0, input2);
//              let real_return_value = return_value;
//              real_return_value
//          })
//      }
//      let lpfnWriteToStream = Some(writeembedproc_impl);
//      let mut lpfn_write_to_stream = lpfn_write_to_stream;
//      let lpvWriteStream = (&mut lpfn_write_to_stream) as *mut _ as *mut _;
//      // SAFETY: type is a thin type
//      let pusCharCodeSet = unsafe { &*(pus_char_code_set as *const _ as *const _) };
//      let usCharCodeCount = us_char_code_count;
//      let usLanguage = us_language;
//      let temp48 = p_tt_embed_info.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
//      let pTTEmbedInfo = temp48.as_ref();
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTEmbedFont(hDC, ulFlags, ulCharSet, pulPrivStatus, pulStatus, lpfnWriteToStream, lpvWriteStream, pusCharCodeSet, usCharCodeCount, usLanguage, pTTEmbedInfo) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let pul_status = unsafe { pulStatus.assume_init() };
//      let pul_priv_status = unsafe { pulPrivStatus.assume_init() };
//      Ok((return_value,pulPrivStatus, pulStatus))
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn tt_embed_font_ex<Writeembedproc: FnMut(&mut todo_void, u32) -> u32>(h_dc: Hdc, ul_flags: u32, ul_char_set: u32, lpfn_write_to_stream: Writeembedproc, pul_char_code_set: &u32, us_char_code_count: u16, us_language: u16, p_tt_embed_info: Option<&Ttembedinfo<'_>>) -> Result<(i32, u32, u32)> {
//      let mut pul_priv_status = mem::MaybeUninit::zeroed();
//      let pulPrivStatus = pul_priv_status.as_mut_ptr();
//      let mut pul_status = mem::MaybeUninit::zeroed();
//      let pulStatus = pul_status.as_mut_ptr();
//      let hDC = h_dc.into_raw();
//      let ulFlags = ul_flags;
//      let ulCharSet = ul_char_set;
//      unsafe extern "system" fn writeembedproc_impl(param0: *mut c_void, param1: *const c_void, param2: u32) -> u32 {
//          abort_on_panic(move || {
//              let input0 = unsafe { &mut *(param0 as *mut _) };
//              let input2 = param2;
//              let closure = unsafe {
//                  &mut *(param1 as usize as *mut Writeembedproc)
//              };
//              let return_value = closure(input0, input2);
//              let real_return_value = return_value;
//              real_return_value
//          })
//      }
//      let lpfnWriteToStream = Some(writeembedproc_impl);
//      let mut lpfn_write_to_stream = lpfn_write_to_stream;
//      let lpvWriteStream = (&mut lpfn_write_to_stream) as *mut _ as *mut _;
//      // SAFETY: type is a thin type
//      let pulCharCodeSet = unsafe { &*(pul_char_code_set as *const _ as *const _) };
//      let usCharCodeCount = us_char_code_count;
//      let usLanguage = us_language;
//      let temp49 = p_tt_embed_info.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
//      let pTTEmbedInfo = temp49.as_ref();
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTEmbedFontEx(hDC, ulFlags, ulCharSet, pulPrivStatus, pulStatus, lpfnWriteToStream, lpvWriteStream, pulCharCodeSet, usCharCodeCount, usLanguage, pTTEmbedInfo) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let pul_status = unsafe { pulStatus.assume_init() };
//      let pul_priv_status = unsafe { pulPrivStatus.assume_init() };
//      Ok((return_value,pulPrivStatus, pulStatus))
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn tt_embed_font_from_file_a<Writeembedproc: FnMut(&mut todo_void, u32) -> u32>(h_dc: Hdc, sz_font_file_name: &CStr, us_ttc_index: u16, ul_flags: u32, ul_char_set: u32, lpfn_write_to_stream: Writeembedproc, pus_char_code_set: &u16, us_char_code_count: u16, us_language: u16, p_tt_embed_info: Option<&Ttembedinfo<'_>>) -> Result<(i32, u32, u32)> {
//      let mut pul_priv_status = mem::MaybeUninit::zeroed();
//      let pulPrivStatus = pul_priv_status.as_mut_ptr();
//      let mut pul_status = mem::MaybeUninit::zeroed();
//      let pulStatus = pul_status.as_mut_ptr();
//      let hDC = h_dc.into_raw();
//      let szFontFileName = sz_font_file_name.as_ptr() as _;
//      let usTTCIndex = us_ttc_index;
//      let ulFlags = ul_flags;
//      let ulCharSet = ul_char_set;
//      unsafe extern "system" fn writeembedproc_impl(param0: *mut c_void, param1: *const c_void, param2: u32) -> u32 {
//          abort_on_panic(move || {
//              let input0 = unsafe { &mut *(param0 as *mut _) };
//              let input2 = param2;
//              let closure = unsafe {
//                  &mut *(param1 as usize as *mut Writeembedproc)
//              };
//              let return_value = closure(input0, input2);
//              let real_return_value = return_value;
//              real_return_value
//          })
//      }
//      let lpfnWriteToStream = Some(writeembedproc_impl);
//      let mut lpfn_write_to_stream = lpfn_write_to_stream;
//      let lpvWriteStream = (&mut lpfn_write_to_stream) as *mut _ as *mut _;
//      // SAFETY: type is a thin type
//      let pusCharCodeSet = unsafe { &*(pus_char_code_set as *const _ as *const _) };
//      let usCharCodeCount = us_char_code_count;
//      let usLanguage = us_language;
//      let temp50 = p_tt_embed_info.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
//      let pTTEmbedInfo = temp50.as_ref();
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTEmbedFontFromFileA(hDC, szFontFileName, usTTCIndex, ulFlags, ulCharSet, pulPrivStatus, pulStatus, lpfnWriteToStream, lpvWriteStream, pusCharCodeSet, usCharCodeCount, usLanguage, pTTEmbedInfo) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let pul_status = unsafe { pulStatus.assume_init() };
//      let pul_priv_status = unsafe { pulPrivStatus.assume_init() };
//      Ok((return_value,pulPrivStatus, pulStatus))
//  }
#[inline]
pub fn tt_enable_embedding_for_facename(lpsz_facename: &CStr, b_enable: BOOL) -> Result<i32> {
    let lpszFacename = lpsz_facename.as_ptr() as _;
    let bEnable = b_enable;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTEnableEmbeddingForFacename(lpszFacename, bEnable) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn tt_get_embedded_font_info(ul_flags: u32, ul_privs: u32, lpfn_read_from_stream: Option<unsafe extern "system" fn(*mut c_void, *mut c_void, u32) -> u32>, lpv_read_stream: &todo_void, p_tt_load_info: Option<&Ttloadinfo<'_>>) -> Result<(i32, u32, u32)> {
//      let mut pul_priv_status = mem::MaybeUninit::zeroed();
//      let pulPrivStatus = pul_priv_status.as_mut_ptr();
//      let mut pul_status = mem::MaybeUninit::zeroed();
//      let pulStatus = pul_status.as_mut_ptr();
//      let ulFlags = ul_flags;
//      let ulPrivs = ul_privs;
//      let lpfnReadFromStream = lpfn_read_from_stream;
//      // SAFETY: type is a thin type
//      let lpvReadStream = unsafe { &*(lpv_read_stream as *const _ as *const _) };
//      let temp51 = p_tt_load_info.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
//      let pTTLoadInfo = temp51.as_ref();
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTGetEmbeddedFontInfo(ulFlags, pulPrivStatus, ulPrivs, pulStatus, lpfnReadFromStream, lpvReadStream, pTTLoadInfo) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let pul_status = unsafe { pulStatus.assume_init() };
//      let pul_priv_status = unsafe { pulPrivStatus.assume_init() };
//      Ok((return_value,pulPrivStatus, pulStatus))
//  }
#[inline]
pub fn tt_get_embedding_type(h_dc: Hdc, ) -> Result<(i32, u32)> {
    let mut pul_embed_type = mem::MaybeUninit::zeroed();
    let pulEmbedType = pul_embed_type.as_mut_ptr();
    let hDC = h_dc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTGetEmbeddingType(hDC, pulEmbedType) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pul_embed_type = unsafe { pulEmbedType.assume_init() };
    Ok((return_value,pulEmbedType))
}
#[inline]
pub fn tt_get_new_font_name(ph_font_reference: &[Handle], cch_max_win_name: i32, ) -> Result<(i32, OsString, CString)> {
    let mut wz_win_family_name = Vec::<u16>::with_capacity(cch_max_mac_name as usize + 1);
    let wzWinFamilyName = wz_win_family_name.as_mut_ptr();
    let mut sz_mac_family_name = Vec::<u8>::with_capacity(cch_max_mac_name as usize + 1);
    let szMacFamilyName = sz_mac_family_name.as_mut_ptr();
    let phFontReference = ph_font_reference.as_ptr() as _;
    let cchMaxMacName = ph_font_reference.len() as _;
    let cchMaxWinName = cch_max_win_name;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTGetNewFontName(phFontReference, wzWinFamilyName, cchMaxWinName, szMacFamilyName, cchMaxMacName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let out6 = unsafe {
        slice::from_raw_parts(unsafe { szMacFamilyName.assume_init() }, return_value as usize)
    };
    let mut out6 = out6.to_vec();
    out6.push(0);
    let sz_mac_family_name = unsafe { CString::from_vec_unchecked(out6) };
    let out7 = unsafe {
        slice::from_raw_parts(unsafe { wzWinFamilyName.assume_init() }, return_value as usize)
    };
    let out7 = out7.to_vec();
    let wz_win_family_name = OsStringExt::from_wide(out7);
    Ok((return_value,wzWinFamilyName, szMacFamilyName))
}
#[inline]
pub fn tt_is_embedding_enabled(h_dc: Hdc, ) -> Result<(i32, BOOL)> {
    let mut pb_enabled = mem::MaybeUninit::zeroed();
    let pbEnabled = pb_enabled.as_mut_ptr();
    let hDC = h_dc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTIsEmbeddingEnabled(hDC, pbEnabled) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pb_enabled = unsafe { pbEnabled.assume_init() };
    Ok((return_value,pbEnabled))
}
#[inline]
pub fn tt_is_embedding_enabled_for_facename(lpsz_facename: &CStr, ) -> Result<(i32, BOOL)> {
    let mut pb_enabled = mem::MaybeUninit::zeroed();
    let pbEnabled = pb_enabled.as_mut_ptr();
    let lpszFacename = lpsz_facename.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTIsEmbeddingEnabledForFacename(lpszFacename, pbEnabled) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pb_enabled = unsafe { pbEnabled.assume_init() };
    Ok((return_value,pbEnabled))
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn tt_load_embedded_font(ul_flags: u32, ul_privs: u32, lpfn_read_from_stream: Option<unsafe extern "system" fn(*mut c_void, *mut c_void, u32) -> u32>, lpv_read_stream: &todo_void, sz_win_family_name: Option<&OsStr>, sz_mac_family_name: Option<&CStr>, p_tt_load_info: Option<&Ttloadinfo<'_>>) -> Result<(i32, Handle, u32, u32)> {
//      let mut ph_font_reference = mem::MaybeUninit::zeroed();
//      let phFontReference = ph_font_reference.as_mut_ptr();
//      let mut pul_priv_status = mem::MaybeUninit::zeroed();
//      let pulPrivStatus = pul_priv_status.as_mut_ptr();
//      let mut pul_status = mem::MaybeUninit::zeroed();
//      let pulStatus = pul_status.as_mut_ptr();
//      let ulFlags = ul_flags;
//      let ulPrivs = ul_privs;
//      let lpfnReadFromStream = lpfn_read_from_stream;
//      // SAFETY: type is a thin type
//      let lpvReadStream = unsafe { &*(lpv_read_stream as *const _ as *const _) };
//      let temp52 = sz_win_family_name.map(|val| {
//          let mut temp52: Vec<u16> = val.encode_wide().collect();
//          temp52.push(0);
//          temp52
//      });
//      let szWinFamilyName = temp52.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let szMacFamilyName = sz_mac_family_name.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let temp53 = p_tt_load_info.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
//      let pTTLoadInfo = temp53.as_ref();
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTLoadEmbeddedFont(phFontReference, ulFlags, pulPrivStatus, ulPrivs, pulStatus, lpfnReadFromStream, lpvReadStream, szWinFamilyName, szMacFamilyName, pTTLoadInfo) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let pul_status = unsafe { pulStatus.assume_init() };
//      let pul_priv_status = unsafe { pulPrivStatus.assume_init() };
//      let ph_font_reference = unsafe { Handle::new(unsafe { phFontReference.assume_init() }) };
//      Ok((return_value,phFontReference, pulPrivStatus, pulStatus))
//  }
#[inline]
pub fn tt_run_validation_tests(h_dc: Hdc, p_test_param: &Ttvalidationtestsparams<'_>) -> Result<i32> {
    let hDC = h_dc.into_raw();
    let temp54 = p_test_param.to_win32();
    let pTestParam = &temp54;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTRunValidationTests(hDC, pTestParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn tt_run_validation_tests_ex(h_dc: Hdc, p_test_param: &Ttvalidationtestsparamsex<'_>) -> Result<i32> {
    let hDC = h_dc.into_raw();
    let temp55 = p_test_param.to_win32();
    let pTestParam = &temp55;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTRunValidationTestsEx(hDC, pTestParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn tabbed_text_out_a(hdc: Hdc, x: i32, y: i32, lp_string: &CStr, ch_count: i32, n_tab_positions: i32, lpn_tab_stop_positions: Option<&[i32]>, ) -> Result<i32> {
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    let lpString = lp_string.as_ptr() as _;
    let chCount = ch_count;
    let nTabPositions = n_tab_positions;
    let lpnTabStopPositions = lpn_tab_stop_positions.map_or(ptr::null(), |v| v.as_ptr() as _);
    let nTabOrigin = lpn_tab_stop_positions.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TabbedTextOutA(hdc, x, y, lpString, chCount, nTabPositions, lpnTabStopPositions, nTabOrigin) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn tabbed_text_out_w(hdc: Hdc, x: i32, y: i32, lp_string: &OsStr, ch_count: i32, n_tab_positions: i32, lpn_tab_stop_positions: Option<&[i32]>, ) -> Result<i32> {
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    let mut temp56: Vec<u16> = lp_string.encode_wide().collect();
    temp56.push(0);
    let lpString = temp56.as_ptr() as _;
    let chCount = ch_count;
    let nTabPositions = n_tab_positions;
    let lpnTabStopPositions = lpn_tab_stop_positions.map_or(ptr::null(), |v| v.as_ptr() as _);
    let nTabOrigin = lpn_tab_stop_positions.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TabbedTextOutW(hdc, x, y, lpString, chCount, nTabPositions, lpnTabStopPositions, nTabOrigin) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn text_out_a(hdc: Hdc, x: i32, y: i32, lp_string: &CStr, c: i32) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    let lpString = lp_string.as_ptr() as _;
    let c = c;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TextOutA(hdc, x, y, lpString, c) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn text_out_w(hdc: Hdc, x: i32, y: i32, lp_string: &OsStr, c: i32) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let x = x;
    let y = y;
    let mut temp57: Vec<u16> = lp_string.encode_wide().collect();
    temp57.push(0);
    let lpString = temp57.as_ptr() as _;
    let c = c;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TextOutW(hdc, x, y, lpString, c) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn transparent_blt(hdc_dest: Hdc, xorigin_dest: i32, yorigin_dest: i32, w_dest: i32, h_dest: i32, hdc_src: Hdc, xorigin_src: i32, yorigin_src: i32, w_src: i32, h_src: i32, cr_transparent: u32) -> Result<BOOL> {
    let hdcDest = hdc_dest.into_raw();
    let xoriginDest = xorigin_dest;
    let yoriginDest = yorigin_dest;
    let wDest = w_dest;
    let hDest = h_dest;
    let hdcSrc = hdc_src.into_raw();
    let xoriginSrc = xorigin_src;
    let yoriginSrc = yorigin_src;
    let wSrc = w_src;
    let hSrc = h_src;
    let crTransparent = cr_transparent;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TransparentBlt(hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, crTransparent) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn union_rect(lprc_src1: &Rect, lprc_src2: &Rect) -> Result<(BOOL, Rect)> {
    let mut lprc_dst = mem::MaybeUninit::zeroed();
    let lprcDst = lprc_dst.as_mut_ptr();
    // SAFETY: type is a thin type
    let lprcSrc1 = unsafe { &*(lprc_src1 as *const _ as *const _) };
    // SAFETY: type is a thin type
    let lprcSrc2 = unsafe { &*(lprc_src2 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::UnionRect(lprcDst, lprcSrc1, lprcSrc2) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lprc_dst = unsafe { Rect::from_win32(unsafe { lprcDst.assume_init() }) };
    Ok((return_value,lprcDst))
}
#[inline]
pub fn unrealize_object(h: Hgdiobj) -> Result<BOOL> {
    let h = h.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::UnrealizeObject(h) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn update_colors(hdc: Hdc) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::UpdateColors(hdc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn update_window(h_wnd: Hwnd) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::UpdateWindow(hWnd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn validate_rect(h_wnd: Option<Hwnd>, lp_rect: Option<&Rect>) -> Result<BOOL> {
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    // SAFETY: type is a thin type
    let lpRect = lp_rect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ValidateRect(hWnd, lpRect) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn validate_rgn(h_wnd: Hwnd, h_rgn: Option<Hrgn>) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let hRgn = h_rgn.map_or(0, Hrgn::into_raw);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ValidateRgn(hWnd, hRgn) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn widen_path(hdc: Hdc) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::WidenPath(hdc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn window_from_dc(h_dc: Hdc) -> Result<Hwnd> {
    let hDC = h_dc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::WindowFromDC(hDC) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn wgl_swap_multiple_buffers(param0: u32, param1: &Wglswap) -> u32 {
    let param0 = param0;
    // SAFETY: type is a thin type
    let param1 = unsafe { &*(param1 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::wglSwapMultipleBuffers(param0, param1) };
    return_value
}
#[inline]
pub fn enable_mouse_in_pointer(f_enable: BOOL) -> BOOL {
    let fEnable = f_enable;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::EnableMouseInPointer(fEnable) };
    return_value
}
#[inline]
pub fn get_pointer_cursor_id(pointer_id: u32, ) -> Result<(BOOL, u32)> {
    let mut cursor_id = mem::MaybeUninit::zeroed();
    let cursorId = cursor_id.as_mut_ptr();
    let pointerId = pointer_id;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerCursorId(pointerId, cursorId) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let cursor_id = unsafe { cursorId.assume_init() };
    Ok((return_value,cursorId))
}
#[inline]
pub fn get_pointer_device(device: Handle, ) -> Result<(BOOL, PointerDeviceInfo)> {
    let mut pointer_device = mem::MaybeUninit::zeroed();
    let pointerDevice = pointer_device.as_mut_ptr();
    let device = device.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerDevice(device, pointerDevice) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pointer_device = unsafe { PointerDeviceInfo::from_win32(unsafe { pointerDevice.assume_init() }) };
    Ok((return_value,pointerDevice))
}
#[inline]
pub fn get_pointer_device_cursors(device: Handle, cursor_count: u32, ) -> Result<(BOOL, u32, PointerDeviceCursorInfo)> {
    let mut device_cursors = mem::MaybeUninit::zeroed();
    let deviceCursors = device_cursors.as_mut_ptr();
    let device = device.into_raw();
    let mut cursorCount = cursor_count;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerDeviceCursors(device, &mut cursorCount, deviceCursors) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let device_cursors = unsafe { PointerDeviceCursorInfo::from_win32(unsafe { deviceCursors.assume_init() }) };
    let cursor_count = cursorCount;
    Ok((return_value,cursorCount, deviceCursors))
}
#[inline]
pub fn get_pointer_device_properties(device: Handle, property_count: u32, ) -> Result<(BOOL, u32, PointerDeviceProperty)> {
    let mut pointer_properties = mem::MaybeUninit::zeroed();
    let pointerProperties = pointer_properties.as_mut_ptr();
    let device = device.into_raw();
    let mut propertyCount = property_count;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerDeviceProperties(device, &mut propertyCount, pointerProperties) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pointer_properties = unsafe { PointerDeviceProperty::from_win32(unsafe { pointerProperties.assume_init() }) };
    let property_count = propertyCount;
    Ok((return_value,propertyCount, pointerProperties))
}
#[inline]
pub fn get_pointer_device_rects(device: Handle, ) -> Result<(BOOL, Rect, Rect)> {
    let mut pointer_device_rect = mem::MaybeUninit::zeroed();
    let pointerDeviceRect = pointer_device_rect.as_mut_ptr();
    let mut display_rect = mem::MaybeUninit::zeroed();
    let displayRect = display_rect.as_mut_ptr();
    let device = device.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerDeviceRects(device, pointerDeviceRect, displayRect) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let display_rect = unsafe { Rect::from_win32(unsafe { displayRect.assume_init() }) };
    let pointer_device_rect = unsafe { Rect::from_win32(unsafe { pointerDeviceRect.assume_init() }) };
    Ok((return_value,pointerDeviceRect, displayRect))
}
#[inline]
pub fn get_pointer_devices(device_count: u32, ) -> Result<(BOOL, u32, PointerDeviceInfo)> {
    let mut pointer_devices = mem::MaybeUninit::zeroed();
    let pointerDevices = pointer_devices.as_mut_ptr();
    let mut deviceCount = device_count;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerDevices(&mut deviceCount, pointerDevices) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pointer_devices = unsafe { PointerDeviceInfo::from_win32(unsafe { pointerDevices.assume_init() }) };
    let device_count = deviceCount;
    Ok((return_value,deviceCount, pointerDevices))
}
#[inline]
pub fn get_pointer_frame_info(pointer_id: u32, pointer_count: u32, ) -> Result<(BOOL, u32, PointerInfo)> {
    let mut pointer_info = mem::MaybeUninit::zeroed();
    let pointerInfo = pointer_info.as_mut_ptr();
    let pointerId = pointer_id;
    let mut pointerCount = pointer_count;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerFrameInfo(pointerId, &mut pointerCount, pointerInfo) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pointer_info = unsafe { PointerInfo::from_win32(unsafe { pointerInfo.assume_init() }) };
    let pointer_count = pointerCount;
    Ok((return_value,pointerCount, pointerInfo))
}
#[inline]
pub fn get_pointer_frame_info_history(pointer_id: u32, entries_count: u32, pointer_count: u32, ) -> Result<(BOOL, u32, u32, PointerInfo)> {
    let mut pointer_info = mem::MaybeUninit::zeroed();
    let pointerInfo = pointer_info.as_mut_ptr();
    let pointerId = pointer_id;
    let mut entriesCount = entries_count;
    let mut pointerCount = pointer_count;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerFrameInfoHistory(pointerId, &mut entriesCount, &mut pointerCount, pointerInfo) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pointer_info = unsafe { PointerInfo::from_win32(unsafe { pointerInfo.assume_init() }) };
    let pointer_count = pointerCount;
    let entries_count = entriesCount;
    Ok((return_value,entriesCount, pointerCount, pointerInfo))
}
#[inline]
pub fn get_pointer_frame_pen_info(pointer_id: u32, pointer_count: u32, ) -> Result<(BOOL, u32, PointerPenInfo)> {
    let mut pen_info = mem::MaybeUninit::zeroed();
    let penInfo = pen_info.as_mut_ptr();
    let pointerId = pointer_id;
    let mut pointerCount = pointer_count;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerFramePenInfo(pointerId, &mut pointerCount, penInfo) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pen_info = unsafe { PointerPenInfo::from_win32(unsafe { penInfo.assume_init() }) };
    let pointer_count = pointerCount;
    Ok((return_value,pointerCount, penInfo))
}
#[inline]
pub fn get_pointer_frame_pen_info_history(pointer_id: u32, entries_count: u32, pointer_count: u32, ) -> Result<(BOOL, u32, u32, PointerPenInfo)> {
    let mut pen_info = mem::MaybeUninit::zeroed();
    let penInfo = pen_info.as_mut_ptr();
    let pointerId = pointer_id;
    let mut entriesCount = entries_count;
    let mut pointerCount = pointer_count;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerFramePenInfoHistory(pointerId, &mut entriesCount, &mut pointerCount, penInfo) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pen_info = unsafe { PointerPenInfo::from_win32(unsafe { penInfo.assume_init() }) };
    let pointer_count = pointerCount;
    let entries_count = entriesCount;
    Ok((return_value,entriesCount, pointerCount, penInfo))
}
#[inline]
pub fn get_pointer_frame_touch_info(pointer_id: u32, pointer_count: u32, ) -> Result<(BOOL, u32, PointerTouchInfo)> {
    let mut touch_info = mem::MaybeUninit::zeroed();
    let touchInfo = touch_info.as_mut_ptr();
    let pointerId = pointer_id;
    let mut pointerCount = pointer_count;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerFrameTouchInfo(pointerId, &mut pointerCount, touchInfo) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let touch_info = unsafe { PointerTouchInfo::from_win32(unsafe { touchInfo.assume_init() }) };
    let pointer_count = pointerCount;
    Ok((return_value,pointerCount, touchInfo))
}
#[inline]
pub fn get_pointer_frame_touch_info_history(pointer_id: u32, entries_count: u32, pointer_count: u32, ) -> Result<(BOOL, u32, u32, PointerTouchInfo)> {
    let mut touch_info = mem::MaybeUninit::zeroed();
    let touchInfo = touch_info.as_mut_ptr();
    let pointerId = pointer_id;
    let mut entriesCount = entries_count;
    let mut pointerCount = pointer_count;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerFrameTouchInfoHistory(pointerId, &mut entriesCount, &mut pointerCount, touchInfo) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let touch_info = unsafe { PointerTouchInfo::from_win32(unsafe { touchInfo.assume_init() }) };
    let pointer_count = pointerCount;
    let entries_count = entriesCount;
    Ok((return_value,entriesCount, pointerCount, touchInfo))
}
#[inline]
pub fn get_pointer_info(pointer_id: u32, ) -> Result<(BOOL, PointerInfo)> {
    let mut pointer_info = mem::MaybeUninit::zeroed();
    let pointerInfo = pointer_info.as_mut_ptr();
    let pointerId = pointer_id;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerInfo(pointerId, pointerInfo) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pointer_info = unsafe { PointerInfo::from_win32(unsafe { pointerInfo.assume_init() }) };
    Ok((return_value,pointerInfo))
}
#[inline]
pub fn get_pointer_info_history(pointer_id: u32, entries_count: u32, ) -> Result<(BOOL, u32, PointerInfo)> {
    let mut pointer_info = mem::MaybeUninit::zeroed();
    let pointerInfo = pointer_info.as_mut_ptr();
    let pointerId = pointer_id;
    let mut entriesCount = entries_count;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerInfoHistory(pointerId, &mut entriesCount, pointerInfo) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pointer_info = unsafe { PointerInfo::from_win32(unsafe { pointerInfo.assume_init() }) };
    let entries_count = entriesCount;
    Ok((return_value,entriesCount, pointerInfo))
}
#[inline]
pub fn get_pointer_pen_info(pointer_id: u32, ) -> Result<(BOOL, PointerPenInfo)> {
    let mut pen_info = mem::MaybeUninit::zeroed();
    let penInfo = pen_info.as_mut_ptr();
    let pointerId = pointer_id;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerPenInfo(pointerId, penInfo) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pen_info = unsafe { PointerPenInfo::from_win32(unsafe { penInfo.assume_init() }) };
    Ok((return_value,penInfo))
}
#[inline]
pub fn get_pointer_pen_info_history(pointer_id: u32, entries_count: u32, ) -> Result<(BOOL, u32, PointerPenInfo)> {
    let mut pen_info = mem::MaybeUninit::zeroed();
    let penInfo = pen_info.as_mut_ptr();
    let pointerId = pointer_id;
    let mut entriesCount = entries_count;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerPenInfoHistory(pointerId, &mut entriesCount, penInfo) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pen_info = unsafe { PointerPenInfo::from_win32(unsafe { penInfo.assume_init() }) };
    let entries_count = entriesCount;
    Ok((return_value,entriesCount, penInfo))
}
#[inline]
pub fn get_pointer_touch_info(pointer_id: u32, ) -> Result<(BOOL, PointerTouchInfo)> {
    let mut touch_info = mem::MaybeUninit::zeroed();
    let touchInfo = touch_info.as_mut_ptr();
    let pointerId = pointer_id;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerTouchInfo(pointerId, touchInfo) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let touch_info = unsafe { PointerTouchInfo::from_win32(unsafe { touchInfo.assume_init() }) };
    Ok((return_value,touchInfo))
}
#[inline]
pub fn get_pointer_touch_info_history(pointer_id: u32, entries_count: u32, ) -> Result<(BOOL, u32, PointerTouchInfo)> {
    let mut touch_info = mem::MaybeUninit::zeroed();
    let touchInfo = touch_info.as_mut_ptr();
    let pointerId = pointer_id;
    let mut entriesCount = entries_count;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerTouchInfoHistory(pointerId, &mut entriesCount, touchInfo) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let touch_info = unsafe { PointerTouchInfo::from_win32(unsafe { touchInfo.assume_init() }) };
    let entries_count = entriesCount;
    Ok((return_value,entriesCount, touchInfo))
}
#[inline]
pub fn get_pointer_type(pointer_id: u32, ) -> Result<(BOOL, i32)> {
    let mut pointer_type = mem::MaybeUninit::zeroed();
    let pointerType = pointer_type.as_mut_ptr();
    let pointerId = pointer_id;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerType(pointerId, pointerType) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pointer_type = unsafe { pointerType.assume_init() };
    Ok((return_value,pointerType))
}
#[inline]
pub fn get_raw_pointer_device_data(pointer_id: u32, history_count: u32, p_properties: &[PointerDeviceProperty], ) -> Result<(BOOL, i32)> {
    let mut p_values = mem::MaybeUninit::zeroed();
    let pValues = p_values.as_mut_ptr();
    let pointerId = pointer_id;
    let historyCount = history_count;
    let pProperties = p_properties.as_ptr() as _;
    let propertiesCount = p_properties.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetRawPointerDeviceData(pointerId, historyCount, propertiesCount, pProperties, pValues) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let p_values = unsafe { pValues.assume_init() };
    Ok((return_value,pValues))
}
#[inline]
pub fn get_unpredicted_message_pos() -> u32 {
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetUnpredictedMessagePos() };
    return_value
}
#[inline]
pub fn initialize_touch_injection(max_count: u32, dw_mode: u32) -> Result<BOOL> {
    let maxCount = max_count;
    let dwMode = dw_mode;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::InitializeTouchInjection(maxCount, dwMode) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn inject_synthetic_pointer_input(device: Hsyntheticpointerdevice, pointer_info: &[PointerTypeInfo], ) -> Result<BOOL> {
    let device = device.into_raw();
    let pointerInfo = pointer_info.as_ptr() as _;
    let count = pointer_info.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::InjectSyntheticPointerInput(device, pointerInfo, count) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn inject_touch_input(contacts: &[PointerTouchInfo]) -> Result<BOOL> {
    let contacts = contacts.as_ptr() as _;
    let count = contacts.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::InjectTouchInput(count, contacts) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn is_mouse_in_pointer_enabled() -> BOOL {
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::IsMouseInPointerEnabled() };
    return_value
}
#[inline]
pub fn skip_pointer_frame_messages(pointer_id: u32) -> Result<BOOL> {
    let pointerId = pointer_id;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::SkipPointerFrameMessages(pointerId) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn begin_buffered_animation(hwnd: Hwnd, hdc_target: Hdc, prc_target: &Rect, dw_format: i32, p_paint_params: Option<&BpPaintparams<'_>>, p_animation_params: &BpAnimationparams, ) -> (isize, Hdc, Hdc) {
    let mut phdc_from = mem::MaybeUninit::zeroed();
    let phdcFrom = phdc_from.as_mut_ptr();
    let mut phdc_to = mem::MaybeUninit::zeroed();
    let phdcTo = phdc_to.as_mut_ptr();
    let hwnd = hwnd.into_raw();
    let hdcTarget = hdc_target.into_raw();
    // SAFETY: type is a thin type
    let prcTarget = unsafe { &*(prc_target as *const _ as *const _) };
    let dwFormat = dw_format;
    let temp58 = p_paint_params.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
    let pPaintParams = temp58.as_ref();
    let temp59 = p_animation_params.to_win32();
    let pAnimationParams = &temp59;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::BeginBufferedAnimation(hwnd, hdcTarget, prcTarget, dwFormat, pPaintParams, pAnimationParams, phdcFrom, phdcTo) };
    let phdc_to = unsafe { Hdc::new(unsafe { phdcTo.assume_init() }) };
    let phdc_from = unsafe { Hdc::new(unsafe { phdcFrom.assume_init() }) };
    (return_value,phdcFrom, phdcTo)
}
#[inline]
pub fn begin_buffered_paint(hdc_target: Hdc, prc_target: &Rect, dw_format: i32, p_paint_params: Option<&BpPaintparams<'_>>, ) -> (isize, Hdc) {
    let mut phdc = mem::MaybeUninit::zeroed();
    let phdc = phdc.as_mut_ptr();
    let hdcTarget = hdc_target.into_raw();
    // SAFETY: type is a thin type
    let prcTarget = unsafe { &*(prc_target as *const _ as *const _) };
    let dwFormat = dw_format;
    let temp60 = p_paint_params.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
    let pPaintParams = temp60.as_ref();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::BeginBufferedPaint(hdcTarget, prcTarget, dwFormat, pPaintParams, phdc) };
    let phdc = unsafe { Hdc::new(unsafe { phdc.assume_init() }) };
    (return_value,phdc)
}
#[inline]
pub fn begin_panning_feedback(hwnd: Hwnd) -> Result<BOOL> {
    let hwnd = hwnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::BeginPanningFeedback(hwnd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn buffered_paint_clear(h_buffered_paint: isize, prc: Option<&Rect>) -> HRESULT {
    let hBufferedPaint = h_buffered_paint;
    // SAFETY: type is a thin type
    let prc = prc.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let return_value = unsafe { windows_sys::Win32::UI::Controls::BufferedPaintClear(hBufferedPaint, prc) };
    return_value
}
#[inline]
pub fn buffered_paint_init() -> HRESULT {
    let return_value = unsafe { windows_sys::Win32::UI::Controls::BufferedPaintInit() };
    return_value
}
#[inline]
pub fn buffered_paint_render_animation(hwnd: Hwnd, hdc_target: Hdc) -> Result<BOOL> {
    let hwnd = hwnd.into_raw();
    let hdcTarget = hdc_target.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::BufferedPaintRenderAnimation(hwnd, hdcTarget) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn buffered_paint_set_alpha(h_buffered_paint: isize, prc: Option<&Rect>, alpha: u8) -> HRESULT {
    let hBufferedPaint = h_buffered_paint;
    // SAFETY: type is a thin type
    let prc = prc.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let alpha = alpha;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::BufferedPaintSetAlpha(hBufferedPaint, prc, alpha) };
    return_value
}
#[inline]
pub fn buffered_paint_stop_all_animations(hwnd: Hwnd) -> HRESULT {
    let hwnd = hwnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::BufferedPaintStopAllAnimations(hwnd) };
    return_value
}
#[inline]
pub fn buffered_paint_un_init() -> HRESULT {
    let return_value = unsafe { windows_sys::Win32::UI::Controls::BufferedPaintUnInit() };
    return_value
}
#[inline]
pub fn check_dlg_button(h_dlg: Hwnd, n_id_button: i32, u_check: u32) -> Result<BOOL> {
    let hDlg = h_dlg.into_raw();
    let nIDButton = n_id_button;
    let uCheck = u_check;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::CheckDlgButton(hDlg, nIDButton, uCheck) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn check_radio_button(h_dlg: Hwnd, n_id_first_button: i32, n_id_last_button: i32, n_id_check_button: i32) -> Result<BOOL> {
    let hDlg = h_dlg.into_raw();
    let nIDFirstButton = n_id_first_button;
    let nIDLastButton = n_id_last_button;
    let nIDCheckButton = n_id_check_button;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::CheckRadioButton(hDlg, nIDFirstButton, nIDLastButton, nIDCheckButton) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn close_theme_data(h_theme: isize) -> HRESULT {
    let hTheme = h_theme;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::CloseThemeData(hTheme) };
    return_value
}
#[inline]
pub fn create_mapped_bitmap(h_instance: Hinstance, id_bitmap: isize, w_flags: u32, lp_color_map: Option<&Colormap>, i_num_maps: i32) -> Result<Hbitmap> {
    let hInstance = h_instance.into_raw();
    let idBitmap = id_bitmap;
    let wFlags = w_flags;
    // SAFETY: type is a thin type
    let lpColorMap = lp_color_map.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let iNumMaps = i_num_maps;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::CreateMappedBitmap(hInstance, idBitmap, wFlags, lpColorMap, iNumMaps) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_status_window_a(style: i32, lpsz_text: &CStr, hwnd_parent: Hwnd, w_id: u32) -> Result<Hwnd> {
    let style = style;
    let lpszText = lpsz_text.as_ptr() as _;
    let hwndParent = hwnd_parent.into_raw();
    let wID = w_id;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::CreateStatusWindowA(style, lpszText, hwndParent, wID) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_status_window_w(style: i32, lpsz_text: &OsStr, hwnd_parent: Hwnd, w_id: u32) -> Result<Hwnd> {
    let style = style;
    let mut temp61: Vec<u16> = lpsz_text.encode_wide().collect();
    temp61.push(0);
    let lpszText = temp61.as_ptr() as _;
    let hwndParent = hwnd_parent.into_raw();
    let wID = w_id;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::CreateStatusWindowW(style, lpszText, hwndParent, wID) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_synthetic_pointer_device(pointer_type: i32, max_count: u32, mode: i32) -> Result<Hsyntheticpointerdevice> {
    let pointerType = pointer_type;
    let maxCount = max_count;
    let mode = mode;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::CreateSyntheticPointerDevice(pointerType, maxCount, mode) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_toolbar_ex(hwnd: Hwnd, ws: u32, w_id: u32, n_bitmaps: i32, h_bm_inst: Hinstance, w_bmid: usize, lp_buttons: Tbbutton, i_num_buttons: i32, dx_button: i32, dy_button: i32, dx_bitmap: i32, dy_bitmap: i32, u_struct_size: u32) -> Result<(Hwnd, Tbbutton)> {
    let hwnd = hwnd.into_raw();
    let ws = ws;
    let wID = w_id;
    let nBitmaps = n_bitmaps;
    let hBMInst = h_bm_inst.into_raw();
    let wBMID = w_bmid;
    let mut lpButtons = lp_buttons.to_win32();
    let iNumButtons = i_num_buttons;
    let dxButton = dx_button;
    let dyButton = dy_button;
    let dxBitmap = dx_bitmap;
    let dyBitmap = dy_bitmap;
    let uStructSize = u_struct_size;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::CreateToolbarEx(hwnd, ws, wID, nBitmaps, hBMInst, wBMID, &mut lpButtons, iNumButtons, dxButton, dyButton, dxBitmap, dyBitmap, uStructSize) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_buttons = unsafe { Tbbutton::from_win32(lpButtons) };
    Ok((return_value,lpButtons))
}
#[inline]
pub fn create_up_down_control(dw_style: u32, x: i32, y: i32, cx: i32, cy: i32, h_parent: Hwnd, n_id: i32, h_inst: Hinstance, h_buddy: Hwnd, n_upper: i32, n_lower: i32, n_pos: i32) -> Result<Hwnd> {
    let dwStyle = dw_style;
    let x = x;
    let y = y;
    let cx = cx;
    let cy = cy;
    let hParent = h_parent.into_raw();
    let nID = n_id;
    let hInst = h_inst.into_raw();
    let hBuddy = h_buddy.into_raw();
    let nUpper = n_upper;
    let nLower = n_lower;
    let nPos = n_pos;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::CreateUpDownControl(dwStyle, x, y, cx, cy, hParent, nID, hInst, hBuddy, nUpper, nLower, nPos) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn dpa_clone(hdpa: Hdpa, hdpa_new: Option<Hdpa>) -> Result<Hdpa> {
    let hdpa = hdpa.into_raw();
    let hdpaNew = hdpa_new.map_or(0, Hdpa::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_Clone(hdpa, hdpaNew) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn dpa_create(c_item_grow: i32) -> Result<Hdpa> {
    let cItemGrow = c_item_grow;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_Create(cItemGrow) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn dpa_create_ex(cp_grow: i32, hheap: Option<Handle>) -> Result<Hdpa> {
    let cpGrow = cp_grow;
    let hheap = hheap.map_or(0, Handle::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_CreateEx(cpGrow, hheap) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn dpa_delete_all_ptrs(hdpa: Hdpa) -> Result<BOOL> {
    let hdpa = hdpa.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_DeleteAllPtrs(hdpa) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dpa_delete_ptr(hdpa: Hdpa, i: i32) -> &mut todo_void_ret {
//      let hdpa = hdpa.into_raw();
//      let i = i;
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_DeletePtr(hdpa, i) };
//      return_value
//  }
#[inline]
pub fn dpa_destroy(hdpa: Option<Hdpa>) -> Result<BOOL> {
    let hdpa = hdpa.map_or(0, Hdpa::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_Destroy(hdpa) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dpa_destroy_callback<Pfndaenumcallback: FnMut() -> i32>(hdpa: Option<Hdpa>, pfn_cb: Pfndaenumcallback, ) -> () {
//      let hdpa = hdpa.map_or(0, Hdpa::into_raw);
//      unsafe extern "system" fn pfndaenumcallback_impl(param0: *const c_void, param1: *const c_void) -> i32 {
//          abort_on_panic(move || {
//              let closure = unsafe {
//                  &mut *(param0 as usize as *mut Pfndaenumcallback)
//              };
//              let return_value = closure();
//              let real_return_value = return_value;
//              real_return_value
//          })
//      }
//      let pfnCB = Some(pfndaenumcallback_impl);
//      let mut pfn_cb = pfn_cb;
//      let pData = (&mut pfn_cb) as *mut _ as *mut _;
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_DestroyCallback(hdpa, pfnCB, pData) };
//      let _ = return_value;
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dpa_enum_callback<Pfndaenumcallback: FnMut() -> i32>(hdpa: Option<Hdpa>, pfn_cb: Option<Pfndaenumcallback>, ) -> () {
//      let hdpa = hdpa.map_or(0, Hdpa::into_raw);
//      unsafe extern "system" fn pfndaenumcallback_impl(param0: *const c_void, param1: *const c_void) -> i32 {
//          abort_on_panic(move || {
//              let closure = unsafe {
//                  &mut *(param0 as usize as *mut Pfndaenumcallback)
//              };
//              let return_value = closure();
//              let real_return_value = return_value;
//              real_return_value
//          })
//      }
//      let pfnCB = Some(pfndaenumcallback_impl);
//      let mut pfn_cb = pfn_cb;
//      let pData = (&mut pfn_cb) as *mut _ as *mut _;
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_EnumCallback(hdpa, pfnCB, pData) };
//      let _ = return_value;
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dpa_get_ptr(hdpa: Hdpa, i: isize) -> &mut todo_void_ret {
//      let hdpa = hdpa.into_raw();
//      let i = i;
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_GetPtr(hdpa, i) };
//      return_value
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dpa_get_ptr_index(hdpa: Hdpa, p: Option<&todo_void>) -> Result<i32> {
//      let hdpa = hdpa.into_raw();
//      // SAFETY: type is a thin type
//      let p = p.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_GetPtrIndex(hdpa, p) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
#[inline]
pub fn dpa_get_size(hdpa: Option<Hdpa>) -> u64 {
    let hdpa = hdpa.map_or(0, Hdpa::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_GetSize(hdpa) };
    return_value
}
#[inline]
pub fn dpa_grow(pdpa: Hdpa, cp: i32) -> Result<BOOL> {
    let pdpa = pdpa.into_raw();
    let cp = cp;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_Grow(pdpa, cp) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dpa_insert_ptr(hdpa: Hdpa, i: i32, p: Option<&todo_void>) -> Result<i32> {
//      let hdpa = hdpa.into_raw();
//      let i = i;
//      // SAFETY: type is a thin type
//      let p = p.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_InsertPtr(hdpa, i, p) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dpa_merge<Pfndpamerge: FnMut(u32, &todo_void, &todo_void, ) -> &mut todo_void_ret>(hdpa_dest: Hdpa, hdpa_src: Hdpa, dw_flags: u32, pfn_compare: Option<unsafe extern "system" fn(*const c_void, *const c_void, LPARAM) -> i32>, pfn_merge: Pfndpamerge, ) -> Result<BOOL> {
//      let hdpaDest = hdpa_dest.into_raw();
//      let hdpaSrc = hdpa_src.into_raw();
//      let dwFlags = dw_flags;
//      let pfnCompare = pfn_compare;
//      unsafe extern "system" fn pfndpamerge_impl(param0: u32, param1: *const c_void, param2: *const c_void, param3: LPARAM) -> *mut c_void {
//          abort_on_panic(move || {
//              let input0 = param0;
//              let input1 = unsafe { &*(param1 as *const _) };
//              let input2 = unsafe { &*(param2 as *const _) };
//              let closure = unsafe {
//                  &mut *(param3 as usize as *mut Pfndpamerge)
//              };
//              let return_value = closure(input0, input1, input2, );
//              let mut temp62 = todo_void;
//              let real_return_value = &mut temp62;
//              real_return_value
//          })
//      }
//      let pfnMerge = Some(pfndpamerge_impl);
//      let mut pfn_merge = pfn_merge;
//      let lParam = unsafe { Lparam::from_ptr((&mut pfn_merge) as *mut _ as *mut _) };
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_Merge(hdpaDest, hdpaSrc, dwFlags, pfnCompare, pfnMerge, lParam) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dpa_search<Pfndacompare: FnMut(&todo_void, &todo_void, ) -> i32>(hdpa: Hdpa, p_find: Option<&todo_void>, i_start: i32, pfn_compare: Pfndacompare, options: u32) -> Result<i32> {
//      let hdpa = hdpa.into_raw();
//      // SAFETY: type is a thin type
//      let pFind = p_find.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      let iStart = i_start;
//      unsafe extern "system" fn pfndacompare_impl(param0: *const c_void, param1: *const c_void, param2: LPARAM) -> i32 {
//          abort_on_panic(move || {
//              let input0 = unsafe { &*(param0 as *const _) };
//              let input1 = unsafe { &*(param1 as *const _) };
//              let closure = unsafe {
//                  &mut *(param2 as usize as *mut Pfndacompare)
//              };
//              let return_value = closure(input0, input1, );
//              let real_return_value = return_value;
//              real_return_value
//          })
//      }
//      let pfnCompare = Some(pfndacompare_impl);
//      let mut pfn_compare = pfn_compare;
//      let lParam = unsafe { Lparam::from_ptr((&mut pfn_compare) as *mut _ as *mut _) };
//      let options = options;
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_Search(hdpa, pFind, iStart, pfnCompare, lParam, options) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dpa_set_ptr(hdpa: Hdpa, i: i32, p: Option<&todo_void>) -> Result<BOOL> {
//      let hdpa = hdpa.into_raw();
//      let i = i;
//      // SAFETY: type is a thin type
//      let p = p.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_SetPtr(hdpa, i, p) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dpa_sort<Pfndacompare: FnMut(&todo_void, &todo_void, ) -> i32>(hdpa: Hdpa, pfn_compare: Pfndacompare, ) -> Result<BOOL> {
//      let hdpa = hdpa.into_raw();
//      unsafe extern "system" fn pfndacompare_impl(param0: *const c_void, param1: *const c_void, param2: LPARAM) -> i32 {
//          abort_on_panic(move || {
//              let input0 = unsafe { &*(param0 as *const _) };
//              let input1 = unsafe { &*(param1 as *const _) };
//              let closure = unsafe {
//                  &mut *(param2 as usize as *mut Pfndacompare)
//              };
//              let return_value = closure(input0, input1, );
//              let real_return_value = return_value;
//              real_return_value
//          })
//      }
//      let pfnCompare = Some(pfndacompare_impl);
//      let mut pfn_compare = pfn_compare;
//      let lParam = unsafe { Lparam::from_ptr((&mut pfn_compare) as *mut _ as *mut _) };
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_Sort(hdpa, pfnCompare, lParam) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
#[inline]
pub fn dsa_clone(hdsa: Hdsa) -> Result<Hdsa> {
    let hdsa = hdsa.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_Clone(hdsa) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn dsa_create(cb_item: i32, c_item_grow: i32) -> Result<Hdsa> {
    let cbItem = cb_item;
    let cItemGrow = c_item_grow;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_Create(cbItem, cItemGrow) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn dsa_delete_all_items(hdsa: Hdsa) -> Result<BOOL> {
    let hdsa = hdsa.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_DeleteAllItems(hdsa) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn dsa_delete_item(hdsa: Hdsa, i: i32) -> Result<BOOL> {
    let hdsa = hdsa.into_raw();
    let i = i;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_DeleteItem(hdsa, i) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn dsa_destroy(hdsa: Option<Hdsa>) -> Result<BOOL> {
    let hdsa = hdsa.map_or(0, Hdsa::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_Destroy(hdsa) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dsa_destroy_callback<Pfndaenumcallback: FnMut() -> i32>(hdsa: Option<Hdsa>, pfn_cb: Pfndaenumcallback, ) -> () {
//      let hdsa = hdsa.map_or(0, Hdsa::into_raw);
//      unsafe extern "system" fn pfndaenumcallback_impl(param0: *const c_void, param1: *const c_void) -> i32 {
//          abort_on_panic(move || {
//              let closure = unsafe {
//                  &mut *(param0 as usize as *mut Pfndaenumcallback)
//              };
//              let return_value = closure();
//              let real_return_value = return_value;
//              real_return_value
//          })
//      }
//      let pfnCB = Some(pfndaenumcallback_impl);
//      let mut pfn_cb = pfn_cb;
//      let pData = (&mut pfn_cb) as *mut _ as *mut _;
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_DestroyCallback(hdsa, pfnCB, pData) };
//      let _ = return_value;
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dsa_enum_callback<Pfndaenumcallback: FnMut() -> i32>(hdsa: Hdsa, pfn_cb: Pfndaenumcallback, ) -> () {
//      let hdsa = hdsa.into_raw();
//      unsafe extern "system" fn pfndaenumcallback_impl(param0: *const c_void, param1: *const c_void) -> i32 {
//          abort_on_panic(move || {
//              let closure = unsafe {
//                  &mut *(param0 as usize as *mut Pfndaenumcallback)
//              };
//              let return_value = closure();
//              let real_return_value = return_value;
//              real_return_value
//          })
//      }
//      let pfnCB = Some(pfndaenumcallback_impl);
//      let mut pfn_cb = pfn_cb;
//      let pData = (&mut pfn_cb) as *mut _ as *mut _;
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_EnumCallback(hdsa, pfnCB, pData) };
//      let _ = return_value;
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dsa_get_item(hdsa: Hdsa, i: i32, ) -> Result<(BOOL, todo_void_ret)> {
//      let mut pitem = mem::MaybeUninit::zeroed();
//      let pitem = pitem.as_mut_ptr();
//      let hdsa = hdsa.into_raw();
//      let i = i;
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_GetItem(hdsa, i, pitem) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let pitem = todo_void;
//      Ok((return_value,pitem))
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dsa_get_item_ptr(hdsa: Hdsa, i: i32) -> &mut todo_void_ret {
//      let hdsa = hdsa.into_raw();
//      let i = i;
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_GetItemPtr(hdsa, i) };
//      return_value
//  }
#[inline]
pub fn dsa_get_size(hdsa: Option<Hdsa>) -> u64 {
    let hdsa = hdsa.map_or(0, Hdsa::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_GetSize(hdsa) };
    return_value
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dsa_insert_item(hdsa: Hdsa, i: i32, pitem: &todo_void) -> Result<i32> {
//      let hdsa = hdsa.into_raw();
//      let i = i;
//      // SAFETY: type is a thin type
//      let pitem = unsafe { &*(pitem as *const _ as *const _) };
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_InsertItem(hdsa, i, pitem) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dsa_set_item(hdsa: Hdsa, i: i32, pitem: &todo_void) -> Result<BOOL> {
//      let hdsa = hdsa.into_raw();
//      let i = i;
//      // SAFETY: type is a thin type
//      let pitem = unsafe { &*(pitem as *const _ as *const _) };
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_SetItem(hdsa, i, pitem) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dsa_sort<Pfndacompare: FnMut(&todo_void, &todo_void, ) -> i32>(pdsa: Hdsa, pfn_compare: Pfndacompare, ) -> Result<BOOL> {
//      let pdsa = pdsa.into_raw();
//      unsafe extern "system" fn pfndacompare_impl(param0: *const c_void, param1: *const c_void, param2: LPARAM) -> i32 {
//          abort_on_panic(move || {
//              let input0 = unsafe { &*(param0 as *const _) };
//              let input1 = unsafe { &*(param1 as *const _) };
//              let closure = unsafe {
//                  &mut *(param2 as usize as *mut Pfndacompare)
//              };
//              let return_value = closure(input0, input1, );
//              let real_return_value = return_value;
//              real_return_value
//          })
//      }
//      let pfnCompare = Some(pfndacompare_impl);
//      let mut pfn_compare = pfn_compare;
//      let lParam = unsafe { Lparam::from_ptr((&mut pfn_compare) as *mut _ as *mut _) };
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_Sort(pdsa, pfnCompare, lParam) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
#[inline]
pub fn destroy_synthetic_pointer_device(device: Hsyntheticpointerdevice) -> () {
    let device = device.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DestroySyntheticPointerDevice(device) };
    let _ = return_value;
}
#[inline]
pub fn dlg_dir_list_a(h_dlg: Hwnd, lp_path_spec: &CStr, n_id_list_box: i32, n_id_static_path: i32, u_file_type: u32) -> Result<(i32, CString)> {
    let hDlg = h_dlg.into_raw();
    let mut lpPathSpec = lp_path_spec.as_ptr() as _;
    let nIDListBox = n_id_list_box;
    let nIDStaticPath = n_id_static_path;
    let uFileType = u_file_type;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DlgDirListA(hDlg, &mut lpPathSpec, nIDListBox, nIDStaticPath, uFileType) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let out8 = unsafe {
        slice::from_raw_parts(lpPathSpec, return_value as usize)
    };
    let mut out8 = out8.to_vec();
    out8.push(0);
    let lp_path_spec = unsafe { CString::from_vec_unchecked(out8) };
    Ok((return_value,lpPathSpec))
}
#[inline]
pub fn dlg_dir_list_combo_box_a(h_dlg: Hwnd, lp_path_spec: &CStr, n_id_combo_box: i32, n_id_static_path: i32, u_filetype: u32) -> Result<(i32, CString)> {
    let hDlg = h_dlg.into_raw();
    let mut lpPathSpec = lp_path_spec.as_ptr() as _;
    let nIDComboBox = n_id_combo_box;
    let nIDStaticPath = n_id_static_path;
    let uFiletype = u_filetype;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DlgDirListComboBoxA(hDlg, &mut lpPathSpec, nIDComboBox, nIDStaticPath, uFiletype) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let out9 = unsafe {
        slice::from_raw_parts(lpPathSpec, return_value as usize)
    };
    let mut out9 = out9.to_vec();
    out9.push(0);
    let lp_path_spec = unsafe { CString::from_vec_unchecked(out9) };
    Ok((return_value,lpPathSpec))
}
#[inline]
pub fn dlg_dir_list_combo_box_w(h_dlg: Hwnd, lp_path_spec: &OsStr, n_id_combo_box: i32, n_id_static_path: i32, u_filetype: u32) -> Result<(i32, OsString)> {
    let hDlg = h_dlg.into_raw();
    let mut temp63: Vec<u16> = lp_path_spec.encode_wide().collect();
    temp63.push(0);
    let mut lpPathSpec = temp63.as_ptr() as _;
    let nIDComboBox = n_id_combo_box;
    let nIDStaticPath = n_id_static_path;
    let uFiletype = u_filetype;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DlgDirListComboBoxW(hDlg, &mut lpPathSpec, nIDComboBox, nIDStaticPath, uFiletype) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let out10 = unsafe {
        slice::from_raw_parts(lpPathSpec, return_value as usize)
    };
    let out10 = out10.to_vec();
    let lp_path_spec = OsStringExt::from_wide(out10);
    Ok((return_value,lpPathSpec))
}
#[inline]
pub fn dlg_dir_list_w(h_dlg: Hwnd, lp_path_spec: &OsStr, n_id_list_box: i32, n_id_static_path: i32, u_file_type: u32) -> Result<(i32, OsString)> {
    let hDlg = h_dlg.into_raw();
    let mut temp64: Vec<u16> = lp_path_spec.encode_wide().collect();
    temp64.push(0);
    let mut lpPathSpec = temp64.as_ptr() as _;
    let nIDListBox = n_id_list_box;
    let nIDStaticPath = n_id_static_path;
    let uFileType = u_file_type;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DlgDirListW(hDlg, &mut lpPathSpec, nIDListBox, nIDStaticPath, uFileType) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let out11 = unsafe {
        slice::from_raw_parts(lpPathSpec, return_value as usize)
    };
    let out11 = out11.to_vec();
    let lp_path_spec = OsStringExt::from_wide(out11);
    Ok((return_value,lpPathSpec))
}
#[inline]
pub fn dlg_dir_select_combo_box_ex_a(hwnd_dlg: Hwnd, cch_out: i32, id_combo_box: i32) -> Result<(BOOL, CString)> {
    let mut lp_string = Vec::<u8>::with_capacity(cch_out as usize + 1);
    let lpString = lp_string.as_mut_ptr();
    let hwndDlg = hwnd_dlg.into_raw();
    let cchOut = cch_out;
    let idComboBox = id_combo_box;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DlgDirSelectComboBoxExA(hwndDlg, lpString, cchOut, idComboBox) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let out12 = unsafe {
        slice::from_raw_parts(unsafe { lpString.assume_init() }, return_value as usize)
    };
    let mut out12 = out12.to_vec();
    out12.push(0);
    let lp_string = unsafe { CString::from_vec_unchecked(out12) };
    Ok((return_value,lpString))
}
#[inline]
pub fn dlg_dir_select_combo_box_ex_w(hwnd_dlg: Hwnd, cch_out: i32, id_combo_box: i32) -> Result<(BOOL, OsString)> {
    let mut lp_string = Vec::<u16>::with_capacity(cch_out as usize + 1);
    let lpString = lp_string.as_mut_ptr();
    let hwndDlg = hwnd_dlg.into_raw();
    let cchOut = cch_out;
    let idComboBox = id_combo_box;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DlgDirSelectComboBoxExW(hwndDlg, lpString, cchOut, idComboBox) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let out13 = unsafe {
        slice::from_raw_parts(unsafe { lpString.assume_init() }, return_value as usize)
    };
    let out13 = out13.to_vec();
    let lp_string = OsStringExt::from_wide(out13);
    Ok((return_value,lpString))
}
#[inline]
pub fn dlg_dir_select_ex_a(hwnd_dlg: Hwnd, ch_count: i32, id_list_box: i32) -> Result<(BOOL, CString)> {
    let mut lp_string = Vec::<u8>::with_capacity(ch_count as usize + 1);
    let lpString = lp_string.as_mut_ptr();
    let hwndDlg = hwnd_dlg.into_raw();
    let chCount = ch_count;
    let idListBox = id_list_box;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DlgDirSelectExA(hwndDlg, lpString, chCount, idListBox) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let out14 = unsafe {
        slice::from_raw_parts(unsafe { lpString.assume_init() }, return_value as usize)
    };
    let mut out14 = out14.to_vec();
    out14.push(0);
    let lp_string = unsafe { CString::from_vec_unchecked(out14) };
    Ok((return_value,lpString))
}
#[inline]
pub fn dlg_dir_select_ex_w(hwnd_dlg: Hwnd, ch_count: i32, id_list_box: i32) -> Result<(BOOL, OsString)> {
    let mut lp_string = Vec::<u16>::with_capacity(ch_count as usize + 1);
    let lpString = lp_string.as_mut_ptr();
    let hwndDlg = hwnd_dlg.into_raw();
    let chCount = ch_count;
    let idListBox = id_list_box;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DlgDirSelectExW(hwndDlg, lpString, chCount, idListBox) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let out15 = unsafe {
        slice::from_raw_parts(unsafe { lpString.assume_init() }, return_value as usize)
    };
    let out15 = out15.to_vec();
    let lp_string = OsStringExt::from_wide(out15);
    Ok((return_value,lpString))
}
#[inline]
pub fn draw_insert(hand_parent: Hwnd, h_lb: Hwnd, n_item: i32) -> () {
    let handParent = hand_parent.into_raw();
    let hLB = h_lb.into_raw();
    let nItem = n_item;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DrawInsert(handParent, hLB, nItem) };
    let _ = return_value;
}
#[inline]
pub fn draw_shadow_text(hdc: Hdc, psz_text: &OsStr, cch: u32, prc: &[Rect], dw_flags: u32, cr_text: u32, ix_offset: i32, iy_offset: i32) -> Result<i32> {
    let hdc = hdc.into_raw();
    let mut temp65: Vec<u16> = psz_text.encode_wide().collect();
    temp65.push(0);
    let pszText = temp65.as_ptr() as _;
    let cch = cch;
    let prc = prc.as_ptr() as _;
    let crShadow = prc.len() as _;
    let dwFlags = dw_flags;
    let crText = cr_text;
    let ixOffset = ix_offset;
    let iyOffset = iy_offset;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DrawShadowText(hdc, pszText, cch, prc, dwFlags, crText, crShadow, ixOffset, iyOffset) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn draw_status_text_a(h_dc: Hdc, lprc: Rect, psz_text: &CStr, u_flags: u32) -> Rect {
    let hDC = h_dc.into_raw();
    let mut lprc = lprc.to_win32();
    let pszText = psz_text.as_ptr() as _;
    let uFlags = u_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DrawStatusTextA(hDC, &mut lprc, pszText, uFlags) };
    let lprc = unsafe { Rect::from_win32(lprc) };
    lprc
}
#[inline]
pub fn draw_status_text_w(h_dc: Hdc, lprc: Rect, psz_text: &OsStr, u_flags: u32) -> Rect {
    let hDC = h_dc.into_raw();
    let mut lprc = lprc.to_win32();
    let mut temp66: Vec<u16> = psz_text.encode_wide().collect();
    temp66.push(0);
    let pszText = temp66.as_ptr() as _;
    let uFlags = u_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DrawStatusTextW(hDC, &mut lprc, pszText, uFlags) };
    let lprc = unsafe { Rect::from_win32(lprc) };
    lprc
}
#[inline]
pub fn draw_theme_background(h_theme: isize, hdc: Hdc, i_part_id: i32, i_state_id: i32, p_rect: &Rect, p_clip_rect: Option<&Rect>) -> HRESULT {
    let hTheme = h_theme;
    let hdc = hdc.into_raw();
    let iPartId = i_part_id;
    let iStateId = i_state_id;
    // SAFETY: type is a thin type
    let pRect = unsafe { &*(p_rect as *const _ as *const _) };
    // SAFETY: type is a thin type
    let pClipRect = p_clip_rect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DrawThemeBackground(hTheme, hdc, iPartId, iStateId, pRect, pClipRect) };
    return_value
}
#[inline]
pub fn draw_theme_background_ex(h_theme: isize, hdc: Hdc, i_part_id: i32, i_state_id: i32, p_rect: &Rect, p_options: Option<&Dtbgopts>) -> HRESULT {
    let hTheme = h_theme;
    let hdc = hdc.into_raw();
    let iPartId = i_part_id;
    let iStateId = i_state_id;
    // SAFETY: type is a thin type
    let pRect = unsafe { &*(p_rect as *const _ as *const _) };
    let temp67 = p_options.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
    let pOptions = temp67.as_ref();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DrawThemeBackgroundEx(hTheme, hdc, iPartId, iStateId, pRect, pOptions) };
    return_value
}
#[inline]
pub fn draw_theme_edge(h_theme: isize, hdc: Hdc, i_part_id: i32, i_state_id: i32, p_dest_rect: &Rect, u_edge: u32, u_flags: u32, ) -> (HRESULT, Rect) {
    let mut p_content_rect = mem::MaybeUninit::zeroed();
    let pContentRect = p_content_rect.as_mut_ptr();
    let hTheme = h_theme;
    let hdc = hdc.into_raw();
    let iPartId = i_part_id;
    let iStateId = i_state_id;
    // SAFETY: type is a thin type
    let pDestRect = unsafe { &*(p_dest_rect as *const _ as *const _) };
    let uEdge = u_edge;
    let uFlags = u_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DrawThemeEdge(hTheme, hdc, iPartId, iStateId, pDestRect, uEdge, uFlags, pContentRect) };
    let p_content_rect = unsafe { Rect::from_win32(unsafe { pContentRect.assume_init() }) };
    (return_value,pContentRect)
}
#[inline]
pub fn draw_theme_icon(h_theme: isize, hdc: Hdc, i_part_id: i32, i_state_id: i32, p_rect: &Rect, himl: Himagelist, i_image_index: i32) -> HRESULT {
    let hTheme = h_theme;
    let hdc = hdc.into_raw();
    let iPartId = i_part_id;
    let iStateId = i_state_id;
    // SAFETY: type is a thin type
    let pRect = unsafe { &*(p_rect as *const _ as *const _) };
    let himl = himl.into_raw();
    let iImageIndex = i_image_index;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DrawThemeIcon(hTheme, hdc, iPartId, iStateId, pRect, himl, iImageIndex) };
    return_value
}
#[inline]
pub fn draw_theme_parent_background(hwnd: Hwnd, hdc: Hdc, prc: Option<&Rect>) -> HRESULT {
    let hwnd = hwnd.into_raw();
    let hdc = hdc.into_raw();
    // SAFETY: type is a thin type
    let prc = prc.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DrawThemeParentBackground(hwnd, hdc, prc) };
    return_value
}
#[inline]
pub fn draw_theme_parent_background_ex(hwnd: Hwnd, hdc: Hdc, dw_flags: u32, prc: Option<&Rect>) -> HRESULT {
    let hwnd = hwnd.into_raw();
    let hdc = hdc.into_raw();
    let dwFlags = dw_flags;
    // SAFETY: type is a thin type
    let prc = prc.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DrawThemeParentBackgroundEx(hwnd, hdc, dwFlags, prc) };
    return_value
}
#[inline]
pub fn draw_theme_text(h_theme: isize, hdc: Hdc, i_part_id: i32, i_state_id: i32, psz_text: &OsStr, cch_text: i32, dw_text_flags: u32, dw_text_flags2: u32, p_rect: &Rect) -> HRESULT {
    let hTheme = h_theme;
    let hdc = hdc.into_raw();
    let iPartId = i_part_id;
    let iStateId = i_state_id;
    let mut temp68: Vec<u16> = psz_text.encode_wide().collect();
    temp68.push(0);
    let pszText = temp68.as_ptr() as _;
    let cchText = cch_text;
    let dwTextFlags = dw_text_flags;
    let dwTextFlags2 = dw_text_flags2;
    // SAFETY: type is a thin type
    let pRect = unsafe { &*(p_rect as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DrawThemeText(hTheme, hdc, iPartId, iStateId, pszText, cchText, dwTextFlags, dwTextFlags2, pRect) };
    return_value
}
#[inline]
pub fn draw_theme_text_ex(h_theme: isize, hdc: Hdc, i_part_id: i32, i_state_id: i32, psz_text: &OsStr, cch_text: i32, dw_text_flags: u32, p_rect: Rect, p_options: Option<&Dttopts>) -> (HRESULT, Rect) {
    let hTheme = h_theme;
    let hdc = hdc.into_raw();
    let iPartId = i_part_id;
    let iStateId = i_state_id;
    let mut temp69: Vec<u16> = psz_text.encode_wide().collect();
    temp69.push(0);
    let pszText = temp69.as_ptr() as _;
    let cchText = cch_text;
    let dwTextFlags = dw_text_flags;
    let mut pRect = p_rect.to_win32();
    let temp70 = p_options.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
    let pOptions = temp70.as_ref();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DrawThemeTextEx(hTheme, hdc, iPartId, iStateId, pszText, cchText, dwTextFlags, &mut pRect, pOptions) };
    let p_rect = unsafe { Rect::from_win32(pRect) };
    (return_value,pRect)
}
#[inline]
pub fn enable_scroll_bar(h_wnd: Hwnd, w_s_bflags: u32, w_arrows: u32) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let wSBflags = w_s_bflags;
    let wArrows = w_arrows;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::EnableScrollBar(hWnd, wSBflags, wArrows) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enable_theme_dialog_texture(hwnd: Hwnd, dw_flags: u32) -> HRESULT {
    let hwnd = hwnd.into_raw();
    let dwFlags = dw_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::EnableThemeDialogTexture(hwnd, dwFlags) };
    return_value
}
#[inline]
pub fn enable_theming(f_enable: BOOL) -> HRESULT {
    let fEnable = f_enable;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::EnableTheming(fEnable) };
    return_value
}
#[inline]
pub fn end_buffered_animation(hbp_animation: isize, f_update_target: BOOL) -> HRESULT {
    let hbpAnimation = hbp_animation;
    let fUpdateTarget = f_update_target;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::EndBufferedAnimation(hbpAnimation, fUpdateTarget) };
    return_value
}
#[inline]
pub fn end_buffered_paint(h_buffered_paint: isize, f_update_target: BOOL) -> HRESULT {
    let hBufferedPaint = h_buffered_paint;
    let fUpdateTarget = f_update_target;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::EndBufferedPaint(hBufferedPaint, fUpdateTarget) };
    return_value
}
#[inline]
pub fn end_panning_feedback(hwnd: Hwnd, f_animate_back: BOOL) -> Result<BOOL> {
    let hwnd = hwnd.into_raw();
    let fAnimateBack = f_animate_back;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::EndPanningFeedback(hwnd, fAnimateBack) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn evaluate_proximity_to_polygon(control_polygon: &Point, p_hit_testing_input: &[TouchHitTestingInput], ) -> Result<(BOOL, TouchHitTestingProximityEvaluation)> {
    let mut p_proximity_eval = mem::MaybeUninit::zeroed();
    let pProximityEval = p_proximity_eval.as_mut_ptr();
    // SAFETY: type is a thin type
    let controlPolygon = unsafe { &*(control_polygon as *const _ as *const _) };
    let pHitTestingInput = p_hit_testing_input.as_ptr() as _;
    let numVertices = p_hit_testing_input.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::EvaluateProximityToPolygon(numVertices, controlPolygon, pHitTestingInput, pProximityEval) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let p_proximity_eval = unsafe { TouchHitTestingProximityEvaluation::from_win32(unsafe { pProximityEval.assume_init() }) };
    Ok((return_value,pProximityEval))
}
#[inline]
pub fn evaluate_proximity_to_rect(control_bounding_box: &Rect, p_hit_testing_input: &TouchHitTestingInput, ) -> Result<(BOOL, TouchHitTestingProximityEvaluation)> {
    let mut p_proximity_eval = mem::MaybeUninit::zeroed();
    let pProximityEval = p_proximity_eval.as_mut_ptr();
    // SAFETY: type is a thin type
    let controlBoundingBox = unsafe { &*(control_bounding_box as *const _ as *const _) };
    // SAFETY: type is a thin type
    let pHitTestingInput = unsafe { &*(p_hit_testing_input as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Controls::EvaluateProximityToRect(controlBoundingBox, pHitTestingInput, pProximityEval) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let p_proximity_eval = unsafe { TouchHitTestingProximityEvaluation::from_win32(unsafe { pProximityEval.assume_init() }) };
    Ok((return_value,pProximityEval))
}
#[inline]
pub fn flat_sb_enable_scroll_bar(param0: Hwnd, param1: i32, param2: u32) -> Result<BOOL> {
    let param0 = param0.into_raw();
    let param1 = param1;
    let param2 = param2;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::FlatSB_EnableScrollBar(param0, param1, param2) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn flat_sb_get_scroll_info(param0: Hwnd, code: u32, param2: Scrollinfo) -> Result<(BOOL, Scrollinfo)> {
    let param0 = param0.into_raw();
    let code = code;
    let mut param2 = param2.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::FlatSB_GetScrollInfo(param0, code, &mut param2) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let param2 = unsafe { Scrollinfo::from_win32(param2) };
    Ok((return_value,param2))
}
#[inline]
pub fn flat_sb_get_scroll_pos(param0: Hwnd, code: u32) -> Result<i32> {
    let param0 = param0.into_raw();
    let code = code;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::FlatSB_GetScrollPos(param0, code) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn flat_sb_get_scroll_prop(param0: Hwnd, prop_index: i32, param2: i32) -> Result<(BOOL, i32)> {
    let param0 = param0.into_raw();
    let propIndex = prop_index;
    let mut param2 = param2;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::FlatSB_GetScrollProp(param0, propIndex, &mut param2) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let param2 = param2;
    Ok((return_value,param2))
}
#[inline]
pub fn flat_sb_get_scroll_range(param0: Hwnd, code: u32, param2: i32, param3: i32) -> Result<(BOOL, i32, i32)> {
    let param0 = param0.into_raw();
    let code = code;
    let mut param2 = param2;
    let mut param3 = param3;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::FlatSB_GetScrollRange(param0, code, &mut param2, &mut param3) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let param3 = param3;
    let param2 = param2;
    Ok((return_value,param2, param3))
}
#[inline]
pub fn flat_sb_set_scroll_info(param0: Hwnd, code: u32, psi: Scrollinfo, f_redraw: BOOL) -> Result<(i32, Scrollinfo)> {
    let param0 = param0.into_raw();
    let code = code;
    let mut psi = psi.to_win32();
    let fRedraw = f_redraw;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::FlatSB_SetScrollInfo(param0, code, &mut psi, fRedraw) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let psi = unsafe { Scrollinfo::from_win32(psi) };
    Ok((return_value,psi))
}
#[inline]
pub fn flat_sb_set_scroll_pos(param0: Hwnd, code: u32, pos: i32, f_redraw: BOOL) -> Result<i32> {
    let param0 = param0.into_raw();
    let code = code;
    let pos = pos;
    let fRedraw = f_redraw;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::FlatSB_SetScrollPos(param0, code, pos, fRedraw) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn flat_sb_set_scroll_prop(param0: Hwnd, index: i32, new_value: isize, param3: BOOL) -> Result<BOOL> {
    let param0 = param0.into_raw();
    let index = index;
    let newValue = new_value;
    let param3 = param3;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::FlatSB_SetScrollProp(param0, index, newValue, param3) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn flat_sb_set_scroll_range(param0: Hwnd, code: u32, min: i32, max: i32, f_redraw: BOOL) -> Result<i32> {
    let param0 = param0.into_raw();
    let code = code;
    let min = min;
    let max = max;
    let fRedraw = f_redraw;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::FlatSB_SetScrollRange(param0, code, min, max, fRedraw) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn flat_sb_show_scroll_bar(param0: Hwnd, code: u32, param2: BOOL) -> Result<BOOL> {
    let param0 = param0.into_raw();
    let code = code;
    let param2 = param2;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::FlatSB_ShowScrollBar(param0, code, param2) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_buffered_paint_bits(h_buffered_paint: isize, ) -> (HRESULT, &mut Rgbquad, i32) {
    let mut ppb_buffer = mem::MaybeUninit::zeroed();
    let ppbBuffer = ppb_buffer.as_mut_ptr();
    let mut pcx_row = mem::MaybeUninit::zeroed();
    let pcxRow = pcx_row.as_mut_ptr();
    let hBufferedPaint = h_buffered_paint;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::GetBufferedPaintBits(hBufferedPaint, ppbBuffer, pcxRow) };
    let pcx_row = unsafe { pcxRow.assume_init() };
    let ppb_buffer = unsafe { &mut *(unsafe { ppbBuffer.assume_init() } as *mut _) };
    (return_value,ppbBuffer, pcxRow)
}
#[inline]
pub fn get_buffered_paint_dc(h_buffered_paint: isize) -> Result<Hdc> {
    let hBufferedPaint = h_buffered_paint;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::GetBufferedPaintDC(hBufferedPaint) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_buffered_paint_target_dc(h_buffered_paint: isize) -> Result<Hdc> {
    let hBufferedPaint = h_buffered_paint;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::GetBufferedPaintTargetDC(hBufferedPaint) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_buffered_paint_target_rect(h_buffered_paint: isize, ) -> (HRESULT, Rect) {
    let mut prc = mem::MaybeUninit::zeroed();
    let prc = prc.as_mut_ptr();
    let hBufferedPaint = h_buffered_paint;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::GetBufferedPaintTargetRect(hBufferedPaint, prc) };
    let prc = unsafe { Rect::from_win32(unsafe { prc.assume_init() }) };
    (return_value,prc)
}
#[inline]
pub fn get_combo_box_info(hwnd_combo: Hwnd, pcbi: Comboboxinfo) -> Result<(BOOL, Comboboxinfo)> {
    let hwndCombo = hwnd_combo.into_raw();
    let mut pcbi = pcbi.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::GetComboBoxInfo(hwndCombo, &mut pcbi) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pcbi = unsafe { Comboboxinfo::from_win32(pcbi) };
    Ok((return_value,pcbi))
}
#[inline]
pub fn get_current_theme_name(cch_max_name_chars: i32, cch_max_color_chars: i32, cch_max_size_chars: i32) -> (HRESULT, OsString, OsString, OsString) {
    let mut psz_theme_file_name = Vec::<u16>::with_capacity(cch_max_size_chars as usize + 1);
    let pszThemeFileName = psz_theme_file_name.as_mut_ptr();
    let mut psz_color_buff = Vec::<u16>::with_capacity(cch_max_size_chars as usize + 1);
    let pszColorBuff = psz_color_buff.as_mut_ptr();
    let mut psz_size_buff = Vec::<u16>::with_capacity(cch_max_size_chars as usize + 1);
    let pszSizeBuff = psz_size_buff.as_mut_ptr();
    let cchMaxNameChars = cch_max_name_chars;
    let cchMaxColorChars = cch_max_color_chars;
    let cchMaxSizeChars = cch_max_size_chars;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::GetCurrentThemeName(pszThemeFileName, cchMaxNameChars, pszColorBuff, cchMaxColorChars, pszSizeBuff, cchMaxSizeChars) };
    let out16 = unsafe {
        slice::from_raw_parts(unsafe { pszSizeBuff.assume_init() }, return_value as usize)
    };
    let out16 = out16.to_vec();
    let psz_size_buff = OsStringExt::from_wide(out16);
    let out17 = unsafe {
        slice::from_raw_parts(unsafe { pszColorBuff.assume_init() }, return_value as usize)
    };
    let out17 = out17.to_vec();
    let psz_color_buff = OsStringExt::from_wide(out17);
    let out18 = unsafe {
        slice::from_raw_parts(unsafe { pszThemeFileName.assume_init() }, return_value as usize)
    };
    let out18 = out18.to_vec();
    let psz_theme_file_name = OsStringExt::from_wide(out18);
    (return_value,pszThemeFileName, pszColorBuff, pszSizeBuff)
}
#[inline]
pub fn get_effective_client_rect(h_wnd: Hwnd, lp_info: &i32) -> Rect {
    let mut lprc = mem::MaybeUninit::zeroed();
    let lprc = lprc.as_mut_ptr();
    let hWnd = h_wnd.into_raw();
    // SAFETY: type is a thin type
    let lpInfo = unsafe { &*(lp_info as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Controls::GetEffectiveClientRect(hWnd, lprc, lpInfo) };
    let lprc = unsafe { Rect::from_win32(unsafe { lprc.assume_init() }) };
    lprc
}
#[inline]
pub fn get_list_box_info(hwnd: Hwnd) -> u32 {
    let hwnd = hwnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::GetListBoxInfo(hwnd) };
    return_value
}
#[inline]
pub fn get_mui_language() -> u16 {
    let return_value = unsafe { windows_sys::Win32::UI::Controls::GetMUILanguage() };
    return_value
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn get_window_feedback_setting(hwnd: Hwnd, feedback: i32, dw_flags: u32, p_size: u32, ) -> Result<(BOOL, u32, todo_void_ret)> {
//      let mut config = mem::MaybeUninit::zeroed();
//      let config = config.as_mut_ptr();
//      let hwnd = hwnd.into_raw();
//      let feedback = feedback;
//      let dwFlags = dw_flags;
//      let mut pSize = p_size;
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::GetWindowFeedbackSetting(hwnd, feedback, dwFlags, &mut pSize, config) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let config = todo_void;
//      let p_size = pSize;
//      Ok((return_value,pSize, config))
//  }
#[inline]
pub fn get_window_theme(hwnd: Hwnd) -> isize {
    let hwnd = hwnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::GetWindowTheme(hwnd) };
    return_value
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn himagelist_query_interface(himl: Himagelist, riid: &GUID, ) -> (HRESULT, &mut todo_void_ret) {
//      let mut ppv = mem::MaybeUninit::zeroed();
//      let ppv = ppv.as_mut_ptr();
//      let himl = himl.into_raw();
//      // SAFETY: type is a thin type
//      let riid = unsafe { &*(riid as *const _ as *const _) };
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::HIMAGELIST_QueryInterface(himl, riid, ppv) };
//      let ppv = unsafe { &mut *(unsafe { ppv.assume_init() } as *mut _) };
//      (return_value,ppv)
//  }
#[inline]
pub fn hit_test_theme_background(h_theme: isize, hdc: Option<Hdc>, i_part_id: i32, i_state_id: i32, dw_options: u32, p_rect: &Rect, hrgn: Option<Hrgn>, pt_test: Point, ) -> (HRESULT, u16) {
    let mut pw_hit_test_code = mem::MaybeUninit::zeroed();
    let pwHitTestCode = pw_hit_test_code.as_mut_ptr();
    let hTheme = h_theme;
    let hdc = hdc.map_or(0, Hdc::into_raw);
    let iPartId = i_part_id;
    let iStateId = i_state_id;
    let dwOptions = dw_options;
    // SAFETY: type is a thin type
    let pRect = unsafe { &*(p_rect as *const _ as *const _) };
    let hrgn = hrgn.map_or(0, Hrgn::into_raw);
    let ptTest = pt_test.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::HitTestThemeBackground(hTheme, hdc, iPartId, iStateId, dwOptions, pRect, hrgn, ptTest, pwHitTestCode) };
    let pw_hit_test_code = unsafe { pwHitTestCode.assume_init() };
    (return_value,pwHitTestCode)
}
#[inline]
pub fn init_common_controls() -> () {
    let return_value = unsafe { windows_sys::Win32::UI::Controls::InitCommonControls() };
    let _ = return_value;
}
#[inline]
pub fn init_common_controls_ex(picce: &Initcommoncontrolsex) -> Result<BOOL> {
    let temp71 = picce.to_win32();
    let picce = &temp71;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::InitCommonControlsEx(picce) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn init_mui_language(ui_lang: u16) -> () {
    let uiLang = ui_lang;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::InitMUILanguage(uiLang) };
    let _ = return_value;
}
#[inline]
pub fn initialize_flat_sb(param0: Hwnd) -> Result<BOOL> {
    let param0 = param0.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::InitializeFlatSB(param0) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn is_app_themed() -> BOOL {
    let return_value = unsafe { windows_sys::Win32::UI::Controls::IsAppThemed() };
    return_value
}
#[inline]
pub fn is_composition_active() -> BOOL {
    let return_value = unsafe { windows_sys::Win32::UI::Controls::IsCompositionActive() };
    return_value
}
#[inline]
pub fn is_dlg_button_checked(h_dlg: Hwnd, n_id_button: i32) -> u32 {
    let hDlg = h_dlg.into_raw();
    let nIDButton = n_id_button;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::IsDlgButtonChecked(hDlg, nIDButton) };
    return_value
}
#[inline]
pub fn is_theme_active() -> BOOL {
    let return_value = unsafe { windows_sys::Win32::UI::Controls::IsThemeActive() };
    return_value
}
#[inline]
pub fn is_theme_background_partially_transparent(h_theme: isize, i_part_id: i32, i_state_id: i32) -> BOOL {
    let hTheme = h_theme;
    let iPartId = i_part_id;
    let iStateId = i_state_id;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::IsThemeBackgroundPartiallyTransparent(hTheme, iPartId, iStateId) };
    return_value
}
#[inline]
pub fn is_theme_dialog_texture_enabled(hwnd: Hwnd) -> BOOL {
    let hwnd = hwnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::IsThemeDialogTextureEnabled(hwnd) };
    return_value
}
#[inline]
pub fn is_theme_part_defined(h_theme: isize, i_part_id: i32, i_state_id: i32) -> BOOL {
    let hTheme = h_theme;
    let iPartId = i_part_id;
    let iStateId = i_state_id;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::IsThemePartDefined(hTheme, iPartId, iStateId) };
    return_value
}
#[inline]
pub fn lb_item_from_pt(h_lb: Hwnd, pt: Point, b_auto_scroll: BOOL) -> Result<i32> {
    let hLB = h_lb.into_raw();
    let pt = pt.to_win32();
    let bAutoScroll = b_auto_scroll;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::LBItemFromPt(hLB, pt, bAutoScroll) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn load_icon_metric(hinst: Hinstance, psz_name: &OsStr, lims: i32, ) -> (HRESULT, Hicon) {
    let mut phico = mem::MaybeUninit::zeroed();
    let phico = phico.as_mut_ptr();
    let hinst = hinst.into_raw();
    let mut temp72: Vec<u16> = psz_name.encode_wide().collect();
    temp72.push(0);
    let pszName = temp72.as_ptr() as _;
    let lims = lims;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::LoadIconMetric(hinst, pszName, lims, phico) };
    let phico = unsafe { Hicon::new(unsafe { phico.assume_init() }) };
    (return_value,phico)
}
#[inline]
pub fn load_icon_with_scale_down(hinst: Hinstance, psz_name: &OsStr, cx: i32, cy: i32, ) -> (HRESULT, Hicon) {
    let mut phico = mem::MaybeUninit::zeroed();
    let phico = phico.as_mut_ptr();
    let hinst = hinst.into_raw();
    let mut temp73: Vec<u16> = psz_name.encode_wide().collect();
    temp73.push(0);
    let pszName = temp73.as_ptr() as _;
    let cx = cx;
    let cy = cy;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::LoadIconWithScaleDown(hinst, pszName, cx, cy, phico) };
    let phico = unsafe { Hicon::new(unsafe { phico.assume_init() }) };
    (return_value,phico)
}
#[inline]
pub fn make_drag_list(h_lb: Hwnd) -> Result<BOOL> {
    let hLB = h_lb.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::MakeDragList(hLB) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn menu_help(u_msg: u32, w_param: Wparam, l_param: Lparam, h_main_menu: Hmenu, h_inst: Hinstance, hwnd_status: Hwnd, lpw_i_ds: &u32) -> () {
    let uMsg = u_msg;
    let wParam = w_param.into_inner();
    let lParam = l_param.into_inner();
    let hMainMenu = h_main_menu.into_raw();
    let hInst = h_inst.into_raw();
    let hwndStatus = hwnd_status.into_raw();
    // SAFETY: type is a thin type
    let lpwIDs = unsafe { &*(lpw_i_ds as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Controls::MenuHelp(uMsg, wParam, lParam, hMainMenu, hInst, hwndStatus, lpwIDs) };
    let _ = return_value;
}
#[inline]
pub fn open_theme_data(hwnd: Option<Hwnd>, psz_class_list: &OsStr) -> isize {
    let hwnd = hwnd.map_or(0, Hwnd::into_raw);
    let mut temp74: Vec<u16> = psz_class_list.encode_wide().collect();
    temp74.push(0);
    let pszClassList = temp74.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::OpenThemeData(hwnd, pszClassList) };
    return_value
}
#[inline]
pub fn open_theme_data_ex(hwnd: Option<Hwnd>, psz_class_list: &OsStr, dw_flags: u32) -> isize {
    let hwnd = hwnd.map_or(0, Hwnd::into_raw);
    let mut temp75: Vec<u16> = psz_class_list.encode_wide().collect();
    temp75.push(0);
    let pszClassList = temp75.as_ptr() as _;
    let dwFlags = dw_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::OpenThemeDataEx(hwnd, pszClassList, dwFlags) };
    return_value
}
#[inline]
pub fn pack_touch_hit_testing_proximity_evaluation(p_hit_testing_input: &TouchHitTestingInput, p_proximity_eval: &TouchHitTestingProximityEvaluation) -> Result<Lresult> {
    // SAFETY: type is a thin type
    let pHitTestingInput = unsafe { &*(p_hit_testing_input as *const _ as *const _) };
    // SAFETY: type is a thin type
    let pProximityEval = unsafe { &*(p_proximity_eval as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Controls::PackTouchHitTestingProximityEvaluation(pHitTestingInput, pProximityEval) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_scroll_info(hwnd: Hwnd, n_bar: u32, lpsi: &Scrollinfo, redraw: BOOL) -> Result<i32> {
    let hwnd = hwnd.into_raw();
    let nBar = n_bar;
    let temp76 = lpsi.to_win32();
    let lpsi = &temp76;
    let redraw = redraw;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::SetScrollInfo(hwnd, nBar, lpsi, redraw) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_scroll_pos(h_wnd: Hwnd, n_bar: u32, n_pos: i32, b_redraw: BOOL) -> Result<i32> {
    let hWnd = h_wnd.into_raw();
    let nBar = n_bar;
    let nPos = n_pos;
    let bRedraw = b_redraw;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::SetScrollPos(hWnd, nBar, nPos, bRedraw) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_scroll_range(h_wnd: Hwnd, n_bar: u32, n_min_pos: i32, n_max_pos: i32, b_redraw: BOOL) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let nBar = n_bar;
    let nMinPos = n_min_pos;
    let nMaxPos = n_max_pos;
    let bRedraw = b_redraw;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::SetScrollRange(hWnd, nBar, nMinPos, nMaxPos, bRedraw) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_theme_app_properties(dw_flags: u32) -> () {
    let dwFlags = dw_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::SetThemeAppProperties(dwFlags) };
    let _ = return_value;
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn set_window_feedback_setting(hwnd: Hwnd, feedback: i32, dw_flags: u32, configuration: Option<&[todo_void]>) -> Result<BOOL> {
//      let hwnd = hwnd.into_raw();
//      let feedback = feedback;
//      let dwFlags = dw_flags;
//      let configuration = configuration.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let size = configuration.len() as _;
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::SetWindowFeedbackSetting(hwnd, feedback, dwFlags, size, configuration) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
#[inline]
pub fn set_window_theme(hwnd: Hwnd, psz_sub_app_name: Option<&OsStr>, psz_sub_id_list: Option<&OsStr>) -> HRESULT {
    let hwnd = hwnd.into_raw();
    let temp77 = psz_sub_app_name.map(|val| {
        let mut temp77: Vec<u16> = val.encode_wide().collect();
        temp77.push(0);
        temp77
    });
    let pszSubAppName = temp77.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp78 = psz_sub_id_list.map(|val| {
        let mut temp78: Vec<u16> = val.encode_wide().collect();
        temp78.push(0);
        temp78
    });
    let pszSubIdList = temp78.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::Controls::SetWindowTheme(hwnd, pszSubAppName, pszSubIdList) };
    return_value
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn set_window_theme_attribute(hwnd: Hwnd, e_attribute: i32, pv_attribute: &[todo_void], ) -> HRESULT {
//      let hwnd = hwnd.into_raw();
//      let eAttribute = e_attribute;
//      let pvAttribute = pv_attribute.as_ptr() as _;
//      let cbAttribute = pv_attribute.len() as _;
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::SetWindowThemeAttribute(hwnd, eAttribute, pvAttribute, cbAttribute) };
//      return_value
//  }
#[inline]
pub fn show_hide_menu_ctl(h_wnd: Hwnd, u_flags: usize, lp_info: &i32) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let uFlags = u_flags;
    // SAFETY: type is a thin type
    let lpInfo = unsafe { &*(lp_info as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Controls::ShowHideMenuCtl(hWnd, uFlags, lpInfo) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn show_scroll_bar(h_wnd: Hwnd, w_bar: u32, b_show: BOOL) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let wBar = w_bar;
    let bShow = b_show;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::ShowScrollBar(hWnd, wBar, bShow) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn uninitialize_flat_sb(param0: Hwnd) -> HRESULT {
    let param0 = param0.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::UninitializeFlatSB(param0) };
    return_value
}
#[inline]
pub fn update_panning_feedback(hwnd: Hwnd, l_total_overpan_offset_x: i32, l_total_overpan_offset_y: i32, f_in_inertia: BOOL) -> Result<BOOL> {
    let hwnd = hwnd.into_raw();
    let lTotalOverpanOffsetX = l_total_overpan_offset_x;
    let lTotalOverpanOffsetY = l_total_overpan_offset_y;
    let fInInertia = f_in_inertia;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::UpdatePanningFeedback(hwnd, lTotalOverpanOffsetX, lTotalOverpanOffsetY, fInInertia) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn chr_cmp_ia(w1: u16, w2: u16) -> Result<BOOL> {
    let w1 = w1;
    let w2 = w2;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ChrCmpIA(w1, w2) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn chr_cmp_iw(w1: u8, w2: u8) -> Result<BOOL> {
    let w1 = w1;
    let w2 = w2;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ChrCmpIW(w1, w2) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn color_adjust_luma(clr_rgb: u32, n: i32, f_scale: BOOL) -> u32 {
    let clrRGB = clr_rgb;
    let n = n;
    let fScale = f_scale;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ColorAdjustLuma(clrRGB, n, fScale) };
    return_value
}
#[inline]
pub fn color_hls_to_rgb(w_hue: u16, w_luminance: u16, w_saturation: u16) -> u32 {
    let wHue = w_hue;
    let wLuminance = w_luminance;
    let wSaturation = w_saturation;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ColorHLSToRGB(wHue, wLuminance, wSaturation) };
    return_value
}
#[inline]
pub fn color_rgb_to_hls(clr_rgb: u32, ) -> (u16, u16, u16) {
    let mut pw_hue = mem::MaybeUninit::zeroed();
    let pwHue = pw_hue.as_mut_ptr();
    let mut pw_luminance = mem::MaybeUninit::zeroed();
    let pwLuminance = pw_luminance.as_mut_ptr();
    let mut pw_saturation = mem::MaybeUninit::zeroed();
    let pwSaturation = pw_saturation.as_mut_ptr();
    let clrRGB = clr_rgb;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ColorRGBToHLS(clrRGB, pwHue, pwLuminance, pwSaturation) };
    let pw_saturation = unsafe { pwSaturation.assume_init() };
    let pw_luminance = unsafe { pwLuminance.assume_init() };
    let pw_hue = unsafe { pwHue.assume_init() };
    (pwHue, pwLuminance, pwSaturation)
}
#[inline]
pub fn command_line_to_argv_w(lp_cmd_line: &OsStr, ) -> (&mut &mut OsString, i32) {
    let mut p_num_args = mem::MaybeUninit::zeroed();
    let pNumArgs = p_num_args.as_mut_ptr();
    let mut temp79: Vec<u16> = lp_cmd_line.encode_wide().collect();
    temp79.push(0);
    let lpCmdLine = temp79.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::CommandLineToArgvW(lpCmdLine, pNumArgs) };
    let p_num_args = unsafe { pNumArgs.assume_init() };
    (return_value,pNumArgs)
}
#[inline]
pub fn dad_auto_scroll(hwnd: Hwnd, pad: AutoScrollData, ppt_now: &Point) -> Result<(BOOL, AutoScrollData)> {
    let hwnd = hwnd.into_raw();
    let mut pad = pad.to_win32();
    // SAFETY: type is a thin type
    let pptNow = unsafe { &*(ppt_now as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DAD_AutoScroll(hwnd, &mut pad, pptNow) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pad = unsafe { AutoScrollData::from_win32(pad) };
    Ok((return_value,pad))
}
#[inline]
pub fn dad_drag_enter_ex(hwnd_target: Hwnd, pt_start: Point) -> Result<BOOL> {
    let hwndTarget = hwnd_target.into_raw();
    let ptStart = pt_start.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DAD_DragEnterEx(hwndTarget, ptStart) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn dad_drag_leave() -> Result<BOOL> {
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DAD_DragLeave() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn dad_drag_move(pt: Point) -> Result<BOOL> {
    let pt = pt.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DAD_DragMove(pt) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn dad_set_drag_image(him: Himagelist, ppt_offset: Point) -> Result<(BOOL, Point)> {
    let him = him.into_raw();
    let mut pptOffset = ppt_offset.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DAD_SetDragImage(him, &mut pptOffset) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let ppt_offset = unsafe { Point::from_win32(pptOffset) };
    Ok((return_value,pptOffset))
}
#[inline]
pub fn dad_show_drag_image(f_show: BOOL) -> Result<BOOL> {
    let fShow = f_show;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DAD_ShowDragImage(fShow) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn def_subclass_proc(h_wnd: Hwnd, u_msg: u32, w_param: Wparam, l_param: Lparam) -> Result<Lresult> {
    let hWnd = h_wnd.into_raw();
    let uMsg = u_msg;
    let wParam = w_param.into_inner();
    let lParam = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DefSubclassProc(hWnd, uMsg, wParam, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn delete_profile_a(lp_sid_string: &CStr, lp_profile_path: Option<&CStr>, lp_computer_name: Option<&CStr>) -> Result<BOOL> {
    let lpSidString = lp_sid_string.as_ptr() as _;
    let lpProfilePath = lp_profile_path.map_or(ptr::null(), |v| v.as_ptr() as _);
    let lpComputerName = lp_computer_name.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DeleteProfileA(lpSidString, lpProfilePath, lpComputerName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn delete_profile_w(lp_sid_string: &OsStr, lp_profile_path: Option<&OsStr>, lp_computer_name: Option<&OsStr>) -> Result<BOOL> {
    let mut temp80: Vec<u16> = lp_sid_string.encode_wide().collect();
    temp80.push(0);
    let lpSidString = temp80.as_ptr() as _;
    let temp81 = lp_profile_path.map(|val| {
        let mut temp81: Vec<u16> = val.encode_wide().collect();
        temp81.push(0);
        temp81
    });
    let lpProfilePath = temp81.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp82 = lp_computer_name.map(|val| {
        let mut temp82: Vec<u16> = val.encode_wide().collect();
        temp82.push(0);
        temp82
    });
    let lpComputerName = temp82.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DeleteProfileW(lpSidString, lpProfilePath, lpComputerName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn do_environment_subst_a(psz_src: &CStr, cch_src: u32) -> (u32, CString) {
    let mut pszSrc = psz_src.as_ptr() as _;
    let cchSrc = cch_src;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DoEnvironmentSubstA(&mut pszSrc, cchSrc) };
    let out19 = unsafe {
        slice::from_raw_parts(pszSrc, return_value as usize)
    };
    let mut out19 = out19.to_vec();
    out19.push(0);
    let psz_src = unsafe { CString::from_vec_unchecked(out19) };
    (return_value,pszSrc)
}
#[inline]
pub fn do_environment_subst_w(psz_src: &OsStr, cch_src: u32) -> (u32, OsString) {
    let mut temp83: Vec<u16> = psz_src.encode_wide().collect();
    temp83.push(0);
    let mut pszSrc = temp83.as_ptr() as _;
    let cchSrc = cch_src;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DoEnvironmentSubstW(&mut pszSrc, cchSrc) };
    let out20 = unsafe {
        slice::from_raw_parts(pszSrc, return_value as usize)
    };
    let out20 = out20.to_vec();
    let psz_src = OsStringExt::from_wide(out20);
    (return_value,pszSrc)
}
#[inline]
pub fn drag_accept_files(h_wnd: Hwnd, f_accept: BOOL) -> () {
    let hWnd = h_wnd.into_raw();
    let fAccept = f_accept;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DragAcceptFiles(hWnd, fAccept) };
    let _ = return_value;
}
#[inline]
pub fn drag_finish(h_drop: Hdrop) -> () {
    let hDrop = h_drop.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DragFinish(hDrop) };
    let _ = return_value;
}
#[inline]
pub fn drag_query_file_a(h_drop: Hdrop, i_file: u32, cch: u32) -> (u32, CString) {
    let mut lpsz_file = Vec::<u8>::with_capacity(cch as usize + 1);
    let lpszFile = lpsz_file.as_mut_ptr();
    let hDrop = h_drop.into_raw();
    let iFile = i_file;
    let cch = cch;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DragQueryFileA(hDrop, iFile, lpszFile, cch) };
    let out21 = unsafe {
        slice::from_raw_parts(unsafe { lpszFile.assume_init() }, return_value as usize)
    };
    let mut out21 = out21.to_vec();
    out21.push(0);
    let lpsz_file = unsafe { CString::from_vec_unchecked(out21) };
    (return_value,lpszFile)
}
#[inline]
pub fn drag_query_file_w(h_drop: Hdrop, i_file: u32, cch: u32) -> (u32, OsString) {
    let mut lpsz_file = Vec::<u16>::with_capacity(cch as usize + 1);
    let lpszFile = lpsz_file.as_mut_ptr();
    let hDrop = h_drop.into_raw();
    let iFile = i_file;
    let cch = cch;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DragQueryFileW(hDrop, iFile, lpszFile, cch) };
    let out22 = unsafe {
        slice::from_raw_parts(unsafe { lpszFile.assume_init() }, return_value as usize)
    };
    let out22 = out22.to_vec();
    let lpsz_file = OsStringExt::from_wide(out22);
    (return_value,lpszFile)
}
#[inline]
pub fn drag_query_point(h_drop: Hdrop, ) -> Result<(BOOL, Point)> {
    let mut ppt = mem::MaybeUninit::zeroed();
    let ppt = ppt.as_mut_ptr();
    let hDrop = h_drop.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DragQueryPoint(hDrop, ppt) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let ppt = unsafe { Point::from_win32(unsafe { ppt.assume_init() }) };
    Ok((return_value,ppt))
}
#[inline]
pub fn drive_type(i_drive: i32) -> Result<i32> {
    let iDrive = i_drive;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DriveType(iDrive) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn duplicate_icon(h_inst: Hinstance, h_icon: Hicon) -> Result<Hicon> {
    let hInst = h_inst.into_raw();
    let hIcon = h_icon.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DuplicateIcon(hInst, hIcon) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn extract_icon_a(h_inst: Hinstance, psz_exe_file_name: &CStr, n_icon_index: u32) -> Result<Hicon> {
    let hInst = h_inst.into_raw();
    let pszExeFileName = psz_exe_file_name.as_ptr() as _;
    let nIconIndex = n_icon_index;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ExtractIconA(hInst, pszExeFileName, nIconIndex) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn extract_icon_ex_a(lpsz_file: &CStr, n_icon_index: i32, n_icons: u32) -> (u32, Hicon, Hicon) {
    let mut phicon_large = mem::MaybeUninit::zeroed();
    let phiconLarge = phicon_large.as_mut_ptr();
    let mut phicon_small = mem::MaybeUninit::zeroed();
    let phiconSmall = phicon_small.as_mut_ptr();
    let lpszFile = lpsz_file.as_ptr() as _;
    let nIconIndex = n_icon_index;
    let nIcons = n_icons;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ExtractIconExA(lpszFile, nIconIndex, phiconLarge, phiconSmall, nIcons) };
    let phicon_small = unsafe { Hicon::new(unsafe { phiconSmall.assume_init() }) };
    let phicon_large = unsafe { Hicon::new(unsafe { phiconLarge.assume_init() }) };
    (return_value,phiconLarge, phiconSmall)
}
#[inline]
pub fn extract_icon_ex_w(lpsz_file: &OsStr, n_icon_index: i32, n_icons: u32) -> (u32, Hicon, Hicon) {
    let mut phicon_large = mem::MaybeUninit::zeroed();
    let phiconLarge = phicon_large.as_mut_ptr();
    let mut phicon_small = mem::MaybeUninit::zeroed();
    let phiconSmall = phicon_small.as_mut_ptr();
    let mut temp84: Vec<u16> = lpsz_file.encode_wide().collect();
    temp84.push(0);
    let lpszFile = temp84.as_ptr() as _;
    let nIconIndex = n_icon_index;
    let nIcons = n_icons;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ExtractIconExW(lpszFile, nIconIndex, phiconLarge, phiconSmall, nIcons) };
    let phicon_small = unsafe { Hicon::new(unsafe { phiconSmall.assume_init() }) };
    let phicon_large = unsafe { Hicon::new(unsafe { phiconLarge.assume_init() }) };
    (return_value,phiconLarge, phiconSmall)
}
#[inline]
pub fn extract_icon_w(h_inst: Hinstance, psz_exe_file_name: &OsStr, n_icon_index: u32) -> Result<Hicon> {
    let hInst = h_inst.into_raw();
    let mut temp85: Vec<u16> = psz_exe_file_name.encode_wide().collect();
    temp85.push(0);
    let pszExeFileName = temp85.as_ptr() as _;
    let nIconIndex = n_icon_index;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ExtractIconW(hInst, pszExeFileName, nIconIndex) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_accept_languages_a(pcch_languages: u32) -> (HRESULT, CString, u32) {
    let mut psz_languages = Vec::<u8>::with_capacity(pcch_languages as usize + 1);
    let pszLanguages = psz_languages.as_mut_ptr();
    let mut pcchLanguages = pcch_languages;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetAcceptLanguagesA(pszLanguages, &mut pcchLanguages) };
    let pcch_languages = pcchLanguages;
    let out23 = unsafe {
        slice::from_raw_parts(unsafe { pszLanguages.assume_init() }, pcch_languages as usize)
    };
    let mut out23 = out23.to_vec();
    out23.push(0);
    let psz_languages = unsafe { CString::from_vec_unchecked(out23) };
    (return_value,pszLanguages, pcchLanguages)
}
#[inline]
pub fn get_accept_languages_w(pcch_languages: u32) -> (HRESULT, OsString, u32) {
    let mut psz_languages = Vec::<u16>::with_capacity(pcch_languages as usize + 1);
    let pszLanguages = psz_languages.as_mut_ptr();
    let mut pcchLanguages = pcch_languages;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetAcceptLanguagesW(pszLanguages, &mut pcchLanguages) };
    let pcch_languages = pcchLanguages;
    let out24 = unsafe {
        slice::from_raw_parts(unsafe { pszLanguages.assume_init() }, pcch_languages as usize)
    };
    let out24 = out24.to_vec();
    let psz_languages = OsStringExt::from_wide(out24);
    (return_value,pszLanguages, pcchLanguages)
}
#[inline]
pub fn get_all_users_profile_directory_a(lpcch_size: u32) -> Result<(BOOL, CString, u32)> {
    let mut lp_profile_dir = Vec::<u8>::with_capacity(lpcch_size as usize + 1);
    let lpProfileDir = lp_profile_dir.as_mut_ptr();
    let mut lpcchSize = lpcch_size;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetAllUsersProfileDirectoryA(lpProfileDir, &mut lpcchSize) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpcch_size = lpcchSize;
    let out25 = unsafe {
        slice::from_raw_parts(unsafe { lpProfileDir.assume_init() }, lpcch_size as usize)
    };
    let mut out25 = out25.to_vec();
    out25.push(0);
    let lp_profile_dir = unsafe { CString::from_vec_unchecked(out25) };
    Ok((return_value,lpProfileDir, lpcchSize))
}
#[inline]
pub fn get_all_users_profile_directory_w(lpcch_size: u32) -> Result<(BOOL, OsString, u32)> {
    let mut lp_profile_dir = Vec::<u16>::with_capacity(lpcch_size as usize + 1);
    let lpProfileDir = lp_profile_dir.as_mut_ptr();
    let mut lpcchSize = lpcch_size;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetAllUsersProfileDirectoryW(lpProfileDir, &mut lpcchSize) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpcch_size = lpcchSize;
    let out26 = unsafe {
        slice::from_raw_parts(unsafe { lpProfileDir.assume_init() }, lpcch_size as usize)
    };
    let out26 = out26.to_vec();
    let lp_profile_dir = OsStringExt::from_wide(out26);
    Ok((return_value,lpProfileDir, lpcchSize))
}
#[inline]
pub fn get_default_user_profile_directory_a(lpcch_size: u32) -> Result<(BOOL, CString, u32)> {
    let mut lp_profile_dir = Vec::<u8>::with_capacity(lpcch_size as usize + 1);
    let lpProfileDir = lp_profile_dir.as_mut_ptr();
    let mut lpcchSize = lpcch_size;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetDefaultUserProfileDirectoryA(lpProfileDir, &mut lpcchSize) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpcch_size = lpcchSize;
    let out27 = unsafe {
        slice::from_raw_parts(unsafe { lpProfileDir.assume_init() }, lpcch_size as usize)
    };
    let mut out27 = out27.to_vec();
    out27.push(0);
    let lp_profile_dir = unsafe { CString::from_vec_unchecked(out27) };
    Ok((return_value,lpProfileDir, lpcchSize))
}
#[inline]
pub fn get_default_user_profile_directory_w(lpcch_size: u32) -> Result<(BOOL, OsString, u32)> {
    let mut lp_profile_dir = Vec::<u16>::with_capacity(lpcch_size as usize + 1);
    let lpProfileDir = lp_profile_dir.as_mut_ptr();
    let mut lpcchSize = lpcch_size;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetDefaultUserProfileDirectoryW(lpProfileDir, &mut lpcchSize) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpcch_size = lpcchSize;
    let out28 = unsafe {
        slice::from_raw_parts(unsafe { lpProfileDir.assume_init() }, lpcch_size as usize)
    };
    let out28 = out28.to_vec();
    let lp_profile_dir = OsStringExt::from_wide(out28);
    Ok((return_value,lpProfileDir, lpcchSize))
}
#[inline]
pub fn get_file_name_from_browse(hwnd: Option<Hwnd>, psz_file_path: &OsStr, cch_file_path: u32, psz_working_dir: Option<&OsStr>, psz_def_ext: &OsStr, psz_filters: Option<&OsStr>, psz_title: Option<&OsStr>) -> Result<(BOOL, OsString)> {
    let hwnd = hwnd.map_or(0, Hwnd::into_raw);
    let mut temp86: Vec<u16> = psz_file_path.encode_wide().collect();
    temp86.push(0);
    let mut pszFilePath = temp86.as_ptr() as _;
    let cchFilePath = cch_file_path;
    let temp87 = psz_working_dir.map(|val| {
        let mut temp87: Vec<u16> = val.encode_wide().collect();
        temp87.push(0);
        temp87
    });
    let pszWorkingDir = temp87.map_or(ptr::null(), |v| v.as_ptr() as _);
    let mut temp88: Vec<u16> = psz_def_ext.encode_wide().collect();
    temp88.push(0);
    let pszDefExt = temp88.as_ptr() as _;
    let temp89 = psz_filters.map(|val| {
        let mut temp89: Vec<u16> = val.encode_wide().collect();
        temp89.push(0);
        temp89
    });
    let pszFilters = temp89.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp90 = psz_title.map(|val| {
        let mut temp90: Vec<u16> = val.encode_wide().collect();
        temp90.push(0);
        temp90
    });
    let pszTitle = temp90.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetFileNameFromBrowse(hwnd, &mut pszFilePath, cchFilePath, pszWorkingDir, pszDefExt, pszFilters, pszTitle) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let out29 = unsafe {
        slice::from_raw_parts(pszFilePath, return_value as usize)
    };
    let out29 = out29.to_vec();
    let psz_file_path = OsStringExt::from_wide(out29);
    Ok((return_value,pszFilePath))
}
#[inline]
pub fn get_menu_context_help_id(param0: Hmenu) -> u32 {
    let param0 = param0.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetMenuContextHelpId(param0) };
    return_value
}
#[inline]
pub fn get_menu_pos_from_id(hmenu: Hmenu, id: u32) -> Result<i32> {
    let hmenu = hmenu.into_raw();
    let id = id;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetMenuPosFromID(hmenu, id) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_profile_type() -> Result<(BOOL, u32)> {
    let mut dw_flags = mem::MaybeUninit::zeroed();
    let dwFlags = dw_flags.as_mut_ptr();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetProfileType(dwFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let dw_flags = unsafe { dwFlags.assume_init() };
    Ok((return_value,dwFlags))
}
#[inline]
pub fn get_profiles_directory_a(lpcch_size: u32) -> Result<(BOOL, CString, u32)> {
    let mut lp_profile_dir = Vec::<u8>::with_capacity(lpcch_size as usize + 1);
    let lpProfileDir = lp_profile_dir.as_mut_ptr();
    let mut lpcchSize = lpcch_size;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetProfilesDirectoryA(lpProfileDir, &mut lpcchSize) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpcch_size = lpcchSize;
    let out30 = unsafe {
        slice::from_raw_parts(unsafe { lpProfileDir.assume_init() }, lpcch_size as usize)
    };
    let mut out30 = out30.to_vec();
    out30.push(0);
    let lp_profile_dir = unsafe { CString::from_vec_unchecked(out30) };
    Ok((return_value,lpProfileDir, lpcchSize))
}
#[inline]
pub fn get_profiles_directory_w(lpcch_size: u32) -> Result<(BOOL, OsString, u32)> {
    let mut lp_profile_dir = Vec::<u16>::with_capacity(lpcch_size as usize + 1);
    let lpProfileDir = lp_profile_dir.as_mut_ptr();
    let mut lpcchSize = lpcch_size;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetProfilesDirectoryW(lpProfileDir, &mut lpcchSize) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpcch_size = lpcchSize;
    let out31 = unsafe {
        slice::from_raw_parts(unsafe { lpProfileDir.assume_init() }, lpcch_size as usize)
    };
    let out31 = out31.to_vec();
    let lp_profile_dir = OsStringExt::from_wide(out31);
    Ok((return_value,lpProfileDir, lpcchSize))
}
#[inline]
pub fn get_user_profile_directory_a(h_token: Handle, lpcch_size: u32) -> Result<(BOOL, CString, u32)> {
    let mut lp_profile_dir = Vec::<u8>::with_capacity(lpcch_size as usize + 1);
    let lpProfileDir = lp_profile_dir.as_mut_ptr();
    let hToken = h_token.into_raw();
    let mut lpcchSize = lpcch_size;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetUserProfileDirectoryA(hToken, lpProfileDir, &mut lpcchSize) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpcch_size = lpcchSize;
    let out32 = unsafe {
        slice::from_raw_parts(unsafe { lpProfileDir.assume_init() }, lpcch_size as usize)
    };
    let mut out32 = out32.to_vec();
    out32.push(0);
    let lp_profile_dir = unsafe { CString::from_vec_unchecked(out32) };
    Ok((return_value,lpProfileDir, lpcchSize))
}
#[inline]
pub fn get_user_profile_directory_w(h_token: Handle, lpcch_size: u32) -> Result<(BOOL, OsString, u32)> {
    let mut lp_profile_dir = Vec::<u16>::with_capacity(lpcch_size as usize + 1);
    let lpProfileDir = lp_profile_dir.as_mut_ptr();
    let hToken = h_token.into_raw();
    let mut lpcchSize = lpcch_size;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetUserProfileDirectoryW(hToken, lpProfileDir, &mut lpcchSize) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpcch_size = lpcchSize;
    let out33 = unsafe {
        slice::from_raw_parts(unsafe { lpProfileDir.assume_init() }, lpcch_size as usize)
    };
    let out33 = out33.to_vec();
    let lp_profile_dir = OsStringExt::from_wide(out33);
    Ok((return_value,lpProfileDir, lpcchSize))
}
#[inline]
pub fn get_window_context_help_id(param0: Hwnd) -> u32 {
    let param0 = param0.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetWindowContextHelpId(param0) };
    return_value
}
#[inline]
pub fn get_window_subclass<Subclassproc: FnMut(Hwnd, u32, Wparam, Lparam, ) -> Lresult>(h_wnd: Hwnd, pfn_subclass: Subclassproc, ) -> Result<(BOOL, usize)> {
    let mut pdw_ref_data = mem::MaybeUninit::zeroed();
    let pdwRefData = pdw_ref_data.as_mut_ptr();
    let hWnd = h_wnd.into_raw();
    unsafe extern "system" fn subclassproc_impl(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM, param4: usize, param5: usize) -> LRESULT {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let input3 = unsafe { Lparam::from_inner(param3) };
            let closure = unsafe {
                &mut *(param4 as usize as *mut Subclassproc)
            };
            let return_value = closure(input0, input1, input2, input3, );
            let real_return_value = return_value.into_raw();
            real_return_value
        })
    }
    let pfnSubclass = Some(subclassproc_impl);
    let mut pfn_subclass = pfn_subclass;
    let uIdSubclass = (&mut pfn_subclass) as *mut _ as *mut _;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetWindowSubclass(hWnd, pfnSubclass, uIdSubclass, pdwRefData) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pdw_ref_data = unsafe { pdwRefData.assume_init() };
    Ok((return_value,pdwRefData))
}
#[inline]
pub fn hmonitor_user_free(param0: &u32, param1: &Hmonitor) -> () {
    // SAFETY: type is a thin type
    let param0 = unsafe { &*(param0 as *const _ as *const _) };
    // SAFETY: type is a thin type
    let param1 = unsafe { &*(param1 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Shell::HMONITOR_UserFree(param0, param1) };
    let _ = return_value;
}
#[inline]
pub fn hmonitor_user_free64(param0: &u32, param1: &Hmonitor) -> () {
    // SAFETY: type is a thin type
    let param0 = unsafe { &*(param0 as *const _ as *const _) };
    // SAFETY: type is a thin type
    let param1 = unsafe { &*(param1 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Shell::HMONITOR_UserFree64(param0, param1) };
    let _ = return_value;
}
#[inline]
pub fn hmonitor_user_marshal(param0: &u32, param1: u8, param2: &Hmonitor) -> (&mut u8, u8) {
    // SAFETY: type is a thin type
    let param0 = unsafe { &*(param0 as *const _ as *const _) };
    let mut param1 = param1;
    // SAFETY: type is a thin type
    let param2 = unsafe { &*(param2 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Shell::HMONITOR_UserMarshal(param0, &mut param1, param2) };
    let param1 = param1;
    (return_value,param1)
}
#[inline]
pub fn hmonitor_user_marshal64(param0: &u32, param1: u8, param2: &Hmonitor) -> (&mut u8, u8) {
    // SAFETY: type is a thin type
    let param0 = unsafe { &*(param0 as *const _ as *const _) };
    let mut param1 = param1;
    // SAFETY: type is a thin type
    let param2 = unsafe { &*(param2 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Shell::HMONITOR_UserMarshal64(param0, &mut param1, param2) };
    let param1 = param1;
    (return_value,param1)
}
#[inline]
pub fn hmonitor_user_size(param0: &u32, param1: u32, param2: &Hmonitor) -> u32 {
    // SAFETY: type is a thin type
    let param0 = unsafe { &*(param0 as *const _ as *const _) };
    let param1 = param1;
    // SAFETY: type is a thin type
    let param2 = unsafe { &*(param2 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Shell::HMONITOR_UserSize(param0, param1, param2) };
    return_value
}
#[inline]
pub fn hmonitor_user_size64(param0: &u32, param1: u32, param2: &Hmonitor) -> u32 {
    // SAFETY: type is a thin type
    let param0 = unsafe { &*(param0 as *const _ as *const _) };
    let param1 = param1;
    // SAFETY: type is a thin type
    let param2 = unsafe { &*(param2 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Shell::HMONITOR_UserSize64(param0, param1, param2) };
    return_value
}
#[inline]
pub fn hmonitor_user_unmarshal(param0: &u32, param1: &u8, ) -> (&mut u8, Hmonitor) {
    let mut param2 = mem::MaybeUninit::zeroed();
    let param2 = param2.as_mut_ptr();
    // SAFETY: type is a thin type
    let param0 = unsafe { &*(param0 as *const _ as *const _) };
    // SAFETY: type is a thin type
    let param1 = unsafe { &*(param1 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Shell::HMONITOR_UserUnmarshal(param0, param1, param2) };
    let param2 = unsafe { Hmonitor::new(unsafe { param2.assume_init() }) };
    (return_value,param2)
}
#[inline]
pub fn hmonitor_user_unmarshal64(param0: &u32, param1: &u8, ) -> (&mut u8, Hmonitor) {
    let mut param2 = mem::MaybeUninit::zeroed();
    let param2 = param2.as_mut_ptr();
    // SAFETY: type is a thin type
    let param0 = unsafe { &*(param0 as *const _ as *const _) };
    // SAFETY: type is a thin type
    let param1 = unsafe { &*(param1 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Shell::HMONITOR_UserUnmarshal64(param0, param1, param2) };
    let param2 = unsafe { Hmonitor::new(unsafe { param2.assume_init() }) };
    (return_value,param2)
}
#[inline]
pub fn hash_data(pb_data: &[u8], cb_data: u32, ) -> (HRESULT, u8) {
    let mut pb_hash = mem::MaybeUninit::zeroed();
    let pbHash = pb_hash.as_mut_ptr();
    let pbData = pb_data.as_ptr() as _;
    let cbHash = pb_data.len() as _;
    let cbData = cb_data;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::HashData(pbData, cbData, pbHash, cbHash) };
    let pb_hash = unsafe { pbHash.assume_init() };
    (return_value,pbHash)
}
#[inline]
pub fn import_privacy_settings(psz_filename: &OsStr, pf_parse_privacy_preferences: BOOL, pf_parse_per_site_rules: BOOL) -> Result<(BOOL, BOOL, BOOL)> {
    let mut temp91: Vec<u16> = psz_filename.encode_wide().collect();
    temp91.push(0);
    let pszFilename = temp91.as_ptr() as _;
    let mut pfParsePrivacyPreferences = pf_parse_privacy_preferences;
    let mut pfParsePerSiteRules = pf_parse_per_site_rules;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ImportPrivacySettings(pszFilename, &mut pfParsePrivacyPreferences, &mut pfParsePerSiteRules) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pf_parse_per_site_rules = pfParsePerSiteRules;
    let pf_parse_privacy_preferences = pfParsePrivacyPreferences;
    Ok((return_value,pfParsePrivacyPreferences, pfParsePerSiteRules))
}
#[inline]
pub fn init_network_address_control() -> Result<BOOL> {
    let return_value = unsafe { windows_sys::Win32::UI::Shell::InitNetworkAddressControl() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn intl_str_eq_worker_a(f_case_sens: BOOL, lp_string1: &CStr, lp_string2: &CStr, n_char: i32) -> Result<BOOL> {
    let fCaseSens = f_case_sens;
    let lpString1 = lp_string1.as_ptr() as _;
    let lpString2 = lp_string2.as_ptr() as _;
    let nChar = n_char;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::IntlStrEqWorkerA(fCaseSens, lpString1, lpString2, nChar) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn intl_str_eq_worker_w(f_case_sens: BOOL, lp_string1: &OsStr, lp_string2: &OsStr, n_char: i32) -> Result<BOOL> {
    let fCaseSens = f_case_sens;
    let mut temp92: Vec<u16> = lp_string1.encode_wide().collect();
    temp92.push(0);
    let lpString1 = temp92.as_ptr() as _;
    let mut temp93: Vec<u16> = lp_string2.encode_wide().collect();
    temp93.push(0);
    let lpString2 = temp93.as_ptr() as _;
    let nChar = n_char;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::IntlStrEqWorkerW(fCaseSens, lpString1, lpString2, nChar) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn is_internet_esc_enabled() -> BOOL {
    let return_value = unsafe { windows_sys::Win32::UI::Shell::IsInternetESCEnabled() };
    return_value
}
#[inline]
pub fn is_lfn_drive_a(psz_path: Option<&CStr>) -> BOOL {
    let pszPath = psz_path.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::Shell::IsLFNDriveA(pszPath) };
    return_value
}
#[inline]
pub fn is_lfn_drive_w(psz_path: Option<&OsStr>) -> BOOL {
    let temp94 = psz_path.map(|val| {
        let mut temp94: Vec<u16> = val.encode_wide().collect();
        temp94.push(0);
        temp94
    });
    let pszPath = temp94.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::Shell::IsLFNDriveW(pszPath) };
    return_value
}
#[inline]
pub fn is_net_drive(i_drive: i32) -> Result<i32> {
    let iDrive = i_drive;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::IsNetDrive(iDrive) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn is_os(dw_os: u32) -> BOOL {
    let dwOS = dw_os;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::IsOS(dwOS) };
    return_value
}
#[inline]
pub fn is_user_an_admin() -> BOOL {
    let return_value = unsafe { windows_sys::Win32::UI::Shell::IsUserAnAdmin() };
    return_value
}
#[inline]
pub fn load_user_profile_a(h_token: Handle, lp_profile_info: Profileinfoa<'_>) -> Result<(BOOL, Profileinfoa<'_>)> {
    let hToken = h_token.into_raw();
    let mut lpProfileInfo = lp_profile_info.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::LoadUserProfileA(hToken, &mut lpProfileInfo) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_profile_info = unsafe { Profileinfoa::from_win32(lpProfileInfo) };
    Ok((return_value,lpProfileInfo))
}
#[inline]
pub fn load_user_profile_w(h_token: Handle, lp_profile_info: Profileinfow<'_>) -> Result<(BOOL, Profileinfow<'_>)> {
    let hToken = h_token.into_raw();
    let mut lpProfileInfo = lp_profile_info.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::LoadUserProfileW(hToken, &mut lpProfileInfo) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_profile_info = unsafe { Profileinfow::from_win32(lpProfileInfo) };
    Ok((return_value,lpProfileInfo))
}
#[inline]
pub fn parse_urla(pcsz_url: &CStr, ppu: Parsedurla<'_>) -> (HRESULT, Parsedurla<'_>) {
    let pcszURL = pcsz_url.as_ptr() as _;
    let mut ppu = ppu.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ParseURLA(pcszURL, &mut ppu) };
    let ppu = unsafe { Parsedurla::from_win32(ppu) };
    (return_value,ppu)
}
#[inline]
pub fn parse_urlw(pcsz_url: &OsStr, ppu: Parsedurlw<'_>) -> (HRESULT, Parsedurlw<'_>) {
    let mut temp95: Vec<u16> = pcsz_url.encode_wide().collect();
    temp95.push(0);
    let pcszURL = temp95.as_ptr() as _;
    let mut ppu = ppu.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ParseURLW(pcszURL, &mut ppu) };
    let ppu = unsafe { Parsedurlw::from_win32(ppu) };
    (return_value,ppu)
}
#[inline]
pub fn pick_icon_dlg(hwnd: Option<Hwnd>, psz_icon_path: &OsStr, cch_icon_path: u32, pi_icon_index: Option<i32>) -> Result<(i32, OsString, i32)> {
    let hwnd = hwnd.map_or(0, Hwnd::into_raw);
    let mut temp96: Vec<u16> = psz_icon_path.encode_wide().collect();
    temp96.push(0);
    let mut pszIconPath = temp96.as_ptr() as _;
    let cchIconPath = cch_icon_path;
    let mut piIconIndex = pi_icon_index;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::PickIconDlg(hwnd, &mut pszIconPath, cchIconPath, &mut piIconIndex) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pi_icon_index = piIconIndex;
    let out34 = unsafe {
        slice::from_raw_parts(pszIconPath, return_value as usize)
    };
    let out34 = out34.to_vec();
    let psz_icon_path = OsStringExt::from_wide(out34);
    Ok((return_value,pszIconPath, piIconIndex))
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn qi_search(that: todo_void, pqit: &Qitab<'_>, riid: &GUID, ) -> (HRESULT, todo_void_ret, &mut todo_void_ret) {
//      let mut ppv = mem::MaybeUninit::zeroed();
//      let ppv = ppv.as_mut_ptr();
//      let mut that = todo_void;
//      let temp97 = pqit.to_win32();
//      let pqit = &temp97;
//      // SAFETY: type is a thin type
//      let riid = unsafe { &*(riid as *const _ as *const _) };
//      let return_value = unsafe { windows_sys::Win32::UI::Shell::QISearch(&mut that, pqit, riid, ppv) };
//      let ppv = unsafe { &mut *(unsafe { ppv.assume_init() } as *mut _) };
//      let that = todo_void;
//      (return_value,that, ppv)
//  }
#[inline]
pub fn read_cabinet_state(c_length: i32) -> Result<(BOOL, Cabinetstate)> {
    let mut pcs = mem::MaybeUninit::zeroed();
    let pcs = pcs.as_mut_ptr();
    let cLength = c_length;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ReadCabinetState(pcs, cLength) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pcs = unsafe { Cabinetstate::from_win32(unsafe { pcs.assume_init() }) };
    Ok((return_value,pcs))
}
#[inline]
pub fn real_drive_type(i_drive: i32, f_ok_to_hit_net: BOOL) -> Result<i32> {
    let iDrive = i_drive;
    let fOKToHitNet = f_ok_to_hit_net;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::RealDriveType(iDrive, fOKToHitNet) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn remove_window_subclass<Subclassproc: FnMut(Hwnd, u32, Wparam, Lparam, ) -> Lresult>(h_wnd: Hwnd, pfn_subclass: Subclassproc, ) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    unsafe extern "system" fn subclassproc_impl(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM, param4: usize, param5: usize) -> LRESULT {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let input3 = unsafe { Lparam::from_inner(param3) };
            let closure = unsafe {
                &mut *(param4 as usize as *mut Subclassproc)
            };
            let return_value = closure(input0, input1, input2, input3, );
            let real_return_value = return_value.into_raw();
            real_return_value
        })
    }
    let pfnSubclass = Some(subclassproc_impl);
    let mut pfn_subclass = pfn_subclass;
    let uIdSubclass = (&mut pfn_subclass) as *mut _ as *mut _;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::RemoveWindowSubclass(hWnd, pfnSubclass, uIdSubclass) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn restart_dialog(hwnd: Option<Hwnd>, psz_prompt: Option<&OsStr>, dw_return: u32) -> Result<i32> {
    let hwnd = hwnd.map_or(0, Hwnd::into_raw);
    let temp98 = psz_prompt.map(|val| {
        let mut temp98: Vec<u16> = val.encode_wide().collect();
        temp98.push(0);
        temp98
    });
    let pszPrompt = temp98.map_or(ptr::null(), |v| v.as_ptr() as _);
    let dwReturn = dw_return;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::RestartDialog(hwnd, pszPrompt, dwReturn) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn restart_dialog_ex(hwnd: Option<Hwnd>, psz_prompt: Option<&OsStr>, dw_return: u32, dw_reason_code: u32) -> Result<i32> {
    let hwnd = hwnd.map_or(0, Hwnd::into_raw);
    let temp99 = psz_prompt.map(|val| {
        let mut temp99: Vec<u16> = val.encode_wide().collect();
        temp99.push(0);
        temp99
    });
    let pszPrompt = temp99.map_or(ptr::null(), |v| v.as_ptr() as _);
    let dwReturn = dw_return;
    let dwReasonCode = dw_reason_code;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::RestartDialogEx(hwnd, pszPrompt, dwReturn, dwReasonCode) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn revoke_scale_change_notifications(display_device: i32, dw_cookie: u32) -> HRESULT {
    let displayDevice = display_device;
    let dwCookie = dw_cookie;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::RevokeScaleChangeNotifications(displayDevice, dwCookie) };
    return_value
}
#[inline]
pub fn sh_add_from_prop_sheet_ext_array<Lpfnsvaddpropsheetpage: FnMut(Hpropsheetpage, ) -> BOOL>(hpsxa: Hpsxa, lpfn_add_page: Lpfnsvaddpropsheetpage, ) -> u32 {
    let hpsxa = hpsxa.into_raw();
    unsafe extern "system" fn lpfnsvaddpropsheetpage_impl(param0: HPROPSHEETPAGE, param1: LPARAM) -> BOOL {
        abort_on_panic(move || {
            let input0 = unsafe { Hpropsheetpage::new(param0) };
            let closure = unsafe {
                &mut *(param1 as usize as *mut Lpfnsvaddpropsheetpage)
            };
            let return_value = closure(input0, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpfnAddPage = Some(lpfnsvaddpropsheetpage_impl);
    let mut lpfn_add_page = lpfn_add_page;
    let lParam = unsafe { Lparam::from_ptr((&mut lpfn_add_page) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHAddFromPropSheetExtArray(hpsxa, lpfnAddPage, lParam) };
    return_value
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn sh_add_to_recent_docs(u_flags: u32, pv: Option<&todo_void>) -> () {
//      let uFlags = u_flags;
//      // SAFETY: type is a thin type
//      let pv = pv.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      let return_value = unsafe { windows_sys::Win32::UI::Shell::SHAddToRecentDocs(uFlags, pv) };
//      let _ = return_value;
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn sh_alloc(cb: usize) -> &mut todo_void_ret {
//      let cb = cb;
//      let return_value = unsafe { windows_sys::Win32::UI::Shell::SHAlloc(cb) };
//      return_value
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn sh_alloc_shared(pv_data: Option<&[todo_void]>, dw_process_id: u32) -> Result<Handle> {
//      let pvData = pv_data.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let dwSize = pv_data.len() as _;
//      let dwProcessId = dw_process_id;
//      let return_value = unsafe { windows_sys::Win32::UI::Shell::SHAllocShared(pvData, dwSize, dwProcessId) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
#[inline]
pub fn sh_app_bar_message(dw_message: u32, p_data: Appbardata) -> (usize, Appbardata) {
    let dwMessage = dw_message;
    let mut pData = p_data.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHAppBarMessage(dwMessage, &mut pData) };
    let p_data = unsafe { Appbardata::from_win32(pData) };
    (return_value,pData)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn sh_assoc_enum_handlers_for_protocol_by_application(protocol: &OsStr, riid: &GUID, ) -> (HRESULT, &mut todo_void_ret) {
//      let mut enum_handlers = mem::MaybeUninit::zeroed();
//      let enumHandlers = enum_handlers.as_mut_ptr();
//      let mut temp100: Vec<u16> = protocol.encode_wide().collect();
//      temp100.push(0);
//      let protocol = temp100.as_ptr() as _;
//      // SAFETY: type is a thin type
//      let riid = unsafe { &*(riid as *const _ as *const _) };
//      let return_value = unsafe { windows_sys::Win32::UI::Shell::SHAssocEnumHandlersForProtocolByApplication(protocol, riid, enumHandlers) };
//      let enum_handlers = unsafe { &mut *(unsafe { enumHandlers.assume_init() } as *mut _) };
//      (return_value,enumHandlers)
//  }
#[inline]
pub fn sh_auto_complete(hwnd_edit: Hwnd, dw_flags: u32) -> HRESULT {
    let hwndEdit = hwnd_edit.into_raw();
    let dwFlags = dw_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHAutoComplete(hwndEdit, dwFlags) };
    return_value
}
#[inline]
pub fn shclsid_from_string(psz: &OsStr, ) -> (HRESULT, GUID) {
    let mut pclsid = mem::MaybeUninit::zeroed();
    let pclsid = pclsid.as_mut_ptr();
    let mut temp101: Vec<u16> = psz.encode_wide().collect();
    temp101.push(0);
    let psz = temp101.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHCLSIDFromString(psz, pclsid) };
    let pclsid = unsafe { pclsid.assume_init() };
    (return_value,pclsid)
}
#[inline]
pub fn sh_empty_recycle_bin_a(hwnd: Option<Hwnd>, psz_root_path: Option<&CStr>, dw_flags: u32) -> HRESULT {
    let hwnd = hwnd.map_or(0, Hwnd::into_raw);
    let pszRootPath = psz_root_path.map_or(ptr::null(), |v| v.as_ptr() as _);
    let dwFlags = dw_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHEmptyRecycleBinA(hwnd, pszRootPath, dwFlags) };
    return_value
}
#[inline]
pub fn sh_empty_recycle_bin_w(hwnd: Option<Hwnd>, psz_root_path: Option<&OsStr>, dw_flags: u32) -> HRESULT {
    let hwnd = hwnd.map_or(0, Hwnd::into_raw);
    let temp102 = psz_root_path.map(|val| {
        let mut temp102: Vec<u16> = val.encode_wide().collect();
        temp102.push(0);
        temp102
    });
    let pszRootPath = temp102.map_or(ptr::null(), |v| v.as_ptr() as _);
    let dwFlags = dw_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHEmptyRecycleBinW(hwnd, pszRootPath, dwFlags) };
    return_value
}
#[inline]
pub fn sh_flush_sf_cache() -> () {
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHFlushSFCache() };
    let _ = return_value;
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn sh_free(pv: Option<&todo_void>) -> () {
//      // SAFETY: type is a thin type
//      let pv = pv.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      let return_value = unsafe { windows_sys::Win32::UI::Shell::SHFree(pv) };
//      let _ = return_value;
//  }
#[inline]
pub fn sh_free_name_mappings(h_name_mappings: Option<Handle>) -> () {
    let hNameMappings = h_name_mappings.map_or(0, Handle::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHFreeNameMappings(hNameMappings) };
    let _ = return_value;
}
#[inline]
pub fn sh_free_shared(h_data: Handle, dw_process_id: u32) -> Result<BOOL> {
    let hData = h_data.into_raw();
    let dwProcessId = dw_process_id;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHFreeShared(hData, dwProcessId) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn sh_global_counter_decrement(id: i32) -> Result<i32> {
    let id = id;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHGlobalCounterDecrement(id) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn sh_global_counter_get_value(id: i32) -> Result<i32> {
    let id = id;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHGlobalCounterGetValue(id) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn sh_global_counter_increment(id: i32) -> Result<i32> {
    let id = id;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHGlobalCounterIncrement(id) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn sh_invoke_printer_command_a(hwnd: Option<Hwnd>, u_action: u32, lp_buf1: &CStr, lp_buf2: Option<&CStr>, f_modal: BOOL) -> Result<BOOL> {
    let hwnd = hwnd.map_or(0, Hwnd::into_raw);
    let uAction = u_action;
    let lpBuf1 = lp_buf1.as_ptr() as _;
    let lpBuf2 = lp_buf2.map_or(ptr::null(), |v| v.as_ptr() as _);
    let fModal = f_modal;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHInvokePrinterCommandA(hwnd, uAction, lpBuf1, lpBuf2, fModal) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn sh_invoke_printer_command_w(hwnd: Option<Hwnd>, u_action: u32, lp_buf1: &OsStr, lp_buf2: Option<&OsStr>, f_modal: BOOL) -> Result<BOOL> {
    let hwnd = hwnd.map_or(0, Hwnd::into_raw);
    let uAction = u_action;
    let mut temp103: Vec<u16> = lp_buf1.encode_wide().collect();
    temp103.push(0);
    let lpBuf1 = temp103.as_ptr() as _;
    let temp104 = lp_buf2.map(|val| {
        let mut temp104: Vec<u16> = val.encode_wide().collect();
        temp104.push(0);
        temp104
    });
    let lpBuf2 = temp104.map_or(ptr::null(), |v| v.as_ptr() as _);
    let fModal = f_modal;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHInvokePrinterCommandW(hwnd, uAction, lpBuf1, lpBuf2, fModal) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn sh_is_file_available_offline(pwsz_path: &OsStr, ) -> (HRESULT, u32) {
    let mut pdw_status = mem::MaybeUninit::zeroed();
    let pdwStatus = pdw_status.as_mut_ptr();
    let mut temp105: Vec<u16> = pwsz_path.encode_wide().collect();
    temp105.push(0);
    let pwszPath = temp105.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHIsFileAvailableOffline(pwszPath, pdwStatus) };
    let pdw_status = unsafe { pdwStatus.assume_init() };
    (return_value,pdwStatus)
}
#[inline]
pub fn sh_is_low_memory_machine(dw_type: u32) -> BOOL {
    let dwType = dw_type;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHIsLowMemoryMachine(dwType) };
    return_value
}
#[inline]
pub fn sh_message_box_check_a(hwnd: Option<Hwnd>, psz_text: &CStr, psz_caption: &CStr, u_type: u32, i_default: i32, psz_reg_val: &CStr) -> Result<i32> {
    let hwnd = hwnd.map_or(0, Hwnd::into_raw);
    let pszText = psz_text.as_ptr() as _;
    let pszCaption = psz_caption.as_ptr() as _;
    let uType = u_type;
    let iDefault = i_default;
    let pszRegVal = psz_reg_val.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHMessageBoxCheckA(hwnd, pszText, pszCaption, uType, iDefault, pszRegVal) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn sh_message_box_check_w(hwnd: Option<Hwnd>, psz_text: &OsStr, psz_caption: &OsStr, u_type: u32, i_default: i32, psz_reg_val: &OsStr) -> Result<i32> {
    let hwnd = hwnd.map_or(0, Hwnd::into_raw);
    let mut temp106: Vec<u16> = psz_text.encode_wide().collect();
    temp106.push(0);
    let pszText = temp106.as_ptr() as _;
    let mut temp107: Vec<u16> = psz_caption.encode_wide().collect();
    temp107.push(0);
    let pszCaption = temp107.as_ptr() as _;
    let uType = u_type;
    let iDefault = i_default;
    let mut temp108: Vec<u16> = psz_reg_val.encode_wide().collect();
    temp108.push(0);
    let pszRegVal = temp108.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHMessageBoxCheckW(hwnd, pszText, pszCaption, uType, iDefault, pszRegVal) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn sh_object_properties(hwnd: Option<Hwnd>, shop_object_type: i32, psz_object_name: &OsStr, psz_property_page: Option<&OsStr>) -> Result<BOOL> {
    let hwnd = hwnd.map_or(0, Hwnd::into_raw);
    let shopObjectType = shop_object_type;
    let mut temp109: Vec<u16> = psz_object_name.encode_wide().collect();
    temp109.push(0);
    let pszObjectName = temp109.as_ptr() as _;
    let temp110 = psz_property_page.map(|val| {
        let mut temp110: Vec<u16> = val.encode_wide().collect();
        temp110.push(0);
        temp110
    });
    let pszPropertyPage = temp110.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHObjectProperties(hwnd, shopObjectType, pszObjectName, pszPropertyPage) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn sh_test_token_membership(h_token: Option<Handle>, ul_rid: u32) -> Result<BOOL> {
    let hToken = h_token.map_or(0, Handle::into_raw);
    let ulRID = ul_rid;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHTestTokenMembership(hToken, ulRID) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn sh_update_image_a(psz_hash_item: &CStr, i_index: i32, u_flags: u32, i_image_index: i32) -> () {
    let pszHashItem = psz_hash_item.as_ptr() as _;
    let iIndex = i_index;
    let uFlags = u_flags;
    let iImageIndex = i_image_index;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHUpdateImageA(pszHashItem, iIndex, uFlags, iImageIndex) };
    let _ = return_value;
}
#[inline]
pub fn sh_update_image_w(psz_hash_item: &OsStr, i_index: i32, u_flags: u32, i_image_index: i32) -> () {
    let mut temp111: Vec<u16> = psz_hash_item.encode_wide().collect();
    temp111.push(0);
    let pszHashItem = temp111.as_ptr() as _;
    let iIndex = i_index;
    let uFlags = u_flags;
    let iImageIndex = i_image_index;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHUpdateImageW(pszHashItem, iIndex, uFlags, iImageIndex) };
    let _ = return_value;
}
#[inline]
pub fn sh_validate_unc(hwnd_owner: Option<Hwnd>, psz_file: &OsStr, f_connect: i32) -> Result<(BOOL, OsString)> {
    let hwndOwner = hwnd_owner.map_or(0, Hwnd::into_raw);
    let mut temp112: Vec<u16> = psz_file.encode_wide().collect();
    temp112.push(0);
    let mut pszFile = temp112.as_ptr() as _;
    let fConnect = f_connect;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHValidateUNC(hwndOwner, &mut pszFile, fConnect) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let out35 = unsafe {
        slice::from_raw_parts(pszFile, return_value as usize)
    };
    let out35 = out35.to_vec();
    let psz_file = OsStringExt::from_wide(out35);
    Ok((return_value,pszFile))
}
#[inline]
pub fn set_current_process_explicit_app_user_model_id(app_id: &OsStr) -> HRESULT {
    let mut temp113: Vec<u16> = app_id.encode_wide().collect();
    temp113.push(0);
    let AppID = temp113.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SetCurrentProcessExplicitAppUserModelID(AppID) };
    return_value
}
#[inline]
pub fn set_menu_context_help_id(param0: Hmenu, param1: u32) -> Result<BOOL> {
    let param0 = param0.into_raw();
    let param1 = param1;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SetMenuContextHelpId(param0, param1) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_window_context_help_id(param0: Hwnd, param1: u32) -> Result<BOOL> {
    let param0 = param0.into_raw();
    let param1 = param1;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SetWindowContextHelpId(param0, param1) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_window_subclass<Subclassproc: FnMut(Hwnd, u32, Wparam, Lparam, ) -> Lresult>(h_wnd: Hwnd, pfn_subclass: Subclassproc, u_id_subclass: usize, ) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    unsafe extern "system" fn subclassproc_impl(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM, param4: usize, param5: usize) -> LRESULT {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let input3 = unsafe { Lparam::from_inner(param3) };
            let closure = unsafe {
                &mut *(param4 as usize as *mut Subclassproc)
            };
            let return_value = closure(input0, input1, input2, input3, );
            let real_return_value = return_value.into_raw();
            real_return_value
        })
    }
    let pfnSubclass = Some(subclassproc_impl);
    let mut pfn_subclass = pfn_subclass;
    let dwRefData = (&mut pfn_subclass) as *mut _ as *mut _;
    let uIdSubclass = u_id_subclass;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SetWindowSubclass(hWnd, pfnSubclass, uIdSubclass, dwRefData) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn shell_about_a(h_wnd: Option<Hwnd>, sz_app: &CStr, sz_other_stuff: Option<&CStr>, h_icon: Option<Hicon>) -> Result<i32> {
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let szApp = sz_app.as_ptr() as _;
    let szOtherStuff = sz_other_stuff.map_or(ptr::null(), |v| v.as_ptr() as _);
    let hIcon = h_icon.map_or(0, Hicon::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ShellAboutA(hWnd, szApp, szOtherStuff, hIcon) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn shell_about_w(h_wnd: Option<Hwnd>, sz_app: &OsStr, sz_other_stuff: Option<&OsStr>, h_icon: Option<Hicon>) -> Result<i32> {
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let mut temp114: Vec<u16> = sz_app.encode_wide().collect();
    temp114.push(0);
    let szApp = temp114.as_ptr() as _;
    let temp115 = sz_other_stuff.map(|val| {
        let mut temp115: Vec<u16> = val.encode_wide().collect();
        temp115.push(0);
        temp115
    });
    let szOtherStuff = temp115.map_or(ptr::null(), |v| v.as_ptr() as _);
    let hIcon = h_icon.map_or(0, Hicon::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ShellAboutW(hWnd, szApp, szOtherStuff, hIcon) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn shell_execute_a(hwnd: Option<Hwnd>, lp_operation: Option<&CStr>, lp_file: &CStr, lp_parameters: Option<&CStr>, lp_directory: Option<&CStr>, n_show_cmd: i32) -> Result<Hinstance> {
    let hwnd = hwnd.map_or(0, Hwnd::into_raw);
    let lpOperation = lp_operation.map_or(ptr::null(), |v| v.as_ptr() as _);
    let lpFile = lp_file.as_ptr() as _;
    let lpParameters = lp_parameters.map_or(ptr::null(), |v| v.as_ptr() as _);
    let lpDirectory = lp_directory.map_or(ptr::null(), |v| v.as_ptr() as _);
    let nShowCmd = n_show_cmd;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ShellExecuteA(hwnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn shell_execute_w(hwnd: Option<Hwnd>, lp_operation: Option<&OsStr>, lp_file: &OsStr, lp_parameters: Option<&OsStr>, lp_directory: Option<&OsStr>, n_show_cmd: i32) -> Result<Hinstance> {
    let hwnd = hwnd.map_or(0, Hwnd::into_raw);
    let temp116 = lp_operation.map(|val| {
        let mut temp116: Vec<u16> = val.encode_wide().collect();
        temp116.push(0);
        temp116
    });
    let lpOperation = temp116.map_or(ptr::null(), |v| v.as_ptr() as _);
    let mut temp117: Vec<u16> = lp_file.encode_wide().collect();
    temp117.push(0);
    let lpFile = temp117.as_ptr() as _;
    let temp118 = lp_parameters.map(|val| {
        let mut temp118: Vec<u16> = val.encode_wide().collect();
        temp118.push(0);
        temp118
    });
    let lpParameters = temp118.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp119 = lp_directory.map(|val| {
        let mut temp119: Vec<u16> = val.encode_wide().collect();
        temp119.push(0);
        temp119
    });
    let lpDirectory = temp119.map_or(ptr::null(), |v| v.as_ptr() as _);
    let nShowCmd = n_show_cmd;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ShellExecuteW(hwnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn shell_message_box_a(h_app_inst: Option<Hinstance>, h_wnd: Option<Hwnd>, lpc_text: &CStr, lpc_title: Option<&CStr>, fu_style: u32) -> Result<i32> {
    let hAppInst = h_app_inst.map_or(0, Hinstance::into_raw);
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let lpcText = lpc_text.as_ptr() as _;
    let lpcTitle = lpc_title.map_or(ptr::null(), |v| v.as_ptr() as _);
    let fuStyle = fu_style;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ShellMessageBoxA(hAppInst, hWnd, lpcText, lpcTitle, fuStyle) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn shell_message_box_w(h_app_inst: Option<Hinstance>, h_wnd: Option<Hwnd>, lpc_text: &OsStr, lpc_title: Option<&OsStr>, fu_style: u32) -> Result<i32> {
    let hAppInst = h_app_inst.map_or(0, Hinstance::into_raw);
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let mut temp120: Vec<u16> = lpc_text.encode_wide().collect();
    temp120.push(0);
    let lpcText = temp120.as_ptr() as _;
    let temp121 = lpc_title.map(|val| {
        let mut temp121: Vec<u16> = val.encode_wide().collect();
        temp121.push(0);
        temp121
    });
    let lpcTitle = temp121.map_or(ptr::null(), |v| v.as_ptr() as _);
    let fuStyle = fu_style;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ShellMessageBoxW(hAppInst, hWnd, lpcText, lpcTitle, fuStyle) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn shell_get_cached_image_index(pwsz_icon_path: &OsStr, i_icon_index: i32, u_icon_flags: u32) -> Result<i32> {
    let mut temp122: Vec<u16> = pwsz_icon_path.encode_wide().collect();
    temp122.push(0);
    let pwszIconPath = temp122.as_ptr() as _;
    let iIconIndex = i_icon_index;
    let uIconFlags = u_icon_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::Shell_GetCachedImageIndex(pwszIconPath, iIconIndex, uIconFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn shell_get_cached_image_index_a(psz_icon_path: &CStr, i_icon_index: i32, u_icon_flags: u32) -> Result<i32> {
    let pszIconPath = psz_icon_path.as_ptr() as _;
    let iIconIndex = i_icon_index;
    let uIconFlags = u_icon_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::Shell_GetCachedImageIndexA(pszIconPath, iIconIndex, uIconFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn shell_get_cached_image_index_w(psz_icon_path: &OsStr, i_icon_index: i32, u_icon_flags: u32) -> Result<i32> {
    let mut temp123: Vec<u16> = psz_icon_path.encode_wide().collect();
    temp123.push(0);
    let pszIconPath = temp123.as_ptr() as _;
    let iIconIndex = i_icon_index;
    let uIconFlags = u_icon_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::Shell_GetCachedImageIndexW(pszIconPath, iIconIndex, uIconFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn shell_merge_menus(hm_dst: Hmenu, hm_src: Hmenu, u_insert: u32, u_id_adjust: u32, u_id_adjust_max: u32, u_flags: u32) -> u32 {
    let hmDst = hm_dst.into_raw();
    let hmSrc = hm_src.into_raw();
    let uInsert = u_insert;
    let uIDAdjust = u_id_adjust;
    let uIDAdjustMax = u_id_adjust_max;
    let uFlags = u_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::Shell_MergeMenus(hmDst, hmSrc, uInsert, uIDAdjust, uIDAdjustMax, uFlags) };
    return_value
}
#[inline]
pub fn shell_notify_icon_a(dw_message: u32, lp_data: &Notifyicondataa) -> Result<BOOL> {
    let dwMessage = dw_message;
    let temp124 = lp_data.to_win32();
    let lpData = &temp124;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::Shell_NotifyIconA(dwMessage, lpData) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn shell_notify_icon_get_rect(identifier: &Notifyiconidentifier, ) -> (HRESULT, Rect) {
    let mut icon_location = mem::MaybeUninit::zeroed();
    let iconLocation = icon_location.as_mut_ptr();
    let temp125 = identifier.to_win32();
    let identifier = &temp125;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::Shell_NotifyIconGetRect(identifier, iconLocation) };
    let icon_location = unsafe { Rect::from_win32(unsafe { iconLocation.assume_init() }) };
    (return_value,iconLocation)
}
#[inline]
pub fn shell_notify_icon_w(dw_message: u32, lp_data: &Notifyicondataw) -> Result<BOOL> {
    let dwMessage = dw_message;
    let temp126 = lp_data.to_win32();
    let lpData = &temp126;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::Shell_NotifyIconW(dwMessage, lpData) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn unload_user_profile(h_token: Handle, h_profile: Handle) -> Result<BOOL> {
    let hToken = h_token.into_raw();
    let hProfile = h_profile.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::UnloadUserProfile(hToken, hProfile) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn unregister_app_constrained_change_notification(registration: AppconstrainRegistration) -> AppconstrainRegistration {
    let mut Registration = registration.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::UnregisterAppConstrainedChangeNotification(&mut Registration) };
    let registration = unsafe { AppconstrainRegistration::from_win32(Registration) };
    registration
}
#[inline]
pub fn unregister_app_state_change_notification(registration: AppstateRegistration) -> AppstateRegistration {
    let mut Registration = registration.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::UnregisterAppStateChangeNotification(&mut Registration) };
    let registration = unsafe { AppstateRegistration::from_win32(Registration) };
    registration
}
#[inline]
pub fn unregister_scale_change_event(dw_cookie: usize) -> HRESULT {
    let dwCookie = dw_cookie;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::UnregisterScaleChangeEvent(dwCookie) };
    return_value
}
#[inline]
pub fn which_platform() -> u32 {
    let return_value = unsafe { windows_sys::Win32::UI::Shell::WhichPlatform() };
    return_value
}
#[inline]
pub fn win32_delete_file(psz_path: &OsStr) -> Result<BOOL> {
    let mut temp127: Vec<u16> = psz_path.encode_wide().collect();
    temp127.push(0);
    let pszPath = temp127.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::Win32DeleteFile(pszPath) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn win_help_a(h_wnd_main: Option<Hwnd>, lpsz_help: Option<&CStr>, u_command: u32, dw_data: usize) -> Result<BOOL> {
    let hWndMain = h_wnd_main.map_or(0, Hwnd::into_raw);
    let lpszHelp = lpsz_help.map_or(ptr::null(), |v| v.as_ptr() as _);
    let uCommand = u_command;
    let dwData = dw_data;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::WinHelpA(hWndMain, lpszHelp, uCommand, dwData) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn win_help_w(h_wnd_main: Option<Hwnd>, lpsz_help: Option<&OsStr>, u_command: u32, dw_data: usize) -> Result<BOOL> {
    let hWndMain = h_wnd_main.map_or(0, Hwnd::into_raw);
    let temp128 = lpsz_help.map(|val| {
        let mut temp128: Vec<u16> = val.encode_wide().collect();
        temp128.push(0);
        temp128
    });
    let lpszHelp = temp128.map_or(ptr::null(), |v| v.as_ptr() as _);
    let uCommand = u_command;
    let dwData = dw_data;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::WinHelpW(hWndMain, lpszHelp, uCommand, dwData) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn write_cabinet_state(pcs: &Cabinetstate) -> Result<BOOL> {
    // SAFETY: type is a thin type
    let pcs = unsafe { &*(pcs as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Shell::WriteCabinetState(pcs) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn adjust_window_rect(lp_rect: Rect, dw_style: u32, b_menu: BOOL) -> Result<(BOOL, Rect)> {
    let mut lpRect = lp_rect.to_win32();
    let dwStyle = dw_style;
    let bMenu = b_menu;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::AdjustWindowRect(&mut lpRect, dwStyle, bMenu) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_rect = unsafe { Rect::from_win32(lpRect) };
    Ok((return_value,lpRect))
}
#[inline]
pub fn adjust_window_rect_ex(lp_rect: Rect, dw_style: u32, b_menu: BOOL, dw_ex_style: u32) -> Result<(BOOL, Rect)> {
    let mut lpRect = lp_rect.to_win32();
    let dwStyle = dw_style;
    let bMenu = b_menu;
    let dwExStyle = dw_ex_style;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::AdjustWindowRectEx(&mut lpRect, dwStyle, bMenu, dwExStyle) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_rect = unsafe { Rect::from_win32(lpRect) };
    Ok((return_value,lpRect))
}
#[inline]
pub fn allow_set_foreground_window(dw_process_id: u32) -> Result<BOOL> {
    let dwProcessId = dw_process_id;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::AllowSetForegroundWindow(dwProcessId) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn animate_window(h_wnd: Hwnd, dw_time: u32, dw_flags: u32) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let dwTime = dw_time;
    let dwFlags = dw_flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::AnimateWindow(hWnd, dwTime, dwFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn any_popup() -> Result<BOOL> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::AnyPopup() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn append_menu_a(h_menu: Hmenu, u_flags: u32, u_id_new_item: usize, lp_new_item: Option<&CStr>) -> Result<BOOL> {
    let hMenu = h_menu.into_raw();
    let uFlags = u_flags;
    let uIDNewItem = u_id_new_item;
    let lpNewItem = lp_new_item.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::AppendMenuA(hMenu, uFlags, uIDNewItem, lpNewItem) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn append_menu_w(h_menu: Hmenu, u_flags: u32, u_id_new_item: usize, lp_new_item: Option<&OsStr>) -> Result<BOOL> {
    let hMenu = h_menu.into_raw();
    let uFlags = u_flags;
    let uIDNewItem = u_id_new_item;
    let temp129 = lp_new_item.map(|val| {
        let mut temp129: Vec<u16> = val.encode_wide().collect();
        temp129.push(0);
        temp129
    });
    let lpNewItem = temp129.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::AppendMenuW(hMenu, uFlags, uIDNewItem, lpNewItem) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn arrange_iconic_windows(h_wnd: Hwnd) -> u32 {
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ArrangeIconicWindows(hWnd) };
    return_value
}
#[inline]
pub fn begin_defer_window_pos(n_num_windows: i32) -> isize {
    let nNumWindows = n_num_windows;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::BeginDeferWindowPos(nNumWindows) };
    return_value
}
#[inline]
pub fn bring_window_to_top(h_wnd: Hwnd) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::BringWindowToTop(hWnd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn calculate_popup_window_position(anchor_point: &Point, window_size: &Size, flags: u32, exclude_rect: Option<&Rect>, ) -> Result<(BOOL, Rect)> {
    let mut popup_window_position = mem::MaybeUninit::zeroed();
    let popupWindowPosition = popup_window_position.as_mut_ptr();
    // SAFETY: type is a thin type
    let anchorPoint = unsafe { &*(anchor_point as *const _ as *const _) };
    // SAFETY: type is a thin type
    let windowSize = unsafe { &*(window_size as *const _ as *const _) };
    let flags = flags;
    // SAFETY: type is a thin type
    let excludeRect = exclude_rect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CalculatePopupWindowPosition(anchorPoint, windowSize, flags, excludeRect, popupWindowPosition) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let popup_window_position = unsafe { Rect::from_win32(unsafe { popupWindowPosition.assume_init() }) };
    Ok((return_value,popupWindowPosition))
}
#[inline]
pub fn call_msg_filter_a(lp_msg: &[Msg], ) -> Result<BOOL> {
    let lpMsg = lp_msg.as_ptr() as _;
    let nCode = lp_msg.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CallMsgFilterA(lpMsg, nCode) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn call_msg_filter_w(lp_msg: &[Msg], ) -> Result<BOOL> {
    let lpMsg = lp_msg.as_ptr() as _;
    let nCode = lp_msg.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CallMsgFilterW(lpMsg, nCode) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn call_next_hook_ex(hhk: Option<Hhook>, n_code: i32, w_param: Wparam, l_param: Lparam) -> Result<Lresult> {
    let hhk = hhk.map_or(0, Hhook::into_raw);
    let nCode = n_code;
    let wParam = w_param.into_inner();
    let lParam = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CallNextHookEx(hhk, nCode, wParam, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn call_window_proc_a<Wndproc: FnMut(Hwnd, u32, Wparam, ) -> Lresult>(lp_prev_wnd_func: Wndproc, h_wnd: Hwnd, msg: u32, w_param: Wparam, ) -> Result<Lresult> {
    unsafe extern "system" fn wndproc_impl(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM) -> LRESULT {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let closure = unsafe {
                &mut *(param3 as usize as *mut Wndproc)
            };
            let return_value = closure(input0, input1, input2, );
            let real_return_value = return_value.into_raw();
            real_return_value
        })
    }
    let lpPrevWndFunc = Some(wndproc_impl);
    let mut lp_prev_wnd_func = lp_prev_wnd_func;
    let lParam = unsafe { Lparam::from_ptr((&mut lp_prev_wnd_func) as *mut _ as *mut _) };
    let hWnd = h_wnd.into_raw();
    let Msg = msg;
    let wParam = w_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CallWindowProcA(lpPrevWndFunc, hWnd, Msg, wParam, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn call_window_proc_w<Wndproc: FnMut(Hwnd, u32, Wparam, ) -> Lresult>(lp_prev_wnd_func: Wndproc, h_wnd: Hwnd, msg: u32, w_param: Wparam, ) -> Result<Lresult> {
    unsafe extern "system" fn wndproc_impl(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM) -> LRESULT {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let closure = unsafe {
                &mut *(param3 as usize as *mut Wndproc)
            };
            let return_value = closure(input0, input1, input2, );
            let real_return_value = return_value.into_raw();
            real_return_value
        })
    }
    let lpPrevWndFunc = Some(wndproc_impl);
    let mut lp_prev_wnd_func = lp_prev_wnd_func;
    let lParam = unsafe { Lparam::from_ptr((&mut lp_prev_wnd_func) as *mut _ as *mut _) };
    let hWnd = h_wnd.into_raw();
    let Msg = msg;
    let wParam = w_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CallWindowProcW(lpPrevWndFunc, hWnd, Msg, wParam, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn cancel_shutdown() -> Result<BOOL> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CancelShutdown() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn cascade_windows(hwnd_parent: Option<Hwnd>, w_how: u32, lp_rect: Option<&Rect>, lp_kids: Option<&[Hwnd]>) -> u16 {
    let hwndParent = hwnd_parent.map_or(0, Hwnd::into_raw);
    let wHow = w_how;
    // SAFETY: type is a thin type
    let lpRect = lp_rect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let lpKids = lp_kids.map_or(ptr::null(), |v| v.as_ptr() as _);
    let cKids = lp_kids.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CascadeWindows(hwndParent, wHow, lpRect, cKids, lpKids) };
    return_value
}
#[inline]
pub fn change_menu_a(h_menu: Hmenu, cmd: u32, lpsz_new_item: Option<&CStr>, cmd_insert: u32, flags: u32) -> Result<BOOL> {
    let hMenu = h_menu.into_raw();
    let cmd = cmd;
    let lpszNewItem = lpsz_new_item.map_or(ptr::null(), |v| v.as_ptr() as _);
    let cmdInsert = cmd_insert;
    let flags = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ChangeMenuA(hMenu, cmd, lpszNewItem, cmdInsert, flags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn change_menu_w(h_menu: Hmenu, cmd: u32, lpsz_new_item: Option<&OsStr>, cmd_insert: u32, flags: u32) -> Result<BOOL> {
    let hMenu = h_menu.into_raw();
    let cmd = cmd;
    let temp130 = lpsz_new_item.map(|val| {
        let mut temp130: Vec<u16> = val.encode_wide().collect();
        temp130.push(0);
        temp130
    });
    let lpszNewItem = temp130.map_or(ptr::null(), |v| v.as_ptr() as _);
    let cmdInsert = cmd_insert;
    let flags = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ChangeMenuW(hMenu, cmd, lpszNewItem, cmdInsert, flags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn change_window_message_filter(message: u32, dw_flag: u32) -> Result<BOOL> {
    let message = message;
    let dwFlag = dw_flag;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ChangeWindowMessageFilter(message, dwFlag) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn change_window_message_filter_ex(hwnd: Hwnd, message: u32, action: u32, p_change_filter_struct: Option<Changefilterstruct>) -> Result<(BOOL, Changefilterstruct)> {
    let hwnd = hwnd.into_raw();
    let message = message;
    let action = action;
    let mut pChangeFilterStruct = p_change_filter_struct.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ChangeWindowMessageFilterEx(hwnd, message, action, &mut pChangeFilterStruct) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let p_change_filter_struct = unsafe { Changefilterstruct::from_win32(pChangeFilterStruct) };
    Ok((return_value,pChangeFilterStruct))
}
#[inline]
pub fn check_menu_item(h_menu: Hmenu, u_id_check_item: u32, u_check: u32) -> u32 {
    let hMenu = h_menu.into_raw();
    let uIDCheckItem = u_id_check_item;
    let uCheck = u_check;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CheckMenuItem(hMenu, uIDCheckItem, uCheck) };
    return_value
}
#[inline]
pub fn check_menu_radio_item(hmenu: Hmenu, first: u32, last: u32, check: u32, flags: u32) -> Result<BOOL> {
    let hmenu = hmenu.into_raw();
    let first = first;
    let last = last;
    let check = check;
    let flags = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CheckMenuRadioItem(hmenu, first, last, check, flags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn child_window_from_point(h_wnd_parent: Hwnd, point: Point) -> Result<Hwnd> {
    let hWndParent = h_wnd_parent.into_raw();
    let Point = point.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ChildWindowFromPoint(hWndParent, Point) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn child_window_from_point_ex(hwnd: Hwnd, pt: Point, flags: u32) -> Result<Hwnd> {
    let hwnd = hwnd.into_raw();
    let pt = pt.to_win32();
    let flags = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ChildWindowFromPointEx(hwnd, pt, flags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn clip_cursor(lp_rect: Option<&Rect>) -> Result<BOOL> {
    // SAFETY: type is a thin type
    let lpRect = lp_rect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ClipCursor(lpRect) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn close_window(h_wnd: Hwnd) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CloseWindow(hWnd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn copy_accelerator_table_a(h_accel_src: Haccel, c_accel_entries: i32) -> Result<(i32, Accel)> {
    let mut lp_accel_dst = mem::MaybeUninit::zeroed();
    let lpAccelDst = lp_accel_dst.as_mut_ptr();
    let hAccelSrc = h_accel_src.into_raw();
    let cAccelEntries = c_accel_entries;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CopyAcceleratorTableA(hAccelSrc, lpAccelDst, cAccelEntries) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_accel_dst = unsafe { Accel::from_win32(unsafe { lpAccelDst.assume_init() }) };
    Ok((return_value,lpAccelDst))
}
#[inline]
pub fn copy_accelerator_table_w(h_accel_src: Haccel, c_accel_entries: i32) -> Result<(i32, Accel)> {
    let mut lp_accel_dst = mem::MaybeUninit::zeroed();
    let lpAccelDst = lp_accel_dst.as_mut_ptr();
    let hAccelSrc = h_accel_src.into_raw();
    let cAccelEntries = c_accel_entries;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CopyAcceleratorTableW(hAccelSrc, lpAccelDst, cAccelEntries) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_accel_dst = unsafe { Accel::from_win32(unsafe { lpAccelDst.assume_init() }) };
    Ok((return_value,lpAccelDst))
}
#[inline]
pub fn copy_icon(h_icon: Hicon) -> Result<Hicon> {
    let hIcon = h_icon.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CopyIcon(hIcon) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn copy_image(h: Handle, r#type: u32, cx: i32, cy: i32, flags: u32) -> Result<Handle> {
    let h = h.into_raw();
    let r#type = r#type;
    let cx = cx;
    let cy = cy;
    let flags = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CopyImage(h, r#type, cx, cy, flags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_accelerator_table_a(paccel: &[Accel], ) -> Result<Haccel> {
    let paccel = paccel.as_ptr() as _;
    let cAccel = paccel.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateAcceleratorTableA(paccel, cAccel) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_accelerator_table_w(paccel: &[Accel], ) -> Result<Haccel> {
    let paccel = paccel.as_ptr() as _;
    let cAccel = paccel.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateAcceleratorTableW(paccel, cAccel) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_caret(h_wnd: Hwnd, h_bitmap: Option<Hbitmap>, n_width: i32, n_height: i32) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let hBitmap = h_bitmap.map_or(0, Hbitmap::into_raw);
    let nWidth = n_width;
    let nHeight = n_height;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateCaret(hWnd, hBitmap, nWidth, nHeight) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn create_cursor(h_inst: Option<Hinstance>, x_hot_spot: i32, y_hot_spot: i32, pv_and_plane: &[todo_void], pv_xor_plane: &[todo_void]) -> Result<Hcursor> {
//      let hInst = h_inst.map_or(0, Hinstance::into_raw);
//      let xHotSpot = x_hot_spot;
//      let yHotSpot = y_hot_spot;
//      let pvANDPlane = pv_and_plane.as_ptr() as _;
//      let nWidth = pv_and_plane.len() as _;
//      let pvXORPlane = pv_xor_plane.as_ptr() as _;
//      let nHeight = pv_xor_plane.len() as _;
//      let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateCursor(hInst, xHotSpot, yHotSpot, nWidth, nHeight, pvANDPlane, pvXORPlane) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
#[inline]
pub fn create_dialog_indirect_param_a<Dlgproc: FnMut(Hwnd, u32, Wparam, ) -> isize>(h_instance: Option<Hinstance>, lp_template: &Dlgtemplate, h_wnd_parent: Option<Hwnd>, lp_dialog_func: Option<Dlgproc>, ) -> Result<Hwnd> {
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    // SAFETY: type is a thin type
    let lpTemplate = unsafe { &*(lp_template as *const _ as *const _) };
    let hWndParent = h_wnd_parent.map_or(0, Hwnd::into_raw);
    unsafe extern "system" fn dlgproc_impl(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM) -> isize {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let closure = unsafe {
                &mut *(param3 as usize as *mut Dlgproc)
            };
            let return_value = closure(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpDialogFunc = Some(dlgproc_impl);
    let mut lp_dialog_func = lp_dialog_func;
    let dwInitParam = unsafe { Lparam::from_ptr((&mut lp_dialog_func) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateDialogIndirectParamA(hInstance, lpTemplate, hWndParent, lpDialogFunc, dwInitParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_dialog_indirect_param_w<Dlgproc: FnMut(Hwnd, u32, Wparam, ) -> isize>(h_instance: Option<Hinstance>, lp_template: &Dlgtemplate, h_wnd_parent: Option<Hwnd>, lp_dialog_func: Option<Dlgproc>, ) -> Result<Hwnd> {
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    // SAFETY: type is a thin type
    let lpTemplate = unsafe { &*(lp_template as *const _ as *const _) };
    let hWndParent = h_wnd_parent.map_or(0, Hwnd::into_raw);
    unsafe extern "system" fn dlgproc_impl(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM) -> isize {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let closure = unsafe {
                &mut *(param3 as usize as *mut Dlgproc)
            };
            let return_value = closure(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpDialogFunc = Some(dlgproc_impl);
    let mut lp_dialog_func = lp_dialog_func;
    let dwInitParam = unsafe { Lparam::from_ptr((&mut lp_dialog_func) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateDialogIndirectParamW(hInstance, lpTemplate, hWndParent, lpDialogFunc, dwInitParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_dialog_param_a<Dlgproc: FnMut(Hwnd, u32, Wparam, ) -> isize>(h_instance: Option<Hinstance>, lp_template_name: &CStr, h_wnd_parent: Option<Hwnd>, lp_dialog_func: Option<Dlgproc>, ) -> Result<Hwnd> {
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    let lpTemplateName = lp_template_name.as_ptr() as _;
    let hWndParent = h_wnd_parent.map_or(0, Hwnd::into_raw);
    unsafe extern "system" fn dlgproc_impl(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM) -> isize {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let closure = unsafe {
                &mut *(param3 as usize as *mut Dlgproc)
            };
            let return_value = closure(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpDialogFunc = Some(dlgproc_impl);
    let mut lp_dialog_func = lp_dialog_func;
    let dwInitParam = unsafe { Lparam::from_ptr((&mut lp_dialog_func) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateDialogParamA(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_dialog_param_w<Dlgproc: FnMut(Hwnd, u32, Wparam, ) -> isize>(h_instance: Option<Hinstance>, lp_template_name: &OsStr, h_wnd_parent: Option<Hwnd>, lp_dialog_func: Option<Dlgproc>, ) -> Result<Hwnd> {
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    let mut temp131: Vec<u16> = lp_template_name.encode_wide().collect();
    temp131.push(0);
    let lpTemplateName = temp131.as_ptr() as _;
    let hWndParent = h_wnd_parent.map_or(0, Hwnd::into_raw);
    unsafe extern "system" fn dlgproc_impl(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM) -> isize {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let closure = unsafe {
                &mut *(param3 as usize as *mut Dlgproc)
            };
            let return_value = closure(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpDialogFunc = Some(dlgproc_impl);
    let mut lp_dialog_func = lp_dialog_func;
    let dwInitParam = unsafe { Lparam::from_ptr((&mut lp_dialog_func) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateDialogParamW(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_icon(h_instance: Option<Hinstance>, c_planes: u8, c_bits_pixel: u8, lpb_an_dbits: &[u8], lpb_xo_rbits: &[u8]) -> Result<Hicon> {
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    let cPlanes = c_planes;
    let cBitsPixel = c_bits_pixel;
    let lpbANDbits = lpb_an_dbits.as_ptr() as _;
    let nWidth = lpb_an_dbits.len() as _;
    let lpbXORbits = lpb_xo_rbits.as_ptr() as _;
    let nHeight = lpb_xo_rbits.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateIcon(hInstance, nWidth, nHeight, cPlanes, cBitsPixel, lpbANDbits, lpbXORbits) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_icon_from_resource(presbits: &[u8], f_icon: BOOL, dw_ver: u32) -> Result<Hicon> {
    let presbits = presbits.as_ptr() as _;
    let dwResSize = presbits.len() as _;
    let fIcon = f_icon;
    let dwVer = dw_ver;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateIconFromResource(presbits, dwResSize, fIcon, dwVer) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_icon_from_resource_ex(presbits: &[u8], f_icon: BOOL, dw_ver: u32, cx_desired: i32, cy_desired: i32, flags: u32) -> Result<Hicon> {
    let presbits = presbits.as_ptr() as _;
    let dwResSize = presbits.len() as _;
    let fIcon = f_icon;
    let dwVer = dw_ver;
    let cxDesired = cx_desired;
    let cyDesired = cy_desired;
    let Flags = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateIconFromResourceEx(presbits, dwResSize, fIcon, dwVer, cxDesired, cyDesired, Flags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_icon_indirect(piconinfo: &Iconinfo) -> Result<Hicon> {
    // SAFETY: type is a thin type
    let piconinfo = unsafe { &*(piconinfo as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateIconIndirect(piconinfo) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_mdi_window_a(lp_class_name: &CStr, lp_window_name: &CStr, dw_style: u32, x: i32, y: i32, n_width: i32, n_height: i32, h_wnd_parent: Option<Hwnd>, h_instance: Option<Hinstance>, l_param: Lparam) -> Result<Hwnd> {
    let lpClassName = lp_class_name.as_ptr() as _;
    let lpWindowName = lp_window_name.as_ptr() as _;
    let dwStyle = dw_style;
    let X = x;
    let Y = y;
    let nWidth = n_width;
    let nHeight = n_height;
    let hWndParent = h_wnd_parent.map_or(0, Hwnd::into_raw);
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    let lParam = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateMDIWindowA(lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hInstance, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_mdi_window_w(lp_class_name: &OsStr, lp_window_name: &OsStr, dw_style: u32, x: i32, y: i32, n_width: i32, n_height: i32, h_wnd_parent: Option<Hwnd>, h_instance: Option<Hinstance>, l_param: Lparam) -> Result<Hwnd> {
    let mut temp132: Vec<u16> = lp_class_name.encode_wide().collect();
    temp132.push(0);
    let lpClassName = temp132.as_ptr() as _;
    let mut temp133: Vec<u16> = lp_window_name.encode_wide().collect();
    temp133.push(0);
    let lpWindowName = temp133.as_ptr() as _;
    let dwStyle = dw_style;
    let X = x;
    let Y = y;
    let nWidth = n_width;
    let nHeight = n_height;
    let hWndParent = h_wnd_parent.map_or(0, Hwnd::into_raw);
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    let lParam = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateMDIWindowW(lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hInstance, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_menu() -> Result<Hmenu> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateMenu() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn create_popup_menu() -> Result<Hmenu> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreatePopupMenu() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn create_resource_indexer(project_root: &OsStr, extension_dll_path: Option<&OsStr>, ) -> (HRESULT, &mut todo_void_ret) {
//      let mut pp_resource_indexer = mem::MaybeUninit::zeroed();
//      let ppResourceIndexer = pp_resource_indexer.as_mut_ptr();
//      let mut temp134: Vec<u16> = project_root.encode_wide().collect();
//      temp134.push(0);
//      let projectRoot = temp134.as_ptr() as _;
//      let temp135 = extension_dll_path.map(|val| {
//          let mut temp135: Vec<u16> = val.encode_wide().collect();
//          temp135.push(0);
//          temp135
//      });
//      let extensionDllPath = temp135.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateResourceIndexer(projectRoot, extensionDllPath, ppResourceIndexer) };
//      let pp_resource_indexer = unsafe { &mut *(unsafe { ppResourceIndexer.assume_init() } as *mut _) };
//      (return_value,ppResourceIndexer)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn create_window_ex_a(dw_ex_style: u32, lp_class_name: Option<&CStr>, lp_window_name: Option<&CStr>, dw_style: u32, x: i32, y: i32, n_width: i32, h_wnd_parent: Option<Hwnd>, h_menu: Option<Hmenu>, h_instance: Option<Hinstance>, lp_param: Option<&[todo_void]>) -> Result<Hwnd> {
//      let dwExStyle = dw_ex_style;
//      let lpClassName = lp_class_name.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let lpWindowName = lp_window_name.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let dwStyle = dw_style;
//      let X = x;
//      let Y = y;
//      let nWidth = n_width;
//      let hWndParent = h_wnd_parent.map_or(0, Hwnd::into_raw);
//      let hMenu = h_menu.map_or(0, Hmenu::into_raw);
//      let hInstance = h_instance.map_or(0, Hinstance::into_raw);
//      let lpParam = lp_param.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let nHeight = lp_param.len() as _;
//      let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateWindowExA(dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn create_window_ex_w(dw_ex_style: u32, lp_class_name: Option<&OsStr>, lp_window_name: Option<&OsStr>, dw_style: u32, x: i32, y: i32, n_width: i32, h_wnd_parent: Option<Hwnd>, h_menu: Option<Hmenu>, h_instance: Option<Hinstance>, lp_param: Option<&[todo_void]>) -> Result<Hwnd> {
//      let dwExStyle = dw_ex_style;
//      let temp136 = lp_class_name.map(|val| {
//          let mut temp136: Vec<u16> = val.encode_wide().collect();
//          temp136.push(0);
//          temp136
//      });
//      let lpClassName = temp136.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let temp137 = lp_window_name.map(|val| {
//          let mut temp137: Vec<u16> = val.encode_wide().collect();
//          temp137.push(0);
//          temp137
//      });
//      let lpWindowName = temp137.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let dwStyle = dw_style;
//      let X = x;
//      let Y = y;
//      let nWidth = n_width;
//      let hWndParent = h_wnd_parent.map_or(0, Hwnd::into_raw);
//      let hMenu = h_menu.map_or(0, Hmenu::into_raw);
//      let hInstance = h_instance.map_or(0, Hinstance::into_raw);
//      let lpParam = lp_param.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let nHeight = lp_param.len() as _;
//      let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateWindowExW(dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
#[inline]
pub fn def_dlg_proc_a(h_dlg: Hwnd, msg: u32, w_param: Wparam, l_param: Lparam) -> Result<Lresult> {
    let hDlg = h_dlg.into_raw();
    let Msg = msg;
    let wParam = w_param.into_inner();
    let lParam = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DefDlgProcA(hDlg, Msg, wParam, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn def_dlg_proc_w(h_dlg: Hwnd, msg: u32, w_param: Wparam, l_param: Lparam) -> Result<Lresult> {
    let hDlg = h_dlg.into_raw();
    let Msg = msg;
    let wParam = w_param.into_inner();
    let lParam = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DefDlgProcW(hDlg, Msg, wParam, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn def_frame_proc_a(h_wnd: Hwnd, h_wnd_mdi_client: Option<Hwnd>, u_msg: u32, w_param: Wparam, l_param: Lparam) -> Result<Lresult> {
    let hWnd = h_wnd.into_raw();
    let hWndMDIClient = h_wnd_mdi_client.map_or(0, Hwnd::into_raw);
    let uMsg = u_msg;
    let wParam = w_param.into_inner();
    let lParam = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DefFrameProcA(hWnd, hWndMDIClient, uMsg, wParam, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn def_frame_proc_w(h_wnd: Hwnd, h_wnd_mdi_client: Option<Hwnd>, u_msg: u32, w_param: Wparam, l_param: Lparam) -> Result<Lresult> {
    let hWnd = h_wnd.into_raw();
    let hWndMDIClient = h_wnd_mdi_client.map_or(0, Hwnd::into_raw);
    let uMsg = u_msg;
    let wParam = w_param.into_inner();
    let lParam = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DefFrameProcW(hWnd, hWndMDIClient, uMsg, wParam, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn def_mdi_child_proc_a(h_wnd: Hwnd, u_msg: u32, w_param: Wparam, l_param: Lparam) -> Result<Lresult> {
    let hWnd = h_wnd.into_raw();
    let uMsg = u_msg;
    let wParam = w_param.into_inner();
    let lParam = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DefMDIChildProcA(hWnd, uMsg, wParam, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn def_mdi_child_proc_w(h_wnd: Hwnd, u_msg: u32, w_param: Wparam, l_param: Lparam) -> Result<Lresult> {
    let hWnd = h_wnd.into_raw();
    let uMsg = u_msg;
    let wParam = w_param.into_inner();
    let lParam = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DefMDIChildProcW(hWnd, uMsg, wParam, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn def_window_proc_a(h_wnd: Hwnd, msg: u32, w_param: Wparam, l_param: Lparam) -> Result<Lresult> {
    let hWnd = h_wnd.into_raw();
    let Msg = msg;
    let wParam = w_param.into_inner();
    let lParam = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DefWindowProcA(hWnd, Msg, wParam, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn def_window_proc_w(h_wnd: Hwnd, msg: u32, w_param: Wparam, l_param: Lparam) -> Result<Lresult> {
    let hWnd = h_wnd.into_raw();
    let Msg = msg;
    let wParam = w_param.into_inner();
    let lParam = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DefWindowProcW(hWnd, Msg, wParam, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn defer_window_pos(h_win_pos_info: isize, h_wnd: Hwnd, h_wnd_insert_after: Option<Hwnd>, x: i32, y: i32, cx: i32, cy: i32, u_flags: u32) -> isize {
    let hWinPosInfo = h_win_pos_info;
    let hWnd = h_wnd.into_raw();
    let hWndInsertAfter = h_wnd_insert_after.map_or(0, Hwnd::into_raw);
    let x = x;
    let y = y;
    let cx = cx;
    let cy = cy;
    let uFlags = u_flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DeferWindowPos(hWinPosInfo, hWnd, hWndInsertAfter, x, y, cx, cy, uFlags) };
    return_value
}
#[inline]
pub fn delete_menu(h_menu: Hmenu, u_position: u32, u_flags: u32) -> Result<BOOL> {
    let hMenu = h_menu.into_raw();
    let uPosition = u_position;
    let uFlags = u_flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DeleteMenu(hMenu, uPosition, uFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn deregister_shell_hook_window(hwnd: Hwnd) -> Result<BOOL> {
    let hwnd = hwnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DeregisterShellHookWindow(hwnd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn destroy_accelerator_table(h_accel: Haccel) -> Result<BOOL> {
    let hAccel = h_accel.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DestroyAcceleratorTable(hAccel) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn destroy_caret() -> Result<BOOL> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DestroyCaret() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn destroy_cursor(h_cursor: Hcursor) -> Result<BOOL> {
    let hCursor = h_cursor.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DestroyCursor(hCursor) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn destroy_icon(h_icon: Hicon) -> Result<BOOL> {
    let hIcon = h_icon.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DestroyIcon(hIcon) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn destroy_menu(h_menu: Hmenu) -> Result<BOOL> {
    let hMenu = h_menu.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DestroyMenu(hMenu) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn destroy_resource_indexer(resource_indexer: Option<&todo_void>) -> () {
//      // SAFETY: type is a thin type
//      let resourceIndexer = resource_indexer.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DestroyResourceIndexer(resourceIndexer) };
//      let _ = return_value;
//  }
#[inline]
pub fn destroy_window(h_wnd: Hwnd) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DestroyWindow(hWnd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn dialog_box_indirect_param_a<Dlgproc: FnMut(Hwnd, u32, Wparam, ) -> isize>(h_instance: Option<Hinstance>, h_dialog_template: &Dlgtemplate, h_wnd_parent: Option<Hwnd>, lp_dialog_func: Option<Dlgproc>, ) -> isize {
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    // SAFETY: type is a thin type
    let hDialogTemplate = unsafe { &*(h_dialog_template as *const _ as *const _) };
    let hWndParent = h_wnd_parent.map_or(0, Hwnd::into_raw);
    unsafe extern "system" fn dlgproc_impl(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM) -> isize {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let closure = unsafe {
                &mut *(param3 as usize as *mut Dlgproc)
            };
            let return_value = closure(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpDialogFunc = Some(dlgproc_impl);
    let mut lp_dialog_func = lp_dialog_func;
    let dwInitParam = unsafe { Lparam::from_ptr((&mut lp_dialog_func) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DialogBoxIndirectParamA(hInstance, hDialogTemplate, hWndParent, lpDialogFunc, dwInitParam) };
    return_value
}
#[inline]
pub fn dialog_box_indirect_param_w<Dlgproc: FnMut(Hwnd, u32, Wparam, ) -> isize>(h_instance: Option<Hinstance>, h_dialog_template: &Dlgtemplate, h_wnd_parent: Option<Hwnd>, lp_dialog_func: Option<Dlgproc>, ) -> isize {
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    // SAFETY: type is a thin type
    let hDialogTemplate = unsafe { &*(h_dialog_template as *const _ as *const _) };
    let hWndParent = h_wnd_parent.map_or(0, Hwnd::into_raw);
    unsafe extern "system" fn dlgproc_impl(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM) -> isize {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let closure = unsafe {
                &mut *(param3 as usize as *mut Dlgproc)
            };
            let return_value = closure(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpDialogFunc = Some(dlgproc_impl);
    let mut lp_dialog_func = lp_dialog_func;
    let dwInitParam = unsafe { Lparam::from_ptr((&mut lp_dialog_func) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DialogBoxIndirectParamW(hInstance, hDialogTemplate, hWndParent, lpDialogFunc, dwInitParam) };
    return_value
}
#[inline]
pub fn dialog_box_param_a<Dlgproc: FnMut(Hwnd, u32, Wparam, ) -> isize>(h_instance: Option<Hinstance>, lp_template_name: &CStr, h_wnd_parent: Option<Hwnd>, lp_dialog_func: Option<Dlgproc>, ) -> isize {
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    let lpTemplateName = lp_template_name.as_ptr() as _;
    let hWndParent = h_wnd_parent.map_or(0, Hwnd::into_raw);
    unsafe extern "system" fn dlgproc_impl(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM) -> isize {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let closure = unsafe {
                &mut *(param3 as usize as *mut Dlgproc)
            };
            let return_value = closure(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpDialogFunc = Some(dlgproc_impl);
    let mut lp_dialog_func = lp_dialog_func;
    let dwInitParam = unsafe { Lparam::from_ptr((&mut lp_dialog_func) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DialogBoxParamA(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam) };
    return_value
}
#[inline]
pub fn dialog_box_param_w<Dlgproc: FnMut(Hwnd, u32, Wparam, ) -> isize>(h_instance: Option<Hinstance>, lp_template_name: &OsStr, h_wnd_parent: Option<Hwnd>, lp_dialog_func: Option<Dlgproc>, ) -> isize {
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    let mut temp138: Vec<u16> = lp_template_name.encode_wide().collect();
    temp138.push(0);
    let lpTemplateName = temp138.as_ptr() as _;
    let hWndParent = h_wnd_parent.map_or(0, Hwnd::into_raw);
    unsafe extern "system" fn dlgproc_impl(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM) -> isize {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let closure = unsafe {
                &mut *(param3 as usize as *mut Dlgproc)
            };
            let return_value = closure(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpDialogFunc = Some(dlgproc_impl);
    let mut lp_dialog_func = lp_dialog_func;
    let dwInitParam = unsafe { Lparam::from_ptr((&mut lp_dialog_func) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DialogBoxParamW(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam) };
    return_value
}
#[inline]
pub fn disable_process_windows_ghosting() -> () {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DisableProcessWindowsGhosting() };
    let _ = return_value;
}
#[inline]
pub fn dispatch_message_a(lp_msg: &Msg) -> Result<Lresult> {
    // SAFETY: type is a thin type
    let lpMsg = unsafe { &*(lp_msg as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DispatchMessageA(lpMsg) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn dispatch_message_w(lp_msg: &Msg) -> Result<Lresult> {
    // SAFETY: type is a thin type
    let lpMsg = unsafe { &*(lp_msg as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DispatchMessageW(lpMsg) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn drag_object(hwnd_parent: Hwnd, hwnd_from: Hwnd, fmt: u32, data: usize, hcur: Option<Hcursor>) -> u32 {
    let hwndParent = hwnd_parent.into_raw();
    let hwndFrom = hwnd_from.into_raw();
    let fmt = fmt;
    let data = data;
    let hcur = hcur.map_or(0, Hcursor::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DragObject(hwndParent, hwndFrom, fmt, data, hcur) };
    return_value
}
#[inline]
pub fn draw_icon(h_dc: Hdc, x: i32, y: i32, h_icon: Hicon) -> Result<BOOL> {
    let hDC = h_dc.into_raw();
    let X = x;
    let Y = y;
    let hIcon = h_icon.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DrawIcon(hDC, X, Y, hIcon) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn draw_icon_ex(hdc: Hdc, x_left: i32, y_top: i32, h_icon: Hicon, cx_width: i32, cy_width: i32, istep_if_ani_cur: u32, hbr_flicker_free_draw: Option<Hbrush>, di_flags: u32) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let xLeft = x_left;
    let yTop = y_top;
    let hIcon = h_icon.into_raw();
    let cxWidth = cx_width;
    let cyWidth = cy_width;
    let istepIfAniCur = istep_if_ani_cur;
    let hbrFlickerFreeDraw = hbr_flicker_free_draw.map_or(0, Hbrush::into_raw);
    let diFlags = di_flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DrawIconEx(hdc, xLeft, yTop, hIcon, cxWidth, cyWidth, istepIfAniCur, hbrFlickerFreeDraw, diFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn draw_menu_bar(h_wnd: Hwnd) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DrawMenuBar(hWnd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enable_menu_item(h_menu: Hmenu, u_id_enable_item: u32, u_enable: u32) -> Result<BOOL> {
    let hMenu = h_menu.into_raw();
    let uIDEnableItem = u_id_enable_item;
    let uEnable = u_enable;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::EnableMenuItem(hMenu, uIDEnableItem, uEnable) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn end_defer_window_pos(h_win_pos_info: isize) -> Result<BOOL> {
    let hWinPosInfo = h_win_pos_info;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::EndDeferWindowPos(hWinPosInfo) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn end_dialog(h_dlg: Hwnd, n_result: isize) -> Result<BOOL> {
    let hDlg = h_dlg.into_raw();
    let nResult = n_result;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::EndDialog(hDlg, nResult) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn end_menu() -> Result<BOOL> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::EndMenu() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_child_windows<Wndenumproc: FnMut(Hwnd, ) -> BOOL>(h_wnd_parent: Option<Hwnd>, lp_enum_func: Wndenumproc, ) -> Result<BOOL> {
    let hWndParent = h_wnd_parent.map_or(0, Hwnd::into_raw);
    unsafe extern "system" fn wndenumproc_impl(param0: HWND, param1: LPARAM) -> BOOL {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let closure = unsafe {
                &mut *(param1 as usize as *mut Wndenumproc)
            };
            let return_value = closure(input0, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpEnumFunc = Some(wndenumproc_impl);
    let mut lp_enum_func = lp_enum_func;
    let lParam = unsafe { Lparam::from_ptr((&mut lp_enum_func) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::EnumChildWindows(hWndParent, lpEnumFunc, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_props_a(h_wnd: Hwnd, lp_enum_func: Option<unsafe extern "system" fn(HWND, PCSTR, HANDLE) -> BOOL>) -> Result<i32> {
    let hWnd = h_wnd.into_raw();
    let lpEnumFunc = lp_enum_func;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::EnumPropsA(hWnd, lpEnumFunc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_props_ex_a(h_wnd: Hwnd, lp_enum_func: Option<unsafe extern "system" fn(HWND, PCSTR, HANDLE, usize) -> BOOL>, l_param: Lparam) -> Result<i32> {
    let hWnd = h_wnd.into_raw();
    let lpEnumFunc = lp_enum_func;
    let lParam = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::EnumPropsExA(hWnd, lpEnumFunc, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_props_ex_w(h_wnd: Hwnd, lp_enum_func: Option<unsafe extern "system" fn(HWND, PCWSTR, HANDLE, usize) -> BOOL>, l_param: Lparam) -> Result<i32> {
    let hWnd = h_wnd.into_raw();
    let lpEnumFunc = lp_enum_func;
    let lParam = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::EnumPropsExW(hWnd, lpEnumFunc, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_props_w(h_wnd: Hwnd, lp_enum_func: Option<unsafe extern "system" fn(HWND, PCWSTR, HANDLE) -> BOOL>) -> Result<i32> {
    let hWnd = h_wnd.into_raw();
    let lpEnumFunc = lp_enum_func;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::EnumPropsW(hWnd, lpEnumFunc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_thread_windows<Wndenumproc: FnMut(Hwnd, ) -> BOOL>(dw_thread_id: u32, lpfn: Wndenumproc, ) -> Result<BOOL> {
    let dwThreadId = dw_thread_id;
    unsafe extern "system" fn wndenumproc_impl(param0: HWND, param1: LPARAM) -> BOOL {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let closure = unsafe {
                &mut *(param1 as usize as *mut Wndenumproc)
            };
            let return_value = closure(input0, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpfn = Some(wndenumproc_impl);
    let mut lpfn = lpfn;
    let lParam = unsafe { Lparam::from_ptr((&mut lpfn) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::EnumThreadWindows(dwThreadId, lpfn, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_windows<Wndenumproc: FnMut(Hwnd, ) -> BOOL>(lp_enum_func: Wndenumproc, ) -> Result<BOOL> {
    unsafe extern "system" fn wndenumproc_impl(param0: HWND, param1: LPARAM) -> BOOL {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let closure = unsafe {
                &mut *(param1 as usize as *mut Wndenumproc)
            };
            let return_value = closure(input0, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpEnumFunc = Some(wndenumproc_impl);
    let mut lp_enum_func = lp_enum_func;
    let lParam = unsafe { Lparam::from_ptr((&mut lp_enum_func) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::EnumWindows(lpEnumFunc, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn find_window_a(lp_class_name: Option<&CStr>, lp_window_name: Option<&CStr>) -> Result<Hwnd> {
    let lpClassName = lp_class_name.map_or(ptr::null(), |v| v.as_ptr() as _);
    let lpWindowName = lp_window_name.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::FindWindowA(lpClassName, lpWindowName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn find_window_ex_a(h_wnd_parent: Option<Hwnd>, h_wnd_child_after: Option<Hwnd>, lpsz_class: Option<&CStr>, lpsz_window: Option<&CStr>) -> Result<Hwnd> {
    let hWndParent = h_wnd_parent.map_or(0, Hwnd::into_raw);
    let hWndChildAfter = h_wnd_child_after.map_or(0, Hwnd::into_raw);
    let lpszClass = lpsz_class.map_or(ptr::null(), |v| v.as_ptr() as _);
    let lpszWindow = lpsz_window.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::FindWindowExA(hWndParent, hWndChildAfter, lpszClass, lpszWindow) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn find_window_ex_w(h_wnd_parent: Option<Hwnd>, h_wnd_child_after: Option<Hwnd>, lpsz_class: Option<&OsStr>, lpsz_window: Option<&OsStr>) -> Result<Hwnd> {
    let hWndParent = h_wnd_parent.map_or(0, Hwnd::into_raw);
    let hWndChildAfter = h_wnd_child_after.map_or(0, Hwnd::into_raw);
    let temp139 = lpsz_class.map(|val| {
        let mut temp139: Vec<u16> = val.encode_wide().collect();
        temp139.push(0);
        temp139
    });
    let lpszClass = temp139.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp140 = lpsz_window.map(|val| {
        let mut temp140: Vec<u16> = val.encode_wide().collect();
        temp140.push(0);
        temp140
    });
    let lpszWindow = temp140.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::FindWindowExW(hWndParent, hWndChildAfter, lpszClass, lpszWindow) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn find_window_w(lp_class_name: Option<&OsStr>, lp_window_name: Option<&OsStr>) -> Result<Hwnd> {
    let temp141 = lp_class_name.map(|val| {
        let mut temp141: Vec<u16> = val.encode_wide().collect();
        temp141.push(0);
        temp141
    });
    let lpClassName = temp141.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp142 = lp_window_name.map(|val| {
        let mut temp142: Vec<u16> = val.encode_wide().collect();
        temp142.push(0);
        temp142
    });
    let lpWindowName = temp142.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::FindWindowW(lpClassName, lpWindowName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn flash_window(h_wnd: Hwnd, b_invert: BOOL) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let bInvert = b_invert;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::FlashWindow(hWnd, bInvert) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn flash_window_ex(pfwi: &Flashwinfo) -> Result<BOOL> {
    let temp143 = pfwi.to_win32();
    let pfwi = &temp143;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::FlashWindowEx(pfwi) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_alt_tab_info_a(hwnd: Option<Hwnd>, i_item: i32, pati: Alttabinfo, cch_item_text: u32) -> Result<(BOOL, Alttabinfo, CString)> {
    let mut psz_item_text = Vec::<u8>::with_capacity(cch_item_text as usize + 1);
    let pszItemText = psz_item_text.as_mut_ptr();
    let hwnd = hwnd.map_or(0, Hwnd::into_raw);
    let iItem = i_item;
    let mut pati = pati.to_win32();
    let cchItemText = cch_item_text;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetAltTabInfoA(hwnd, iItem, &mut pati, pszItemText, cchItemText) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let out36 = unsafe {
        slice::from_raw_parts(unsafe { pszItemText.assume_init() }, return_value as usize)
    };
    let mut out36 = out36.to_vec();
    out36.push(0);
    let psz_item_text = unsafe { CString::from_vec_unchecked(out36) };
    let pati = unsafe { Alttabinfo::from_win32(pati) };
    Ok((return_value,pati, pszItemText))
}
#[inline]
pub fn get_alt_tab_info_w(hwnd: Option<Hwnd>, i_item: i32, pati: Alttabinfo, cch_item_text: u32) -> Result<(BOOL, Alttabinfo, OsString)> {
    let mut psz_item_text = Vec::<u16>::with_capacity(cch_item_text as usize + 1);
    let pszItemText = psz_item_text.as_mut_ptr();
    let hwnd = hwnd.map_or(0, Hwnd::into_raw);
    let iItem = i_item;
    let mut pati = pati.to_win32();
    let cchItemText = cch_item_text;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetAltTabInfoW(hwnd, iItem, &mut pati, pszItemText, cchItemText) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let out37 = unsafe {
        slice::from_raw_parts(unsafe { pszItemText.assume_init() }, return_value as usize)
    };
    let out37 = out37.to_vec();
    let psz_item_text = OsStringExt::from_wide(out37);
    let pati = unsafe { Alttabinfo::from_win32(pati) };
    Ok((return_value,pati, pszItemText))
}
#[inline]
pub fn get_ancestor(hwnd: Hwnd, ga_flags: u32) -> Result<Hwnd> {
    let hwnd = hwnd.into_raw();
    let gaFlags = ga_flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetAncestor(hwnd, gaFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_caret_blink_time() -> u32 {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetCaretBlinkTime() };
    return_value
}
#[inline]
pub fn get_caret_pos() -> Result<(BOOL, Point)> {
    let mut lp_point = mem::MaybeUninit::zeroed();
    let lpPoint = lp_point.as_mut_ptr();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetCaretPos(lpPoint) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_point = unsafe { Point::from_win32(unsafe { lpPoint.assume_init() }) };
    Ok((return_value,lpPoint))
}
#[inline]
pub fn get_class_info_a(h_instance: Option<Hinstance>, lp_class_name: &CStr, ) -> Result<(BOOL, Wndclassa<'_>)> {
    let mut lp_wnd_class = mem::MaybeUninit::zeroed();
    let lpWndClass = lp_wnd_class.as_mut_ptr();
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    let lpClassName = lp_class_name.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClassInfoA(hInstance, lpClassName, lpWndClass) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_wnd_class = unsafe { Wndclassa::from_win32(unsafe { lpWndClass.assume_init() }) };
    Ok((return_value,lpWndClass))
}
#[inline]
pub fn get_class_info_ex_a(h_instance: Option<Hinstance>, lpsz_class: &CStr, ) -> Result<(BOOL, Wndclassexa<'_>)> {
    let mut lpwcx = mem::MaybeUninit::zeroed();
    let lpwcx = lpwcx.as_mut_ptr();
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    let lpszClass = lpsz_class.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClassInfoExA(hInstance, lpszClass, lpwcx) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpwcx = unsafe { Wndclassexa::from_win32(unsafe { lpwcx.assume_init() }) };
    Ok((return_value,lpwcx))
}
#[inline]
pub fn get_class_info_ex_w(h_instance: Option<Hinstance>, lpsz_class: &OsStr, ) -> Result<(BOOL, Wndclassexw<'_>)> {
    let mut lpwcx = mem::MaybeUninit::zeroed();
    let lpwcx = lpwcx.as_mut_ptr();
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    let mut temp144: Vec<u16> = lpsz_class.encode_wide().collect();
    temp144.push(0);
    let lpszClass = temp144.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClassInfoExW(hInstance, lpszClass, lpwcx) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpwcx = unsafe { Wndclassexw::from_win32(unsafe { lpwcx.assume_init() }) };
    Ok((return_value,lpwcx))
}
#[inline]
pub fn get_class_info_w(h_instance: Option<Hinstance>, lp_class_name: &OsStr, ) -> Result<(BOOL, Wndclassw<'_>)> {
    let mut lp_wnd_class = mem::MaybeUninit::zeroed();
    let lpWndClass = lp_wnd_class.as_mut_ptr();
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    let mut temp145: Vec<u16> = lp_class_name.encode_wide().collect();
    temp145.push(0);
    let lpClassName = temp145.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClassInfoW(hInstance, lpClassName, lpWndClass) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_wnd_class = unsafe { Wndclassw::from_win32(unsafe { lpWndClass.assume_init() }) };
    Ok((return_value,lpWndClass))
}
#[inline]
pub fn get_class_long_a(h_wnd: Hwnd, n_index: i32) -> u32 {
    let hWnd = h_wnd.into_raw();
    let nIndex = n_index;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClassLongA(hWnd, nIndex) };
    return_value
}
#[inline]
pub fn get_class_long_ptr_a(h_wnd: Hwnd, n_index: i32) -> usize {
    let hWnd = h_wnd.into_raw();
    let nIndex = n_index;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClassLongPtrA(hWnd, nIndex) };
    return_value
}
#[inline]
pub fn get_class_long_ptr_w(h_wnd: Hwnd, n_index: i32) -> usize {
    let hWnd = h_wnd.into_raw();
    let nIndex = n_index;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClassLongPtrW(hWnd, nIndex) };
    return_value
}
#[inline]
pub fn get_class_long_w(h_wnd: Hwnd, n_index: i32) -> u32 {
    let hWnd = h_wnd.into_raw();
    let nIndex = n_index;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClassLongW(hWnd, nIndex) };
    return_value
}
#[inline]
pub fn get_class_name_a(h_wnd: Hwnd, n_max_count: i32) -> Result<(i32, CString)> {
    let mut lp_class_name = Vec::<u8>::with_capacity(n_max_count as usize + 1);
    let lpClassName = lp_class_name.as_mut_ptr();
    let hWnd = h_wnd.into_raw();
    let nMaxCount = n_max_count;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClassNameA(hWnd, lpClassName, nMaxCount) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let out38 = unsafe {
        slice::from_raw_parts(unsafe { lpClassName.assume_init() }, return_value as usize)
    };
    let mut out38 = out38.to_vec();
    out38.push(0);
    let lp_class_name = unsafe { CString::from_vec_unchecked(out38) };
    Ok((return_value,lpClassName))
}
#[inline]
pub fn get_class_name_w(h_wnd: Hwnd, n_max_count: i32) -> Result<(i32, OsString)> {
    let mut lp_class_name = Vec::<u16>::with_capacity(n_max_count as usize + 1);
    let lpClassName = lp_class_name.as_mut_ptr();
    let hWnd = h_wnd.into_raw();
    let nMaxCount = n_max_count;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClassNameW(hWnd, lpClassName, nMaxCount) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let out39 = unsafe {
        slice::from_raw_parts(unsafe { lpClassName.assume_init() }, return_value as usize)
    };
    let out39 = out39.to_vec();
    let lp_class_name = OsStringExt::from_wide(out39);
    Ok((return_value,lpClassName))
}
#[inline]
pub fn get_class_word(h_wnd: Hwnd, n_index: i32) -> u16 {
    let hWnd = h_wnd.into_raw();
    let nIndex = n_index;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClassWord(hWnd, nIndex) };
    return_value
}
#[inline]
pub fn get_client_rect(h_wnd: Hwnd, ) -> Result<(BOOL, Rect)> {
    let mut lp_rect = mem::MaybeUninit::zeroed();
    let lpRect = lp_rect.as_mut_ptr();
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClientRect(hWnd, lpRect) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_rect = unsafe { Rect::from_win32(unsafe { lpRect.assume_init() }) };
    Ok((return_value,lpRect))
}
#[inline]
pub fn get_clip_cursor() -> Result<(BOOL, Rect)> {
    let mut lp_rect = mem::MaybeUninit::zeroed();
    let lpRect = lp_rect.as_mut_ptr();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClipCursor(lpRect) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_rect = unsafe { Rect::from_win32(unsafe { lpRect.assume_init() }) };
    Ok((return_value,lpRect))
}
#[inline]
pub fn get_cursor() -> Result<Hcursor> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetCursor() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_cursor_info(pci: Cursorinfo) -> Result<(BOOL, Cursorinfo)> {
    let mut pci = pci.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetCursorInfo(&mut pci) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pci = unsafe { Cursorinfo::from_win32(pci) };
    Ok((return_value,pci))
}
#[inline]
pub fn get_cursor_pos() -> Result<(BOOL, Point)> {
    let mut lp_point = mem::MaybeUninit::zeroed();
    let lpPoint = lp_point.as_mut_ptr();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetCursorPos(lpPoint) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_point = unsafe { Point::from_win32(unsafe { lpPoint.assume_init() }) };
    Ok((return_value,lpPoint))
}
#[inline]
pub fn get_desktop_window() -> Result<Hwnd> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetDesktopWindow() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_dialog_base_units() -> Result<i32> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetDialogBaseUnits() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_dlg_ctrl_id(h_wnd: Hwnd) -> Result<i32> {
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetDlgCtrlID(hWnd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_dlg_item(h_dlg: Option<Hwnd>, n_id_dlg_item: i32) -> Result<Hwnd> {
    let hDlg = h_dlg.map_or(0, Hwnd::into_raw);
    let nIDDlgItem = n_id_dlg_item;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetDlgItem(hDlg, nIDDlgItem) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_dlg_item_int(h_dlg: Hwnd, n_id_dlg_item: i32, b_signed: BOOL) -> (u32, BOOL) {
    let mut lp_translated = mem::MaybeUninit::zeroed();
    let lpTranslated = lp_translated.as_mut_ptr();
    let hDlg = h_dlg.into_raw();
    let nIDDlgItem = n_id_dlg_item;
    let bSigned = b_signed;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetDlgItemInt(hDlg, nIDDlgItem, lpTranslated, bSigned) };
    let lp_translated = unsafe { lpTranslated.assume_init() };
    (return_value,lpTranslated)
}
#[inline]
pub fn get_dlg_item_text_a(h_dlg: Hwnd, n_id_dlg_item: i32, cch_max: i32) -> (u32, CString) {
    let mut lp_string = Vec::<u8>::with_capacity(cch_max as usize + 1);
    let lpString = lp_string.as_mut_ptr();
    let hDlg = h_dlg.into_raw();
    let nIDDlgItem = n_id_dlg_item;
    let cchMax = cch_max;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetDlgItemTextA(hDlg, nIDDlgItem, lpString, cchMax) };
    let out40 = unsafe {
        slice::from_raw_parts(unsafe { lpString.assume_init() }, return_value as usize)
    };
    let mut out40 = out40.to_vec();
    out40.push(0);
    let lp_string = unsafe { CString::from_vec_unchecked(out40) };
    (return_value,lpString)
}
#[inline]
pub fn get_dlg_item_text_w(h_dlg: Hwnd, n_id_dlg_item: i32, cch_max: i32) -> (u32, OsString) {
    let mut lp_string = Vec::<u16>::with_capacity(cch_max as usize + 1);
    let lpString = lp_string.as_mut_ptr();
    let hDlg = h_dlg.into_raw();
    let nIDDlgItem = n_id_dlg_item;
    let cchMax = cch_max;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetDlgItemTextW(hDlg, nIDDlgItem, lpString, cchMax) };
    let out41 = unsafe {
        slice::from_raw_parts(unsafe { lpString.assume_init() }, return_value as usize)
    };
    let out41 = out41.to_vec();
    let lp_string = OsStringExt::from_wide(out41);
    (return_value,lpString)
}
#[inline]
pub fn get_foreground_window() -> Result<Hwnd> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetForegroundWindow() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_gui_thread_info(id_thread: u32, pgui: Guithreadinfo) -> Result<(BOOL, Guithreadinfo)> {
    let idThread = id_thread;
    let mut pgui = pgui.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetGUIThreadInfo(idThread, &mut pgui) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pgui = unsafe { Guithreadinfo::from_win32(pgui) };
    Ok((return_value,pgui))
}
#[inline]
pub fn get_icon_info(h_icon: Hicon, ) -> Result<(BOOL, Iconinfo)> {
    let mut piconinfo = mem::MaybeUninit::zeroed();
    let piconinfo = piconinfo.as_mut_ptr();
    let hIcon = h_icon.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetIconInfo(hIcon, piconinfo) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let piconinfo = unsafe { Iconinfo::from_win32(unsafe { piconinfo.assume_init() }) };
    Ok((return_value,piconinfo))
}
#[inline]
pub fn get_icon_info_ex_a(hicon: Hicon, piconinfo: Iconinfoexa) -> Result<(BOOL, Iconinfoexa)> {
    let hicon = hicon.into_raw();
    let mut piconinfo = piconinfo.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetIconInfoExA(hicon, &mut piconinfo) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let piconinfo = unsafe { Iconinfoexa::from_win32(piconinfo) };
    Ok((return_value,piconinfo))
}
#[inline]
pub fn get_icon_info_ex_w(hicon: Hicon, piconinfo: Iconinfoexw) -> Result<(BOOL, Iconinfoexw)> {
    let hicon = hicon.into_raw();
    let mut piconinfo = piconinfo.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetIconInfoExW(hicon, &mut piconinfo) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let piconinfo = unsafe { Iconinfoexw::from_win32(piconinfo) };
    Ok((return_value,piconinfo))
}
#[inline]
pub fn get_input_state() -> Result<BOOL> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetInputState() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_last_active_popup(h_wnd: Hwnd) -> Result<Hwnd> {
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetLastActivePopup(hWnd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_layered_window_attributes(hwnd: Hwnd, ) -> Result<(BOOL, u32, u8, u32)> {
    let mut pcr_key = mem::MaybeUninit::zeroed();
    let pcrKey = pcr_key.as_mut_ptr();
    let mut pb_alpha = mem::MaybeUninit::zeroed();
    let pbAlpha = pb_alpha.as_mut_ptr();
    let mut pdw_flags = mem::MaybeUninit::zeroed();
    let pdwFlags = pdw_flags.as_mut_ptr();
    let hwnd = hwnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetLayeredWindowAttributes(hwnd, pcrKey, pbAlpha, pdwFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pdw_flags = unsafe { pdwFlags.assume_init() };
    let pb_alpha = unsafe { pbAlpha.assume_init() };
    let pcr_key = unsafe { pcrKey.assume_init() };
    Ok((return_value,pcrKey, pbAlpha, pdwFlags))
}
#[inline]
pub fn get_menu(h_wnd: Hwnd) -> Result<Hmenu> {
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenu(hWnd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_menu_bar_info(hwnd: Hwnd, id_object: i32, id_item: i32, pmbi: Menubarinfo) -> Result<(BOOL, Menubarinfo)> {
    let hwnd = hwnd.into_raw();
    let idObject = id_object;
    let idItem = id_item;
    let mut pmbi = pmbi.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenuBarInfo(hwnd, idObject, idItem, &mut pmbi) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pmbi = unsafe { Menubarinfo::from_win32(pmbi) };
    Ok((return_value,pmbi))
}
#[inline]
pub fn get_menu_check_mark_dimensions() -> Result<i32> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenuCheckMarkDimensions() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_menu_default_item(h_menu: Hmenu, f_by_pos: u32, gmdi_flags: u32) -> u32 {
    let hMenu = h_menu.into_raw();
    let fByPos = f_by_pos;
    let gmdiFlags = gmdi_flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenuDefaultItem(hMenu, fByPos, gmdiFlags) };
    return_value
}
#[inline]
pub fn get_menu_info(param0: Hmenu, param1: Menuinfo) -> Result<(BOOL, Menuinfo)> {
    let param0 = param0.into_raw();
    let mut param1 = param1.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenuInfo(param0, &mut param1) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let param1 = unsafe { Menuinfo::from_win32(param1) };
    Ok((return_value,param1))
}
#[inline]
pub fn get_menu_item_count(h_menu: Option<Hmenu>) -> Result<i32> {
    let hMenu = h_menu.map_or(0, Hmenu::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenuItemCount(hMenu) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_menu_item_id(h_menu: Hmenu, n_pos: i32) -> u32 {
    let hMenu = h_menu.into_raw();
    let nPos = n_pos;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenuItemID(hMenu, nPos) };
    return_value
}
#[inline]
pub fn get_menu_item_info_a(hmenu: Hmenu, item: u32, f_by_position: BOOL, lpmii: Menuiteminfoa<'_>) -> Result<(BOOL, Menuiteminfoa<'_>)> {
    let hmenu = hmenu.into_raw();
    let item = item;
    let fByPosition = f_by_position;
    let mut lpmii = lpmii.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenuItemInfoA(hmenu, item, fByPosition, &mut lpmii) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpmii = unsafe { Menuiteminfoa::from_win32(lpmii) };
    Ok((return_value,lpmii))
}
#[inline]
pub fn get_menu_item_info_w(hmenu: Hmenu, item: u32, f_by_position: BOOL, lpmii: Menuiteminfow<'_>) -> Result<(BOOL, Menuiteminfow<'_>)> {
    let hmenu = hmenu.into_raw();
    let item = item;
    let fByPosition = f_by_position;
    let mut lpmii = lpmii.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenuItemInfoW(hmenu, item, fByPosition, &mut lpmii) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpmii = unsafe { Menuiteminfow::from_win32(lpmii) };
    Ok((return_value,lpmii))
}
#[inline]
pub fn get_menu_item_rect(h_wnd: Option<Hwnd>, h_menu: Hmenu, u_item: u32, ) -> Result<(BOOL, Rect)> {
    let mut lprc_item = mem::MaybeUninit::zeroed();
    let lprcItem = lprc_item.as_mut_ptr();
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let hMenu = h_menu.into_raw();
    let uItem = u_item;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenuItemRect(hWnd, hMenu, uItem, lprcItem) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lprc_item = unsafe { Rect::from_win32(unsafe { lprcItem.assume_init() }) };
    Ok((return_value,lprcItem))
}
#[inline]
pub fn get_menu_state(h_menu: Hmenu, u_id: u32, u_flags: u32) -> u32 {
    let hMenu = h_menu.into_raw();
    let uId = u_id;
    let uFlags = u_flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenuState(hMenu, uId, uFlags) };
    return_value
}
#[inline]
pub fn get_menu_string_a(h_menu: Hmenu, u_id_item: u32, cch_max: i32, flags: u32) -> Result<(i32, CString)> {
    let mut lp_string = Vec::<u8>::with_capacity(cch_max as usize + 1);
    let lpString = lp_string.as_mut_ptr();
    let hMenu = h_menu.into_raw();
    let uIDItem = u_id_item;
    let cchMax = cch_max;
    let flags = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenuStringA(hMenu, uIDItem, lpString, cchMax, flags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let out42 = unsafe {
        slice::from_raw_parts(unsafe { lpString.assume_init() }, return_value as usize)
    };
    let mut out42 = out42.to_vec();
    out42.push(0);
    let lp_string = unsafe { CString::from_vec_unchecked(out42) };
    Ok((return_value,lpString))
}
#[inline]
pub fn get_menu_string_w(h_menu: Hmenu, u_id_item: u32, cch_max: i32, flags: u32) -> Result<(i32, OsString)> {
    let mut lp_string = Vec::<u16>::with_capacity(cch_max as usize + 1);
    let lpString = lp_string.as_mut_ptr();
    let hMenu = h_menu.into_raw();
    let uIDItem = u_id_item;
    let cchMax = cch_max;
    let flags = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenuStringW(hMenu, uIDItem, lpString, cchMax, flags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let out43 = unsafe {
        slice::from_raw_parts(unsafe { lpString.assume_init() }, return_value as usize)
    };
    let out43 = out43.to_vec();
    let lp_string = OsStringExt::from_wide(out43);
    Ok((return_value,lpString))
}
#[inline]
pub fn get_message_a(h_wnd: Option<Hwnd>, w_msg_filter_min: u32, w_msg_filter_max: u32) -> Result<(BOOL, Msg)> {
    let mut lp_msg = mem::MaybeUninit::zeroed();
    let lpMsg = lp_msg.as_mut_ptr();
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let wMsgFilterMin = w_msg_filter_min;
    let wMsgFilterMax = w_msg_filter_max;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_msg = unsafe { Msg::from_win32(unsafe { lpMsg.assume_init() }) };
    Ok((return_value,lpMsg))
}
#[inline]
pub fn get_message_extra_info() -> Lparam {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMessageExtraInfo() };
    return_value
}
#[inline]
pub fn get_message_pos() -> u32 {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMessagePos() };
    return_value
}
#[inline]
pub fn get_message_time() -> Result<i32> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMessageTime() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_message_w(h_wnd: Option<Hwnd>, w_msg_filter_min: u32, w_msg_filter_max: u32) -> Result<(BOOL, Msg)> {
    let mut lp_msg = mem::MaybeUninit::zeroed();
    let lpMsg = lp_msg.as_mut_ptr();
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let wMsgFilterMin = w_msg_filter_min;
    let wMsgFilterMax = w_msg_filter_max;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_msg = unsafe { Msg::from_win32(unsafe { lpMsg.assume_init() }) };
    Ok((return_value,lpMsg))
}
#[inline]
pub fn get_next_dlg_group_item(h_dlg: Hwnd, h_ctl: Option<Hwnd>, b_previous: BOOL) -> Result<Hwnd> {
    let hDlg = h_dlg.into_raw();
    let hCtl = h_ctl.map_or(0, Hwnd::into_raw);
    let bPrevious = b_previous;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetNextDlgGroupItem(hDlg, hCtl, bPrevious) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_next_dlg_tab_item(h_dlg: Hwnd, h_ctl: Option<Hwnd>, b_previous: BOOL) -> Result<Hwnd> {
    let hDlg = h_dlg.into_raw();
    let hCtl = h_ctl.map_or(0, Hwnd::into_raw);
    let bPrevious = b_previous;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetNextDlgTabItem(hDlg, hCtl, bPrevious) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_parent(h_wnd: Hwnd) -> Result<Hwnd> {
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetParent(hWnd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_physical_cursor_pos() -> Result<(BOOL, Point)> {
    let mut lp_point = mem::MaybeUninit::zeroed();
    let lpPoint = lp_point.as_mut_ptr();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetPhysicalCursorPos(lpPoint) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_point = unsafe { Point::from_win32(unsafe { lpPoint.assume_init() }) };
    Ok((return_value,lpPoint))
}
#[inline]
pub fn get_process_default_layout() -> Result<(BOOL, u32)> {
    let mut pdw_default_layout = mem::MaybeUninit::zeroed();
    let pdwDefaultLayout = pdw_default_layout.as_mut_ptr();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetProcessDefaultLayout(pdwDefaultLayout) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pdw_default_layout = unsafe { pdwDefaultLayout.assume_init() };
    Ok((return_value,pdwDefaultLayout))
}
#[inline]
pub fn get_prop_a(h_wnd: Hwnd, lp_string: &CStr) -> Result<Handle> {
    let hWnd = h_wnd.into_raw();
    let lpString = lp_string.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetPropA(hWnd, lpString) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_prop_w(h_wnd: Hwnd, lp_string: &OsStr) -> Result<Handle> {
    let hWnd = h_wnd.into_raw();
    let mut temp146: Vec<u16> = lp_string.encode_wide().collect();
    temp146.push(0);
    let lpString = temp146.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetPropW(hWnd, lpString) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_queue_status(flags: u32) -> u32 {
    let flags = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetQueueStatus(flags) };
    return_value
}
#[inline]
pub fn get_scroll_bar_info(hwnd: Hwnd, id_object: i32, psbi: Scrollbarinfo) -> Result<(BOOL, Scrollbarinfo)> {
    let hwnd = hwnd.into_raw();
    let idObject = id_object;
    let mut psbi = psbi.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetScrollBarInfo(hwnd, idObject, &mut psbi) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let psbi = unsafe { Scrollbarinfo::from_win32(psbi) };
    Ok((return_value,psbi))
}
#[inline]
pub fn get_scroll_info(hwnd: Hwnd, n_bar: u32, lpsi: Scrollinfo) -> Result<(BOOL, Scrollinfo)> {
    let hwnd = hwnd.into_raw();
    let nBar = n_bar;
    let mut lpsi = lpsi.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetScrollInfo(hwnd, nBar, &mut lpsi) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpsi = unsafe { Scrollinfo::from_win32(lpsi) };
    Ok((return_value,lpsi))
}
#[inline]
pub fn get_scroll_pos(h_wnd: Hwnd, n_bar: u32) -> Result<i32> {
    let hWnd = h_wnd.into_raw();
    let nBar = n_bar;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetScrollPos(hWnd, nBar) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_scroll_range(h_wnd: Hwnd, n_bar: u32, ) -> Result<(BOOL, i32, i32)> {
    let mut lp_min_pos = mem::MaybeUninit::zeroed();
    let lpMinPos = lp_min_pos.as_mut_ptr();
    let mut lp_max_pos = mem::MaybeUninit::zeroed();
    let lpMaxPos = lp_max_pos.as_mut_ptr();
    let hWnd = h_wnd.into_raw();
    let nBar = n_bar;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetScrollRange(hWnd, nBar, lpMinPos, lpMaxPos) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_max_pos = unsafe { lpMaxPos.assume_init() };
    let lp_min_pos = unsafe { lpMinPos.assume_init() };
    Ok((return_value,lpMinPos, lpMaxPos))
}
#[inline]
pub fn get_shell_window() -> Result<Hwnd> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetShellWindow() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_sub_menu(h_menu: Hmenu, n_pos: i32) -> Result<Hmenu> {
    let hMenu = h_menu.into_raw();
    let nPos = n_pos;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetSubMenu(hMenu, nPos) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_sys_color(n_index: u32) -> u32 {
    let nIndex = n_index;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetSysColor(nIndex) };
    return_value
}
#[inline]
pub fn get_system_menu(h_wnd: Hwnd, b_revert: BOOL) -> Result<Hmenu> {
    let hWnd = h_wnd.into_raw();
    let bRevert = b_revert;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetSystemMenu(hWnd, bRevert) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_system_metrics(n_index: u32) -> Result<i32> {
    let nIndex = n_index;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetSystemMetrics(nIndex) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_title_bar_info(hwnd: Hwnd, pti: Titlebarinfo) -> Result<(BOOL, Titlebarinfo)> {
    let hwnd = hwnd.into_raw();
    let mut pti = pti.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetTitleBarInfo(hwnd, &mut pti) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pti = unsafe { Titlebarinfo::from_win32(pti) };
    Ok((return_value,pti))
}
#[inline]
pub fn get_top_window(h_wnd: Option<Hwnd>) -> Result<Hwnd> {
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetTopWindow(hWnd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_window(h_wnd: Hwnd, u_cmd: u32) -> Result<Hwnd> {
    let hWnd = h_wnd.into_raw();
    let uCmd = u_cmd;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindow(hWnd, uCmd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_window_display_affinity(h_wnd: Hwnd, ) -> Result<(BOOL, u32)> {
    let mut pdw_affinity = mem::MaybeUninit::zeroed();
    let pdwAffinity = pdw_affinity.as_mut_ptr();
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowDisplayAffinity(hWnd, pdwAffinity) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pdw_affinity = unsafe { pdwAffinity.assume_init() };
    Ok((return_value,pdwAffinity))
}
#[inline]
pub fn get_window_info(hwnd: Hwnd, pwi: Windowinfo) -> Result<(BOOL, Windowinfo)> {
    let hwnd = hwnd.into_raw();
    let mut pwi = pwi.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowInfo(hwnd, &mut pwi) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let pwi = unsafe { Windowinfo::from_win32(pwi) };
    Ok((return_value,pwi))
}
#[inline]
pub fn get_window_long_a(h_wnd: Hwnd, n_index: i32) -> Result<i32> {
    let hWnd = h_wnd.into_raw();
    let nIndex = n_index;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowLongA(hWnd, nIndex) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_window_long_ptr_a(h_wnd: Hwnd, n_index: i32) -> isize {
    let hWnd = h_wnd.into_raw();
    let nIndex = n_index;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowLongPtrA(hWnd, nIndex) };
    return_value
}
#[inline]
pub fn get_window_long_ptr_w(h_wnd: Hwnd, n_index: i32) -> isize {
    let hWnd = h_wnd.into_raw();
    let nIndex = n_index;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowLongPtrW(hWnd, nIndex) };
    return_value
}
#[inline]
pub fn get_window_long_w(h_wnd: Hwnd, n_index: i32) -> Result<i32> {
    let hWnd = h_wnd.into_raw();
    let nIndex = n_index;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowLongW(hWnd, nIndex) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_window_module_file_name_a(hwnd: Hwnd, cch_file_name_max: u32) -> (u32, CString) {
    let mut psz_file_name = Vec::<u8>::with_capacity(cch_file_name_max as usize + 1);
    let pszFileName = psz_file_name.as_mut_ptr();
    let hwnd = hwnd.into_raw();
    let cchFileNameMax = cch_file_name_max;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowModuleFileNameA(hwnd, pszFileName, cchFileNameMax) };
    let out44 = unsafe {
        slice::from_raw_parts(unsafe { pszFileName.assume_init() }, return_value as usize)
    };
    let mut out44 = out44.to_vec();
    out44.push(0);
    let psz_file_name = unsafe { CString::from_vec_unchecked(out44) };
    (return_value,pszFileName)
}
#[inline]
pub fn get_window_module_file_name_w(hwnd: Hwnd, cch_file_name_max: u32) -> (u32, OsString) {
    let mut psz_file_name = Vec::<u16>::with_capacity(cch_file_name_max as usize + 1);
    let pszFileName = psz_file_name.as_mut_ptr();
    let hwnd = hwnd.into_raw();
    let cchFileNameMax = cch_file_name_max;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowModuleFileNameW(hwnd, pszFileName, cchFileNameMax) };
    let out45 = unsafe {
        slice::from_raw_parts(unsafe { pszFileName.assume_init() }, return_value as usize)
    };
    let out45 = out45.to_vec();
    let psz_file_name = OsStringExt::from_wide(out45);
    (return_value,pszFileName)
}
#[inline]
pub fn get_window_placement(h_wnd: Hwnd, lpwndpl: Windowplacement) -> Result<(BOOL, Windowplacement)> {
    let hWnd = h_wnd.into_raw();
    let mut lpwndpl = lpwndpl.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowPlacement(hWnd, &mut lpwndpl) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpwndpl = unsafe { Windowplacement::from_win32(lpwndpl) };
    Ok((return_value,lpwndpl))
}
#[inline]
pub fn get_window_rect(h_wnd: Hwnd, ) -> Result<(BOOL, Rect)> {
    let mut lp_rect = mem::MaybeUninit::zeroed();
    let lpRect = lp_rect.as_mut_ptr();
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowRect(hWnd, lpRect) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_rect = unsafe { Rect::from_win32(unsafe { lpRect.assume_init() }) };
    Ok((return_value,lpRect))
}
#[inline]
pub fn get_window_text_a(h_wnd: Hwnd, n_max_count: i32) -> Result<(i32, CString)> {
    let mut lp_string = Vec::<u8>::with_capacity(n_max_count as usize + 1);
    let lpString = lp_string.as_mut_ptr();
    let hWnd = h_wnd.into_raw();
    let nMaxCount = n_max_count;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowTextA(hWnd, lpString, nMaxCount) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let out46 = unsafe {
        slice::from_raw_parts(unsafe { lpString.assume_init() }, return_value as usize)
    };
    let mut out46 = out46.to_vec();
    out46.push(0);
    let lp_string = unsafe { CString::from_vec_unchecked(out46) };
    Ok((return_value,lpString))
}
#[inline]
pub fn get_window_text_length_a(h_wnd: Hwnd) -> Result<i32> {
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowTextLengthA(hWnd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_window_text_length_w(h_wnd: Hwnd) -> Result<i32> {
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowTextLengthW(hWnd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_window_text_w(h_wnd: Hwnd, n_max_count: i32) -> Result<(i32, OsString)> {
    let mut lp_string = Vec::<u16>::with_capacity(n_max_count as usize + 1);
    let lpString = lp_string.as_mut_ptr();
    let hWnd = h_wnd.into_raw();
    let nMaxCount = n_max_count;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowTextW(hWnd, lpString, nMaxCount) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let out47 = unsafe {
        slice::from_raw_parts(unsafe { lpString.assume_init() }, return_value as usize)
    };
    let out47 = out47.to_vec();
    let lp_string = OsStringExt::from_wide(out47);
    Ok((return_value,lpString))
}
#[inline]
pub fn get_window_thread_process_id(h_wnd: Hwnd, ) -> (u32, u32) {
    let mut lpdw_process_id = mem::MaybeUninit::zeroed();
    let lpdwProcessId = lpdw_process_id.as_mut_ptr();
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowThreadProcessId(hWnd, lpdwProcessId) };
    let lpdw_process_id = unsafe { lpdwProcessId.assume_init() };
    (return_value,lpdwProcessId)
}
#[inline]
pub fn get_window_word(h_wnd: Hwnd, n_index: i32) -> u16 {
    let hWnd = h_wnd.into_raw();
    let nIndex = n_index;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowWord(hWnd, nIndex) };
    return_value
}
#[inline]
pub fn hide_caret(h_wnd: Option<Hwnd>) -> Result<BOOL> {
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::HideCaret(hWnd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn hilite_menu_item(h_wnd: Hwnd, h_menu: Hmenu, u_id_hilite_item: u32, u_hilite: u32) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let hMenu = h_menu.into_raw();
    let uIDHiliteItem = u_id_hilite_item;
    let uHilite = u_hilite;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::HiliteMenuItem(hWnd, hMenu, uIDHiliteItem, uHilite) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn in_send_message() -> BOOL {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::InSendMessage() };
    return_value
}
#[inline]
pub fn inherit_window_monitor(hwnd: Hwnd, hwnd_inherit: Option<Hwnd>) -> Result<BOOL> {
    let hwnd = hwnd.into_raw();
    let hwndInherit = hwnd_inherit.map_or(0, Hwnd::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::InheritWindowMonitor(hwnd, hwndInherit) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn insert_menu_a(h_menu: Hmenu, u_position: u32, u_flags: u32, u_id_new_item: usize, lp_new_item: Option<&CStr>) -> Result<BOOL> {
    let hMenu = h_menu.into_raw();
    let uPosition = u_position;
    let uFlags = u_flags;
    let uIDNewItem = u_id_new_item;
    let lpNewItem = lp_new_item.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::InsertMenuA(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn insert_menu_item_a(hmenu: Hmenu, item: u32, f_by_position: BOOL, lpmi: &Menuiteminfoa<'_>) -> Result<BOOL> {
    let hmenu = hmenu.into_raw();
    let item = item;
    let fByPosition = f_by_position;
    let temp147 = lpmi.to_win32();
    let lpmi = &temp147;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::InsertMenuItemA(hmenu, item, fByPosition, lpmi) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn insert_menu_item_w(hmenu: Hmenu, item: u32, f_by_position: BOOL, lpmi: &Menuiteminfow<'_>) -> Result<BOOL> {
    let hmenu = hmenu.into_raw();
    let item = item;
    let fByPosition = f_by_position;
    let temp148 = lpmi.to_win32();
    let lpmi = &temp148;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::InsertMenuItemW(hmenu, item, fByPosition, lpmi) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn insert_menu_w(h_menu: Hmenu, u_position: u32, u_flags: u32, u_id_new_item: usize, lp_new_item: Option<&OsStr>) -> Result<BOOL> {
    let hMenu = h_menu.into_raw();
    let uPosition = u_position;
    let uFlags = u_flags;
    let uIDNewItem = u_id_new_item;
    let temp149 = lp_new_item.map(|val| {
        let mut temp149: Vec<u16> = val.encode_wide().collect();
        temp149.push(0);
        temp149
    });
    let lpNewItem = temp149.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::InsertMenuW(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn internal_get_window_text(h_wnd: Hwnd, cch_max_count: i32) -> Result<(i32, OsString)> {
    let mut p_string = Vec::<u16>::with_capacity(cch_max_count as usize + 1);
    let pString = p_string.as_mut_ptr();
    let hWnd = h_wnd.into_raw();
    let cchMaxCount = cch_max_count;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::InternalGetWindowText(hWnd, pString, cchMaxCount) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let out48 = unsafe {
        slice::from_raw_parts(unsafe { pString.assume_init() }, return_value as usize)
    };
    let out48 = out48.to_vec();
    let p_string = OsStringExt::from_wide(out48);
    Ok((return_value,pString))
}
#[inline]
pub fn is_child(h_wnd_parent: Hwnd, h_wnd: Hwnd) -> BOOL {
    let hWndParent = h_wnd_parent.into_raw();
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsChild(hWndParent, hWnd) };
    return_value
}
#[inline]
pub fn is_dialog_message_a(h_dlg: Hwnd, lp_msg: &Msg) -> BOOL {
    let hDlg = h_dlg.into_raw();
    // SAFETY: type is a thin type
    let lpMsg = unsafe { &*(lp_msg as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsDialogMessageA(hDlg, lpMsg) };
    return_value
}
#[inline]
pub fn is_dialog_message_w(h_dlg: Hwnd, lp_msg: &Msg) -> BOOL {
    let hDlg = h_dlg.into_raw();
    // SAFETY: type is a thin type
    let lpMsg = unsafe { &*(lp_msg as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsDialogMessageW(hDlg, lpMsg) };
    return_value
}
#[inline]
pub fn is_gui_thread(b_convert: BOOL) -> BOOL {
    let bConvert = b_convert;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsGUIThread(bConvert) };
    return_value
}
#[inline]
pub fn is_hung_app_window(hwnd: Hwnd) -> BOOL {
    let hwnd = hwnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsHungAppWindow(hwnd) };
    return_value
}
#[inline]
pub fn is_iconic(h_wnd: Hwnd) -> BOOL {
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsIconic(hWnd) };
    return_value
}
#[inline]
pub fn is_menu(h_menu: Hmenu) -> BOOL {
    let hMenu = h_menu.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsMenu(hMenu) };
    return_value
}
#[inline]
pub fn is_process_dpi_aware() -> BOOL {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsProcessDPIAware() };
    return_value
}
#[inline]
pub fn is_window(h_wnd: Option<Hwnd>) -> BOOL {
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsWindow(hWnd) };
    return_value
}
#[inline]
pub fn is_window_unicode(h_wnd: Hwnd) -> BOOL {
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsWindowUnicode(hWnd) };
    return_value
}
#[inline]
pub fn is_window_visible(h_wnd: Hwnd) -> BOOL {
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsWindowVisible(hWnd) };
    return_value
}
#[inline]
pub fn is_wow64_message() -> BOOL {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsWow64Message() };
    return_value
}
#[inline]
pub fn is_zoomed(h_wnd: Hwnd) -> BOOL {
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsZoomed(hWnd) };
    return_value
}
#[inline]
pub fn kill_timer(h_wnd: Option<Hwnd>, u_id_event: usize) -> Result<BOOL> {
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let uIDEvent = u_id_event;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::KillTimer(hWnd, uIDEvent) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn load_accelerators_a(h_instance: Option<Hinstance>, lp_table_name: &CStr) -> Result<Haccel> {
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    let lpTableName = lp_table_name.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadAcceleratorsA(hInstance, lpTableName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn load_accelerators_w(h_instance: Option<Hinstance>, lp_table_name: &OsStr) -> Result<Haccel> {
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    let mut temp150: Vec<u16> = lp_table_name.encode_wide().collect();
    temp150.push(0);
    let lpTableName = temp150.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadAcceleratorsW(hInstance, lpTableName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn load_cursor_a(h_instance: Option<Hinstance>, lp_cursor_name: &CStr) -> Result<Hcursor> {
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    let lpCursorName = lp_cursor_name.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadCursorA(hInstance, lpCursorName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn load_cursor_from_file_a(lp_file_name: &CStr) -> Result<Hcursor> {
    let lpFileName = lp_file_name.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadCursorFromFileA(lpFileName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn load_cursor_from_file_w(lp_file_name: &OsStr) -> Result<Hcursor> {
    let mut temp151: Vec<u16> = lp_file_name.encode_wide().collect();
    temp151.push(0);
    let lpFileName = temp151.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadCursorFromFileW(lpFileName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn load_cursor_w(h_instance: Option<Hinstance>, lp_cursor_name: &OsStr) -> Result<Hcursor> {
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    let mut temp152: Vec<u16> = lp_cursor_name.encode_wide().collect();
    temp152.push(0);
    let lpCursorName = temp152.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadCursorW(hInstance, lpCursorName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn load_icon_a(h_instance: Option<Hinstance>, lp_icon_name: &CStr) -> Result<Hicon> {
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    let lpIconName = lp_icon_name.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadIconA(hInstance, lpIconName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn load_icon_w(h_instance: Option<Hinstance>, lp_icon_name: &OsStr) -> Result<Hicon> {
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    let mut temp153: Vec<u16> = lp_icon_name.encode_wide().collect();
    temp153.push(0);
    let lpIconName = temp153.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadIconW(hInstance, lpIconName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn load_image_a(h_inst: Option<Hinstance>, name: &CStr, r#type: u32, cx: i32, cy: i32, fu_load: u32) -> Result<Handle> {
    let hInst = h_inst.map_or(0, Hinstance::into_raw);
    let name = name.as_ptr() as _;
    let r#type = r#type;
    let cx = cx;
    let cy = cy;
    let fuLoad = fu_load;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadImageA(hInst, name, r#type, cx, cy, fuLoad) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn load_image_w(h_inst: Option<Hinstance>, name: &OsStr, r#type: u32, cx: i32, cy: i32, fu_load: u32) -> Result<Handle> {
    let hInst = h_inst.map_or(0, Hinstance::into_raw);
    let mut temp154: Vec<u16> = name.encode_wide().collect();
    temp154.push(0);
    let name = temp154.as_ptr() as _;
    let r#type = r#type;
    let cx = cx;
    let cy = cy;
    let fuLoad = fu_load;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadImageW(hInst, name, r#type, cx, cy, fuLoad) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn load_menu_a(h_instance: Option<Hinstance>, lp_menu_name: &CStr) -> Result<Hmenu> {
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    let lpMenuName = lp_menu_name.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadMenuA(hInstance, lpMenuName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn load_menu_indirect_a(lp_menu_template: &todo_void) -> Result<Hmenu> {
//      // SAFETY: type is a thin type
//      let lpMenuTemplate = unsafe { &*(lp_menu_template as *const _ as *const _) };
//      let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadMenuIndirectA(lpMenuTemplate) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn load_menu_indirect_w(lp_menu_template: &todo_void) -> Result<Hmenu> {
//      // SAFETY: type is a thin type
//      let lpMenuTemplate = unsafe { &*(lp_menu_template as *const _ as *const _) };
//      let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadMenuIndirectW(lpMenuTemplate) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
#[inline]
pub fn load_menu_w(h_instance: Option<Hinstance>, lp_menu_name: &OsStr) -> Result<Hmenu> {
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    let mut temp155: Vec<u16> = lp_menu_name.encode_wide().collect();
    temp155.push(0);
    let lpMenuName = temp155.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadMenuW(hInstance, lpMenuName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn load_string_a(h_instance: Option<Hinstance>, u_id: u32, cch_buffer_max: i32) -> Result<(i32, CString)> {
    let mut lp_buffer = Vec::<u8>::with_capacity(cch_buffer_max as usize + 1);
    let lpBuffer = lp_buffer.as_mut_ptr();
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    let uID = u_id;
    let cchBufferMax = cch_buffer_max;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadStringA(hInstance, uID, lpBuffer, cchBufferMax) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let out49 = unsafe {
        slice::from_raw_parts(unsafe { lpBuffer.assume_init() }, return_value as usize)
    };
    let mut out49 = out49.to_vec();
    out49.push(0);
    let lp_buffer = unsafe { CString::from_vec_unchecked(out49) };
    Ok((return_value,lpBuffer))
}
#[inline]
pub fn load_string_w(h_instance: Option<Hinstance>, u_id: u32, cch_buffer_max: i32) -> Result<(i32, OsString)> {
    let mut lp_buffer = Vec::<u16>::with_capacity(cch_buffer_max as usize + 1);
    let lpBuffer = lp_buffer.as_mut_ptr();
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    let uID = u_id;
    let cchBufferMax = cch_buffer_max;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadStringW(hInstance, uID, lpBuffer, cchBufferMax) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let out50 = unsafe {
        slice::from_raw_parts(unsafe { lpBuffer.assume_init() }, return_value as usize)
    };
    let out50 = out50.to_vec();
    let lp_buffer = OsStringExt::from_wide(out50);
    Ok((return_value,lpBuffer))
}
#[inline]
pub fn lock_set_foreground_window(u_lock_code: u32) -> Result<BOOL> {
    let uLockCode = u_lock_code;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LockSetForegroundWindow(uLockCode) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn logical_to_physical_point(h_wnd: Hwnd, lp_point: Point) -> Result<(BOOL, Point)> {
    let hWnd = h_wnd.into_raw();
    let mut lpPoint = lp_point.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LogicalToPhysicalPoint(hWnd, &mut lpPoint) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_point = unsafe { Point::from_win32(lpPoint) };
    Ok((return_value,lpPoint))
}
#[inline]
pub fn lookup_icon_id_from_directory(presbits: &u8, f_icon: BOOL) -> Result<i32> {
    // SAFETY: type is a thin type
    let presbits = unsafe { &*(presbits as *const _ as *const _) };
    let fIcon = f_icon;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LookupIconIdFromDirectory(presbits, fIcon) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn lookup_icon_id_from_directory_ex(presbits: &u8, f_icon: BOOL, cx_desired: i32, cy_desired: i32, flags: u32) -> Result<i32> {
    // SAFETY: type is a thin type
    let presbits = unsafe { &*(presbits as *const _ as *const _) };
    let fIcon = f_icon;
    let cxDesired = cx_desired;
    let cyDesired = cy_desired;
    let Flags = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LookupIconIdFromDirectoryEx(presbits, fIcon, cxDesired, cyDesired, Flags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn map_dialog_rect(h_dlg: Hwnd, lp_rect: Rect) -> Result<(BOOL, Rect)> {
    let hDlg = h_dlg.into_raw();
    let mut lpRect = lp_rect.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::MapDialogRect(hDlg, &mut lpRect) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_rect = unsafe { Rect::from_win32(lpRect) };
    Ok((return_value,lpRect))
}
#[inline]
pub fn menu_item_from_point(h_wnd: Option<Hwnd>, h_menu: Hmenu, pt_screen: Point) -> Result<i32> {
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let hMenu = h_menu.into_raw();
    let ptScreen = pt_screen.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::MenuItemFromPoint(hWnd, hMenu, ptScreen) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn message_box_a(h_wnd: Option<Hwnd>, lp_text: Option<&CStr>, lp_caption: Option<&CStr>, u_type: u32) -> i32 {
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let lpText = lp_text.map_or(ptr::null(), |v| v.as_ptr() as _);
    let lpCaption = lp_caption.map_or(ptr::null(), |v| v.as_ptr() as _);
    let uType = u_type;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::MessageBoxA(hWnd, lpText, lpCaption, uType) };
    return_value
}
#[inline]
pub fn message_box_ex_a(h_wnd: Option<Hwnd>, lp_text: Option<&CStr>, lp_caption: Option<&CStr>, u_type: u32, w_language_id: u16) -> i32 {
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let lpText = lp_text.map_or(ptr::null(), |v| v.as_ptr() as _);
    let lpCaption = lp_caption.map_or(ptr::null(), |v| v.as_ptr() as _);
    let uType = u_type;
    let wLanguageId = w_language_id;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::MessageBoxExA(hWnd, lpText, lpCaption, uType, wLanguageId) };
    return_value
}
#[inline]
pub fn message_box_ex_w(h_wnd: Option<Hwnd>, lp_text: Option<&OsStr>, lp_caption: Option<&OsStr>, u_type: u32, w_language_id: u16) -> i32 {
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let temp156 = lp_text.map(|val| {
        let mut temp156: Vec<u16> = val.encode_wide().collect();
        temp156.push(0);
        temp156
    });
    let lpText = temp156.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp157 = lp_caption.map(|val| {
        let mut temp157: Vec<u16> = val.encode_wide().collect();
        temp157.push(0);
        temp157
    });
    let lpCaption = temp157.map_or(ptr::null(), |v| v.as_ptr() as _);
    let uType = u_type;
    let wLanguageId = w_language_id;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::MessageBoxExW(hWnd, lpText, lpCaption, uType, wLanguageId) };
    return_value
}
#[inline]
pub fn message_box_indirect_a(lpmbp: &Msgboxparamsa<'_>) -> i32 {
    let temp158 = lpmbp.to_win32();
    let lpmbp = &temp158;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::MessageBoxIndirectA(lpmbp) };
    return_value
}
#[inline]
pub fn message_box_indirect_w(lpmbp: &Msgboxparamsw<'_>) -> i32 {
    let temp159 = lpmbp.to_win32();
    let lpmbp = &temp159;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::MessageBoxIndirectW(lpmbp) };
    return_value
}
#[inline]
pub fn message_box_w(h_wnd: Option<Hwnd>, lp_text: Option<&OsStr>, lp_caption: Option<&OsStr>, u_type: u32) -> i32 {
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let temp160 = lp_text.map(|val| {
        let mut temp160: Vec<u16> = val.encode_wide().collect();
        temp160.push(0);
        temp160
    });
    let lpText = temp160.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp161 = lp_caption.map(|val| {
        let mut temp161: Vec<u16> = val.encode_wide().collect();
        temp161.push(0);
        temp161
    });
    let lpCaption = temp161.map_or(ptr::null(), |v| v.as_ptr() as _);
    let uType = u_type;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::MessageBoxW(hWnd, lpText, lpCaption, uType) };
    return_value
}
#[inline]
pub fn modify_menu_a(h_mnu: Hmenu, u_position: u32, u_flags: u32, u_id_new_item: usize, lp_new_item: Option<&CStr>) -> Result<BOOL> {
    let hMnu = h_mnu.into_raw();
    let uPosition = u_position;
    let uFlags = u_flags;
    let uIDNewItem = u_id_new_item;
    let lpNewItem = lp_new_item.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ModifyMenuA(hMnu, uPosition, uFlags, uIDNewItem, lpNewItem) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn modify_menu_w(h_mnu: Hmenu, u_position: u32, u_flags: u32, u_id_new_item: usize, lp_new_item: Option<&OsStr>) -> Result<BOOL> {
    let hMnu = h_mnu.into_raw();
    let uPosition = u_position;
    let uFlags = u_flags;
    let uIDNewItem = u_id_new_item;
    let temp162 = lp_new_item.map(|val| {
        let mut temp162: Vec<u16> = val.encode_wide().collect();
        temp162.push(0);
        temp162
    });
    let lpNewItem = temp162.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ModifyMenuW(hMnu, uPosition, uFlags, uIDNewItem, lpNewItem) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn move_window(h_wnd: Hwnd, x: i32, y: i32, n_width: i32, n_height: i32, b_repaint: BOOL) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let X = x;
    let Y = y;
    let nWidth = n_width;
    let nHeight = n_height;
    let bRepaint = b_repaint;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::MoveWindow(hWnd, X, Y, nWidth, nHeight, bRepaint) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn msg_wait_for_multiple_objects(p_handles: Option<&[Handle]>, f_wait_all: BOOL, dw_milliseconds: u32, dw_wake_mask: u32) -> u32 {
    let pHandles = p_handles.map_or(ptr::null(), |v| v.as_ptr() as _);
    let nCount = p_handles.len() as _;
    let fWaitAll = f_wait_all;
    let dwMilliseconds = dw_milliseconds;
    let dwWakeMask = dw_wake_mask;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::MsgWaitForMultipleObjects(nCount, pHandles, fWaitAll, dwMilliseconds, dwWakeMask) };
    return_value
}
#[inline]
pub fn msg_wait_for_multiple_objects_ex(p_handles: Option<&[Handle]>, dw_milliseconds: u32, dw_wake_mask: u32, dw_flags: u32) -> u32 {
    let pHandles = p_handles.map_or(ptr::null(), |v| v.as_ptr() as _);
    let nCount = p_handles.len() as _;
    let dwMilliseconds = dw_milliseconds;
    let dwWakeMask = dw_wake_mask;
    let dwFlags = dw_flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::MsgWaitForMultipleObjectsEx(nCount, pHandles, dwMilliseconds, dwWakeMask, dwFlags) };
    return_value
}
#[inline]
pub fn open_icon(h_wnd: Hwnd) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::OpenIcon(hWnd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn peek_message_a(h_wnd: Option<Hwnd>, w_msg_filter_min: u32, w_msg_filter_max: u32, w_remove_msg: u32) -> Result<(BOOL, Msg)> {
    let mut lp_msg = mem::MaybeUninit::zeroed();
    let lpMsg = lp_msg.as_mut_ptr();
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let wMsgFilterMin = w_msg_filter_min;
    let wMsgFilterMax = w_msg_filter_max;
    let wRemoveMsg = w_remove_msg;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::PeekMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_msg = unsafe { Msg::from_win32(unsafe { lpMsg.assume_init() }) };
    Ok((return_value,lpMsg))
}
#[inline]
pub fn peek_message_w(h_wnd: Option<Hwnd>, w_msg_filter_min: u32, w_msg_filter_max: u32, w_remove_msg: u32) -> Result<(BOOL, Msg)> {
    let mut lp_msg = mem::MaybeUninit::zeroed();
    let lpMsg = lp_msg.as_mut_ptr();
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let wMsgFilterMin = w_msg_filter_min;
    let wMsgFilterMax = w_msg_filter_max;
    let wRemoveMsg = w_remove_msg;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::PeekMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_msg = unsafe { Msg::from_win32(unsafe { lpMsg.assume_init() }) };
    Ok((return_value,lpMsg))
}
#[inline]
pub fn physical_to_logical_point(h_wnd: Hwnd, lp_point: Point) -> Result<(BOOL, Point)> {
    let hWnd = h_wnd.into_raw();
    let mut lpPoint = lp_point.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::PhysicalToLogicalPoint(hWnd, &mut lpPoint) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lp_point = unsafe { Point::from_win32(lpPoint) };
    Ok((return_value,lpPoint))
}
#[inline]
pub fn post_message_a(h_wnd: Option<Hwnd>, msg: u32, w_param: Wparam, l_param: Lparam) -> Result<BOOL> {
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let Msg = msg;
    let wParam = w_param.into_inner();
    let lParam = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::PostMessageA(hWnd, Msg, wParam, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn post_message_w(h_wnd: Option<Hwnd>, msg: u32, w_param: Wparam, l_param: Lparam) -> Result<BOOL> {
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let Msg = msg;
    let wParam = w_param.into_inner();
    let lParam = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::PostMessageW(hWnd, Msg, wParam, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn post_quit_message(n_exit_code: i32) -> () {
    let nExitCode = n_exit_code;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::PostQuitMessage(nExitCode) };
    let _ = return_value;
}
#[inline]
pub fn post_thread_message_a(id_thread: u32, msg: u32, w_param: Wparam, l_param: Lparam) -> Result<BOOL> {
    let idThread = id_thread;
    let Msg = msg;
    let wParam = w_param.into_inner();
    let lParam = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::PostThreadMessageA(idThread, Msg, wParam, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn post_thread_message_w(id_thread: u32, msg: u32, w_param: Wparam, l_param: Lparam) -> Result<BOOL> {
    let idThread = id_thread;
    let Msg = msg;
    let wParam = w_param.into_inner();
    let lParam = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::PostThreadMessageW(idThread, Msg, wParam, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn private_extract_icons_a(sz_file_name: &CStr, n_icon_index: i32, cx_icon: i32, cy_icon: i32, n_icons: u32, flags: u32) -> (u32, Hicon, u32) {
    let mut phicon = mem::MaybeUninit::zeroed();
    let phicon = phicon.as_mut_ptr();
    let mut piconid = mem::MaybeUninit::zeroed();
    let piconid = piconid.as_mut_ptr();
    let szFileName = sz_file_name.as_ptr() as _;
    let nIconIndex = n_icon_index;
    let cxIcon = cx_icon;
    let cyIcon = cy_icon;
    let nIcons = n_icons;
    let flags = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::PrivateExtractIconsA(szFileName, nIconIndex, cxIcon, cyIcon, phicon, piconid, nIcons, flags) };
    let piconid = unsafe { piconid.assume_init() };
    let phicon = unsafe { Hicon::new(unsafe { phicon.assume_init() }) };
    (return_value,phicon, piconid)
}
#[inline]
pub fn private_extract_icons_w(sz_file_name: &OsStr, n_icon_index: i32, cx_icon: i32, cy_icon: i32, n_icons: u32, flags: u32) -> (u32, Hicon, u32) {
    let mut phicon = mem::MaybeUninit::zeroed();
    let phicon = phicon.as_mut_ptr();
    let mut piconid = mem::MaybeUninit::zeroed();
    let piconid = piconid.as_mut_ptr();
    let mut temp163: Vec<u16> = sz_file_name.encode_wide().collect();
    temp163.push(0);
    let szFileName = temp163.as_ptr() as _;
    let nIconIndex = n_icon_index;
    let cxIcon = cx_icon;
    let cyIcon = cy_icon;
    let nIcons = n_icons;
    let flags = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::PrivateExtractIconsW(szFileName, nIconIndex, cxIcon, cyIcon, phicon, piconid, nIcons, flags) };
    let piconid = unsafe { piconid.assume_init() };
    let phicon = unsafe { Hicon::new(unsafe { phicon.assume_init() }) };
    (return_value,phicon, piconid)
}
#[inline]
pub fn real_child_window_from_point(hwnd_parent: Hwnd, pt_parent_client_coords: Point) -> Result<Hwnd> {
    let hwndParent = hwnd_parent.into_raw();
    let ptParentClientCoords = pt_parent_client_coords.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::RealChildWindowFromPoint(hwndParent, ptParentClientCoords) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn real_get_window_class_a(hwnd: Hwnd, cch_class_name_max: u32) -> (u32, CString) {
    let mut ptsz_class_name = Vec::<u8>::with_capacity(cch_class_name_max as usize + 1);
    let ptszClassName = ptsz_class_name.as_mut_ptr();
    let hwnd = hwnd.into_raw();
    let cchClassNameMax = cch_class_name_max;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::RealGetWindowClassA(hwnd, ptszClassName, cchClassNameMax) };
    let out51 = unsafe {
        slice::from_raw_parts(unsafe { ptszClassName.assume_init() }, return_value as usize)
    };
    let mut out51 = out51.to_vec();
    out51.push(0);
    let ptsz_class_name = unsafe { CString::from_vec_unchecked(out51) };
    (return_value,ptszClassName)
}
#[inline]
pub fn real_get_window_class_w(hwnd: Hwnd, cch_class_name_max: u32) -> (u32, OsString) {
    let mut ptsz_class_name = Vec::<u16>::with_capacity(cch_class_name_max as usize + 1);
    let ptszClassName = ptsz_class_name.as_mut_ptr();
    let hwnd = hwnd.into_raw();
    let cchClassNameMax = cch_class_name_max;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::RealGetWindowClassW(hwnd, ptszClassName, cchClassNameMax) };
    let out52 = unsafe {
        slice::from_raw_parts(unsafe { ptszClassName.assume_init() }, return_value as usize)
    };
    let out52 = out52.to_vec();
    let ptsz_class_name = OsStringExt::from_wide(out52);
    (return_value,ptszClassName)
}
#[inline]
pub fn remove_menu(h_menu: Hmenu, u_position: u32, u_flags: u32) -> Result<BOOL> {
    let hMenu = h_menu.into_raw();
    let uPosition = u_position;
    let uFlags = u_flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::RemoveMenu(hMenu, uPosition, uFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn remove_prop_a(h_wnd: Hwnd, lp_string: &CStr) -> Result<Handle> {
    let hWnd = h_wnd.into_raw();
    let lpString = lp_string.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::RemovePropA(hWnd, lpString) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn remove_prop_w(h_wnd: Hwnd, lp_string: &OsStr) -> Result<Handle> {
    let hWnd = h_wnd.into_raw();
    let mut temp164: Vec<u16> = lp_string.encode_wide().collect();
    temp164.push(0);
    let lpString = temp164.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::RemovePropW(hWnd, lpString) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn reply_message(l_result: Lresult) -> Result<BOOL> {
    let lResult = l_result.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ReplyMessage(lResult) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn scroll_dc(h_dc: Hdc, dx: i32, dy: i32, lprc_scroll: Option<&Rect>, lprc_clip: Option<&Rect>, hrgn_update: Option<Hrgn>, ) -> Result<(BOOL, Rect)> {
    let mut lprc_update = mem::MaybeUninit::zeroed();
    let lprcUpdate = lprc_update.as_mut_ptr();
    let hDC = h_dc.into_raw();
    let dx = dx;
    let dy = dy;
    // SAFETY: type is a thin type
    let lprcScroll = lprc_scroll.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    // SAFETY: type is a thin type
    let lprcClip = lprc_clip.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let hrgnUpdate = hrgn_update.map_or(0, Hrgn::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ScrollDC(hDC, dx, dy, lprcScroll, lprcClip, hrgnUpdate, lprcUpdate) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lprc_update = unsafe { Rect::from_win32(unsafe { lprcUpdate.assume_init() }) };
    Ok((return_value,lprcUpdate))
}
#[inline]
pub fn scroll_window(h_wnd: Hwnd, x_amount: i32, y_amount: i32, lp_rect: Option<&Rect>, lp_clip_rect: Option<&Rect>) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let XAmount = x_amount;
    let YAmount = y_amount;
    // SAFETY: type is a thin type
    let lpRect = lp_rect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    // SAFETY: type is a thin type
    let lpClipRect = lp_clip_rect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ScrollWindow(hWnd, XAmount, YAmount, lpRect, lpClipRect) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn scroll_window_ex(h_wnd: Hwnd, dx: i32, dy: i32, prc_scroll: Option<&Rect>, prc_clip: Option<&Rect>, hrgn_update: Option<Hrgn>, flags: u32) -> Result<(i32, Rect)> {
    let mut prc_update = mem::MaybeUninit::zeroed();
    let prcUpdate = prc_update.as_mut_ptr();
    let hWnd = h_wnd.into_raw();
    let dx = dx;
    let dy = dy;
    // SAFETY: type is a thin type
    let prcScroll = prc_scroll.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    // SAFETY: type is a thin type
    let prcClip = prc_clip.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let hrgnUpdate = hrgn_update.map_or(0, Hrgn::into_raw);
    let flags = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ScrollWindowEx(hWnd, dx, dy, prcScroll, prcClip, hrgnUpdate, prcUpdate, flags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let prc_update = unsafe { Rect::from_win32(unsafe { prcUpdate.assume_init() }) };
    Ok((return_value,prcUpdate))
}
#[inline]
pub fn send_dlg_item_message_a(h_dlg: Hwnd, n_id_dlg_item: i32, msg: u32, w_param: Wparam, l_param: Lparam) -> Result<Lresult> {
    let hDlg = h_dlg.into_raw();
    let nIDDlgItem = n_id_dlg_item;
    let Msg = msg;
    let wParam = w_param.into_inner();
    let lParam = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SendDlgItemMessageA(hDlg, nIDDlgItem, Msg, wParam, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn send_dlg_item_message_w(h_dlg: Hwnd, n_id_dlg_item: i32, msg: u32, w_param: Wparam, l_param: Lparam) -> Result<Lresult> {
    let hDlg = h_dlg.into_raw();
    let nIDDlgItem = n_id_dlg_item;
    let Msg = msg;
    let wParam = w_param.into_inner();
    let lParam = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SendDlgItemMessageW(hDlg, nIDDlgItem, Msg, wParam, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn send_message_a(h_wnd: Hwnd, msg: u32, ) -> Result<Lresult> {
    let wParam = unsafe { mem::zeroed() };
    let lParam = unsafe { mem::zeroed() };
    let hWnd = h_wnd.into_raw();
    let Msg = msg;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SendMessageA(hWnd, Msg, wParam, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn send_message_callback_a<Sendasyncproc: FnMut(Hwnd, u32, Lresult)>(h_wnd: Hwnd, msg: u32, w_param: Wparam, l_param: Lparam, lp_result_call_back: Sendasyncproc, ) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let Msg = msg;
    let wParam = w_param.into_inner();
    let lParam = l_param.into_inner();
    unsafe extern "system" fn sendasyncproc_impl(param0: HWND, param1: u32, param2: usize, param3: LRESULT) -> () {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input3 = unsafe { Lresult::new(param3) };
            let closure = unsafe {
                &mut *(param2 as usize as *mut Sendasyncproc)
            };
            let return_value = closure(input0, input1, input3);
        })
    }
    let lpResultCallBack = Some(sendasyncproc_impl);
    let mut lp_result_call_back = lp_result_call_back;
    let dwData = (&mut lp_result_call_back) as *mut _ as *mut _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SendMessageCallbackA(hWnd, Msg, wParam, lParam, lpResultCallBack, dwData) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn send_message_callback_w<Sendasyncproc: FnMut(Hwnd, u32, Lresult)>(h_wnd: Hwnd, msg: u32, w_param: Wparam, l_param: Lparam, lp_result_call_back: Sendasyncproc, ) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let Msg = msg;
    let wParam = w_param.into_inner();
    let lParam = l_param.into_inner();
    unsafe extern "system" fn sendasyncproc_impl(param0: HWND, param1: u32, param2: usize, param3: LRESULT) -> () {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input3 = unsafe { Lresult::new(param3) };
            let closure = unsafe {
                &mut *(param2 as usize as *mut Sendasyncproc)
            };
            let return_value = closure(input0, input1, input3);
        })
    }
    let lpResultCallBack = Some(sendasyncproc_impl);
    let mut lp_result_call_back = lp_result_call_back;
    let dwData = (&mut lp_result_call_back) as *mut _ as *mut _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SendMessageCallbackW(hWnd, Msg, wParam, lParam, lpResultCallBack, dwData) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn send_message_timeout_a(h_wnd: Hwnd, msg: u32, w_param: Wparam, l_param: Lparam, fu_flags: u32, u_timeout: u32, ) -> Result<(Lresult, usize)> {
    let mut lpdw_result = mem::MaybeUninit::zeroed();
    let lpdwResult = lpdw_result.as_mut_ptr();
    let hWnd = h_wnd.into_raw();
    let Msg = msg;
    let wParam = w_param.into_inner();
    let lParam = l_param.into_inner();
    let fuFlags = fu_flags;
    let uTimeout = u_timeout;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SendMessageTimeoutA(hWnd, Msg, wParam, lParam, fuFlags, uTimeout, lpdwResult) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpdw_result = unsafe { lpdwResult.assume_init() };
    Ok((return_value,lpdwResult))
}
#[inline]
pub fn send_message_timeout_w(h_wnd: Hwnd, msg: u32, w_param: Wparam, l_param: Lparam, fu_flags: u32, u_timeout: u32, ) -> Result<(Lresult, usize)> {
    let mut lpdw_result = mem::MaybeUninit::zeroed();
    let lpdwResult = lpdw_result.as_mut_ptr();
    let hWnd = h_wnd.into_raw();
    let Msg = msg;
    let wParam = w_param.into_inner();
    let lParam = l_param.into_inner();
    let fuFlags = fu_flags;
    let uTimeout = u_timeout;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SendMessageTimeoutW(hWnd, Msg, wParam, lParam, fuFlags, uTimeout, lpdwResult) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let lpdw_result = unsafe { lpdwResult.assume_init() };
    Ok((return_value,lpdwResult))
}
#[inline]
pub fn send_message_w(h_wnd: Hwnd, msg: u32, ) -> Result<Lresult> {
    let wParam = unsafe { mem::zeroed() };
    let lParam = unsafe { mem::zeroed() };
    let hWnd = h_wnd.into_raw();
    let Msg = msg;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SendMessageW(hWnd, Msg, wParam, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn send_notify_message_a(h_wnd: Hwnd, msg: u32, w_param: Wparam, l_param: Lparam) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let Msg = msg;
    let wParam = w_param.into_inner();
    let lParam = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SendNotifyMessageA(hWnd, Msg, wParam, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn send_notify_message_w(h_wnd: Hwnd, msg: u32, w_param: Wparam, l_param: Lparam) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let Msg = msg;
    let wParam = w_param.into_inner();
    let lParam = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SendNotifyMessageW(hWnd, Msg, wParam, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_caret_blink_time(u_m_seconds: u32) -> Result<BOOL> {
    let uMSeconds = u_m_seconds;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetCaretBlinkTime(uMSeconds) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_caret_pos(x: i32, y: i32) -> Result<BOOL> {
    let X = x;
    let Y = y;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetCaretPos(X, Y) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_class_long_a(h_wnd: Hwnd, n_index: i32, dw_new_long: i32) -> u32 {
    let hWnd = h_wnd.into_raw();
    let nIndex = n_index;
    let dwNewLong = dw_new_long;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetClassLongA(hWnd, nIndex, dwNewLong) };
    return_value
}
#[inline]
pub fn set_class_long_ptr_a(h_wnd: Hwnd, n_index: i32, dw_new_long: isize) -> usize {
    let hWnd = h_wnd.into_raw();
    let nIndex = n_index;
    let dwNewLong = dw_new_long;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetClassLongPtrA(hWnd, nIndex, dwNewLong) };
    return_value
}
#[inline]
pub fn set_class_long_ptr_w(h_wnd: Hwnd, n_index: i32, dw_new_long: isize) -> usize {
    let hWnd = h_wnd.into_raw();
    let nIndex = n_index;
    let dwNewLong = dw_new_long;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetClassLongPtrW(hWnd, nIndex, dwNewLong) };
    return_value
}
#[inline]
pub fn set_class_long_w(h_wnd: Hwnd, n_index: i32, dw_new_long: i32) -> u32 {
    let hWnd = h_wnd.into_raw();
    let nIndex = n_index;
    let dwNewLong = dw_new_long;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetClassLongW(hWnd, nIndex, dwNewLong) };
    return_value
}
#[inline]
pub fn set_class_word(h_wnd: Hwnd, n_index: i32, w_new_word: u16) -> u16 {
    let hWnd = h_wnd.into_raw();
    let nIndex = n_index;
    let wNewWord = w_new_word;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetClassWord(hWnd, nIndex, wNewWord) };
    return_value
}
#[inline]
pub fn set_coalescable_timer(h_wnd: Option<Hwnd>, n_id_event: usize, u_elapse: u32, lp_timer_func: Option<unsafe extern "system" fn(HWND, u32, usize, u32)>, u_tolerance_delay: u32) -> usize {
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let nIDEvent = n_id_event;
    let uElapse = u_elapse;
    let lpTimerFunc = lp_timer_func;
    let uToleranceDelay = u_tolerance_delay;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetCoalescableTimer(hWnd, nIDEvent, uElapse, lpTimerFunc, uToleranceDelay) };
    return_value
}
#[inline]
pub fn set_cursor(h_cursor: Option<Hcursor>) -> Result<Hcursor> {
    let hCursor = h_cursor.map_or(0, Hcursor::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetCursor(hCursor) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_cursor_pos(x: i32, y: i32) -> Result<BOOL> {
    let X = x;
    let Y = y;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetCursorPos(X, Y) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_debug_error_level(dw_level: u32) -> () {
    let dwLevel = dw_level;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetDebugErrorLevel(dwLevel) };
    let _ = return_value;
}
#[inline]
pub fn set_dlg_item_int(h_dlg: Hwnd, n_id_dlg_item: i32, u_value: u32, b_signed: BOOL) -> Result<BOOL> {
    let hDlg = h_dlg.into_raw();
    let nIDDlgItem = n_id_dlg_item;
    let uValue = u_value;
    let bSigned = b_signed;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetDlgItemInt(hDlg, nIDDlgItem, uValue, bSigned) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_dlg_item_text_a(h_dlg: Hwnd, n_id_dlg_item: i32, lp_string: &CStr) -> Result<BOOL> {
    let hDlg = h_dlg.into_raw();
    let nIDDlgItem = n_id_dlg_item;
    let lpString = lp_string.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetDlgItemTextA(hDlg, nIDDlgItem, lpString) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_dlg_item_text_w(h_dlg: Hwnd, n_id_dlg_item: i32, lp_string: &OsStr) -> Result<BOOL> {
    let hDlg = h_dlg.into_raw();
    let nIDDlgItem = n_id_dlg_item;
    let mut temp165: Vec<u16> = lp_string.encode_wide().collect();
    temp165.push(0);
    let lpString = temp165.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetDlgItemTextW(hDlg, nIDDlgItem, lpString) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_foreground_window(h_wnd: Hwnd) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetForegroundWindow(hWnd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_layered_window_attributes(hwnd: Hwnd, cr_key: u32, b_alpha: u8, dw_flags: u32) -> Result<BOOL> {
    let hwnd = hwnd.into_raw();
    let crKey = cr_key;
    let bAlpha = b_alpha;
    let dwFlags = dw_flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetLayeredWindowAttributes(hwnd, crKey, bAlpha, dwFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_menu(h_wnd: Hwnd, h_menu: Option<Hmenu>) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let hMenu = h_menu.map_or(0, Hmenu::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetMenu(hWnd, hMenu) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_menu_default_item(h_menu: Hmenu, u_item: u32, f_by_pos: u32) -> Result<BOOL> {
    let hMenu = h_menu.into_raw();
    let uItem = u_item;
    let fByPos = f_by_pos;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetMenuDefaultItem(hMenu, uItem, fByPos) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_menu_info(param0: Hmenu, param1: &Menuinfo) -> Result<BOOL> {
    let param0 = param0.into_raw();
    let temp166 = param1.to_win32();
    let param1 = &temp166;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetMenuInfo(param0, param1) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_menu_item_bitmaps(h_menu: Hmenu, u_position: u32, u_flags: u32, h_bitmap_unchecked: Option<Hbitmap>, h_bitmap_checked: Option<Hbitmap>) -> Result<BOOL> {
    let hMenu = h_menu.into_raw();
    let uPosition = u_position;
    let uFlags = u_flags;
    let hBitmapUnchecked = h_bitmap_unchecked.map_or(0, Hbitmap::into_raw);
    let hBitmapChecked = h_bitmap_checked.map_or(0, Hbitmap::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetMenuItemBitmaps(hMenu, uPosition, uFlags, hBitmapUnchecked, hBitmapChecked) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_menu_item_info_a(hmenu: Hmenu, item: u32, f_by_positon: BOOL, lpmii: &Menuiteminfoa<'_>) -> Result<BOOL> {
    let hmenu = hmenu.into_raw();
    let item = item;
    let fByPositon = f_by_positon;
    let temp167 = lpmii.to_win32();
    let lpmii = &temp167;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetMenuItemInfoA(hmenu, item, fByPositon, lpmii) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_menu_item_info_w(hmenu: Hmenu, item: u32, f_by_positon: BOOL, lpmii: &Menuiteminfow<'_>) -> Result<BOOL> {
    let hmenu = hmenu.into_raw();
    let item = item;
    let fByPositon = f_by_positon;
    let temp168 = lpmii.to_win32();
    let lpmii = &temp168;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetMenuItemInfoW(hmenu, item, fByPositon, lpmii) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_message_extra_info(l_param: Lparam) -> Lparam {
    let lParam = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetMessageExtraInfo(lParam) };
    return_value
}
#[inline]
pub fn set_message_queue(c_messages_max: i32) -> Result<BOOL> {
    let cMessagesMax = c_messages_max;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetMessageQueue(cMessagesMax) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_parent(h_wnd_child: Hwnd, h_wnd_new_parent: Option<Hwnd>) -> Result<Hwnd> {
    let hWndChild = h_wnd_child.into_raw();
    let hWndNewParent = h_wnd_new_parent.map_or(0, Hwnd::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetParent(hWndChild, hWndNewParent) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_physical_cursor_pos(x: i32, y: i32) -> Result<BOOL> {
    let X = x;
    let Y = y;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetPhysicalCursorPos(X, Y) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_process_dpi_aware() -> Result<BOOL> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetProcessDPIAware() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_process_default_layout(dw_default_layout: u32) -> Result<BOOL> {
    let dwDefaultLayout = dw_default_layout;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetProcessDefaultLayout(dwDefaultLayout) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_prop_a(h_wnd: Hwnd, lp_string: &CStr, h_data: Option<Handle>) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let lpString = lp_string.as_ptr() as _;
    let hData = h_data.map_or(0, Handle::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetPropA(hWnd, lpString, hData) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_prop_w(h_wnd: Hwnd, lp_string: &OsStr, h_data: Option<Handle>) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let mut temp169: Vec<u16> = lp_string.encode_wide().collect();
    temp169.push(0);
    let lpString = temp169.as_ptr() as _;
    let hData = h_data.map_or(0, Handle::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetPropW(hWnd, lpString, hData) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_sys_colors(lpa_elements: &i32, lpa_rgb_values: &[u32]) -> Result<BOOL> {
    // SAFETY: type is a thin type
    let lpaElements = unsafe { &*(lpa_elements as *const _ as *const _) };
    let lpaRgbValues = lpa_rgb_values.as_ptr() as _;
    let cElements = lpa_rgb_values.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetSysColors(cElements, lpaElements, lpaRgbValues) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_system_cursor(hcur: Hcursor, id: u32) -> Result<BOOL> {
    let hcur = hcur.into_raw();
    let id = id;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetSystemCursor(hcur, id) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_timer(h_wnd: Option<Hwnd>, n_id_event: usize, u_elapse: u32, lp_timer_func: Option<unsafe extern "system" fn(HWND, u32, usize, u32)>) -> usize {
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let nIDEvent = n_id_event;
    let uElapse = u_elapse;
    let lpTimerFunc = lp_timer_func;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetTimer(hWnd, nIDEvent, uElapse, lpTimerFunc) };
    return_value
}
#[inline]
pub fn set_window_display_affinity(h_wnd: Hwnd, dw_affinity: u32) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let dwAffinity = dw_affinity;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowDisplayAffinity(hWnd, dwAffinity) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_window_long_a(h_wnd: Hwnd, n_index: i32, dw_new_long: i32) -> Result<i32> {
    let hWnd = h_wnd.into_raw();
    let nIndex = n_index;
    let dwNewLong = dw_new_long;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowLongA(hWnd, nIndex, dwNewLong) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_window_long_ptr_a(h_wnd: Hwnd, n_index: i32, dw_new_long: isize) -> isize {
    let hWnd = h_wnd.into_raw();
    let nIndex = n_index;
    let dwNewLong = dw_new_long;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowLongPtrA(hWnd, nIndex, dwNewLong) };
    return_value
}
#[inline]
pub fn set_window_long_ptr_w(h_wnd: Hwnd, n_index: i32, dw_new_long: isize) -> isize {
    let hWnd = h_wnd.into_raw();
    let nIndex = n_index;
    let dwNewLong = dw_new_long;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowLongPtrW(hWnd, nIndex, dwNewLong) };
    return_value
}
#[inline]
pub fn set_window_long_w(h_wnd: Hwnd, n_index: i32, dw_new_long: i32) -> Result<i32> {
    let hWnd = h_wnd.into_raw();
    let nIndex = n_index;
    let dwNewLong = dw_new_long;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowLongW(hWnd, nIndex, dwNewLong) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_window_placement(h_wnd: Hwnd, lpwndpl: &Windowplacement) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    // SAFETY: type is a thin type
    let lpwndpl = unsafe { &*(lpwndpl as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowPlacement(hWnd, lpwndpl) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_window_pos(h_wnd: Hwnd, h_wnd_insert_after: Option<Hwnd>, x: i32, y: i32, cx: i32, cy: i32, u_flags: u32) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let hWndInsertAfter = h_wnd_insert_after.map_or(0, Hwnd::into_raw);
    let X = x;
    let Y = y;
    let cx = cx;
    let cy = cy;
    let uFlags = u_flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowPos(hWnd, hWndInsertAfter, X, Y, cx, cy, uFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_window_text_a(h_wnd: Hwnd, lp_string: Option<&CStr>) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let lpString = lp_string.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowTextA(hWnd, lpString) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_window_text_w(h_wnd: Hwnd, lp_string: Option<&OsStr>) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let temp170 = lp_string.map(|val| {
        let mut temp170: Vec<u16> = val.encode_wide().collect();
        temp170.push(0);
        temp170
    });
    let lpString = temp170.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowTextW(hWnd, lpString) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_window_word(h_wnd: Hwnd, n_index: i32, w_new_word: u16) -> u16 {
    let hWnd = h_wnd.into_raw();
    let nIndex = n_index;
    let wNewWord = w_new_word;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowWord(hWnd, nIndex, wNewWord) };
    return_value
}
#[inline]
pub fn set_windows_hook_a(n_filter_type: i32, pfn_filter_proc: Option<unsafe extern "system" fn(i32, WPARAM, LPARAM) -> LRESULT>) -> Result<Hhook> {
    let nFilterType = n_filter_type;
    let pfnFilterProc = pfn_filter_proc;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowsHookA(nFilterType, pfnFilterProc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_windows_hook_ex_a(id_hook: i32, lpfn: Option<unsafe extern "system" fn(i32, WPARAM, LPARAM) -> LRESULT>, hmod: Option<Hinstance>, dw_thread_id: u32) -> Result<Hhook> {
    let idHook = id_hook;
    let lpfn = lpfn;
    let hmod = hmod.map_or(0, Hinstance::into_raw);
    let dwThreadId = dw_thread_id;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowsHookExA(idHook, lpfn, hmod, dwThreadId) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_windows_hook_ex_w(id_hook: i32, lpfn: Option<unsafe extern "system" fn(i32, WPARAM, LPARAM) -> LRESULT>, hmod: Option<Hinstance>, dw_thread_id: u32) -> Result<Hhook> {
    let idHook = id_hook;
    let lpfn = lpfn;
    let hmod = hmod.map_or(0, Hinstance::into_raw);
    let dwThreadId = dw_thread_id;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowsHookExW(idHook, lpfn, hmod, dwThreadId) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_windows_hook_w(n_filter_type: i32, pfn_filter_proc: Option<unsafe extern "system" fn(i32, WPARAM, LPARAM) -> LRESULT>) -> Result<Hhook> {
    let nFilterType = n_filter_type;
    let pfnFilterProc = pfn_filter_proc;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowsHookW(nFilterType, pfnFilterProc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn show_caret(h_wnd: Option<Hwnd>) -> Result<BOOL> {
    let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ShowCaret(hWnd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn show_cursor(b_show: BOOL) -> Result<i32> {
    let bShow = b_show;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ShowCursor(bShow) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn show_owned_popups(h_wnd: Hwnd, f_show: BOOL) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let fShow = f_show;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ShowOwnedPopups(hWnd, fShow) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn show_window(h_wnd: Hwnd, n_cmd_show: u32) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let nCmdShow = n_cmd_show;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ShowWindow(hWnd, nCmdShow) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn show_window_async(h_wnd: Hwnd, n_cmd_show: u32) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let nCmdShow = n_cmd_show;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ShowWindowAsync(hWnd, nCmdShow) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn sound_sentry() -> Result<BOOL> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SoundSentry() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn switch_to_this_window(hwnd: Hwnd, f_unknown: BOOL) -> () {
    let hwnd = hwnd.into_raw();
    let fUnknown = f_unknown;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SwitchToThisWindow(hwnd, fUnknown) };
    let _ = return_value;
}
#[inline]
pub fn tile_windows(hwnd_parent: Option<Hwnd>, w_how: u32, lp_rect: Option<&Rect>, lp_kids: Option<&[Hwnd]>) -> u16 {
    let hwndParent = hwnd_parent.map_or(0, Hwnd::into_raw);
    let wHow = w_how;
    // SAFETY: type is a thin type
    let lpRect = lp_rect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let lpKids = lp_kids.map_or(ptr::null(), |v| v.as_ptr() as _);
    let cKids = lp_kids.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::TileWindows(hwndParent, wHow, lpRect, cKids, lpKids) };
    return_value
}
#[inline]
pub fn track_popup_menu(h_menu: Hmenu, u_flags: u32, x: i32, y: i32, h_wnd: Hwnd, prc_rect: &[Rect]) -> Result<BOOL> {
    let hMenu = h_menu.into_raw();
    let uFlags = u_flags;
    let x = x;
    let y = y;
    let hWnd = h_wnd.into_raw();
    let prcRect = prc_rect.as_ptr() as _;
    let nReserved = prc_rect.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::TrackPopupMenu(hMenu, uFlags, x, y, nReserved, hWnd, prcRect) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn track_popup_menu_ex(h_menu: Hmenu, u_flags: u32, x: i32, y: i32, hwnd: Hwnd, lptpm: Option<&Tpmparams>) -> Result<BOOL> {
    let hMenu = h_menu.into_raw();
    let uFlags = u_flags;
    let x = x;
    let y = y;
    let hwnd = hwnd.into_raw();
    let temp171 = lptpm.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
    let lptpm = temp171.as_ref();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::TrackPopupMenuEx(hMenu, uFlags, x, y, hwnd, lptpm) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn translate_accelerator_a(h_wnd: Hwnd, h_acc_table: Haccel, lp_msg: &Msg) -> Result<i32> {
    let hWnd = h_wnd.into_raw();
    let hAccTable = h_acc_table.into_raw();
    // SAFETY: type is a thin type
    let lpMsg = unsafe { &*(lp_msg as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::TranslateAcceleratorA(hWnd, hAccTable, lpMsg) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn translate_accelerator_w(h_wnd: Hwnd, h_acc_table: Haccel, lp_msg: &Msg) -> Result<i32> {
    let hWnd = h_wnd.into_raw();
    let hAccTable = h_acc_table.into_raw();
    // SAFETY: type is a thin type
    let lpMsg = unsafe { &*(lp_msg as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::TranslateAcceleratorW(hWnd, hAccTable, lpMsg) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn translate_mdi_sys_accel(h_wnd_client: Hwnd, lp_msg: &Msg) -> Result<BOOL> {
    let hWndClient = h_wnd_client.into_raw();
    // SAFETY: type is a thin type
    let lpMsg = unsafe { &*(lp_msg as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::TranslateMDISysAccel(hWndClient, lpMsg) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn translate_message(lp_msg: &Msg) -> BOOL {
    // SAFETY: type is a thin type
    let lpMsg = unsafe { &*(lp_msg as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::TranslateMessage(lpMsg) };
    return_value
}
#[inline]
pub fn unhook_windows_hook(n_code: i32, pfn_filter_proc: Option<unsafe extern "system" fn(i32, WPARAM, LPARAM) -> LRESULT>) -> Result<BOOL> {
    let nCode = n_code;
    let pfnFilterProc = pfn_filter_proc;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::UnhookWindowsHook(nCode, pfnFilterProc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn unhook_windows_hook_ex(hhk: Hhook) -> Result<BOOL> {
    let hhk = hhk.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::UnhookWindowsHookEx(hhk) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn unregister_class_a(lp_class_name: &CStr, h_instance: Option<Hinstance>) -> Result<BOOL> {
    let lpClassName = lp_class_name.as_ptr() as _;
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::UnregisterClassA(lpClassName, hInstance) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn unregister_class_w(lp_class_name: &OsStr, h_instance: Option<Hinstance>) -> Result<BOOL> {
    let mut temp172: Vec<u16> = lp_class_name.encode_wide().collect();
    temp172.push(0);
    let lpClassName = temp172.as_ptr() as _;
    let hInstance = h_instance.map_or(0, Hinstance::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::UnregisterClassW(lpClassName, hInstance) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn update_layered_window(h_wnd: Hwnd, hdc_dst: Option<Hdc>, ppt_dst: Option<&Point>, psize: Option<&Size>, hdc_src: Option<Hdc>, ppt_src: Option<&Point>, pblend: Option<&[Blendfunction]>, dw_flags: u32) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let hdcDst = hdc_dst.map_or(0, Hdc::into_raw);
    // SAFETY: type is a thin type
    let pptDst = ppt_dst.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    // SAFETY: type is a thin type
    let psize = psize.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let hdcSrc = hdc_src.map_or(0, Hdc::into_raw);
    // SAFETY: type is a thin type
    let pptSrc = ppt_src.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let pblend = pblend.map_or(ptr::null(), |v| v.as_ptr() as _);
    let crKey = pblend.len() as _;
    let dwFlags = dw_flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::UpdateLayeredWindow(hWnd, hdcDst, pptDst, psize, hdcSrc, pptSrc, crKey, pblend, dwFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn update_layered_window_indirect(h_wnd: Hwnd, p_ulw_info: &Updatelayeredwindowinfo<'_>) -> Result<BOOL> {
    let hWnd = h_wnd.into_raw();
    let temp173 = p_ulw_info.to_win32();
    let pULWInfo = &temp173;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::UpdateLayeredWindowIndirect(hWnd, pULWInfo) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn wait_message() -> Result<BOOL> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::WaitMessage() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn window_from_physical_point(point: Point) -> Result<Hwnd> {
    let Point = point.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::WindowFromPhysicalPoint(Point) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn window_from_point(point: Point) -> Result<Hwnd> {
    let Point = point.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::WindowFromPoint(Point) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn add_dll_directory(new_directory: &OsStr) -> &mut todo_void_ret {
//      let mut temp174: Vec<u16> = new_directory.encode_wide().collect();
//      temp174.push(0);
//      let NewDirectory = temp174.as_ptr() as _;
//      let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::AddDllDirectory(NewDirectory) };
//      return_value
//  }
#[inline]
pub fn begin_update_resource_a(p_file_name: &CStr, b_delete_existing_resources: BOOL) -> Result<Handle> {
    let pFileName = p_file_name.as_ptr() as _;
    let bDeleteExistingResources = b_delete_existing_resources;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::BeginUpdateResourceA(pFileName, bDeleteExistingResources) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn begin_update_resource_w(p_file_name: &OsStr, b_delete_existing_resources: BOOL) -> Result<Handle> {
    let mut temp175: Vec<u16> = p_file_name.encode_wide().collect();
    temp175.push(0);
    let pFileName = temp175.as_ptr() as _;
    let bDeleteExistingResources = b_delete_existing_resources;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::BeginUpdateResourceW(pFileName, bDeleteExistingResources) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn disable_thread_library_calls(h_lib_module: Hinstance) -> Result<BOOL> {
    let hLibModule = h_lib_module.into_raw();
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::DisableThreadLibraryCalls(hLibModule) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn end_update_resource_a(h_update: Handle, f_discard: BOOL) -> Result<BOOL> {
    let hUpdate = h_update.into_raw();
    let fDiscard = f_discard;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EndUpdateResourceA(hUpdate, fDiscard) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn end_update_resource_w(h_update: Handle, f_discard: BOOL) -> Result<BOOL> {
    let hUpdate = h_update.into_raw();
    let fDiscard = f_discard;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EndUpdateResourceW(hUpdate, fDiscard) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_resource_languages_a(h_module: Option<Hinstance>, lp_type: &CStr, lp_name: &CStr, lp_enum_func: Option<unsafe extern "system" fn(HINSTANCE, PCSTR, PCSTR, u16, isize) -> BOOL>, l_param: isize) -> Result<BOOL> {
    let hModule = h_module.map_or(0, Hinstance::into_raw);
    let lpType = lp_type.as_ptr() as _;
    let lpName = lp_name.as_ptr() as _;
    let lpEnumFunc = lp_enum_func;
    let lParam = l_param;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EnumResourceLanguagesA(hModule, lpType, lpName, lpEnumFunc, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_resource_languages_ex_a(h_module: Option<Hinstance>, lp_type: &CStr, lp_name: &CStr, lp_enum_func: Option<unsafe extern "system" fn(HINSTANCE, PCSTR, PCSTR, u16, isize) -> BOOL>, l_param: Option<isize>, dw_flags: u32, lang_id: u16) -> Result<BOOL> {
    let hModule = h_module.map_or(0, Hinstance::into_raw);
    let lpType = lp_type.as_ptr() as _;
    let lpName = lp_name.as_ptr() as _;
    let lpEnumFunc = lp_enum_func;
    let lParam = l_param;
    let dwFlags = dw_flags;
    let LangId = lang_id;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EnumResourceLanguagesExA(hModule, lpType, lpName, lpEnumFunc, lParam, dwFlags, LangId) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_resource_languages_ex_w(h_module: Option<Hinstance>, lp_type: &OsStr, lp_name: &OsStr, lp_enum_func: Option<unsafe extern "system" fn(HINSTANCE, PCWSTR, PCWSTR, u16, isize) -> BOOL>, l_param: Option<isize>, dw_flags: u32, lang_id: u16) -> Result<BOOL> {
    let hModule = h_module.map_or(0, Hinstance::into_raw);
    let mut temp176: Vec<u16> = lp_type.encode_wide().collect();
    temp176.push(0);
    let lpType = temp176.as_ptr() as _;
    let mut temp177: Vec<u16> = lp_name.encode_wide().collect();
    temp177.push(0);
    let lpName = temp177.as_ptr() as _;
    let lpEnumFunc = lp_enum_func;
    let lParam = l_param;
    let dwFlags = dw_flags;
    let LangId = lang_id;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EnumResourceLanguagesExW(hModule, lpType, lpName, lpEnumFunc, lParam, dwFlags, LangId) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_resource_languages_w(h_module: Option<Hinstance>, lp_type: &OsStr, lp_name: &OsStr, lp_enum_func: Option<unsafe extern "system" fn(HINSTANCE, PCWSTR, PCWSTR, u16, isize) -> BOOL>, l_param: isize) -> Result<BOOL> {
    let hModule = h_module.map_or(0, Hinstance::into_raw);
    let mut temp178: Vec<u16> = lp_type.encode_wide().collect();
    temp178.push(0);
    let lpType = temp178.as_ptr() as _;
    let mut temp179: Vec<u16> = lp_name.encode_wide().collect();
    temp179.push(0);
    let lpName = temp179.as_ptr() as _;
    let lpEnumFunc = lp_enum_func;
    let lParam = l_param;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EnumResourceLanguagesW(hModule, lpType, lpName, lpEnumFunc, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_resource_names_a(h_module: Option<Hinstance>, lp_type: &CStr, lp_enum_func: Option<unsafe extern "system" fn(HINSTANCE, PCSTR, PCSTR, isize) -> BOOL>, l_param: isize) -> Result<BOOL> {
    let hModule = h_module.map_or(0, Hinstance::into_raw);
    let lpType = lp_type.as_ptr() as _;
    let lpEnumFunc = lp_enum_func;
    let lParam = l_param;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EnumResourceNamesA(hModule, lpType, lpEnumFunc, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_resource_names_ex_a(h_module: Option<Hinstance>, lp_type: &CStr, lp_enum_func: Option<unsafe extern "system" fn(HINSTANCE, PCSTR, PCSTR, isize) -> BOOL>, l_param: isize, dw_flags: u32, lang_id: u16) -> Result<BOOL> {
    let hModule = h_module.map_or(0, Hinstance::into_raw);
    let lpType = lp_type.as_ptr() as _;
    let lpEnumFunc = lp_enum_func;
    let lParam = l_param;
    let dwFlags = dw_flags;
    let LangId = lang_id;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EnumResourceNamesExA(hModule, lpType, lpEnumFunc, lParam, dwFlags, LangId) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_resource_names_ex_w(h_module: Option<Hinstance>, lp_type: &OsStr, lp_enum_func: Option<unsafe extern "system" fn(HINSTANCE, PCWSTR, PCWSTR, isize) -> BOOL>, l_param: isize, dw_flags: u32, lang_id: u16) -> Result<BOOL> {
    let hModule = h_module.map_or(0, Hinstance::into_raw);
    let mut temp180: Vec<u16> = lp_type.encode_wide().collect();
    temp180.push(0);
    let lpType = temp180.as_ptr() as _;
    let lpEnumFunc = lp_enum_func;
    let lParam = l_param;
    let dwFlags = dw_flags;
    let LangId = lang_id;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EnumResourceNamesExW(hModule, lpType, lpEnumFunc, lParam, dwFlags, LangId) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_resource_names_w(h_module: Option<Hinstance>, lp_type: &OsStr, lp_enum_func: Option<unsafe extern "system" fn(HINSTANCE, PCWSTR, PCWSTR, isize) -> BOOL>, l_param: isize) -> Result<BOOL> {
    let hModule = h_module.map_or(0, Hinstance::into_raw);
    let mut temp181: Vec<u16> = lp_type.encode_wide().collect();
    temp181.push(0);
    let lpType = temp181.as_ptr() as _;
    let lpEnumFunc = lp_enum_func;
    let lParam = l_param;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EnumResourceNamesW(hModule, lpType, lpEnumFunc, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_resource_types_a(h_module: Option<Hinstance>, lp_enum_func: Option<unsafe extern "system" fn(HINSTANCE, PCSTR, isize) -> BOOL>, l_param: isize) -> Result<BOOL> {
    let hModule = h_module.map_or(0, Hinstance::into_raw);
    let lpEnumFunc = lp_enum_func;
    let lParam = l_param;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EnumResourceTypesA(hModule, lpEnumFunc, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_resource_types_ex_a(h_module: Option<Hinstance>, lp_enum_func: Option<unsafe extern "system" fn(HINSTANCE, PCSTR, isize) -> BOOL>, l_param: isize, dw_flags: u32, lang_id: u16) -> Result<BOOL> {
    let hModule = h_module.map_or(0, Hinstance::into_raw);
    let lpEnumFunc = lp_enum_func;
    let lParam = l_param;
    let dwFlags = dw_flags;
    let LangId = lang_id;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EnumResourceTypesExA(hModule, lpEnumFunc, lParam, dwFlags, LangId) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_resource_types_ex_w(h_module: Option<Hinstance>, lp_enum_func: Option<unsafe extern "system" fn(HINSTANCE, PCWSTR, isize) -> BOOL>, l_param: isize, dw_flags: u32, lang_id: u16) -> Result<BOOL> {
    let hModule = h_module.map_or(0, Hinstance::into_raw);
    let lpEnumFunc = lp_enum_func;
    let lParam = l_param;
    let dwFlags = dw_flags;
    let LangId = lang_id;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EnumResourceTypesExW(hModule, lpEnumFunc, lParam, dwFlags, LangId) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn enum_resource_types_w(h_module: Option<Hinstance>, lp_enum_func: Option<unsafe extern "system" fn(HINSTANCE, PCWSTR, isize) -> BOOL>, l_param: isize) -> Result<BOOL> {
    let hModule = h_module.map_or(0, Hinstance::into_raw);
    let lpEnumFunc = lp_enum_func;
    let lParam = l_param;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EnumResourceTypesW(hModule, lpEnumFunc, lParam) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn find_resource_a(h_module: Option<Hinstance>, lp_name: &CStr, lp_type: &CStr) -> Result<Hrsrc> {
    let hModule = h_module.map_or(0, Hinstance::into_raw);
    let lpName = lp_name.as_ptr() as _;
    let lpType = lp_type.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::FindResourceA(hModule, lpName, lpType) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn find_resource_ex_a(h_module: Option<Hinstance>, lp_type: &CStr, lp_name: &CStr, w_language: u16) -> Result<Hrsrc> {
    let hModule = h_module.map_or(0, Hinstance::into_raw);
    let lpType = lp_type.as_ptr() as _;
    let lpName = lp_name.as_ptr() as _;
    let wLanguage = w_language;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::FindResourceExA(hModule, lpType, lpName, wLanguage) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn find_resource_ex_w(h_module: Option<Hinstance>, lp_type: &OsStr, lp_name: &OsStr, w_language: u16) -> Result<Hrsrc> {
    let hModule = h_module.map_or(0, Hinstance::into_raw);
    let mut temp182: Vec<u16> = lp_type.encode_wide().collect();
    temp182.push(0);
    let lpType = temp182.as_ptr() as _;
    let mut temp183: Vec<u16> = lp_name.encode_wide().collect();
    temp183.push(0);
    let lpName = temp183.as_ptr() as _;
    let wLanguage = w_language;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::FindResourceExW(hModule, lpType, lpName, wLanguage) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn find_resource_w(h_module: Option<Hinstance>, lp_name: &OsStr, lp_type: &OsStr) -> Result<Hrsrc> {
    let hModule = h_module.map_or(0, Hinstance::into_raw);
    let mut temp184: Vec<u16> = lp_name.encode_wide().collect();
    temp184.push(0);
    let lpName = temp184.as_ptr() as _;
    let mut temp185: Vec<u16> = lp_type.encode_wide().collect();
    temp185.push(0);
    let lpType = temp185.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::FindResourceW(hModule, lpName, lpType) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn free_library(h_lib_module: Hinstance) -> Result<BOOL> {
    let hLibModule = h_lib_module.into_raw();
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::FreeLibrary(hLibModule) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn free_library_and_exit_thread(h_lib_module: Hinstance, dw_exit_code: u32) -> () {
    let hLibModule = h_lib_module.into_raw();
    let dwExitCode = dw_exit_code;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::FreeLibraryAndExitThread(hLibModule, dwExitCode) };
    let _ = return_value;
}
#[inline]
pub fn free_resource(h_res_data: isize) -> Result<BOOL> {
    let hResData = h_res_data;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::FreeResource(hResData) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_dll_directory_a(n_buffer_length: u32, ) -> (u32, CString) {
    let mut lp_buffer = Vec::<u8>::with_capacity(n_buffer_length as usize + 1);
    let lpBuffer = lp_buffer.as_mut_ptr();
    let nBufferLength = n_buffer_length;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::GetDllDirectoryA(nBufferLength, lpBuffer) };
    let out53 = unsafe {
        slice::from_raw_parts(unsafe { lpBuffer.assume_init() }, return_value as usize)
    };
    let mut out53 = out53.to_vec();
    out53.push(0);
    let lp_buffer = unsafe { CString::from_vec_unchecked(out53) };
    (return_value,lpBuffer)
}
#[inline]
pub fn get_dll_directory_w(n_buffer_length: u32, ) -> (u32, OsString) {
    let mut lp_buffer = Vec::<u16>::with_capacity(n_buffer_length as usize + 1);
    let lpBuffer = lp_buffer.as_mut_ptr();
    let nBufferLength = n_buffer_length;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::GetDllDirectoryW(nBufferLength, lpBuffer) };
    let out54 = unsafe {
        slice::from_raw_parts(unsafe { lpBuffer.assume_init() }, return_value as usize)
    };
    let out54 = out54.to_vec();
    let lp_buffer = OsStringExt::from_wide(out54);
    (return_value,lpBuffer)
}
#[inline]
pub fn get_module_file_name_a(h_module: Option<Hinstance>, n_size: u32) -> (u32, CString) {
    let mut lp_filename = Vec::<u8>::with_capacity(n_size as usize + 1);
    let lpFilename = lp_filename.as_mut_ptr();
    let hModule = h_module.map_or(0, Hinstance::into_raw);
    let nSize = n_size;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::GetModuleFileNameA(hModule, lpFilename, nSize) };
    let out55 = unsafe {
        slice::from_raw_parts(unsafe { lpFilename.assume_init() }, return_value as usize)
    };
    let mut out55 = out55.to_vec();
    out55.push(0);
    let lp_filename = unsafe { CString::from_vec_unchecked(out55) };
    (return_value,lpFilename)
}
#[inline]
pub fn get_module_file_name_w(h_module: Option<Hinstance>, n_size: u32) -> (u32, OsString) {
    let mut lp_filename = Vec::<u16>::with_capacity(n_size as usize + 1);
    let lpFilename = lp_filename.as_mut_ptr();
    let hModule = h_module.map_or(0, Hinstance::into_raw);
    let nSize = n_size;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::GetModuleFileNameW(hModule, lpFilename, nSize) };
    let out56 = unsafe {
        slice::from_raw_parts(unsafe { lpFilename.assume_init() }, return_value as usize)
    };
    let out56 = out56.to_vec();
    let lp_filename = OsStringExt::from_wide(out56);
    (return_value,lpFilename)
}
#[inline]
pub fn get_module_handle_a(lp_module_name: Option<&CStr>) -> Result<Hinstance> {
    let lpModuleName = lp_module_name.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::GetModuleHandleA(lpModuleName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_module_handle_ex_a(dw_flags: u32, lp_module_name: Option<&CStr>, ) -> Result<(BOOL, Hinstance)> {
    let mut ph_module = mem::MaybeUninit::zeroed();
    let phModule = ph_module.as_mut_ptr();
    let dwFlags = dw_flags;
    let lpModuleName = lp_module_name.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::GetModuleHandleExA(dwFlags, lpModuleName, phModule) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let ph_module = unsafe { Hinstance::new(unsafe { phModule.assume_init() }) };
    Ok((return_value,phModule))
}
#[inline]
pub fn get_module_handle_ex_w(dw_flags: u32, lp_module_name: Option<&OsStr>, ) -> Result<(BOOL, Hinstance)> {
    let mut ph_module = mem::MaybeUninit::zeroed();
    let phModule = ph_module.as_mut_ptr();
    let dwFlags = dw_flags;
    let temp186 = lp_module_name.map(|val| {
        let mut temp186: Vec<u16> = val.encode_wide().collect();
        temp186.push(0);
        temp186
    });
    let lpModuleName = temp186.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::GetModuleHandleExW(dwFlags, lpModuleName, phModule) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let ph_module = unsafe { Hinstance::new(unsafe { phModule.assume_init() }) };
    Ok((return_value,phModule))
}
#[inline]
pub fn get_module_handle_w(lp_module_name: Option<&OsStr>) -> Result<Hinstance> {
    let temp187 = lp_module_name.map(|val| {
        let mut temp187: Vec<u16> = val.encode_wide().collect();
        temp187.push(0);
        temp187
    });
    let lpModuleName = temp187.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::GetModuleHandleW(lpModuleName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn get_proc_address(h_module: Hinstance, lp_proc_name: &CStr) -> Option<unsafe extern "system" fn() -> isize> {
    let hModule = h_module.into_raw();
    let lpProcName = lp_proc_name.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::GetProcAddress(hModule, lpProcName) };
    return_value
}
#[inline]
pub fn load_library_a(lp_lib_file_name: &CStr) -> Result<Hinstance> {
    let lpLibFileName = lp_lib_file_name.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::LoadLibraryA(lpLibFileName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn load_library_ex_a(lp_lib_file_name: &CStr, h_file: Handle, dw_flags: u32) -> Result<Hinstance> {
    let lpLibFileName = lp_lib_file_name.as_ptr() as _;
    let hFile = h_file.into_raw();
    let dwFlags = dw_flags;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::LoadLibraryExA(lpLibFileName, hFile, dwFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn load_library_ex_w(lp_lib_file_name: &OsStr, h_file: Handle, dw_flags: u32) -> Result<Hinstance> {
    let mut temp188: Vec<u16> = lp_lib_file_name.encode_wide().collect();
    temp188.push(0);
    let lpLibFileName = temp188.as_ptr() as _;
    let hFile = h_file.into_raw();
    let dwFlags = dw_flags;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::LoadLibraryExW(lpLibFileName, hFile, dwFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn load_library_w(lp_lib_file_name: &OsStr) -> Result<Hinstance> {
    let mut temp189: Vec<u16> = lp_lib_file_name.encode_wide().collect();
    temp189.push(0);
    let lpLibFileName = temp189.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::LoadLibraryW(lpLibFileName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn load_module(lp_module_name: &CStr, lp_parameter_block: &todo_void) -> u32 {
//      let lpModuleName = lp_module_name.as_ptr() as _;
//      // SAFETY: type is a thin type
//      let lpParameterBlock = unsafe { &*(lp_parameter_block as *const _ as *const _) };
//      let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::LoadModule(lpModuleName, lpParameterBlock) };
//      return_value
//  }
#[inline]
pub fn load_packaged_library(lpw_lib_file_name: &OsStr, reserved: u32) -> Result<Hinstance> {
    let mut temp190: Vec<u16> = lpw_lib_file_name.encode_wide().collect();
    temp190.push(0);
    let lpwLibFileName = temp190.as_ptr() as _;
    let Reserved = reserved;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::LoadPackagedLibrary(lpwLibFileName, Reserved) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn load_resource(h_module: Option<Hinstance>, h_res_info: Hrsrc) -> isize {
    let hModule = h_module.map_or(0, Hinstance::into_raw);
    let hResInfo = h_res_info.into_raw();
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::LoadResource(hModule, hResInfo) };
    return_value
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn lock_resource(h_res_data: isize) -> &mut todo_void_ret {
//      let hResData = h_res_data;
//      let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::LockResource(hResData) };
//      return_value
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn remove_dll_directory(cookie: &todo_void) -> Result<BOOL> {
//      // SAFETY: type is a thin type
//      let Cookie = unsafe { &*(cookie as *const _ as *const _) };
//      let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::RemoveDllDirectory(Cookie) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
#[inline]
pub fn set_default_dll_directories(directory_flags: u32) -> Result<BOOL> {
    let DirectoryFlags = directory_flags;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::SetDefaultDllDirectories(DirectoryFlags) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_dll_directory_a(lp_path_name: Option<&CStr>) -> Result<BOOL> {
    let lpPathName = lp_path_name.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::SetDllDirectoryA(lpPathName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_dll_directory_w(lp_path_name: Option<&OsStr>) -> Result<BOOL> {
    let temp191 = lp_path_name.map(|val| {
        let mut temp191: Vec<u16> = val.encode_wide().collect();
        temp191.push(0);
        temp191
    });
    let lpPathName = temp191.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::SetDllDirectoryW(lpPathName) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn sizeof_resource(h_module: Option<Hinstance>, h_res_info: Hrsrc) -> u32 {
    let hModule = h_module.map_or(0, Hinstance::into_raw);
    let hResInfo = h_res_info.into_raw();
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::SizeofResource(hModule, hResInfo) };
    return_value
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn update_resource_a(h_update: Handle, lp_type: &CStr, lp_name: &CStr, w_language: u16, lp_data: Option<&[todo_void]>, ) -> Result<BOOL> {
//      let hUpdate = h_update.into_raw();
//      let lpType = lp_type.as_ptr() as _;
//      let lpName = lp_name.as_ptr() as _;
//      let wLanguage = w_language;
//      let lpData = lp_data.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let cb = lp_data.len() as _;
//      let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::UpdateResourceA(hUpdate, lpType, lpName, wLanguage, lpData, cb) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn update_resource_w(h_update: Handle, lp_type: &OsStr, lp_name: &OsStr, w_language: u16, lp_data: Option<&[todo_void]>, ) -> Result<BOOL> {
//      let hUpdate = h_update.into_raw();
//      let mut temp192: Vec<u16> = lp_type.encode_wide().collect();
//      temp192.push(0);
//      let lpType = temp192.as_ptr() as _;
//      let mut temp193: Vec<u16> = lp_name.encode_wide().collect();
//      temp193.push(0);
//      let lpName = temp193.as_ptr() as _;
//      let wLanguage = w_language;
//      let lpData = lp_data.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let cb = lp_data.len() as _;
//      let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::UpdateResourceW(hUpdate, lpType, lpName, wLanguage, lpData, cb) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      Ok(return_value)
//  }
#[inline]
pub fn choose_pixel_format(hdc: Hdc, ppfd: &Pixelformatdescriptor) -> Result<i32> {
    let hdc = hdc.into_raw();
    let temp194 = ppfd.to_win32();
    let ppfd = &temp194;
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::ChoosePixelFormat(hdc, ppfd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn describe_pixel_format(hdc: Hdc, i_pixel_format: i8, n_bytes: u32, ) -> Result<(i32, Pixelformatdescriptor)> {
    let mut ppfd = mem::MaybeUninit::zeroed();
    let ppfd = ppfd.as_mut_ptr();
    let hdc = hdc.into_raw();
    let iPixelFormat = i_pixel_format;
    let nBytes = n_bytes;
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::DescribePixelFormat(hdc, iPixelFormat, nBytes, ppfd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let ppfd = unsafe { Pixelformatdescriptor::from_win32(unsafe { ppfd.assume_init() }) };
    Ok((return_value,ppfd))
}
#[inline]
pub fn get_enh_meta_file_pixel_format(hemf: Henhmetafile, cb_buffer: u32, ) -> (u32, Pixelformatdescriptor) {
    let mut ppfd = mem::MaybeUninit::zeroed();
    let ppfd = ppfd.as_mut_ptr();
    let hemf = hemf.into_raw();
    let cbBuffer = cb_buffer;
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::GetEnhMetaFilePixelFormat(hemf, cbBuffer, ppfd) };
    let ppfd = unsafe { Pixelformatdescriptor::from_win32(unsafe { ppfd.assume_init() }) };
    (return_value,ppfd)
}
#[inline]
pub fn get_pixel_format(hdc: Hdc) -> Result<i32> {
    let hdc = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::GetPixelFormat(hdc) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn set_pixel_format(hdc: Hdc, format: i32, ppfd: &Pixelformatdescriptor) -> Result<BOOL> {
    let hdc = hdc.into_raw();
    let format = format;
    let temp195 = ppfd.to_win32();
    let ppfd = &temp195;
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::SetPixelFormat(hdc, format, ppfd) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn swap_buffers(param0: Hdc) -> Result<BOOL> {
    let param0 = param0.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::SwapBuffers(param0) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn wgl_copy_context(param0: Hglrc, param1: Hglrc, param2: u32) -> Result<BOOL> {
    let param0 = param0.into_raw();
    let param1 = param1.into_raw();
    let param2 = param2;
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglCopyContext(param0, param1, param2) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn wgl_create_context(param0: Hdc) -> Result<Hglrc> {
    let param0 = param0.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglCreateContext(param0) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn wgl_create_layer_context(param0: Hdc, param1: i32) -> Result<Hglrc> {
    let param0 = param0.into_raw();
    let param1 = param1;
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglCreateLayerContext(param0, param1) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn wgl_delete_context(param0: Hglrc) -> Result<BOOL> {
    let param0 = param0.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglDeleteContext(param0) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn wgl_describe_layer_plane(param0: Hdc, param1: i32, param2: i32, param3: u32, param4: Layerplanedescriptor) -> Result<(BOOL, Layerplanedescriptor)> {
    let param0 = param0.into_raw();
    let param1 = param1;
    let param2 = param2;
    let param3 = param3;
    let mut param4 = param4.to_win32();
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglDescribeLayerPlane(param0, param1, param2, param3, &mut param4) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let param4 = unsafe { Layerplanedescriptor::from_win32(param4) };
    Ok((return_value,param4))
}
#[inline]
pub fn wgl_get_current_context() -> Result<Hglrc> {
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglGetCurrentContext() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn wgl_get_current_dc() -> Result<Hdc> {
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglGetCurrentDC() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn wgl_get_layer_palette_entries(param0: Hdc, param1: i32, param2: i32, param3: i32, param4: u32) -> Result<(i32, u32)> {
    let param0 = param0.into_raw();
    let param1 = param1;
    let param2 = param2;
    let param3 = param3;
    let mut param4 = param4;
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglGetLayerPaletteEntries(param0, param1, param2, param3, &mut param4) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let param4 = param4;
    Ok((return_value,param4))
}
#[inline]
pub fn wgl_get_proc_address(param0: &CStr) -> Option<unsafe extern "system" fn() -> isize> {
    let param0 = param0.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglGetProcAddress(param0) };
    return_value
}
#[inline]
pub fn wgl_make_current(param0: Hdc, param1: Hglrc) -> Result<BOOL> {
    let param0 = param0.into_raw();
    let param1 = param1.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglMakeCurrent(param0, param1) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn wgl_realize_layer_palette(param0: Hdc, param1: i32, param2: BOOL) -> Result<BOOL> {
    let param0 = param0.into_raw();
    let param1 = param1;
    let param2 = param2;
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglRealizeLayerPalette(param0, param1, param2) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn wgl_set_layer_palette_entries(param0: Hdc, param1: i32, param2: i32, param3: i32, param4: &u32) -> Result<i32> {
    let param0 = param0.into_raw();
    let param1 = param1;
    let param2 = param2;
    let param3 = param3;
    // SAFETY: type is a thin type
    let param4 = unsafe { &*(param4 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglSetLayerPaletteEntries(param0, param1, param2, param3, param4) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn wgl_share_lists(param0: Hglrc, param1: Hglrc) -> Result<BOOL> {
    let param0 = param0.into_raw();
    let param1 = param1.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglShareLists(param0, param1) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn wgl_swap_layer_buffers(param0: Hdc, param1: u32) -> Result<BOOL> {
    let param0 = param0.into_raw();
    let param1 = param1;
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglSwapLayerBuffers(param0, param1) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn wgl_use_font_bitmaps_a(param0: Hdc, param1: u32, param2: u32, param3: u32) -> Result<BOOL> {
    let param0 = param0.into_raw();
    let param1 = param1;
    let param2 = param2;
    let param3 = param3;
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglUseFontBitmapsA(param0, param1, param2, param3) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn wgl_use_font_bitmaps_w(param0: Hdc, param1: u32, param2: u32, param3: u32) -> Result<BOOL> {
    let param0 = param0.into_raw();
    let param1 = param1;
    let param2 = param2;
    let param3 = param3;
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglUseFontBitmapsW(param0, param1, param2, param3) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    Ok(return_value)
}
#[inline]
pub fn wgl_use_font_outlines_a(param0: Hdc, param1: u32, param2: u32, param3: u32, param4: f32, param5: f32, param6: i32, param7: Glyphmetricsfloat) -> Result<(BOOL, Glyphmetricsfloat)> {
    let param0 = param0.into_raw();
    let param1 = param1;
    let param2 = param2;
    let param3 = param3;
    let param4 = param4;
    let param5 = param5;
    let param6 = param6;
    let mut param7 = param7.to_win32();
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglUseFontOutlinesA(param0, param1, param2, param3, param4, param5, param6, &mut param7) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let param7 = unsafe { Glyphmetricsfloat::from_win32(param7) };
    Ok((return_value,param7))
}
#[inline]
pub fn wgl_use_font_outlines_w(param0: Hdc, param1: u32, param2: u32, param3: u32, param4: f32, param5: f32, param6: i32, param7: Glyphmetricsfloat) -> Result<(BOOL, Glyphmetricsfloat)> {
    let param0 = param0.into_raw();
    let param1 = param1;
    let param2 = param2;
    let param3 = param3;
    let param4 = param4;
    let param5 = param5;
    let param6 = param6;
    let mut param7 = param7.to_win32();
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglUseFontOutlinesW(param0, param1, param2, param3, param4, param5, param6, &mut param7) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let param7 = unsafe { Glyphmetricsfloat::from_win32(param7) };
    Ok((return_value,param7))
}
