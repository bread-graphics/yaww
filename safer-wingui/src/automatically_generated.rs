// Automatically generated by yaww-generator
use crate::{abort_on_panic, Cow, Lresult, Lparam, Wparam, wide_strlen, Result, Devmodea, Devmodew, PointerTypeInfo};
use core::{fmt, mem, ptr, slice, num::NonZeroIsize, marker::PhantomData};
use cstr_core::CStr;
#[cfg(feature = "alloc")]
use alloc::vec::Vec;
#[cfg(feature = "alloc")]
use cstr_core::CString;
#[cfg(feature = "std")]
use std::{ffi::{OsStr, OsString}, os::windows::prelude::*};
#[doc(inline)]
use windows_sys::core::*;
use windows_sys::Win32::Foundation::{LPARAM, WPARAM, LRESULT};
#[doc(inline)]
pub use windows_sys::Win32::Foundation::BOOL;
#[doc(inline)]
pub use windows_sys::Win32::Foundation::BOOLEAN;
#[doc(inline)]
pub use windows_sys::Win32::Foundation::BSTR;
#[doc(inline)]
pub use windows_sys::Win32::Foundation::CHAR;
#[allow(unused_imports)]
use windows_sys::Win32::Foundation::HANDLE;
#[doc(inline)]
pub use windows_sys::Win32::Foundation::HANDLE_PTR;
#[allow(unused_imports)]
use windows_sys::Win32::Foundation::HINSTANCE;
#[allow(unused_imports)]
use windows_sys::Win32::Foundation::HRSRC;
#[allow(unused_imports)]
use windows_sys::Win32::Foundation::HWND;
#[doc(inline)]
pub use windows_sys::Win32::Foundation::NTSTATUS;
#[doc(inline)]
pub use windows_sys::Win32::Foundation::PSID;
#[allow(unused_imports)]
use windows_sys::Win32::Foundation::SHANDLE_PTR;
#[allow(unused_imports)]
use windows_sys::Win32::System::Registry::HKEY;
#[allow(unused_imports)]
use windows_sys::Win32::Graphics::Gdi::CreatedHDC;
#[allow(unused_imports)]
use windows_sys::Win32::Graphics::Gdi::HBITMAP;
#[allow(unused_imports)]
use windows_sys::Win32::Graphics::Gdi::HBRUSH;
#[allow(unused_imports)]
use windows_sys::Win32::Graphics::Gdi::HDC;
#[allow(unused_imports)]
use windows_sys::Win32::Graphics::Gdi::HENHMETAFILE;
#[allow(unused_imports)]
use windows_sys::Win32::Graphics::Gdi::HFONT;
#[allow(unused_imports)]
use windows_sys::Win32::Graphics::Gdi::HGDIOBJ;
#[allow(unused_imports)]
use windows_sys::Win32::Graphics::Gdi::HMETAFILE;
#[allow(unused_imports)]
use windows_sys::Win32::Graphics::Gdi::HMONITOR;
#[allow(unused_imports)]
use windows_sys::Win32::Graphics::Gdi::HPALETTE;
#[allow(unused_imports)]
use windows_sys::Win32::Graphics::Gdi::HPEN;
#[allow(unused_imports)]
use windows_sys::Win32::Graphics::Gdi::HRGN;
#[allow(unused_imports)]
use windows_sys::Win32::UI::Controls::HDPA;
#[allow(unused_imports)]
use windows_sys::Win32::UI::Controls::HDSA;
#[allow(unused_imports)]
use windows_sys::Win32::UI::Controls::HIMAGELIST;
#[allow(unused_imports)]
use windows_sys::Win32::UI::Controls::HPROPSHEETPAGE;
#[allow(unused_imports)]
use windows_sys::Win32::UI::Controls::HSYNTHETICPOINTERDEVICE;
#[allow(unused_imports)]
use windows_sys::Win32::UI::Controls::HTREEITEM;
#[allow(unused_imports)]
use windows_sys::Win32::UI::Shell::HDROP;
#[allow(unused_imports)]
use windows_sys::Win32::UI::Shell::HPSXA;
#[allow(unused_imports)]
use windows_sys::Win32::UI::WindowsAndMessaging::HACCEL;
#[allow(unused_imports)]
use windows_sys::Win32::UI::WindowsAndMessaging::HCURSOR;
#[allow(unused_imports)]
use windows_sys::Win32::UI::WindowsAndMessaging::HHOOK;
#[allow(unused_imports)]
use windows_sys::Win32::UI::WindowsAndMessaging::HICON;
#[allow(unused_imports)]
use windows_sys::Win32::UI::WindowsAndMessaging::HMENU;
#[allow(unused_imports)]
use windows_sys::Win32::Graphics::OpenGL::HGLRC;
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Aashellmenufilename {
    pub cb_total: i16,
    pub rgb_reserved: [u8; 12],
    pub sz_file_name: [u8; 1],
}
impl Aashellmenufilename {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::AASHELLMENUFILENAME {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::AASHELLMENUFILENAME) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
//  Not generated due to containing a void type
//  #[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Aashellmenuitem<'a> {
//      pub lp_reserved1: &'a mut todo_void,
//      pub i_reserved: i32,
//      pub ui_reserved: u32,
//      pub lp_name: &'a mut Aashellmenufilename,
//      pub psz: Cow<'a, [u16]>,
//  }
//  impl<'a> Aashellmenuitem<'a> {
//      fn to_win32(&self) -> windows_sys::Win32::UI::Shell::AASHELLMENUITEM {
//          let Self { lp_reserved1, i_reserved, ui_reserved, lp_name, psz } = self;
//          let lpReserved1 = unsafe { &mut *(lp_reserved1 as *mut _ as *mut _) };
//          let iReserved = *i_reserved;
//          let uiReserved = *ui_reserved;
//          let lpName = unsafe { &mut *(lp_name as *mut _ as *mut _) };
//          assert_eq!(psz.last().copied(), Some(0));
//          let psz = psz.as_ptr() as _;
//          windows_sys::Win32::UI::Shell::AASHELLMENUITEM { lpReserved1, iReserved, uiReserved, lpName, psz }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::AASHELLMENUITEM) -> Self {
//          let windows_sys::Win32::UI::Shell::AASHELLMENUITEM { lpReserved1, iReserved, uiReserved, lpName, psz } = win32;
//          let lp_reserved1 = unsafe { &mut *(lpReserved1 as *mut _ as *mut _) };
//          let i_reserved = iReserved;
//          let ui_reserved = uiReserved;
//          let lp_name = unsafe { &mut *(lpName as *mut _ as *mut _) };
//          let slen = unsafe { wide_strlen(psz as *const u16) };
//          let psz = unsafe { slice::from_raw_parts(psz, slen + 1) };
//          let psz = Cow::Owned(psz.to_vec());
//          Self { lp_reserved1, i_reserved, ui_reserved, lp_name, psz }
//      }
//  }
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Abc {
    pub abc_a: i32,
    pub abc_b: u32,
    pub abc_c: i32,
}
impl Abc {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::ABC {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::ABC) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone)]
#[repr(C)]
pub struct Abcfloat {
    pub abcf_a: f32,
    pub abcf_b: f32,
    pub abcf_c: f32,
}
impl Abcfloat {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::ABCFLOAT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::ABCFLOAT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Accel {
    pub f_virt: u8,
    pub key: u16,
    pub cmd: u16,
}
impl Accel {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::ACCEL {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::ACCEL) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Alttabinfo {
    pub cb_size: u32,
    pub c_items: i32,
    pub c_columns: i32,
    pub c_rows: i32,
    pub i_col_focus: i32,
    pub i_row_focus: i32,
    pub cx_item: i32,
    pub cy_item: i32,
    pub pt_start: Point,
}
impl Alttabinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::ALTTABINFO {
        let Self { cb_size, c_items, c_columns, c_rows, i_col_focus, i_row_focus, cx_item, cy_item, pt_start } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::ALTTABINFO>() as _;
        let cItems = *c_items;
        let cColumns = *c_columns;
        let cRows = *c_rows;
        let iColFocus = *i_col_focus;
        let iRowFocus = *i_row_focus;
        let cxItem = *cx_item;
        let cyItem = *cy_item;
        let ptStart = pt_start.to_win32();
        windows_sys::Win32::UI::WindowsAndMessaging::ALTTABINFO { cbSize, cItems, cColumns, cRows, iColFocus, iRowFocus, cxItem, cyItem, ptStart }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::ALTTABINFO) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::ALTTABINFO { cbSize, cItems, cColumns, cRows, iColFocus, iRowFocus, cxItem, cyItem, ptStart } = win32;
        let cb_size = cbSize;
        let c_items = cItems;
        let c_columns = cColumns;
        let c_rows = cRows;
        let i_col_focus = iColFocus;
        let i_row_focus = iRowFocus;
        let cx_item = cxItem;
        let cy_item = cyItem;
        let pt_start = unsafe { Point::from_win32(ptStart) };
        Self { cb_size, c_items, c_columns, c_rows, i_col_focus, i_row_focus, cx_item, cy_item, pt_start }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Animationinfo {
    pub cb_size: u32,
    pub i_min_animate: i32,
}
impl Animationinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::ANIMATIONINFO {
        let Self { cb_size, i_min_animate } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::ANIMATIONINFO>() as _;
        let iMinAnimate = *i_min_animate;
        windows_sys::Win32::UI::WindowsAndMessaging::ANIMATIONINFO { cbSize, iMinAnimate }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::ANIMATIONINFO) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::ANIMATIONINFO { cbSize, iMinAnimate } = win32;
        let cb_size = cbSize;
        let i_min_animate = iMinAnimate;
        Self { cb_size, i_min_animate }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Appbardata {
    pub cb_size: u32,
    pub h_wnd: Option<Hwnd>,
    pub u_callback_message: u32,
    pub u_edge: u32,
    pub rc: Rect,
    pub l_param: Lparam,
}
impl Appbardata {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::APPBARDATA {
        let Self { cb_size, h_wnd, u_callback_message, u_edge, rc, l_param } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::APPBARDATA>() as _;
        let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
        let uCallbackMessage = *u_callback_message;
        let uEdge = *u_edge;
        let rc = rc.to_win32();
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::Shell::APPBARDATA { cbSize, hWnd, uCallbackMessage, uEdge, rc, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::APPBARDATA) -> Self {
        let windows_sys::Win32::UI::Shell::APPBARDATA { cbSize, hWnd, uCallbackMessage, uEdge, rc, lParam } = win32;
        let cb_size = cbSize;
        let h_wnd = unsafe { Hwnd::new_optional(hWnd) };
        let u_callback_message = uCallbackMessage;
        let u_edge = uEdge;
        let rc = unsafe { Rect::from_win32(rc) };
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { cb_size, h_wnd, u_callback_message, u_edge, rc, l_param }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Appinfodata<'a> {
    pub cb_size: u32,
    pub dw_mask: u32,
    pub psz_display_name: Cow<'a, [u16]>,
    pub psz_version: Cow<'a, [u16]>,
    pub psz_publisher: Cow<'a, [u16]>,
    pub psz_product_id: Cow<'a, [u16]>,
    pub psz_registered_owner: Cow<'a, [u16]>,
    pub psz_registered_company: Cow<'a, [u16]>,
    pub psz_language: Cow<'a, [u16]>,
    pub psz_support_url: Cow<'a, [u16]>,
    pub psz_support_telephone: Cow<'a, [u16]>,
    pub psz_help_link: Cow<'a, [u16]>,
    pub psz_install_location: Cow<'a, [u16]>,
    pub psz_install_source: Cow<'a, [u16]>,
    pub psz_install_date: Cow<'a, [u16]>,
    pub psz_contact: Cow<'a, [u16]>,
    pub psz_comments: Cow<'a, [u16]>,
    pub psz_image: Cow<'a, [u16]>,
    pub psz_readme_url: Cow<'a, [u16]>,
    pub psz_update_info_url: Cow<'a, [u16]>,
}
impl<'a> Appinfodata<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::APPINFODATA {
        let Self { cb_size, dw_mask, psz_display_name, psz_version, psz_publisher, psz_product_id, psz_registered_owner, psz_registered_company, psz_language, psz_support_url, psz_support_telephone, psz_help_link, psz_install_location, psz_install_source, psz_install_date, psz_contact, psz_comments, psz_image, psz_readme_url, psz_update_info_url } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::APPINFODATA>() as _;
        let dwMask = *dw_mask;
        assert_eq!(psz_display_name.last().copied(), Some(0));
        let pszDisplayName = psz_display_name.as_ptr() as _;
        assert_eq!(psz_version.last().copied(), Some(0));
        let pszVersion = psz_version.as_ptr() as _;
        assert_eq!(psz_publisher.last().copied(), Some(0));
        let pszPublisher = psz_publisher.as_ptr() as _;
        assert_eq!(psz_product_id.last().copied(), Some(0));
        let pszProductID = psz_product_id.as_ptr() as _;
        assert_eq!(psz_registered_owner.last().copied(), Some(0));
        let pszRegisteredOwner = psz_registered_owner.as_ptr() as _;
        assert_eq!(psz_registered_company.last().copied(), Some(0));
        let pszRegisteredCompany = psz_registered_company.as_ptr() as _;
        assert_eq!(psz_language.last().copied(), Some(0));
        let pszLanguage = psz_language.as_ptr() as _;
        assert_eq!(psz_support_url.last().copied(), Some(0));
        let pszSupportUrl = psz_support_url.as_ptr() as _;
        assert_eq!(psz_support_telephone.last().copied(), Some(0));
        let pszSupportTelephone = psz_support_telephone.as_ptr() as _;
        assert_eq!(psz_help_link.last().copied(), Some(0));
        let pszHelpLink = psz_help_link.as_ptr() as _;
        assert_eq!(psz_install_location.last().copied(), Some(0));
        let pszInstallLocation = psz_install_location.as_ptr() as _;
        assert_eq!(psz_install_source.last().copied(), Some(0));
        let pszInstallSource = psz_install_source.as_ptr() as _;
        assert_eq!(psz_install_date.last().copied(), Some(0));
        let pszInstallDate = psz_install_date.as_ptr() as _;
        assert_eq!(psz_contact.last().copied(), Some(0));
        let pszContact = psz_contact.as_ptr() as _;
        assert_eq!(psz_comments.last().copied(), Some(0));
        let pszComments = psz_comments.as_ptr() as _;
        assert_eq!(psz_image.last().copied(), Some(0));
        let pszImage = psz_image.as_ptr() as _;
        assert_eq!(psz_readme_url.last().copied(), Some(0));
        let pszReadmeUrl = psz_readme_url.as_ptr() as _;
        assert_eq!(psz_update_info_url.last().copied(), Some(0));
        let pszUpdateInfoUrl = psz_update_info_url.as_ptr() as _;
        windows_sys::Win32::UI::Shell::APPINFODATA { cbSize, dwMask, pszDisplayName, pszVersion, pszPublisher, pszProductID, pszRegisteredOwner, pszRegisteredCompany, pszLanguage, pszSupportUrl, pszSupportTelephone, pszHelpLink, pszInstallLocation, pszInstallSource, pszInstallDate, pszContact, pszComments, pszImage, pszReadmeUrl, pszUpdateInfoUrl }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::APPINFODATA) -> Self {
        let windows_sys::Win32::UI::Shell::APPINFODATA { cbSize, dwMask, pszDisplayName, pszVersion, pszPublisher, pszProductID, pszRegisteredOwner, pszRegisteredCompany, pszLanguage, pszSupportUrl, pszSupportTelephone, pszHelpLink, pszInstallLocation, pszInstallSource, pszInstallDate, pszContact, pszComments, pszImage, pszReadmeUrl, pszUpdateInfoUrl } = win32;
        let cb_size = cbSize;
        let dw_mask = dwMask;
        let slen = unsafe { wide_strlen(pszDisplayName as *const u16) };
        let pszDisplayName = unsafe { slice::from_raw_parts(pszDisplayName, slen + 1) };
        let psz_display_name = Cow::Owned(pszDisplayName.to_vec());
        let slen = unsafe { wide_strlen(pszVersion as *const u16) };
        let pszVersion = unsafe { slice::from_raw_parts(pszVersion, slen + 1) };
        let psz_version = Cow::Owned(pszVersion.to_vec());
        let slen = unsafe { wide_strlen(pszPublisher as *const u16) };
        let pszPublisher = unsafe { slice::from_raw_parts(pszPublisher, slen + 1) };
        let psz_publisher = Cow::Owned(pszPublisher.to_vec());
        let slen = unsafe { wide_strlen(pszProductID as *const u16) };
        let pszProductID = unsafe { slice::from_raw_parts(pszProductID, slen + 1) };
        let psz_product_id = Cow::Owned(pszProductID.to_vec());
        let slen = unsafe { wide_strlen(pszRegisteredOwner as *const u16) };
        let pszRegisteredOwner = unsafe { slice::from_raw_parts(pszRegisteredOwner, slen + 1) };
        let psz_registered_owner = Cow::Owned(pszRegisteredOwner.to_vec());
        let slen = unsafe { wide_strlen(pszRegisteredCompany as *const u16) };
        let pszRegisteredCompany = unsafe { slice::from_raw_parts(pszRegisteredCompany, slen + 1) };
        let psz_registered_company = Cow::Owned(pszRegisteredCompany.to_vec());
        let slen = unsafe { wide_strlen(pszLanguage as *const u16) };
        let pszLanguage = unsafe { slice::from_raw_parts(pszLanguage, slen + 1) };
        let psz_language = Cow::Owned(pszLanguage.to_vec());
        let slen = unsafe { wide_strlen(pszSupportUrl as *const u16) };
        let pszSupportUrl = unsafe { slice::from_raw_parts(pszSupportUrl, slen + 1) };
        let psz_support_url = Cow::Owned(pszSupportUrl.to_vec());
        let slen = unsafe { wide_strlen(pszSupportTelephone as *const u16) };
        let pszSupportTelephone = unsafe { slice::from_raw_parts(pszSupportTelephone, slen + 1) };
        let psz_support_telephone = Cow::Owned(pszSupportTelephone.to_vec());
        let slen = unsafe { wide_strlen(pszHelpLink as *const u16) };
        let pszHelpLink = unsafe { slice::from_raw_parts(pszHelpLink, slen + 1) };
        let psz_help_link = Cow::Owned(pszHelpLink.to_vec());
        let slen = unsafe { wide_strlen(pszInstallLocation as *const u16) };
        let pszInstallLocation = unsafe { slice::from_raw_parts(pszInstallLocation, slen + 1) };
        let psz_install_location = Cow::Owned(pszInstallLocation.to_vec());
        let slen = unsafe { wide_strlen(pszInstallSource as *const u16) };
        let pszInstallSource = unsafe { slice::from_raw_parts(pszInstallSource, slen + 1) };
        let psz_install_source = Cow::Owned(pszInstallSource.to_vec());
        let slen = unsafe { wide_strlen(pszInstallDate as *const u16) };
        let pszInstallDate = unsafe { slice::from_raw_parts(pszInstallDate, slen + 1) };
        let psz_install_date = Cow::Owned(pszInstallDate.to_vec());
        let slen = unsafe { wide_strlen(pszContact as *const u16) };
        let pszContact = unsafe { slice::from_raw_parts(pszContact, slen + 1) };
        let psz_contact = Cow::Owned(pszContact.to_vec());
        let slen = unsafe { wide_strlen(pszComments as *const u16) };
        let pszComments = unsafe { slice::from_raw_parts(pszComments, slen + 1) };
        let psz_comments = Cow::Owned(pszComments.to_vec());
        let slen = unsafe { wide_strlen(pszImage as *const u16) };
        let pszImage = unsafe { slice::from_raw_parts(pszImage, slen + 1) };
        let psz_image = Cow::Owned(pszImage.to_vec());
        let slen = unsafe { wide_strlen(pszReadmeUrl as *const u16) };
        let pszReadmeUrl = unsafe { slice::from_raw_parts(pszReadmeUrl, slen + 1) };
        let psz_readme_url = Cow::Owned(pszReadmeUrl.to_vec());
        let slen = unsafe { wide_strlen(pszUpdateInfoUrl as *const u16) };
        let pszUpdateInfoUrl = unsafe { slice::from_raw_parts(pszUpdateInfoUrl, slen + 1) };
        let psz_update_info_url = Cow::Owned(pszUpdateInfoUrl.to_vec());
        Self { cb_size, dw_mask, psz_display_name, psz_version, psz_publisher, psz_product_id, psz_registered_owner, psz_registered_company, psz_language, psz_support_url, psz_support_telephone, psz_help_link, psz_install_location, psz_install_source, psz_install_date, psz_contact, psz_comments, psz_image, psz_readme_url, psz_update_info_url }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct AppLocalDeviceId {
    pub value: [u8; 32],
}
impl AppLocalDeviceId {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::APP_LOCAL_DEVICE_ID {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::APP_LOCAL_DEVICE_ID) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Associationelement<'a> {
    pub ac: i32,
    pub hk_class: Option<Hkey>,
    pub psz_class: Cow<'a, [u16]>,
}
impl<'a> Associationelement<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::ASSOCIATIONELEMENT {
        let Self { ac, hk_class, psz_class } = self;
        let ac = *ac;
        let hkClass = hk_class.map_or(0, Hkey::into_raw);
        assert_eq!(psz_class.last().copied(), Some(0));
        let pszClass = psz_class.as_ptr() as _;
        windows_sys::Win32::UI::Shell::ASSOCIATIONELEMENT { ac, hkClass, pszClass }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::ASSOCIATIONELEMENT) -> Self {
        let windows_sys::Win32::UI::Shell::ASSOCIATIONELEMENT { ac, hkClass, pszClass } = win32;
        let ac = ac;
        let hk_class = unsafe { Hkey::new_optional(hkClass) };
        let slen = unsafe { wide_strlen(pszClass as *const u16) };
        let pszClass = unsafe { slice::from_raw_parts(pszClass, slen + 1) };
        let psz_class = Cow::Owned(pszClass.to_vec());
        Self { ac, hk_class, psz_class }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Audiodescription {
    pub cb_size: u32,
    pub enabled: BOOL,
    pub locale: u32,
}
impl Audiodescription {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::AUDIODESCRIPTION {
        let Self { cb_size, enabled, locale } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::AUDIODESCRIPTION>() as _;
        let Enabled = *enabled;
        let Locale = *locale;
        windows_sys::Win32::UI::WindowsAndMessaging::AUDIODESCRIPTION { cbSize, Enabled, Locale }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::AUDIODESCRIPTION) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::AUDIODESCRIPTION { cbSize, Enabled, Locale } = win32;
        let cb_size = cbSize;
        let enabled = Enabled;
        let locale = Locale;
        Self { cb_size, enabled, locale }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct AutoScrollData {
    pub i_next_sample: i32,
    pub dw_last_scroll: u32,
    pub b_full: BOOL,
    pub pts: [Point; 3],
    pub dw_times: [u32; 3],
}
impl AutoScrollData {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::AUTO_SCROLL_DATA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::AUTO_SCROLL_DATA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Bandsiteinfo {
    pub dw_mask: u32,
    pub dw_state: u32,
    pub dw_style: u32,
}
impl Bandsiteinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::BANDSITEINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::BANDSITEINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct BannerNotification<'a> {
    pub event: i32,
    pub provider_identity: Cow<'a, [u16]>,
    pub content_id: Cow<'a, [u16]>,
}
impl<'a> BannerNotification<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::BANNER_NOTIFICATION {
        let Self { event, provider_identity, content_id } = self;
        let event = *event;
        assert_eq!(provider_identity.last().copied(), Some(0));
        let providerIdentity = provider_identity.as_ptr() as _;
        assert_eq!(content_id.last().copied(), Some(0));
        let contentId = content_id.as_ptr() as _;
        windows_sys::Win32::UI::Shell::BANNER_NOTIFICATION { event, providerIdentity, contentId }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::BANNER_NOTIFICATION) -> Self {
        let windows_sys::Win32::UI::Shell::BANNER_NOTIFICATION { event, providerIdentity, contentId } = win32;
        let event = event;
        let slen = unsafe { wide_strlen(providerIdentity as *const u16) };
        let providerIdentity = unsafe { slice::from_raw_parts(providerIdentity, slen + 1) };
        let provider_identity = Cow::Owned(providerIdentity.to_vec());
        let slen = unsafe { wide_strlen(contentId as *const u16) };
        let contentId = unsafe { slice::from_raw_parts(contentId, slen + 1) };
        let content_id = Cow::Owned(contentId.to_vec());
        Self { event, provider_identity, content_id }
    }
}
//  Not generated due to containing a void type
//  #[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Bitmap<'a> {
//      pub bm_type: i32,
//      pub bm_width: i32,
//      pub bm_height: i32,
//      pub bm_width_bytes: i32,
//      pub bm_planes: u16,
//      pub bm_bits_pixel: u16,
//      pub bm_bits: &'a mut todo_void,
//  }
//  impl<'a> Bitmap<'a> {
//      fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::BITMAP {
//          let Self { bm_type, bm_width, bm_height, bm_width_bytes, bm_planes, bm_bits_pixel, bm_bits } = self;
//          let bmType = *bm_type;
//          let bmWidth = *bm_width;
//          let bmHeight = *bm_height;
//          let bmWidthBytes = *bm_width_bytes;
//          let bmPlanes = *bm_planes;
//          let bmBitsPixel = *bm_bits_pixel;
//          let bmBits = unsafe { &mut *(bm_bits as *mut _ as *mut _) };
//          windows_sys::Win32::Graphics::Gdi::BITMAP { bmType, bmWidth, bmHeight, bmWidthBytes, bmPlanes, bmBitsPixel, bmBits }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::BITMAP) -> Self {
//          let windows_sys::Win32::Graphics::Gdi::BITMAP { bmType, bmWidth, bmHeight, bmWidthBytes, bmPlanes, bmBitsPixel, bmBits } = win32;
//          let bm_type = bmType;
//          let bm_width = bmWidth;
//          let bm_height = bmHeight;
//          let bm_width_bytes = bmWidthBytes;
//          let bm_planes = bmPlanes;
//          let bm_bits_pixel = bmBitsPixel;
//          let bm_bits = unsafe { &mut *(bmBits as *mut _ as *mut _) };
//          Self { bm_type, bm_width, bm_height, bm_width_bytes, bm_planes, bm_bits_pixel, bm_bits }
//      }
//  }
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Bitmapcoreheader {
    pub bc_size: u32,
    pub bc_width: u16,
    pub bc_height: u16,
    pub bc_planes: u16,
    pub bc_bit_count: u16,
}
impl Bitmapcoreheader {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::BITMAPCOREHEADER {
        let Self { bc_size, bc_width, bc_height, bc_planes, bc_bit_count } = self;
        let bcSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::BITMAPCOREHEADER>() as _;
        let bcWidth = *bc_width;
        let bcHeight = *bc_height;
        let bcPlanes = *bc_planes;
        let bcBitCount = *bc_bit_count;
        windows_sys::Win32::Graphics::Gdi::BITMAPCOREHEADER { bcSize, bcWidth, bcHeight, bcPlanes, bcBitCount }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::BITMAPCOREHEADER) -> Self {
        let windows_sys::Win32::Graphics::Gdi::BITMAPCOREHEADER { bcSize, bcWidth, bcHeight, bcPlanes, bcBitCount } = win32;
        let bc_size = bcSize;
        let bc_width = bcWidth;
        let bc_height = bcHeight;
        let bc_planes = bcPlanes;
        let bc_bit_count = bcBitCount;
        Self { bc_size, bc_width, bc_height, bc_planes, bc_bit_count }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Bitmapcoreinfo {
    pub bmci_header: Bitmapcoreheader,
    pub bmci_colors: [Rgbtriple; 1],
}
impl Bitmapcoreinfo {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::BITMAPCOREINFO {
        let Self { bmci_header, bmci_colors } = self;
        let bmciHeader = bmci_header.to_win32();
        let bmciColors = [bmci_colors[0].to_win32()];
        windows_sys::Win32::Graphics::Gdi::BITMAPCOREINFO { bmciHeader, bmciColors }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::BITMAPCOREINFO) -> Self {
        let windows_sys::Win32::Graphics::Gdi::BITMAPCOREINFO { bmciHeader, bmciColors } = win32;
        let bmci_header = unsafe { Bitmapcoreheader::from_win32(bmciHeader) };
        let bmci_colors = [unsafe { Rgbtriple::from_win32(bmciColors[0]) }];
        Self { bmci_header, bmci_colors }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(2))]
pub struct Bitmapfileheader {
    pub bf_type: u16,
    pub bf_size: u32,
    pub bf_reserved1: u16,
    pub bf_reserved2: u16,
    pub bf_off_bits: u32,
}
impl Bitmapfileheader {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::BITMAPFILEHEADER {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::BITMAPFILEHEADER) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Bitmapinfo {
    pub bmi_header: Bitmapinfoheader,
    pub bmi_colors: [Rgbquad; 1],
}
impl Bitmapinfo {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::BITMAPINFO {
        let Self { bmi_header, bmi_colors } = self;
        let bmiHeader = bmi_header.to_win32();
        let bmiColors = [bmi_colors[0].to_win32()];
        windows_sys::Win32::Graphics::Gdi::BITMAPINFO { bmiHeader, bmiColors }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::BITMAPINFO) -> Self {
        let windows_sys::Win32::Graphics::Gdi::BITMAPINFO { bmiHeader, bmiColors } = win32;
        let bmi_header = unsafe { Bitmapinfoheader::from_win32(bmiHeader) };
        let bmi_colors = [unsafe { Rgbquad::from_win32(bmiColors[0]) }];
        Self { bmi_header, bmi_colors }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Bitmapinfoheader {
    pub bi_size: u32,
    pub bi_width: i32,
    pub bi_height: i32,
    pub bi_planes: u16,
    pub bi_bit_count: u16,
    pub bi_compression: u32,
    pub bi_size_image: u32,
    pub bi_x_pels_per_meter: i32,
    pub bi_y_pels_per_meter: i32,
    pub bi_clr_used: u32,
    pub bi_clr_important: u32,
}
impl Bitmapinfoheader {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::BITMAPINFOHEADER {
        let Self { bi_size, bi_width, bi_height, bi_planes, bi_bit_count, bi_compression, bi_size_image, bi_x_pels_per_meter, bi_y_pels_per_meter, bi_clr_used, bi_clr_important } = self;
        let biSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::BITMAPINFOHEADER>() as _;
        let biWidth = *bi_width;
        let biHeight = *bi_height;
        let biPlanes = *bi_planes;
        let biBitCount = *bi_bit_count;
        let biCompression = *bi_compression;
        let biSizeImage = *bi_size_image;
        let biXPelsPerMeter = *bi_x_pels_per_meter;
        let biYPelsPerMeter = *bi_y_pels_per_meter;
        let biClrUsed = *bi_clr_used;
        let biClrImportant = *bi_clr_important;
        windows_sys::Win32::Graphics::Gdi::BITMAPINFOHEADER { biSize, biWidth, biHeight, biPlanes, biBitCount, biCompression, biSizeImage, biXPelsPerMeter, biYPelsPerMeter, biClrUsed, biClrImportant }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::BITMAPINFOHEADER) -> Self {
        let windows_sys::Win32::Graphics::Gdi::BITMAPINFOHEADER { biSize, biWidth, biHeight, biPlanes, biBitCount, biCompression, biSizeImage, biXPelsPerMeter, biYPelsPerMeter, biClrUsed, biClrImportant } = win32;
        let bi_size = biSize;
        let bi_width = biWidth;
        let bi_height = biHeight;
        let bi_planes = biPlanes;
        let bi_bit_count = biBitCount;
        let bi_compression = biCompression;
        let bi_size_image = biSizeImage;
        let bi_x_pels_per_meter = biXPelsPerMeter;
        let bi_y_pels_per_meter = biYPelsPerMeter;
        let bi_clr_used = biClrUsed;
        let bi_clr_important = biClrImportant;
        Self { bi_size, bi_width, bi_height, bi_planes, bi_bit_count, bi_compression, bi_size_image, bi_x_pels_per_meter, bi_y_pels_per_meter, bi_clr_used, bi_clr_important }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Bitmapv4header {
    pub b_v4_size: u32,
    pub b_v4_width: i32,
    pub b_v4_height: i32,
    pub b_v4_planes: u16,
    pub b_v4_bit_count: u16,
    pub b_v4v4_compression: u32,
    pub b_v4_size_image: u32,
    pub b_v4x_pels_per_meter: i32,
    pub b_v4y_pels_per_meter: i32,
    pub b_v4_clr_used: u32,
    pub b_v4_clr_important: u32,
    pub b_v4_red_mask: u32,
    pub b_v4_green_mask: u32,
    pub b_v4_blue_mask: u32,
    pub b_v4_alpha_mask: u32,
    pub b_v4cs_type: u32,
    pub b_v4_endpoints: Ciexyztriple,
    pub b_v4_gamma_red: u32,
    pub b_v4_gamma_green: u32,
    pub b_v4_gamma_blue: u32,
}
impl Bitmapv4header {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::BITMAPV4HEADER {
        let Self { b_v4_size, b_v4_width, b_v4_height, b_v4_planes, b_v4_bit_count, b_v4v4_compression, b_v4_size_image, b_v4x_pels_per_meter, b_v4y_pels_per_meter, b_v4_clr_used, b_v4_clr_important, b_v4_red_mask, b_v4_green_mask, b_v4_blue_mask, b_v4_alpha_mask, b_v4cs_type, b_v4_endpoints, b_v4_gamma_red, b_v4_gamma_green, b_v4_gamma_blue } = self;
        let bV4Size = mem::size_of::<windows_sys::Win32::Graphics::Gdi::BITMAPV4HEADER>() as _;
        let bV4Width = *b_v4_width;
        let bV4Height = *b_v4_height;
        let bV4Planes = *b_v4_planes;
        let bV4BitCount = *b_v4_bit_count;
        let bV4V4Compression = *b_v4v4_compression;
        let bV4SizeImage = *b_v4_size_image;
        let bV4XPelsPerMeter = *b_v4x_pels_per_meter;
        let bV4YPelsPerMeter = *b_v4y_pels_per_meter;
        let bV4ClrUsed = *b_v4_clr_used;
        let bV4ClrImportant = *b_v4_clr_important;
        let bV4RedMask = *b_v4_red_mask;
        let bV4GreenMask = *b_v4_green_mask;
        let bV4BlueMask = *b_v4_blue_mask;
        let bV4AlphaMask = *b_v4_alpha_mask;
        let bV4CSType = *b_v4cs_type;
        let bV4Endpoints = b_v4_endpoints.to_win32();
        let bV4GammaRed = *b_v4_gamma_red;
        let bV4GammaGreen = *b_v4_gamma_green;
        let bV4GammaBlue = *b_v4_gamma_blue;
        windows_sys::Win32::Graphics::Gdi::BITMAPV4HEADER { bV4Size, bV4Width, bV4Height, bV4Planes, bV4BitCount, bV4V4Compression, bV4SizeImage, bV4XPelsPerMeter, bV4YPelsPerMeter, bV4ClrUsed, bV4ClrImportant, bV4RedMask, bV4GreenMask, bV4BlueMask, bV4AlphaMask, bV4CSType, bV4Endpoints, bV4GammaRed, bV4GammaGreen, bV4GammaBlue }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::BITMAPV4HEADER) -> Self {
        let windows_sys::Win32::Graphics::Gdi::BITMAPV4HEADER { bV4Size, bV4Width, bV4Height, bV4Planes, bV4BitCount, bV4V4Compression, bV4SizeImage, bV4XPelsPerMeter, bV4YPelsPerMeter, bV4ClrUsed, bV4ClrImportant, bV4RedMask, bV4GreenMask, bV4BlueMask, bV4AlphaMask, bV4CSType, bV4Endpoints, bV4GammaRed, bV4GammaGreen, bV4GammaBlue } = win32;
        let b_v4_size = bV4Size;
        let b_v4_width = bV4Width;
        let b_v4_height = bV4Height;
        let b_v4_planes = bV4Planes;
        let b_v4_bit_count = bV4BitCount;
        let b_v4v4_compression = bV4V4Compression;
        let b_v4_size_image = bV4SizeImage;
        let b_v4x_pels_per_meter = bV4XPelsPerMeter;
        let b_v4y_pels_per_meter = bV4YPelsPerMeter;
        let b_v4_clr_used = bV4ClrUsed;
        let b_v4_clr_important = bV4ClrImportant;
        let b_v4_red_mask = bV4RedMask;
        let b_v4_green_mask = bV4GreenMask;
        let b_v4_blue_mask = bV4BlueMask;
        let b_v4_alpha_mask = bV4AlphaMask;
        let b_v4cs_type = bV4CSType;
        let b_v4_endpoints = unsafe { Ciexyztriple::from_win32(bV4Endpoints) };
        let b_v4_gamma_red = bV4GammaRed;
        let b_v4_gamma_green = bV4GammaGreen;
        let b_v4_gamma_blue = bV4GammaBlue;
        Self { b_v4_size, b_v4_width, b_v4_height, b_v4_planes, b_v4_bit_count, b_v4v4_compression, b_v4_size_image, b_v4x_pels_per_meter, b_v4y_pels_per_meter, b_v4_clr_used, b_v4_clr_important, b_v4_red_mask, b_v4_green_mask, b_v4_blue_mask, b_v4_alpha_mask, b_v4cs_type, b_v4_endpoints, b_v4_gamma_red, b_v4_gamma_green, b_v4_gamma_blue }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Bitmapv5header {
    pub b_v5_size: u32,
    pub b_v5_width: i32,
    pub b_v5_height: i32,
    pub b_v5_planes: u16,
    pub b_v5_bit_count: u16,
    pub b_v5_compression: u32,
    pub b_v5_size_image: u32,
    pub b_v5x_pels_per_meter: i32,
    pub b_v5y_pels_per_meter: i32,
    pub b_v5_clr_used: u32,
    pub b_v5_clr_important: u32,
    pub b_v5_red_mask: u32,
    pub b_v5_green_mask: u32,
    pub b_v5_blue_mask: u32,
    pub b_v5_alpha_mask: u32,
    pub b_v5cs_type: u32,
    pub b_v5_endpoints: Ciexyztriple,
    pub b_v5_gamma_red: u32,
    pub b_v5_gamma_green: u32,
    pub b_v5_gamma_blue: u32,
    pub b_v5_intent: u32,
    pub b_v5_profile_data: u32,
    pub b_v5_profile_size: u32,
    pub b_v5_reserved: u32,
}
impl Bitmapv5header {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::BITMAPV5HEADER {
        let Self { b_v5_size, b_v5_width, b_v5_height, b_v5_planes, b_v5_bit_count, b_v5_compression, b_v5_size_image, b_v5x_pels_per_meter, b_v5y_pels_per_meter, b_v5_clr_used, b_v5_clr_important, b_v5_red_mask, b_v5_green_mask, b_v5_blue_mask, b_v5_alpha_mask, b_v5cs_type, b_v5_endpoints, b_v5_gamma_red, b_v5_gamma_green, b_v5_gamma_blue, b_v5_intent, b_v5_profile_data, b_v5_profile_size, b_v5_reserved } = self;
        let bV5Size = mem::size_of::<windows_sys::Win32::Graphics::Gdi::BITMAPV5HEADER>() as _;
        let bV5Width = *b_v5_width;
        let bV5Height = *b_v5_height;
        let bV5Planes = *b_v5_planes;
        let bV5BitCount = *b_v5_bit_count;
        let bV5Compression = *b_v5_compression;
        let bV5SizeImage = *b_v5_size_image;
        let bV5XPelsPerMeter = *b_v5x_pels_per_meter;
        let bV5YPelsPerMeter = *b_v5y_pels_per_meter;
        let bV5ClrUsed = *b_v5_clr_used;
        let bV5ClrImportant = *b_v5_clr_important;
        let bV5RedMask = *b_v5_red_mask;
        let bV5GreenMask = *b_v5_green_mask;
        let bV5BlueMask = *b_v5_blue_mask;
        let bV5AlphaMask = *b_v5_alpha_mask;
        let bV5CSType = *b_v5cs_type;
        let bV5Endpoints = b_v5_endpoints.to_win32();
        let bV5GammaRed = *b_v5_gamma_red;
        let bV5GammaGreen = *b_v5_gamma_green;
        let bV5GammaBlue = *b_v5_gamma_blue;
        let bV5Intent = *b_v5_intent;
        let bV5ProfileData = *b_v5_profile_data;
        let bV5ProfileSize = *b_v5_profile_size;
        let bV5Reserved = *b_v5_reserved;
        windows_sys::Win32::Graphics::Gdi::BITMAPV5HEADER { bV5Size, bV5Width, bV5Height, bV5Planes, bV5BitCount, bV5Compression, bV5SizeImage, bV5XPelsPerMeter, bV5YPelsPerMeter, bV5ClrUsed, bV5ClrImportant, bV5RedMask, bV5GreenMask, bV5BlueMask, bV5AlphaMask, bV5CSType, bV5Endpoints, bV5GammaRed, bV5GammaGreen, bV5GammaBlue, bV5Intent, bV5ProfileData, bV5ProfileSize, bV5Reserved }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::BITMAPV5HEADER) -> Self {
        let windows_sys::Win32::Graphics::Gdi::BITMAPV5HEADER { bV5Size, bV5Width, bV5Height, bV5Planes, bV5BitCount, bV5Compression, bV5SizeImage, bV5XPelsPerMeter, bV5YPelsPerMeter, bV5ClrUsed, bV5ClrImportant, bV5RedMask, bV5GreenMask, bV5BlueMask, bV5AlphaMask, bV5CSType, bV5Endpoints, bV5GammaRed, bV5GammaGreen, bV5GammaBlue, bV5Intent, bV5ProfileData, bV5ProfileSize, bV5Reserved } = win32;
        let b_v5_size = bV5Size;
        let b_v5_width = bV5Width;
        let b_v5_height = bV5Height;
        let b_v5_planes = bV5Planes;
        let b_v5_bit_count = bV5BitCount;
        let b_v5_compression = bV5Compression;
        let b_v5_size_image = bV5SizeImage;
        let b_v5x_pels_per_meter = bV5XPelsPerMeter;
        let b_v5y_pels_per_meter = bV5YPelsPerMeter;
        let b_v5_clr_used = bV5ClrUsed;
        let b_v5_clr_important = bV5ClrImportant;
        let b_v5_red_mask = bV5RedMask;
        let b_v5_green_mask = bV5GreenMask;
        let b_v5_blue_mask = bV5BlueMask;
        let b_v5_alpha_mask = bV5AlphaMask;
        let b_v5cs_type = bV5CSType;
        let b_v5_endpoints = unsafe { Ciexyztriple::from_win32(bV5Endpoints) };
        let b_v5_gamma_red = bV5GammaRed;
        let b_v5_gamma_green = bV5GammaGreen;
        let b_v5_gamma_blue = bV5GammaBlue;
        let b_v5_intent = bV5Intent;
        let b_v5_profile_data = bV5ProfileData;
        let b_v5_profile_size = bV5ProfileSize;
        let b_v5_reserved = bV5Reserved;
        Self { b_v5_size, b_v5_width, b_v5_height, b_v5_planes, b_v5_bit_count, b_v5_compression, b_v5_size_image, b_v5x_pels_per_meter, b_v5y_pels_per_meter, b_v5_clr_used, b_v5_clr_important, b_v5_red_mask, b_v5_green_mask, b_v5_blue_mask, b_v5_alpha_mask, b_v5cs_type, b_v5_endpoints, b_v5_gamma_red, b_v5_gamma_green, b_v5_gamma_blue, b_v5_intent, b_v5_profile_data, b_v5_profile_size, b_v5_reserved }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Blendfunction {
    pub blend_op: u8,
    pub blend_flags: u8,
    pub source_constant_alpha: u8,
    pub alpha_format: u8,
}
impl Blendfunction {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::BLENDFUNCTION {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::BLENDFUNCTION) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct BpAnimationparams {
    pub cb_size: u32,
    pub dw_flags: u32,
    pub style: i32,
    pub dw_duration: u32,
}
impl BpAnimationparams {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::BP_ANIMATIONPARAMS {
        let Self { cb_size, dw_flags, style, dw_duration } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::BP_ANIMATIONPARAMS>() as _;
        let dwFlags = *dw_flags;
        let style = *style;
        let dwDuration = *dw_duration;
        windows_sys::Win32::UI::Controls::BP_ANIMATIONPARAMS { cbSize, dwFlags, style, dwDuration }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::BP_ANIMATIONPARAMS) -> Self {
        let windows_sys::Win32::UI::Controls::BP_ANIMATIONPARAMS { cbSize, dwFlags, style, dwDuration } = win32;
        let cb_size = cbSize;
        let dw_flags = dwFlags;
        let style = style;
        let dw_duration = dwDuration;
        Self { cb_size, dw_flags, style, dw_duration }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct BpPaintparams<'a> {
    pub cb_size: u32,
    pub dw_flags: u32,
    pub prc_exclude: Cow<'a, Rect>,
    pub p_blend_function: Cow<'a, Blendfunction>,
}
impl<'a> BpPaintparams<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::BP_PAINTPARAMS {
        let Self { cb_size, dw_flags, prc_exclude, p_blend_function } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::BP_PAINTPARAMS>() as _;
        let dwFlags = *dw_flags;
        let prcExclude = unsafe { &*(&**prc_exclude as *const _ as *const _) };
        let pBlendFunction = unsafe { &*(&**p_blend_function as *const _ as *const _) };
        windows_sys::Win32::UI::Controls::BP_PAINTPARAMS { cbSize, dwFlags, prcExclude, pBlendFunction }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::BP_PAINTPARAMS) -> Self {
        let windows_sys::Win32::UI::Controls::BP_PAINTPARAMS { cbSize, dwFlags, prcExclude, pBlendFunction } = win32;
        let cb_size = cbSize;
        let dw_flags = dwFlags;
        let prc_exclude = Cow::Borrowed(unsafe { &*(prcExclude as *const _ as *const _) });
        let p_blend_function = Cow::Borrowed(unsafe { &*(pBlendFunction as *const _ as *const _) });
        Self { cb_size, dw_flags, prc_exclude, p_blend_function }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct ButtonImagelist {
    pub himl: Option<Himagelist>,
    pub margin: Rect,
    pub u_align: u32,
}
impl ButtonImagelist {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::BUTTON_IMAGELIST {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::BUTTON_IMAGELIST) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct ButtonSplitinfo {
    pub mask: u32,
    pub himl_glyph: Option<Himagelist>,
    pub u_split_style: u32,
    pub size: Size,
}
impl ButtonSplitinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::BUTTON_SPLITINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::BUTTON_SPLITINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Cabinetstate {
    pub c_length: u16,
    pub n_version: u16,
    pub bitfield: i32,
    pub f_menu_enum_filter: u32,
}
impl Cabinetstate {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::CABINETSTATE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::CABINETSTATE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Cbtactivatestruct {
    pub f_mouse: BOOL,
    pub h_wnd_active: Option<Hwnd>,
}
impl Cbtactivatestruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::CBTACTIVATESTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::CBTACTIVATESTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Changefilterstruct {
    pub cb_size: u32,
    pub ext_status: u32,
}
impl Changefilterstruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::CHANGEFILTERSTRUCT {
        let Self { cb_size, ext_status } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::CHANGEFILTERSTRUCT>() as _;
        let ExtStatus = *ext_status;
        windows_sys::Win32::UI::WindowsAndMessaging::CHANGEFILTERSTRUCT { cbSize, ExtStatus }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::CHANGEFILTERSTRUCT) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::CHANGEFILTERSTRUCT { cbSize, ExtStatus } = win32;
        let cb_size = cbSize;
        let ext_status = ExtStatus;
        Self { cb_size, ext_status }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Cida {
    pub cidl: u32,
    pub aoffset: [u32; 1],
}
impl Cida {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::CIDA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::CIDA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Ciexyz {
    pub ciexyz_x: i32,
    pub ciexyz_y: i32,
    pub ciexyz_z: i32,
}
impl Ciexyz {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::CIEXYZ {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::CIEXYZ) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Ciexyztriple {
    pub ciexyz_red: Ciexyz,
    pub ciexyz_green: Ciexyz,
    pub ciexyz_blue: Ciexyz,
}
impl Ciexyztriple {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::CIEXYZTRIPLE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::CIEXYZTRIPLE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Clientcreatestruct {
    pub h_window_menu: Option<Handle>,
    pub id_first_child: u32,
}
impl Clientcreatestruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::CLIENTCREATESTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::CLIENTCREATESTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Cminvokecommandinfo<'a> {
    pub cb_size: u32,
    pub f_mask: u32,
    pub hwnd: Option<Hwnd>,
    pub lp_verb: Cow<'a, CStr>,
    pub lp_parameters: Cow<'a, CStr>,
    pub lp_directory: Cow<'a, CStr>,
    pub n_show: i32,
    pub dw_hot_key: u32,
    pub h_icon: Option<Handle>,
}
impl<'a> Cminvokecommandinfo<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFO {
        let Self { cb_size, f_mask, hwnd, lp_verb, lp_parameters, lp_directory, n_show, dw_hot_key, h_icon } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFO>() as _;
        let fMask = *f_mask;
        let hwnd = hwnd.map_or(0, Hwnd::into_raw);
        let lpVerb = lp_verb.as_ptr() as _;
        let lpParameters = lp_parameters.as_ptr() as _;
        let lpDirectory = lp_directory.as_ptr() as _;
        let nShow = *n_show;
        let dwHotKey = *dw_hot_key;
        let hIcon = h_icon.map_or(0, Handle::into_raw);
        windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFO { cbSize, fMask, hwnd, lpVerb, lpParameters, lpDirectory, nShow, dwHotKey, hIcon }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFO) -> Self {
        let windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFO { cbSize, fMask, hwnd, lpVerb, lpParameters, lpDirectory, nShow, dwHotKey, hIcon } = win32;
        let cb_size = cbSize;
        let f_mask = fMask;
        let hwnd = unsafe { Hwnd::new_optional(hwnd) };
        let lpVerb = unsafe { CStr::from_ptr(lpVerb as *const _) };
        let lpVerb = lpVerb.to_bytes_with_nul().to_vec();
        let lp_verb = Cow::Owned(unsafe { CString::from_vec_unchecked(lpVerb) });
        let lpParameters = unsafe { CStr::from_ptr(lpParameters as *const _) };
        let lpParameters = lpParameters.to_bytes_with_nul().to_vec();
        let lp_parameters = Cow::Owned(unsafe { CString::from_vec_unchecked(lpParameters) });
        let lpDirectory = unsafe { CStr::from_ptr(lpDirectory as *const _) };
        let lpDirectory = lpDirectory.to_bytes_with_nul().to_vec();
        let lp_directory = Cow::Owned(unsafe { CString::from_vec_unchecked(lpDirectory) });
        let n_show = nShow;
        let dw_hot_key = dwHotKey;
        let h_icon = unsafe { Handle::new_optional(hIcon) };
        Self { cb_size, f_mask, hwnd, lp_verb, lp_parameters, lp_directory, n_show, dw_hot_key, h_icon }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Cminvokecommandinfoex<'a> {
    pub cb_size: u32,
    pub f_mask: u32,
    pub hwnd: Option<Hwnd>,
    pub lp_verb: Cow<'a, CStr>,
    pub lp_parameters: Cow<'a, CStr>,
    pub lp_directory: Cow<'a, CStr>,
    pub n_show: i32,
    pub dw_hot_key: u32,
    pub h_icon: Option<Handle>,
    pub lp_title: Cow<'a, CStr>,
    pub lp_verb_w: Cow<'a, [u16]>,
    pub lp_parameters_w: Cow<'a, [u16]>,
    pub lp_directory_w: Cow<'a, [u16]>,
    pub lp_title_w: Cow<'a, [u16]>,
    pub pt_invoke: Point,
}
impl<'a> Cminvokecommandinfoex<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFOEX {
        let Self { cb_size, f_mask, hwnd, lp_verb, lp_parameters, lp_directory, n_show, dw_hot_key, h_icon, lp_title, lp_verb_w, lp_parameters_w, lp_directory_w, lp_title_w, pt_invoke } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFOEX>() as _;
        let fMask = *f_mask;
        let hwnd = hwnd.map_or(0, Hwnd::into_raw);
        let lpVerb = lp_verb.as_ptr() as _;
        let lpParameters = lp_parameters.as_ptr() as _;
        let lpDirectory = lp_directory.as_ptr() as _;
        let nShow = *n_show;
        let dwHotKey = *dw_hot_key;
        let hIcon = h_icon.map_or(0, Handle::into_raw);
        let lpTitle = lp_title.as_ptr() as _;
        assert_eq!(lp_verb_w.last().copied(), Some(0));
        let lpVerbW = lp_verb_w.as_ptr() as _;
        assert_eq!(lp_parameters_w.last().copied(), Some(0));
        let lpParametersW = lp_parameters_w.as_ptr() as _;
        assert_eq!(lp_directory_w.last().copied(), Some(0));
        let lpDirectoryW = lp_directory_w.as_ptr() as _;
        assert_eq!(lp_title_w.last().copied(), Some(0));
        let lpTitleW = lp_title_w.as_ptr() as _;
        let ptInvoke = pt_invoke.to_win32();
        windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFOEX { cbSize, fMask, hwnd, lpVerb, lpParameters, lpDirectory, nShow, dwHotKey, hIcon, lpTitle, lpVerbW, lpParametersW, lpDirectoryW, lpTitleW, ptInvoke }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFOEX) -> Self {
        let windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFOEX { cbSize, fMask, hwnd, lpVerb, lpParameters, lpDirectory, nShow, dwHotKey, hIcon, lpTitle, lpVerbW, lpParametersW, lpDirectoryW, lpTitleW, ptInvoke } = win32;
        let cb_size = cbSize;
        let f_mask = fMask;
        let hwnd = unsafe { Hwnd::new_optional(hwnd) };
        let lpVerb = unsafe { CStr::from_ptr(lpVerb as *const _) };
        let lpVerb = lpVerb.to_bytes_with_nul().to_vec();
        let lp_verb = Cow::Owned(unsafe { CString::from_vec_unchecked(lpVerb) });
        let lpParameters = unsafe { CStr::from_ptr(lpParameters as *const _) };
        let lpParameters = lpParameters.to_bytes_with_nul().to_vec();
        let lp_parameters = Cow::Owned(unsafe { CString::from_vec_unchecked(lpParameters) });
        let lpDirectory = unsafe { CStr::from_ptr(lpDirectory as *const _) };
        let lpDirectory = lpDirectory.to_bytes_with_nul().to_vec();
        let lp_directory = Cow::Owned(unsafe { CString::from_vec_unchecked(lpDirectory) });
        let n_show = nShow;
        let dw_hot_key = dwHotKey;
        let h_icon = unsafe { Handle::new_optional(hIcon) };
        let lpTitle = unsafe { CStr::from_ptr(lpTitle as *const _) };
        let lpTitle = lpTitle.to_bytes_with_nul().to_vec();
        let lp_title = Cow::Owned(unsafe { CString::from_vec_unchecked(lpTitle) });
        let slen = unsafe { wide_strlen(lpVerbW as *const u16) };
        let lpVerbW = unsafe { slice::from_raw_parts(lpVerbW, slen + 1) };
        let lp_verb_w = Cow::Owned(lpVerbW.to_vec());
        let slen = unsafe { wide_strlen(lpParametersW as *const u16) };
        let lpParametersW = unsafe { slice::from_raw_parts(lpParametersW, slen + 1) };
        let lp_parameters_w = Cow::Owned(lpParametersW.to_vec());
        let slen = unsafe { wide_strlen(lpDirectoryW as *const u16) };
        let lpDirectoryW = unsafe { slice::from_raw_parts(lpDirectoryW, slen + 1) };
        let lp_directory_w = Cow::Owned(lpDirectoryW.to_vec());
        let slen = unsafe { wide_strlen(lpTitleW as *const u16) };
        let lpTitleW = unsafe { slice::from_raw_parts(lpTitleW, slen + 1) };
        let lp_title_w = Cow::Owned(lpTitleW.to_vec());
        let pt_invoke = unsafe { Point::from_win32(ptInvoke) };
        Self { cb_size, f_mask, hwnd, lp_verb, lp_parameters, lp_directory, n_show, dw_hot_key, h_icon, lp_title, lp_verb_w, lp_parameters_w, lp_directory_w, lp_title_w, pt_invoke }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct CminvokecommandinfoexRemote<'a> {
    pub cb_size: u32,
    pub f_mask: u32,
    pub hwnd: Option<Hwnd>,
    pub lp_verb_string: Cow<'a, CStr>,
    pub lp_parameters: Cow<'a, CStr>,
    pub lp_directory: Cow<'a, CStr>,
    pub n_show: i32,
    pub dw_hot_key: u32,
    pub lp_title: Cow<'a, CStr>,
    pub lp_verb_w_string: Cow<'a, [u16]>,
    pub lp_parameters_w: Cow<'a, [u16]>,
    pub lp_directory_w: Cow<'a, [u16]>,
    pub lp_title_w: Cow<'a, [u16]>,
    pub pt_invoke: Point,
    pub lp_verb_int: u32,
    pub lp_verb_w_int: u32,
}
impl<'a> CminvokecommandinfoexRemote<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFOEX_REMOTE {
        let Self { cb_size, f_mask, hwnd, lp_verb_string, lp_parameters, lp_directory, n_show, dw_hot_key, lp_title, lp_verb_w_string, lp_parameters_w, lp_directory_w, lp_title_w, pt_invoke, lp_verb_int, lp_verb_w_int } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFOEX_REMOTE>() as _;
        let fMask = *f_mask;
        let hwnd = hwnd.map_or(0, Hwnd::into_raw);
        let lpVerbString = lp_verb_string.as_ptr() as _;
        let lpParameters = lp_parameters.as_ptr() as _;
        let lpDirectory = lp_directory.as_ptr() as _;
        let nShow = *n_show;
        let dwHotKey = *dw_hot_key;
        let lpTitle = lp_title.as_ptr() as _;
        assert_eq!(lp_verb_w_string.last().copied(), Some(0));
        let lpVerbWString = lp_verb_w_string.as_ptr() as _;
        assert_eq!(lp_parameters_w.last().copied(), Some(0));
        let lpParametersW = lp_parameters_w.as_ptr() as _;
        assert_eq!(lp_directory_w.last().copied(), Some(0));
        let lpDirectoryW = lp_directory_w.as_ptr() as _;
        assert_eq!(lp_title_w.last().copied(), Some(0));
        let lpTitleW = lp_title_w.as_ptr() as _;
        let ptInvoke = pt_invoke.to_win32();
        let lpVerbInt = *lp_verb_int;
        let lpVerbWInt = *lp_verb_w_int;
        windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFOEX_REMOTE { cbSize, fMask, hwnd, lpVerbString, lpParameters, lpDirectory, nShow, dwHotKey, lpTitle, lpVerbWString, lpParametersW, lpDirectoryW, lpTitleW, ptInvoke, lpVerbInt, lpVerbWInt }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFOEX_REMOTE) -> Self {
        let windows_sys::Win32::UI::Shell::CMINVOKECOMMANDINFOEX_REMOTE { cbSize, fMask, hwnd, lpVerbString, lpParameters, lpDirectory, nShow, dwHotKey, lpTitle, lpVerbWString, lpParametersW, lpDirectoryW, lpTitleW, ptInvoke, lpVerbInt, lpVerbWInt } = win32;
        let cb_size = cbSize;
        let f_mask = fMask;
        let hwnd = unsafe { Hwnd::new_optional(hwnd) };
        let lpVerbString = unsafe { CStr::from_ptr(lpVerbString as *const _) };
        let lpVerbString = lpVerbString.to_bytes_with_nul().to_vec();
        let lp_verb_string = Cow::Owned(unsafe { CString::from_vec_unchecked(lpVerbString) });
        let lpParameters = unsafe { CStr::from_ptr(lpParameters as *const _) };
        let lpParameters = lpParameters.to_bytes_with_nul().to_vec();
        let lp_parameters = Cow::Owned(unsafe { CString::from_vec_unchecked(lpParameters) });
        let lpDirectory = unsafe { CStr::from_ptr(lpDirectory as *const _) };
        let lpDirectory = lpDirectory.to_bytes_with_nul().to_vec();
        let lp_directory = Cow::Owned(unsafe { CString::from_vec_unchecked(lpDirectory) });
        let n_show = nShow;
        let dw_hot_key = dwHotKey;
        let lpTitle = unsafe { CStr::from_ptr(lpTitle as *const _) };
        let lpTitle = lpTitle.to_bytes_with_nul().to_vec();
        let lp_title = Cow::Owned(unsafe { CString::from_vec_unchecked(lpTitle) });
        let slen = unsafe { wide_strlen(lpVerbWString as *const u16) };
        let lpVerbWString = unsafe { slice::from_raw_parts(lpVerbWString, slen + 1) };
        let lp_verb_w_string = Cow::Owned(lpVerbWString.to_vec());
        let slen = unsafe { wide_strlen(lpParametersW as *const u16) };
        let lpParametersW = unsafe { slice::from_raw_parts(lpParametersW, slen + 1) };
        let lp_parameters_w = Cow::Owned(lpParametersW.to_vec());
        let slen = unsafe { wide_strlen(lpDirectoryW as *const u16) };
        let lpDirectoryW = unsafe { slice::from_raw_parts(lpDirectoryW, slen + 1) };
        let lp_directory_w = Cow::Owned(lpDirectoryW.to_vec());
        let slen = unsafe { wide_strlen(lpTitleW as *const u16) };
        let lpTitleW = unsafe { slice::from_raw_parts(lpTitleW, slen + 1) };
        let lp_title_w = Cow::Owned(lpTitleW.to_vec());
        let pt_invoke = unsafe { Point::from_win32(ptInvoke) };
        let lp_verb_int = lpVerbInt;
        let lp_verb_w_int = lpVerbWInt;
        Self { cb_size, f_mask, hwnd, lp_verb_string, lp_parameters, lp_directory, n_show, dw_hot_key, lp_title, lp_verb_w_string, lp_parameters_w, lp_directory_w, lp_title_w, pt_invoke, lp_verb_int, lp_verb_w_int }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct CmColumninfo {
    pub cb_size: u32,
    pub dw_mask: u32,
    pub dw_state: u32,
    pub u_width: u32,
    pub u_default_width: u32,
    pub u_ideal_width: u32,
    pub wsz_name: [u16; 80],
}
impl CmColumninfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::CM_COLUMNINFO {
        let Self { cb_size, dw_mask, dw_state, u_width, u_default_width, u_ideal_width, wsz_name } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::CM_COLUMNINFO>() as _;
        let dwMask = *dw_mask;
        let dwState = *dw_state;
        let uWidth = *u_width;
        let uDefaultWidth = *u_default_width;
        let uIdealWidth = *u_ideal_width;
        let wszName = [*&wsz_name[0],*&wsz_name[1],*&wsz_name[2],*&wsz_name[3],*&wsz_name[4],*&wsz_name[5],*&wsz_name[6],*&wsz_name[7],*&wsz_name[8],*&wsz_name[9],*&wsz_name[10],*&wsz_name[11],*&wsz_name[12],*&wsz_name[13],*&wsz_name[14],*&wsz_name[15],*&wsz_name[16],*&wsz_name[17],*&wsz_name[18],*&wsz_name[19],*&wsz_name[20],*&wsz_name[21],*&wsz_name[22],*&wsz_name[23],*&wsz_name[24],*&wsz_name[25],*&wsz_name[26],*&wsz_name[27],*&wsz_name[28],*&wsz_name[29],*&wsz_name[30],*&wsz_name[31],*&wsz_name[32],*&wsz_name[33],*&wsz_name[34],*&wsz_name[35],*&wsz_name[36],*&wsz_name[37],*&wsz_name[38],*&wsz_name[39],*&wsz_name[40],*&wsz_name[41],*&wsz_name[42],*&wsz_name[43],*&wsz_name[44],*&wsz_name[45],*&wsz_name[46],*&wsz_name[47],*&wsz_name[48],*&wsz_name[49],*&wsz_name[50],*&wsz_name[51],*&wsz_name[52],*&wsz_name[53],*&wsz_name[54],*&wsz_name[55],*&wsz_name[56],*&wsz_name[57],*&wsz_name[58],*&wsz_name[59],*&wsz_name[60],*&wsz_name[61],*&wsz_name[62],*&wsz_name[63],*&wsz_name[64],*&wsz_name[65],*&wsz_name[66],*&wsz_name[67],*&wsz_name[68],*&wsz_name[69],*&wsz_name[70],*&wsz_name[71],*&wsz_name[72],*&wsz_name[73],*&wsz_name[74],*&wsz_name[75],*&wsz_name[76],*&wsz_name[77],*&wsz_name[78],*&wsz_name[79]];
        windows_sys::Win32::UI::Shell::CM_COLUMNINFO { cbSize, dwMask, dwState, uWidth, uDefaultWidth, uIdealWidth, wszName }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::CM_COLUMNINFO) -> Self {
        let windows_sys::Win32::UI::Shell::CM_COLUMNINFO { cbSize, dwMask, dwState, uWidth, uDefaultWidth, uIdealWidth, wszName } = win32;
        let cb_size = cbSize;
        let dw_mask = dwMask;
        let dw_state = dwState;
        let u_width = uWidth;
        let u_default_width = uDefaultWidth;
        let u_ideal_width = uIdealWidth;
        let wsz_name = [wszName[0],wszName[1],wszName[2],wszName[3],wszName[4],wszName[5],wszName[6],wszName[7],wszName[8],wszName[9],wszName[10],wszName[11],wszName[12],wszName[13],wszName[14],wszName[15],wszName[16],wszName[17],wszName[18],wszName[19],wszName[20],wszName[21],wszName[22],wszName[23],wszName[24],wszName[25],wszName[26],wszName[27],wszName[28],wszName[29],wszName[30],wszName[31],wszName[32],wszName[33],wszName[34],wszName[35],wszName[36],wszName[37],wszName[38],wszName[39],wszName[40],wszName[41],wszName[42],wszName[43],wszName[44],wszName[45],wszName[46],wszName[47],wszName[48],wszName[49],wszName[50],wszName[51],wszName[52],wszName[53],wszName[54],wszName[55],wszName[56],wszName[57],wszName[58],wszName[59],wszName[60],wszName[61],wszName[62],wszName[63],wszName[64],wszName[65],wszName[66],wszName[67],wszName[68],wszName[69],wszName[70],wszName[71],wszName[72],wszName[73],wszName[74],wszName[75],wszName[76],wszName[77],wszName[78],wszName[79]];
        Self { cb_size, dw_mask, dw_state, u_width, u_default_width, u_ideal_width, wsz_name }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Coloradjustment {
    pub ca_size: u16,
    pub ca_flags: u16,
    pub ca_illuminant_index: u16,
    pub ca_red_gamma: u16,
    pub ca_green_gamma: u16,
    pub ca_blue_gamma: u16,
    pub ca_reference_black: u16,
    pub ca_reference_white: u16,
    pub ca_contrast: i16,
    pub ca_brightness: i16,
    pub ca_colorfulness: i16,
    pub ca_red_green_tint: i16,
}
impl Coloradjustment {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::COLORADJUSTMENT {
        let Self { ca_size, ca_flags, ca_illuminant_index, ca_red_gamma, ca_green_gamma, ca_blue_gamma, ca_reference_black, ca_reference_white, ca_contrast, ca_brightness, ca_colorfulness, ca_red_green_tint } = self;
        let caSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::COLORADJUSTMENT>() as _;
        let caFlags = *ca_flags;
        let caIlluminantIndex = *ca_illuminant_index;
        let caRedGamma = *ca_red_gamma;
        let caGreenGamma = *ca_green_gamma;
        let caBlueGamma = *ca_blue_gamma;
        let caReferenceBlack = *ca_reference_black;
        let caReferenceWhite = *ca_reference_white;
        let caContrast = *ca_contrast;
        let caBrightness = *ca_brightness;
        let caColorfulness = *ca_colorfulness;
        let caRedGreenTint = *ca_red_green_tint;
        windows_sys::Win32::Graphics::Gdi::COLORADJUSTMENT { caSize, caFlags, caIlluminantIndex, caRedGamma, caGreenGamma, caBlueGamma, caReferenceBlack, caReferenceWhite, caContrast, caBrightness, caColorfulness, caRedGreenTint }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::COLORADJUSTMENT) -> Self {
        let windows_sys::Win32::Graphics::Gdi::COLORADJUSTMENT { caSize, caFlags, caIlluminantIndex, caRedGamma, caGreenGamma, caBlueGamma, caReferenceBlack, caReferenceWhite, caContrast, caBrightness, caColorfulness, caRedGreenTint } = win32;
        let ca_size = caSize;
        let ca_flags = caFlags;
        let ca_illuminant_index = caIlluminantIndex;
        let ca_red_gamma = caRedGamma;
        let ca_green_gamma = caGreenGamma;
        let ca_blue_gamma = caBlueGamma;
        let ca_reference_black = caReferenceBlack;
        let ca_reference_white = caReferenceWhite;
        let ca_contrast = caContrast;
        let ca_brightness = caBrightness;
        let ca_colorfulness = caColorfulness;
        let ca_red_green_tint = caRedGreenTint;
        Self { ca_size, ca_flags, ca_illuminant_index, ca_red_gamma, ca_green_gamma, ca_blue_gamma, ca_reference_black, ca_reference_white, ca_contrast, ca_brightness, ca_colorfulness, ca_red_green_tint }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Colorcorrectpalette {
    pub emr: Emr,
    pub ih_palette: u32,
    pub n_first_entry: u32,
    pub n_pal_entries: u32,
    pub n_reserved: u32,
}
impl Colorcorrectpalette {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::COLORCORRECTPALETTE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::COLORCORRECTPALETTE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Colormap {
    pub from: u32,
    pub to: u32,
}
impl Colormap {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::COLORMAP {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::COLORMAP) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Colormatchtotarget {
    pub emr: Emr,
    pub dw_action: u32,
    pub dw_flags: u32,
    pub cb_name: u32,
    pub cb_data: u32,
    pub data: [u8; 1],
}
impl Colormatchtotarget {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::COLORMATCHTOTARGET {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::COLORMATCHTOTARGET) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Colorscheme {
    pub dw_size: u32,
    pub clr_btn_highlight: u32,
    pub clr_btn_shadow: u32,
}
impl Colorscheme {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::COLORSCHEME {
        let Self { dw_size, clr_btn_highlight, clr_btn_shadow } = self;
        let dwSize = mem::size_of::<windows_sys::Win32::UI::Controls::COLORSCHEME>() as _;
        let clrBtnHighlight = *clr_btn_highlight;
        let clrBtnShadow = *clr_btn_shadow;
        windows_sys::Win32::UI::Controls::COLORSCHEME { dwSize, clrBtnHighlight, clrBtnShadow }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::COLORSCHEME) -> Self {
        let windows_sys::Win32::UI::Controls::COLORSCHEME { dwSize, clrBtnHighlight, clrBtnShadow } = win32;
        let dw_size = dwSize;
        let clr_btn_highlight = clrBtnHighlight;
        let clr_btn_shadow = clrBtnShadow;
        Self { dw_size, clr_btn_highlight, clr_btn_shadow }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Comboboxinfo {
    pub cb_size: u32,
    pub rc_item: Rect,
    pub rc_button: Rect,
    pub state_button: u32,
    pub hwnd_combo: Option<Hwnd>,
    pub hwnd_item: Option<Hwnd>,
    pub hwnd_list: Option<Hwnd>,
}
impl Comboboxinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::COMBOBOXINFO {
        let Self { cb_size, rc_item, rc_button, state_button, hwnd_combo, hwnd_item, hwnd_list } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::COMBOBOXINFO>() as _;
        let rcItem = rc_item.to_win32();
        let rcButton = rc_button.to_win32();
        let stateButton = *state_button;
        let hwndCombo = hwnd_combo.map_or(0, Hwnd::into_raw);
        let hwndItem = hwnd_item.map_or(0, Hwnd::into_raw);
        let hwndList = hwnd_list.map_or(0, Hwnd::into_raw);
        windows_sys::Win32::UI::Controls::COMBOBOXINFO { cbSize, rcItem, rcButton, stateButton, hwndCombo, hwndItem, hwndList }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::COMBOBOXINFO) -> Self {
        let windows_sys::Win32::UI::Controls::COMBOBOXINFO { cbSize, rcItem, rcButton, stateButton, hwndCombo, hwndItem, hwndList } = win32;
        let cb_size = cbSize;
        let rc_item = unsafe { Rect::from_win32(rcItem) };
        let rc_button = unsafe { Rect::from_win32(rcButton) };
        let state_button = stateButton;
        let hwnd_combo = unsafe { Hwnd::new_optional(hwndCombo) };
        let hwnd_item = unsafe { Hwnd::new_optional(hwndItem) };
        let hwnd_list = unsafe { Hwnd::new_optional(hwndList) };
        Self { cb_size, rc_item, rc_button, state_button, hwnd_combo, hwnd_item, hwnd_list }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Compareitemstruct {
    pub ctl_type: u32,
    pub ctl_id: u32,
    pub hwnd_item: Option<Hwnd>,
    pub item_id1: u32,
    pub item_data1: usize,
    pub item_id2: u32,
    pub item_data2: usize,
    pub dw_locale_id: u32,
}
impl Compareitemstruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::COMPAREITEMSTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::COMPAREITEMSTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct ConfirmConflictResultInfo<'a> {
    pub psz_new_name: Cow<'a, [u16]>,
    pub i_item_index: u32,
}
impl<'a> ConfirmConflictResultInfo<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::CONFIRM_CONFLICT_RESULT_INFO {
        let Self { psz_new_name, i_item_index } = self;
        assert_eq!(psz_new_name.last().copied(), Some(0));
        let pszNewName = psz_new_name.as_ptr() as _;
        let iItemIndex = *i_item_index;
        windows_sys::Win32::UI::Shell::CONFIRM_CONFLICT_RESULT_INFO { pszNewName, iItemIndex }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::CONFIRM_CONFLICT_RESULT_INFO) -> Self {
        let windows_sys::Win32::UI::Shell::CONFIRM_CONFLICT_RESULT_INFO { pszNewName, iItemIndex } = win32;
        let slen = unsafe { wide_strlen(pszNewName as *const u16) };
        let pszNewName = unsafe { slice::from_raw_parts(pszNewName, slen + 1) };
        let psz_new_name = Cow::Owned(pszNewName.to_vec());
        let i_item_index = iItemIndex;
        Self { psz_new_name, i_item_index }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Cplinfo {
    pub id_icon: i32,
    pub id_name: i32,
    pub id_info: i32,
    pub l_data: isize,
}
impl Cplinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::CPLINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::CPLINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
//  Not generated due to containing a void type
//  #[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Createstructa<'a> {
//      pub lp_create_params: &'a mut todo_void,
//      pub h_instance: Option<Hinstance>,
//      pub h_menu: Option<Hmenu>,
//      pub hwnd_parent: Option<Hwnd>,
//      pub cy: i32,
//      pub cx: i32,
//      pub y: i32,
//      pub x: i32,
//      pub style: i32,
//      pub lpsz_name: Cow<'a, CStr>,
//      pub lpsz_class: Cow<'a, CStr>,
//      pub dw_ex_style: u32,
//  }
//  impl<'a> Createstructa<'a> {
//      fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::CREATESTRUCTA {
//          let Self { lp_create_params, h_instance, h_menu, hwnd_parent, cy, cx, y, x, style, lpsz_name, lpsz_class, dw_ex_style } = self;
//          let lpCreateParams = unsafe { &mut *(lp_create_params as *mut _ as *mut _) };
//          let hInstance = h_instance.map_or(0, Hinstance::into_raw);
//          let hMenu = h_menu.map_or(0, Hmenu::into_raw);
//          let hwndParent = hwnd_parent.map_or(0, Hwnd::into_raw);
//          let cy = *cy;
//          let cx = *cx;
//          let y = *y;
//          let x = *x;
//          let style = *style;
//          let lpszName = lpsz_name.as_ptr() as _;
//          let lpszClass = lpsz_class.as_ptr() as _;
//          let dwExStyle = *dw_ex_style;
//          windows_sys::Win32::UI::WindowsAndMessaging::CREATESTRUCTA { lpCreateParams, hInstance, hMenu, hwndParent, cy, cx, y, x, style, lpszName, lpszClass, dwExStyle }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::CREATESTRUCTA) -> Self {
//          let windows_sys::Win32::UI::WindowsAndMessaging::CREATESTRUCTA { lpCreateParams, hInstance, hMenu, hwndParent, cy, cx, y, x, style, lpszName, lpszClass, dwExStyle } = win32;
//          let lp_create_params = unsafe { &mut *(lpCreateParams as *mut _ as *mut _) };
//          let h_instance = unsafe { Hinstance::new_optional(hInstance) };
//          let h_menu = unsafe { Hmenu::new_optional(hMenu) };
//          let hwnd_parent = unsafe { Hwnd::new_optional(hwndParent) };
//          let cy = cy;
//          let cx = cx;
//          let y = y;
//          let x = x;
//          let style = style;
//          let lpszName = unsafe { CStr::from_ptr(lpszName as *const _) };
//          let lpszName = lpszName.to_bytes_with_nul().to_vec();
//          let lpsz_name = Cow::Owned(unsafe { CString::from_vec_unchecked(lpszName) });
//          let lpszClass = unsafe { CStr::from_ptr(lpszClass as *const _) };
//          let lpszClass = lpszClass.to_bytes_with_nul().to_vec();
//          let lpsz_class = Cow::Owned(unsafe { CString::from_vec_unchecked(lpszClass) });
//          let dw_ex_style = dwExStyle;
//          Self { lp_create_params, h_instance, h_menu, hwnd_parent, cy, cx, y, x, style, lpsz_name, lpsz_class, dw_ex_style }
//      }
//  }
//  Not generated due to containing a void type
//  #[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Createstructw<'a> {
//      pub lp_create_params: &'a mut todo_void,
//      pub h_instance: Option<Hinstance>,
//      pub h_menu: Option<Hmenu>,
//      pub hwnd_parent: Option<Hwnd>,
//      pub cy: i32,
//      pub cx: i32,
//      pub y: i32,
//      pub x: i32,
//      pub style: i32,
//      pub lpsz_name: Cow<'a, [u16]>,
//      pub lpsz_class: Cow<'a, [u16]>,
//      pub dw_ex_style: u32,
//  }
//  impl<'a> Createstructw<'a> {
//      fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::CREATESTRUCTW {
//          let Self { lp_create_params, h_instance, h_menu, hwnd_parent, cy, cx, y, x, style, lpsz_name, lpsz_class, dw_ex_style } = self;
//          let lpCreateParams = unsafe { &mut *(lp_create_params as *mut _ as *mut _) };
//          let hInstance = h_instance.map_or(0, Hinstance::into_raw);
//          let hMenu = h_menu.map_or(0, Hmenu::into_raw);
//          let hwndParent = hwnd_parent.map_or(0, Hwnd::into_raw);
//          let cy = *cy;
//          let cx = *cx;
//          let y = *y;
//          let x = *x;
//          let style = *style;
//          assert_eq!(lpsz_name.last().copied(), Some(0));
//          let lpszName = lpsz_name.as_ptr() as _;
//          assert_eq!(lpsz_class.last().copied(), Some(0));
//          let lpszClass = lpsz_class.as_ptr() as _;
//          let dwExStyle = *dw_ex_style;
//          windows_sys::Win32::UI::WindowsAndMessaging::CREATESTRUCTW { lpCreateParams, hInstance, hMenu, hwndParent, cy, cx, y, x, style, lpszName, lpszClass, dwExStyle }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::CREATESTRUCTW) -> Self {
//          let windows_sys::Win32::UI::WindowsAndMessaging::CREATESTRUCTW { lpCreateParams, hInstance, hMenu, hwndParent, cy, cx, y, x, style, lpszName, lpszClass, dwExStyle } = win32;
//          let lp_create_params = unsafe { &mut *(lpCreateParams as *mut _ as *mut _) };
//          let h_instance = unsafe { Hinstance::new_optional(hInstance) };
//          let h_menu = unsafe { Hmenu::new_optional(hMenu) };
//          let hwnd_parent = unsafe { Hwnd::new_optional(hwndParent) };
//          let cy = cy;
//          let cx = cx;
//          let y = y;
//          let x = x;
//          let style = style;
//          let slen = unsafe { wide_strlen(lpszName as *const u16) };
//          let lpszName = unsafe { slice::from_raw_parts(lpszName, slen + 1) };
//          let lpsz_name = Cow::Owned(lpszName.to_vec());
//          let slen = unsafe { wide_strlen(lpszClass as *const u16) };
//          let lpszClass = unsafe { slice::from_raw_parts(lpszClass, slen + 1) };
//          let lpsz_class = Cow::Owned(lpszClass.to_vec());
//          let dw_ex_style = dwExStyle;
//          Self { lp_create_params, h_instance, h_menu, hwnd_parent, cy, cx, y, x, style, lpsz_name, lpsz_class, dw_ex_style }
//      }
//  }
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Cursorinfo {
    pub cb_size: u32,
    pub flags: u32,
    pub h_cursor: Option<Hcursor>,
    pub pt_screen_pos: Point,
}
impl Cursorinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::CURSORINFO {
        let Self { cb_size, flags, h_cursor, pt_screen_pos } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::CURSORINFO>() as _;
        let flags = *flags;
        let hCursor = h_cursor.map_or(0, Hcursor::into_raw);
        let ptScreenPos = pt_screen_pos.to_win32();
        windows_sys::Win32::UI::WindowsAndMessaging::CURSORINFO { cbSize, flags, hCursor, ptScreenPos }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::CURSORINFO) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::CURSORINFO { cbSize, flags, hCursor, ptScreenPos } = win32;
        let cb_size = cbSize;
        let flags = flags;
        let h_cursor = unsafe { Hcursor::new_optional(hCursor) };
        let pt_screen_pos = unsafe { Point::from_win32(ptScreenPos) };
        Self { cb_size, flags, h_cursor, pt_screen_pos }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Cursorshape {
    pub x_hot_spot: i32,
    pub y_hot_spot: i32,
    pub cx: i32,
    pub cy: i32,
    pub cb_width: i32,
    pub planes: u8,
    pub bits_pixel: u8,
}
impl Cursorshape {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::CURSORSHAPE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::CURSORSHAPE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Cwpretstruct {
    pub l_result: Lresult,
    pub l_param: Lparam,
    pub w_param: Wparam,
    pub message: u32,
    pub hwnd: Option<Hwnd>,
}
impl Cwpretstruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::CWPRETSTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::CWPRETSTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Cwpstruct {
    pub l_param: Lparam,
    pub w_param: Wparam,
    pub message: u32,
    pub hwnd: Option<Hwnd>,
}
impl Cwpstruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::CWPSTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::CWPSTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CreatedHdc {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl CreatedHdc {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for CreatedHdc {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for CreatedHdc {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct DatablockHeader {
    pub cb_size: u32,
    pub dw_signature: u32,
}
impl DatablockHeader {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::DATABLOCK_HEADER {
        let Self { cb_size, dw_signature } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::DATABLOCK_HEADER>() as _;
        let dwSignature = *dw_signature;
        windows_sys::Win32::UI::Shell::DATABLOCK_HEADER { cbSize, dwSignature }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::DATABLOCK_HEADER) -> Self {
        let windows_sys::Win32::UI::Shell::DATABLOCK_HEADER { cbSize, dwSignature } = win32;
        let cb_size = cbSize;
        let dw_signature = dwSignature;
        Self { cb_size, dw_signature }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Datetimepickerinfo {
    pub cb_size: u32,
    pub rc_check: Rect,
    pub state_check: u32,
    pub rc_button: Rect,
    pub state_button: u32,
    pub hwnd_edit: Option<Hwnd>,
    pub hwnd_ud: Option<Hwnd>,
    pub hwnd_drop_down: Option<Hwnd>,
}
impl Datetimepickerinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::DATETIMEPICKERINFO {
        let Self { cb_size, rc_check, state_check, rc_button, state_button, hwnd_edit, hwnd_ud, hwnd_drop_down } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::DATETIMEPICKERINFO>() as _;
        let rcCheck = rc_check.to_win32();
        let stateCheck = *state_check;
        let rcButton = rc_button.to_win32();
        let stateButton = *state_button;
        let hwndEdit = hwnd_edit.map_or(0, Hwnd::into_raw);
        let hwndUD = hwnd_ud.map_or(0, Hwnd::into_raw);
        let hwndDropDown = hwnd_drop_down.map_or(0, Hwnd::into_raw);
        windows_sys::Win32::UI::Controls::DATETIMEPICKERINFO { cbSize, rcCheck, stateCheck, rcButton, stateButton, hwndEdit, hwndUD, hwndDropDown }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::DATETIMEPICKERINFO) -> Self {
        let windows_sys::Win32::UI::Controls::DATETIMEPICKERINFO { cbSize, rcCheck, stateCheck, rcButton, stateButton, hwndEdit, hwndUD, hwndDropDown } = win32;
        let cb_size = cbSize;
        let rc_check = unsafe { Rect::from_win32(rcCheck) };
        let state_check = stateCheck;
        let rc_button = unsafe { Rect::from_win32(rcButton) };
        let state_button = stateButton;
        let hwnd_edit = unsafe { Hwnd::new_optional(hwndEdit) };
        let hwnd_ud = unsafe { Hwnd::new_optional(hwndUD) };
        let hwnd_drop_down = unsafe { Hwnd::new_optional(hwndDropDown) };
        Self { cb_size, rc_check, state_check, rc_button, state_button, hwnd_edit, hwnd_ud, hwnd_drop_down }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Debughookinfo {
    pub id_thread: u32,
    pub id_thread_installer: u32,
    pub l_param: Lparam,
    pub w_param: Wparam,
    pub code: i32,
}
impl Debughookinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::DEBUGHOOKINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::DEBUGHOOKINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Delegateitemid {
    pub cb_size: u16,
    pub w_outer: u16,
    pub cb_inner: u16,
    pub rgb: [u8; 1],
}
impl Delegateitemid {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::DELEGATEITEMID {
        let Self { cb_size, w_outer, cb_inner, rgb } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::DELEGATEITEMID>() as _;
        let wOuter = *w_outer;
        let cbInner = *cb_inner;
        let rgb = [*&rgb[0]];
        windows_sys::Win32::UI::Shell::DELEGATEITEMID { cbSize, wOuter, cbInner, rgb }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::DELEGATEITEMID) -> Self {
        let windows_sys::Win32::UI::Shell::DELEGATEITEMID { cbSize, wOuter, cbInner, rgb } = win32;
        let cb_size = cbSize;
        let w_outer = wOuter;
        let cb_inner = cbInner;
        let rgb = [rgb[0]];
        Self { cb_size, w_outer, cb_inner, rgb }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Deleteitemstruct {
    pub ctl_type: u32,
    pub ctl_id: u32,
    pub item_id: u32,
    pub hwnd_item: Option<Hwnd>,
    pub item_data: usize,
}
impl Deleteitemstruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::DELETEITEMSTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::DELETEITEMSTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Designvector {
    pub dv_reserved: u32,
    pub dv_num_axes: u32,
    pub dv_values: [i32; 16],
}
impl Designvector {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::DESIGNVECTOR {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::DESIGNVECTOR) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
//  Not generated because it involves stubs, crate should manually define type
//  #[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Devmodea {
//      STUBBED OUT
//  }
//  Not generated because it involves stubs, crate should manually define type
//  #[repr(C)]
//  pub union Devmodea0 {
//      STUBBED OUT
//  }
//  Not generated because it involves stubs, crate should manually define type
//  #[repr(C)]
//  pub union Devmodea1 {
//      STUBBED OUT
//  }
//  Not generated because it involves stubs, crate should manually define type
//  #[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Devmodew {
//      STUBBED OUT
//  }
//  Not generated because it involves stubs, crate should manually define type
//  #[repr(C)]
//  pub union Devmodew2 {
//      STUBBED OUT
//  }
//  Not generated because it involves stubs, crate should manually define type
//  #[repr(C)]
//  pub union Devmodew3 {
//      STUBBED OUT
//  }
//  Not generated due to containing a void type
//  #[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Dibsection<'a> {
//      pub ds_bm: Bitmap<'a>,
//      pub ds_bmih: Bitmapinfoheader,
//      pub ds_bitfields: [u32; 3],
//      pub dsh_section: Option<Handle>,
//      pub ds_offset: u32,
//  }
//  impl<'a> Dibsection<'a> {
//      fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::DIBSECTION {
//          let Self { ds_bm, ds_bmih, ds_bitfields, dsh_section, ds_offset } = self;
//          let dsBm = ds_bm.to_win32();
//          let dsBmih = ds_bmih.to_win32();
//          let dsBitfields = [*&ds_bitfields[0],*&ds_bitfields[1],*&ds_bitfields[2]];
//          let dshSection = dsh_section.map_or(0, Handle::into_raw);
//          let dsOffset = *ds_offset;
//          windows_sys::Win32::Graphics::Gdi::DIBSECTION { dsBm, dsBmih, dsBitfields, dshSection, dsOffset }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::DIBSECTION) -> Self {
//          let windows_sys::Win32::Graphics::Gdi::DIBSECTION { dsBm, dsBmih, dsBitfields, dshSection, dsOffset } = win32;
//          let ds_bm = unsafe { Bitmap::from_win32(dsBm) };
//          let ds_bmih = unsafe { Bitmapinfoheader::from_win32(dsBmih) };
//          let ds_bitfields = [dsBitfields[0],dsBitfields[1],dsBitfields[2]];
//          let dsh_section = unsafe { Handle::new_optional(dshSection) };
//          let ds_offset = dsOffset;
//          Self { ds_bm, ds_bmih, ds_bitfields, dsh_section, ds_offset }
//      }
//  }
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct DisplayDevicea {
    pub cb: u32,
    pub device_name: [CHAR; 32],
    pub device_string: [CHAR; 128],
    pub state_flags: u32,
    pub device_id: [CHAR; 128],
    pub device_key: [CHAR; 128],
}
impl DisplayDevicea {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::DISPLAY_DEVICEA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::DISPLAY_DEVICEA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct DisplayDevicew {
    pub cb: u32,
    pub device_name: [u16; 32],
    pub device_string: [u16; 128],
    pub state_flags: u32,
    pub device_id: [u16; 128],
    pub device_key: [u16; 128],
}
impl DisplayDevicew {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::DISPLAY_DEVICEW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::DISPLAY_DEVICEW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(2))]
pub struct Dlgitemtemplate {
    pub style: u32,
    pub dw_extended_style: u32,
    pub x: i16,
    pub y: i16,
    pub cx: i16,
    pub cy: i16,
    pub id: u16,
}
impl Dlgitemtemplate {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::DLGITEMTEMPLATE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::DLGITEMTEMPLATE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(2))]
pub struct Dlgtemplate {
    pub style: u32,
    pub dw_extended_style: u32,
    pub cdit: u16,
    pub x: i16,
    pub y: i16,
    pub cx: i16,
    pub cy: i16,
}
impl Dlgtemplate {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::DLGTEMPLATE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::DLGTEMPLATE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Dllversioninfo {
    pub cb_size: u32,
    pub dw_major_version: u32,
    pub dw_minor_version: u32,
    pub dw_build_number: u32,
    pub dw_platform_id: u32,
}
impl Dllversioninfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::DLLVERSIONINFO {
        let Self { cb_size, dw_major_version, dw_minor_version, dw_build_number, dw_platform_id } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::DLLVERSIONINFO>() as _;
        let dwMajorVersion = *dw_major_version;
        let dwMinorVersion = *dw_minor_version;
        let dwBuildNumber = *dw_build_number;
        let dwPlatformID = *dw_platform_id;
        windows_sys::Win32::UI::Shell::DLLVERSIONINFO { cbSize, dwMajorVersion, dwMinorVersion, dwBuildNumber, dwPlatformID }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::DLLVERSIONINFO) -> Self {
        let windows_sys::Win32::UI::Shell::DLLVERSIONINFO { cbSize, dwMajorVersion, dwMinorVersion, dwBuildNumber, dwPlatformID } = win32;
        let cb_size = cbSize;
        let dw_major_version = dwMajorVersion;
        let dw_minor_version = dwMinorVersion;
        let dw_build_number = dwBuildNumber;
        let dw_platform_id = dwPlatformID;
        Self { cb_size, dw_major_version, dw_minor_version, dw_build_number, dw_platform_id }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Dllversioninfo2 {
    pub info1: Dllversioninfo,
    pub dw_flags: u32,
    pub ull_version: u64,
}
impl Dllversioninfo2 {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::DLLVERSIONINFO2 {
        let Self { info1, dw_flags, ull_version } = self;
        let info1 = info1.to_win32();
        let dwFlags = *dw_flags;
        let ullVersion = *ull_version;
        windows_sys::Win32::UI::Shell::DLLVERSIONINFO2 { info1, dwFlags, ullVersion }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::DLLVERSIONINFO2) -> Self {
        let windows_sys::Win32::UI::Shell::DLLVERSIONINFO2 { info1, dwFlags, ullVersion } = win32;
        let info1 = unsafe { Dllversioninfo::from_win32(info1) };
        let dw_flags = dwFlags;
        let ull_version = ullVersion;
        Self { info1, dw_flags, ull_version }
    }
}
//  Not generated due to containing a void type
//  #[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Dpastreaminfo<'a> {
//      pub i_pos: i32,
//      pub pv_item: &'a mut todo_void,
//  }
//  impl<'a> Dpastreaminfo<'a> {
//      fn to_win32(&self) -> windows_sys::Win32::UI::Controls::DPASTREAMINFO {
//          let Self { i_pos, pv_item } = self;
//          let iPos = *i_pos;
//          let pvItem = unsafe { &mut *(pv_item as *mut _ as *mut _) };
//          windows_sys::Win32::UI::Controls::DPASTREAMINFO { iPos, pvItem }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::DPASTREAMINFO) -> Self {
//          let windows_sys::Win32::UI::Controls::DPASTREAMINFO { iPos, pvItem } = win32;
//          let i_pos = iPos;
//          let pv_item = unsafe { &mut *(pvItem as *mut _ as *mut _) };
//          Self { i_pos, pv_item }
//      }
//  }
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Draginfoa<'a> {
    pub u_size: u32,
    pub pt: Point,
    pub f_nc: BOOL,
    pub lp_file_list: Cow<'a, CStr>,
    pub grf_key_state: u32,
}
impl<'a> Draginfoa<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::DRAGINFOA {
        let Self { u_size, pt, f_nc, lp_file_list, grf_key_state } = self;
        let uSize = mem::size_of::<windows_sys::Win32::UI::Shell::DRAGINFOA>() as _;
        let pt = pt.to_win32();
        let fNC = *f_nc;
        let lpFileList = lp_file_list.as_ptr() as _;
        let grfKeyState = *grf_key_state;
        windows_sys::Win32::UI::Shell::DRAGINFOA { uSize, pt, fNC, lpFileList, grfKeyState }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::DRAGINFOA) -> Self {
        let windows_sys::Win32::UI::Shell::DRAGINFOA { uSize, pt, fNC, lpFileList, grfKeyState } = win32;
        let u_size = uSize;
        let pt = unsafe { Point::from_win32(pt) };
        let f_nc = fNC;
        let lpFileList = unsafe { CStr::from_ptr(lpFileList as *const _) };
        let lpFileList = lpFileList.to_bytes_with_nul().to_vec();
        let lp_file_list = Cow::Owned(unsafe { CString::from_vec_unchecked(lpFileList) });
        let grf_key_state = grfKeyState;
        Self { u_size, pt, f_nc, lp_file_list, grf_key_state }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Draginfow<'a> {
    pub u_size: u32,
    pub pt: Point,
    pub f_nc: BOOL,
    pub lp_file_list: Cow<'a, [u16]>,
    pub grf_key_state: u32,
}
impl<'a> Draginfow<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::DRAGINFOW {
        let Self { u_size, pt, f_nc, lp_file_list, grf_key_state } = self;
        let uSize = mem::size_of::<windows_sys::Win32::UI::Shell::DRAGINFOW>() as _;
        let pt = pt.to_win32();
        let fNC = *f_nc;
        assert_eq!(lp_file_list.last().copied(), Some(0));
        let lpFileList = lp_file_list.as_ptr() as _;
        let grfKeyState = *grf_key_state;
        windows_sys::Win32::UI::Shell::DRAGINFOW { uSize, pt, fNC, lpFileList, grfKeyState }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::DRAGINFOW) -> Self {
        let windows_sys::Win32::UI::Shell::DRAGINFOW { uSize, pt, fNC, lpFileList, grfKeyState } = win32;
        let u_size = uSize;
        let pt = unsafe { Point::from_win32(pt) };
        let f_nc = fNC;
        let slen = unsafe { wide_strlen(lpFileList as *const u16) };
        let lpFileList = unsafe { slice::from_raw_parts(lpFileList, slen + 1) };
        let lp_file_list = Cow::Owned(lpFileList.to_vec());
        let grf_key_state = grfKeyState;
        Self { u_size, pt, f_nc, lp_file_list, grf_key_state }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Draglistinfo {
    pub u_notification: u32,
    pub h_wnd: Option<Hwnd>,
    pub pt_cursor: Point,
}
impl Draglistinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::DRAGLISTINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::DRAGLISTINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Drawitemstruct {
    pub ctl_type: u32,
    pub ctl_id: u32,
    pub item_id: u32,
    pub item_action: u32,
    pub item_state: u32,
    pub hwnd_item: Option<Hwnd>,
    pub h_dc: Option<Hdc>,
    pub rc_item: Rect,
    pub item_data: usize,
}
impl Drawitemstruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::DRAWITEMSTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::DRAWITEMSTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Drawtextparams {
    pub cb_size: u32,
    pub i_tab_length: i32,
    pub i_left_margin: i32,
    pub i_right_margin: i32,
    pub ui_length_drawn: u32,
}
impl Drawtextparams {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::DRAWTEXTPARAMS {
        let Self { cb_size, i_tab_length, i_left_margin, i_right_margin, ui_length_drawn } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::DRAWTEXTPARAMS>() as _;
        let iTabLength = *i_tab_length;
        let iLeftMargin = *i_left_margin;
        let iRightMargin = *i_right_margin;
        let uiLengthDrawn = *ui_length_drawn;
        windows_sys::Win32::Graphics::Gdi::DRAWTEXTPARAMS { cbSize, iTabLength, iLeftMargin, iRightMargin, uiLengthDrawn }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::DRAWTEXTPARAMS) -> Self {
        let windows_sys::Win32::Graphics::Gdi::DRAWTEXTPARAMS { cbSize, iTabLength, iLeftMargin, iRightMargin, uiLengthDrawn } = win32;
        let cb_size = cbSize;
        let i_tab_length = iTabLength;
        let i_left_margin = iLeftMargin;
        let i_right_margin = iRightMargin;
        let ui_length_drawn = uiLengthDrawn;
        Self { cb_size, i_tab_length, i_left_margin, i_right_margin, ui_length_drawn }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Dropdescription {
    pub r#type: i32,
    pub sz_message: [u16; 260],
    pub sz_insert: [u16; 260],
}
impl Dropdescription {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::DROPDESCRIPTION {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::DROPDESCRIPTION) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Dropfiles {
    pub p_files: u32,
    pub pt: Point,
    pub f_nc: BOOL,
    pub f_wide: BOOL,
}
impl Dropfiles {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::DROPFILES {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::DROPFILES) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Dropstruct {
    pub hwnd_source: Option<Hwnd>,
    pub hwnd_sink: Option<Hwnd>,
    pub w_fmt: u32,
    pub dw_data: usize,
    pub pt_drop: Point,
    pub dw_control_data: u32,
}
impl Dropstruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::DROPSTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::DROPSTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Dsktlsystemtime {
    pub w_year: u16,
    pub w_month: u16,
    pub w_day_of_week: u16,
    pub w_day: u16,
    pub w_hour: u16,
    pub w_minute: u16,
    pub w_second: u16,
    pub w_milliseconds: u16,
    pub w_result: u16,
}
impl Dsktlsystemtime {
    fn to_win32(&self) -> windows_sys::Win32::System::Registry::DSKTLSYSTEMTIME {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::System::Registry::DSKTLSYSTEMTIME) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Dtbgopts {
    pub dw_size: u32,
    pub dw_flags: u32,
    pub rc_clip: Rect,
}
impl Dtbgopts {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::DTBGOPTS {
        let Self { dw_size, dw_flags, rc_clip } = self;
        let dwSize = mem::size_of::<windows_sys::Win32::UI::Controls::DTBGOPTS>() as _;
        let dwFlags = *dw_flags;
        let rcClip = rc_clip.to_win32();
        windows_sys::Win32::UI::Controls::DTBGOPTS { dwSize, dwFlags, rcClip }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::DTBGOPTS) -> Self {
        let windows_sys::Win32::UI::Controls::DTBGOPTS { dwSize, dwFlags, rcClip } = win32;
        let dw_size = dwSize;
        let dw_flags = dwFlags;
        let rc_clip = unsafe { Rect::from_win32(rcClip) };
        Self { dw_size, dw_flags, rc_clip }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone)]
#[repr(C)]
pub struct Dttopts {
    pub dw_size: u32,
    pub dw_flags: u32,
    pub cr_text: u32,
    pub cr_border: u32,
    pub cr_shadow: u32,
    pub i_text_shadow_type: i32,
    pub pt_shadow_offset: Point,
    pub i_border_size: i32,
    pub i_font_prop_id: i32,
    pub i_color_prop_id: i32,
    pub i_state_id: i32,
    pub f_apply_overlay: BOOL,
    pub i_glow_size: i32,
    pub pfn_draw_text_callback: Option<unsafe extern "system" fn(HDC, PWSTR, i32, *mut windows_sys::Win32::Foundation::RECT, u32, LPARAM) -> i32>,
    pub l_param: Lparam,
}
impl Dttopts {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::DTTOPTS {
        let Self { dw_size, dw_flags, cr_text, cr_border, cr_shadow, i_text_shadow_type, pt_shadow_offset, i_border_size, i_font_prop_id, i_color_prop_id, i_state_id, f_apply_overlay, i_glow_size, pfn_draw_text_callback, l_param } = self;
        let dwSize = mem::size_of::<windows_sys::Win32::UI::Controls::DTTOPTS>() as _;
        let dwFlags = *dw_flags;
        let crText = *cr_text;
        let crBorder = *cr_border;
        let crShadow = *cr_shadow;
        let iTextShadowType = *i_text_shadow_type;
        let ptShadowOffset = pt_shadow_offset.to_win32();
        let iBorderSize = *i_border_size;
        let iFontPropId = *i_font_prop_id;
        let iColorPropId = *i_color_prop_id;
        let iStateId = *i_state_id;
        let fApplyOverlay = *f_apply_overlay;
        let iGlowSize = *i_glow_size;
        let pfnDrawTextCallback = *pfn_draw_text_callback;
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::Controls::DTTOPTS { dwSize, dwFlags, crText, crBorder, crShadow, iTextShadowType, ptShadowOffset, iBorderSize, iFontPropId, iColorPropId, iStateId, fApplyOverlay, iGlowSize, pfnDrawTextCallback, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::DTTOPTS) -> Self {
        let windows_sys::Win32::UI::Controls::DTTOPTS { dwSize, dwFlags, crText, crBorder, crShadow, iTextShadowType, ptShadowOffset, iBorderSize, iFontPropId, iColorPropId, iStateId, fApplyOverlay, iGlowSize, pfnDrawTextCallback, lParam } = win32;
        let dw_size = dwSize;
        let dw_flags = dwFlags;
        let cr_text = crText;
        let cr_border = crBorder;
        let cr_shadow = crShadow;
        let i_text_shadow_type = iTextShadowType;
        let pt_shadow_offset = unsafe { Point::from_win32(ptShadowOffset) };
        let i_border_size = iBorderSize;
        let i_font_prop_id = iFontPropId;
        let i_color_prop_id = iColorPropId;
        let i_state_id = iStateId;
        let f_apply_overlay = fApplyOverlay;
        let i_glow_size = iGlowSize;
        let pfn_draw_text_callback = pfnDrawTextCallback;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { dw_size, dw_flags, cr_text, cr_border, cr_shadow, i_text_shadow_type, pt_shadow_offset, i_border_size, i_font_prop_id, i_color_prop_id, i_state_id, f_apply_overlay, i_glow_size, pfn_draw_text_callback, l_param }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Editballoontip<'a> {
    pub cb_struct: u32,
    pub psz_title: Cow<'a, [u16]>,
    pub psz_text: Cow<'a, [u16]>,
    pub tti_icon: u32,
}
impl<'a> Editballoontip<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::EDITBALLOONTIP {
        let Self { cb_struct, psz_title, psz_text, tti_icon } = self;
        let cbStruct = *cb_struct;
        assert_eq!(psz_title.last().copied(), Some(0));
        let pszTitle = psz_title.as_ptr() as _;
        assert_eq!(psz_text.last().copied(), Some(0));
        let pszText = psz_text.as_ptr() as _;
        let ttiIcon = *tti_icon;
        windows_sys::Win32::UI::Controls::EDITBALLOONTIP { cbStruct, pszTitle, pszText, ttiIcon }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::EDITBALLOONTIP) -> Self {
        let windows_sys::Win32::UI::Controls::EDITBALLOONTIP { cbStruct, pszTitle, pszText, ttiIcon } = win32;
        let cb_struct = cbStruct;
        let slen = unsafe { wide_strlen(pszTitle as *const u16) };
        let pszTitle = unsafe { slice::from_raw_parts(pszTitle, slen + 1) };
        let psz_title = Cow::Owned(pszTitle.to_vec());
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = Cow::Owned(pszText.to_vec());
        let tti_icon = ttiIcon;
        Self { cb_struct, psz_title, psz_text, tti_icon }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emr {
    pub i_type: u32,
    pub n_size: u32,
}
impl Emr {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMR {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMR) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone)]
#[repr(C)]
pub struct Emralphablend {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub x_dest: i32,
    pub y_dest: i32,
    pub cx_dest: i32,
    pub cy_dest: i32,
    pub dw_rop: u32,
    pub x_src: i32,
    pub y_src: i32,
    pub xform_src: Xform,
    pub cr_bk_color_src: u32,
    pub i_usage_src: u32,
    pub off_bmi_src: u32,
    pub cb_bmi_src: u32,
    pub off_bits_src: u32,
    pub cb_bits_src: u32,
    pub cx_src: i32,
    pub cy_src: i32,
}
impl Emralphablend {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRALPHABLEND {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRALPHABLEND) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone)]
#[repr(C)]
pub struct Emranglearc {
    pub emr: Emr,
    pub ptl_center: Pointl,
    pub n_radius: u32,
    pub e_start_angle: f32,
    pub e_sweep_angle: f32,
}
impl Emranglearc {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRANGLEARC {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRANGLEARC) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrarc {
    pub emr: Emr,
    pub rcl_box: Rectl,
    pub ptl_start: Pointl,
    pub ptl_end: Pointl,
}
impl Emrarc {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRARC {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRARC) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone)]
#[repr(C)]
pub struct Emrbitblt {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub x_dest: i32,
    pub y_dest: i32,
    pub cx_dest: i32,
    pub cy_dest: i32,
    pub dw_rop: u32,
    pub x_src: i32,
    pub y_src: i32,
    pub xform_src: Xform,
    pub cr_bk_color_src: u32,
    pub i_usage_src: u32,
    pub off_bmi_src: u32,
    pub cb_bmi_src: u32,
    pub off_bits_src: u32,
    pub cb_bits_src: u32,
}
impl Emrbitblt {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRBITBLT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRBITBLT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrcreatebrushindirect {
    pub emr: Emr,
    pub ih_brush: u32,
    pub lb: Logbrush32,
}
impl Emrcreatebrushindirect {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRCREATEBRUSHINDIRECT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRCREATEBRUSHINDIRECT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrcreatedibpatternbrushpt {
    pub emr: Emr,
    pub ih_brush: u32,
    pub i_usage: u32,
    pub off_bmi: u32,
    pub cb_bmi: u32,
    pub off_bits: u32,
    pub cb_bits: u32,
}
impl Emrcreatedibpatternbrushpt {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRCREATEDIBPATTERNBRUSHPT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRCREATEDIBPATTERNBRUSHPT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrcreatemonobrush {
    pub emr: Emr,
    pub ih_brush: u32,
    pub i_usage: u32,
    pub off_bmi: u32,
    pub cb_bmi: u32,
    pub off_bits: u32,
    pub cb_bits: u32,
}
impl Emrcreatemonobrush {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRCREATEMONOBRUSH {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRCREATEMONOBRUSH) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrcreatepalette {
    pub emr: Emr,
    pub ih_pal: u32,
    pub lgpl: Logpalette,
}
impl Emrcreatepalette {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRCREATEPALETTE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRCREATEPALETTE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrcreatepen {
    pub emr: Emr,
    pub ih_pen: u32,
    pub lopn: Logpen,
}
impl Emrcreatepen {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRCREATEPEN {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRCREATEPEN) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrellipse {
    pub emr: Emr,
    pub rcl_box: Rectl,
}
impl Emrellipse {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRELLIPSE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRELLIPSE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emreof {
    pub emr: Emr,
    pub n_pal_entries: u32,
    pub off_pal_entries: u32,
    pub n_size_last: u32,
}
impl Emreof {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMREOF {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMREOF) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrexcludecliprect {
    pub emr: Emr,
    pub rcl_clip: Rectl,
}
impl Emrexcludecliprect {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMREXCLUDECLIPRECT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMREXCLUDECLIPRECT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrextcreatefontindirectw {
    pub emr: Emr,
    pub ih_font: u32,
    pub elfw: Extlogfontw,
}
impl Emrextcreatefontindirectw {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMREXTCREATEFONTINDIRECTW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMREXTCREATEFONTINDIRECTW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrextcreatepen {
    pub emr: Emr,
    pub ih_pen: u32,
    pub off_bmi: u32,
    pub cb_bmi: u32,
    pub off_bits: u32,
    pub cb_bits: u32,
    pub elp: Extlogpen32,
}
impl Emrextcreatepen {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMREXTCREATEPEN {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMREXTCREATEPEN) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrextescape {
    pub emr: Emr,
    pub i_escape: i32,
    pub cb_esc_data: i32,
    pub esc_data: [u8; 1],
}
impl Emrextescape {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMREXTESCAPE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMREXTESCAPE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrextfloodfill {
    pub emr: Emr,
    pub ptl_start: Pointl,
    pub cr_color: u32,
    pub i_mode: u32,
}
impl Emrextfloodfill {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMREXTFLOODFILL {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMREXTFLOODFILL) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrextselectcliprgn {
    pub emr: Emr,
    pub cb_rgn_data: u32,
    pub i_mode: u32,
    pub rgn_data: [u8; 1],
}
impl Emrextselectcliprgn {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMREXTSELECTCLIPRGN {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMREXTSELECTCLIPRGN) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone)]
#[repr(C)]
pub struct Emrexttextouta {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub i_graphics_mode: u32,
    pub ex_scale: f32,
    pub ey_scale: f32,
    pub emrtext: Emrtext,
}
impl Emrexttextouta {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMREXTTEXTOUTA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMREXTTEXTOUTA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrfillpath {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
}
impl Emrfillpath {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRFILLPATH {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRFILLPATH) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrfillrgn {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub cb_rgn_data: u32,
    pub ih_brush: u32,
    pub rgn_data: [u8; 1],
}
impl Emrfillrgn {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRFILLRGN {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRFILLRGN) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrformat {
    pub d_signature: u32,
    pub n_version: u32,
    pub cb_data: u32,
    pub off_data: u32,
}
impl Emrformat {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRFORMAT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRFORMAT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrframergn {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub cb_rgn_data: u32,
    pub ih_brush: u32,
    pub szl_stroke: Size,
    pub rgn_data: [u8; 1],
}
impl Emrframergn {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRFRAMERGN {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRFRAMERGN) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrgdicomment {
    pub emr: Emr,
    pub cb_data: u32,
    pub data: [u8; 1],
}
impl Emrgdicomment {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRGDICOMMENT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRGDICOMMENT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrglsboundedrecord {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub cb_data: u32,
    pub data: [u8; 1],
}
impl Emrglsboundedrecord {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRGLSBOUNDEDRECORD {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRGLSBOUNDEDRECORD) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrglsrecord {
    pub emr: Emr,
    pub cb_data: u32,
    pub data: [u8; 1],
}
impl Emrglsrecord {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRGLSRECORD {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRGLSRECORD) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrgradientfill {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub n_ver: u32,
    pub n_tri: u32,
    pub ul_mode: u32,
    pub ver: [Trivertex; 1],
}
impl Emrgradientfill {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRGRADIENTFILL {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRGRADIENTFILL) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrinvertrgn {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub cb_rgn_data: u32,
    pub rgn_data: [u8; 1],
}
impl Emrinvertrgn {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRINVERTRGN {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRINVERTRGN) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrlineto {
    pub emr: Emr,
    pub ptl: Pointl,
}
impl Emrlineto {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRLINETO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRLINETO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone)]
#[repr(C)]
pub struct Emrmaskblt {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub x_dest: i32,
    pub y_dest: i32,
    pub cx_dest: i32,
    pub cy_dest: i32,
    pub dw_rop: u32,
    pub x_src: i32,
    pub y_src: i32,
    pub xform_src: Xform,
    pub cr_bk_color_src: u32,
    pub i_usage_src: u32,
    pub off_bmi_src: u32,
    pub cb_bmi_src: u32,
    pub off_bits_src: u32,
    pub cb_bits_src: u32,
    pub x_mask: i32,
    pub y_mask: i32,
    pub i_usage_mask: u32,
    pub off_bmi_mask: u32,
    pub cb_bmi_mask: u32,
    pub off_bits_mask: u32,
    pub cb_bits_mask: u32,
}
impl Emrmaskblt {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRMASKBLT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRMASKBLT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone)]
#[repr(C)]
pub struct Emrmodifyworldtransform {
    pub emr: Emr,
    pub xform: Xform,
    pub i_mode: u32,
}
impl Emrmodifyworldtransform {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRMODIFYWORLDTRANSFORM {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRMODIFYWORLDTRANSFORM) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrnamedescape {
    pub emr: Emr,
    pub i_escape: i32,
    pub cb_driver: i32,
    pub cb_esc_data: i32,
    pub esc_data: [u8; 1],
}
impl Emrnamedescape {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRNAMEDESCAPE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRNAMEDESCAPE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emroffsetcliprgn {
    pub emr: Emr,
    pub ptl_offset: Pointl,
}
impl Emroffsetcliprgn {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMROFFSETCLIPRGN {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMROFFSETCLIPRGN) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrpixelformat {
    pub emr: Emr,
    pub pfd: Pixelformatdescriptor,
}
impl Emrpixelformat {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::OpenGL::EMRPIXELFORMAT {
        let Self { emr, pfd } = self;
        let emr = emr.to_win32();
        let pfd = pfd.to_win32();
        windows_sys::Win32::Graphics::OpenGL::EMRPIXELFORMAT { emr, pfd }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::OpenGL::EMRPIXELFORMAT) -> Self {
        let windows_sys::Win32::Graphics::OpenGL::EMRPIXELFORMAT { emr, pfd } = win32;
        let emr = unsafe { Emr::from_win32(emr) };
        let pfd = unsafe { Pixelformatdescriptor::from_win32(pfd) };
        Self { emr, pfd }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone)]
#[repr(C)]
pub struct Emrplgblt {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub aptl_dest: [Pointl; 3],
    pub x_src: i32,
    pub y_src: i32,
    pub cx_src: i32,
    pub cy_src: i32,
    pub xform_src: Xform,
    pub cr_bk_color_src: u32,
    pub i_usage_src: u32,
    pub off_bmi_src: u32,
    pub cb_bmi_src: u32,
    pub off_bits_src: u32,
    pub cb_bits_src: u32,
    pub x_mask: i32,
    pub y_mask: i32,
    pub i_usage_mask: u32,
    pub off_bmi_mask: u32,
    pub cb_bmi_mask: u32,
    pub off_bits_mask: u32,
    pub cb_bits_mask: u32,
}
impl Emrplgblt {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRPLGBLT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRPLGBLT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrpolydraw {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub cptl: u32,
    pub aptl: [Pointl; 1],
    pub ab_types: [u8; 1],
}
impl Emrpolydraw {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRPOLYDRAW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRPOLYDRAW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrpolydraw16 {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub cpts: u32,
    pub apts: [Points; 1],
    pub ab_types: [u8; 1],
}
impl Emrpolydraw16 {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRPOLYDRAW16 {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRPOLYDRAW16) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrpolyline {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub cptl: u32,
    pub aptl: [Pointl; 1],
}
impl Emrpolyline {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRPOLYLINE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRPOLYLINE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrpolyline16 {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub cpts: u32,
    pub apts: [Points; 1],
}
impl Emrpolyline16 {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRPOLYLINE16 {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRPOLYLINE16) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrpolypolyline {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub n_polys: u32,
    pub cptl: u32,
    pub a_poly_counts: [u32; 1],
    pub aptl: [Pointl; 1],
}
impl Emrpolypolyline {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRPOLYPOLYLINE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRPOLYPOLYLINE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrpolypolyline16 {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub n_polys: u32,
    pub cpts: u32,
    pub a_poly_counts: [u32; 1],
    pub apts: [Points; 1],
}
impl Emrpolypolyline16 {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRPOLYPOLYLINE16 {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRPOLYPOLYLINE16) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone)]
#[repr(C)]
pub struct Emrpolytextouta {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub i_graphics_mode: u32,
    pub ex_scale: f32,
    pub ey_scale: f32,
    pub c_strings: i32,
    pub aemrtext: [Emrtext; 1],
}
impl Emrpolytextouta {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRPOLYTEXTOUTA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRPOLYTEXTOUTA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrresizepalette {
    pub emr: Emr,
    pub ih_pal: u32,
    pub c_entries: u32,
}
impl Emrresizepalette {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRRESIZEPALETTE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRRESIZEPALETTE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrrestoredc {
    pub emr: Emr,
    pub i_relative: i32,
}
impl Emrrestoredc {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRRESTOREDC {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRRESTOREDC) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrroundrect {
    pub emr: Emr,
    pub rcl_box: Rectl,
    pub szl_corner: Size,
}
impl Emrroundrect {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRROUNDRECT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRROUNDRECT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrscaleviewportextex {
    pub emr: Emr,
    pub x_num: i32,
    pub x_denom: i32,
    pub y_num: i32,
    pub y_denom: i32,
}
impl Emrscaleviewportextex {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSCALEVIEWPORTEXTEX {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSCALEVIEWPORTEXTEX) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrselectclippath {
    pub emr: Emr,
    pub i_mode: u32,
}
impl Emrselectclippath {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSELECTCLIPPATH {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSELECTCLIPPATH) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrselectobject {
    pub emr: Emr,
    pub ih_object: u32,
}
impl Emrselectobject {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSELECTOBJECT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSELECTOBJECT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrselectpalette {
    pub emr: Emr,
    pub ih_pal: u32,
}
impl Emrselectpalette {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSELECTPALETTE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSELECTPALETTE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrsetarcdirection {
    pub emr: Emr,
    pub i_arc_direction: u32,
}
impl Emrsetarcdirection {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETARCDIRECTION {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETARCDIRECTION) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrsetcoloradjustment {
    pub emr: Emr,
    pub color_adjustment: Coloradjustment,
}
impl Emrsetcoloradjustment {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETCOLORADJUSTMENT {
        let Self { emr, color_adjustment } = self;
        let emr = emr.to_win32();
        let ColorAdjustment = color_adjustment.to_win32();
        windows_sys::Win32::Graphics::Gdi::EMRSETCOLORADJUSTMENT { emr, ColorAdjustment }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETCOLORADJUSTMENT) -> Self {
        let windows_sys::Win32::Graphics::Gdi::EMRSETCOLORADJUSTMENT { emr, ColorAdjustment } = win32;
        let emr = unsafe { Emr::from_win32(emr) };
        let color_adjustment = unsafe { Coloradjustment::from_win32(ColorAdjustment) };
        Self { emr, color_adjustment }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrsetcolorspace {
    pub emr: Emr,
    pub ih_cs: u32,
}
impl Emrsetcolorspace {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETCOLORSPACE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETCOLORSPACE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrsetdibitstodevice {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub x_dest: i32,
    pub y_dest: i32,
    pub x_src: i32,
    pub y_src: i32,
    pub cx_src: i32,
    pub cy_src: i32,
    pub off_bmi_src: u32,
    pub cb_bmi_src: u32,
    pub off_bits_src: u32,
    pub cb_bits_src: u32,
    pub i_usage_src: u32,
    pub i_start_scan: u32,
    pub c_scans: u32,
}
impl Emrsetdibitstodevice {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETDIBITSTODEVICE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETDIBITSTODEVICE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrseticmprofile {
    pub emr: Emr,
    pub dw_flags: u32,
    pub cb_name: u32,
    pub cb_data: u32,
    pub data: [u8; 1],
}
impl Emrseticmprofile {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETICMPROFILE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETICMPROFILE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrsetmapperflags {
    pub emr: Emr,
    pub dw_flags: u32,
}
impl Emrsetmapperflags {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETMAPPERFLAGS {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETMAPPERFLAGS) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone)]
#[repr(C)]
pub struct Emrsetmiterlimit {
    pub emr: Emr,
    pub e_miter_limit: f32,
}
impl Emrsetmiterlimit {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETMITERLIMIT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETMITERLIMIT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrsetpaletteentries {
    pub emr: Emr,
    pub ih_pal: u32,
    pub i_start: u32,
    pub c_entries: u32,
    pub a_pal_entries: [Paletteentry; 1],
}
impl Emrsetpaletteentries {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETPALETTEENTRIES {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETPALETTEENTRIES) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrsetpixelv {
    pub emr: Emr,
    pub ptl_pixel: Pointl,
    pub cr_color: u32,
}
impl Emrsetpixelv {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETPIXELV {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETPIXELV) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrsettextcolor {
    pub emr: Emr,
    pub cr_color: u32,
}
impl Emrsettextcolor {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETTEXTCOLOR {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETTEXTCOLOR) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrsetviewportextex {
    pub emr: Emr,
    pub szl_extent: Size,
}
impl Emrsetviewportextex {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETVIEWPORTEXTEX {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETVIEWPORTEXTEX) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrsetviewportorgex {
    pub emr: Emr,
    pub ptl_origin: Pointl,
}
impl Emrsetviewportorgex {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETVIEWPORTORGEX {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETVIEWPORTORGEX) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone)]
#[repr(C)]
pub struct Emrsetworldtransform {
    pub emr: Emr,
    pub xform: Xform,
}
impl Emrsetworldtransform {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSETWORLDTRANSFORM {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSETWORLDTRANSFORM) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone)]
#[repr(C)]
pub struct Emrstretchblt {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub x_dest: i32,
    pub y_dest: i32,
    pub cx_dest: i32,
    pub cy_dest: i32,
    pub dw_rop: u32,
    pub x_src: i32,
    pub y_src: i32,
    pub xform_src: Xform,
    pub cr_bk_color_src: u32,
    pub i_usage_src: u32,
    pub off_bmi_src: u32,
    pub cb_bmi_src: u32,
    pub off_bits_src: u32,
    pub cb_bits_src: u32,
    pub cx_src: i32,
    pub cy_src: i32,
}
impl Emrstretchblt {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSTRETCHBLT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSTRETCHBLT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrstretchdibits {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub x_dest: i32,
    pub y_dest: i32,
    pub x_src: i32,
    pub y_src: i32,
    pub cx_src: i32,
    pub cy_src: i32,
    pub off_bmi_src: u32,
    pub cb_bmi_src: u32,
    pub off_bits_src: u32,
    pub cb_bits_src: u32,
    pub i_usage_src: u32,
    pub dw_rop: u32,
    pub cx_dest: i32,
    pub cy_dest: i32,
}
impl Emrstretchdibits {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRSTRETCHDIBITS {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRSTRETCHDIBITS) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Emrtext {
    pub ptl_reference: Pointl,
    pub n_chars: u32,
    pub off_string: u32,
    pub f_options: u32,
    pub rcl: Rectl,
    pub off_dx: u32,
}
impl Emrtext {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRTEXT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRTEXT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone)]
#[repr(C)]
pub struct Emrtransparentblt {
    pub emr: Emr,
    pub rcl_bounds: Rectl,
    pub x_dest: i32,
    pub y_dest: i32,
    pub cx_dest: i32,
    pub cy_dest: i32,
    pub dw_rop: u32,
    pub x_src: i32,
    pub y_src: i32,
    pub xform_src: Xform,
    pub cr_bk_color_src: u32,
    pub i_usage_src: u32,
    pub off_bmi_src: u32,
    pub cb_bmi_src: u32,
    pub off_bits_src: u32,
    pub cb_bits_src: u32,
    pub cx_src: i32,
    pub cy_src: i32,
}
impl Emrtransparentblt {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EMRTRANSPARENTBLT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EMRTRANSPARENTBLT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Enhmetaheader {
    pub i_type: u32,
    pub n_size: u32,
    pub rcl_bounds: Rectl,
    pub rcl_frame: Rectl,
    pub d_signature: u32,
    pub n_version: u32,
    pub n_bytes: u32,
    pub n_records: u32,
    pub n_handles: u16,
    pub s_reserved: u16,
    pub n_description: u32,
    pub off_description: u32,
    pub n_pal_entries: u32,
    pub szl_device: Size,
    pub szl_millimeters: Size,
    pub cb_pixel_format: u32,
    pub off_pixel_format: u32,
    pub b_open_gl: u32,
    pub szl_micrometers: Size,
}
impl Enhmetaheader {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::ENHMETAHEADER {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::ENHMETAHEADER) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Enhmetarecord {
    pub i_type: u32,
    pub n_size: u32,
    pub d_parm: [u32; 1],
}
impl Enhmetarecord {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::ENHMETARECORD {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::ENHMETARECORD) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Enumlogfonta {
    pub elf_log_font: Logfonta,
    pub elf_full_name: [u8; 64],
    pub elf_style: [u8; 32],
}
impl Enumlogfonta {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::ENUMLOGFONTA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::ENUMLOGFONTA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Enumlogfontexa {
    pub elf_log_font: Logfonta,
    pub elf_full_name: [u8; 64],
    pub elf_style: [u8; 32],
    pub elf_script: [u8; 32],
}
impl Enumlogfontexa {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::ENUMLOGFONTEXA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::ENUMLOGFONTEXA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Enumlogfontexdva {
    pub elf_enum_logfont_ex: Enumlogfontexa,
    pub elf_design_vector: Designvector,
}
impl Enumlogfontexdva {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::ENUMLOGFONTEXDVA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::ENUMLOGFONTEXDVA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Enumlogfontexdvw {
    pub elf_enum_logfont_ex: Enumlogfontexw,
    pub elf_design_vector: Designvector,
}
impl Enumlogfontexdvw {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::ENUMLOGFONTEXDVW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::ENUMLOGFONTEXDVW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Enumlogfontexw {
    pub elf_log_font: Logfontw,
    pub elf_full_name: [u16; 64],
    pub elf_style: [u16; 32],
    pub elf_script: [u16; 32],
}
impl Enumlogfontexw {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::ENUMLOGFONTEXW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::ENUMLOGFONTEXW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Enumlogfontw {
    pub elf_log_font: Logfontw,
    pub elf_full_name: [u16; 64],
    pub elf_style: [u16; 32],
}
impl Enumlogfontw {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::ENUMLOGFONTW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::ENUMLOGFONTW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Eventmsg {
    pub message: u32,
    pub param_l: u32,
    pub param_h: u32,
    pub time: u32,
    pub hwnd: Option<Hwnd>,
}
impl Eventmsg {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::EVENTMSG {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::EVENTMSG) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct ExpDarwinLink {
    pub dbh: DatablockHeader,
    pub sz_darwin_id: [CHAR; 260],
    pub szw_darwin_id: [u16; 260],
}
impl ExpDarwinLink {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::EXP_DARWIN_LINK {
        let Self { dbh, sz_darwin_id, szw_darwin_id } = self;
        let dbh = dbh.to_win32();
        let szDarwinID = [*&sz_darwin_id[0],*&sz_darwin_id[1],*&sz_darwin_id[2],*&sz_darwin_id[3],*&sz_darwin_id[4],*&sz_darwin_id[5],*&sz_darwin_id[6],*&sz_darwin_id[7],*&sz_darwin_id[8],*&sz_darwin_id[9],*&sz_darwin_id[10],*&sz_darwin_id[11],*&sz_darwin_id[12],*&sz_darwin_id[13],*&sz_darwin_id[14],*&sz_darwin_id[15],*&sz_darwin_id[16],*&sz_darwin_id[17],*&sz_darwin_id[18],*&sz_darwin_id[19],*&sz_darwin_id[20],*&sz_darwin_id[21],*&sz_darwin_id[22],*&sz_darwin_id[23],*&sz_darwin_id[24],*&sz_darwin_id[25],*&sz_darwin_id[26],*&sz_darwin_id[27],*&sz_darwin_id[28],*&sz_darwin_id[29],*&sz_darwin_id[30],*&sz_darwin_id[31],*&sz_darwin_id[32],*&sz_darwin_id[33],*&sz_darwin_id[34],*&sz_darwin_id[35],*&sz_darwin_id[36],*&sz_darwin_id[37],*&sz_darwin_id[38],*&sz_darwin_id[39],*&sz_darwin_id[40],*&sz_darwin_id[41],*&sz_darwin_id[42],*&sz_darwin_id[43],*&sz_darwin_id[44],*&sz_darwin_id[45],*&sz_darwin_id[46],*&sz_darwin_id[47],*&sz_darwin_id[48],*&sz_darwin_id[49],*&sz_darwin_id[50],*&sz_darwin_id[51],*&sz_darwin_id[52],*&sz_darwin_id[53],*&sz_darwin_id[54],*&sz_darwin_id[55],*&sz_darwin_id[56],*&sz_darwin_id[57],*&sz_darwin_id[58],*&sz_darwin_id[59],*&sz_darwin_id[60],*&sz_darwin_id[61],*&sz_darwin_id[62],*&sz_darwin_id[63],*&sz_darwin_id[64],*&sz_darwin_id[65],*&sz_darwin_id[66],*&sz_darwin_id[67],*&sz_darwin_id[68],*&sz_darwin_id[69],*&sz_darwin_id[70],*&sz_darwin_id[71],*&sz_darwin_id[72],*&sz_darwin_id[73],*&sz_darwin_id[74],*&sz_darwin_id[75],*&sz_darwin_id[76],*&sz_darwin_id[77],*&sz_darwin_id[78],*&sz_darwin_id[79],*&sz_darwin_id[80],*&sz_darwin_id[81],*&sz_darwin_id[82],*&sz_darwin_id[83],*&sz_darwin_id[84],*&sz_darwin_id[85],*&sz_darwin_id[86],*&sz_darwin_id[87],*&sz_darwin_id[88],*&sz_darwin_id[89],*&sz_darwin_id[90],*&sz_darwin_id[91],*&sz_darwin_id[92],*&sz_darwin_id[93],*&sz_darwin_id[94],*&sz_darwin_id[95],*&sz_darwin_id[96],*&sz_darwin_id[97],*&sz_darwin_id[98],*&sz_darwin_id[99],*&sz_darwin_id[100],*&sz_darwin_id[101],*&sz_darwin_id[102],*&sz_darwin_id[103],*&sz_darwin_id[104],*&sz_darwin_id[105],*&sz_darwin_id[106],*&sz_darwin_id[107],*&sz_darwin_id[108],*&sz_darwin_id[109],*&sz_darwin_id[110],*&sz_darwin_id[111],*&sz_darwin_id[112],*&sz_darwin_id[113],*&sz_darwin_id[114],*&sz_darwin_id[115],*&sz_darwin_id[116],*&sz_darwin_id[117],*&sz_darwin_id[118],*&sz_darwin_id[119],*&sz_darwin_id[120],*&sz_darwin_id[121],*&sz_darwin_id[122],*&sz_darwin_id[123],*&sz_darwin_id[124],*&sz_darwin_id[125],*&sz_darwin_id[126],*&sz_darwin_id[127],*&sz_darwin_id[128],*&sz_darwin_id[129],*&sz_darwin_id[130],*&sz_darwin_id[131],*&sz_darwin_id[132],*&sz_darwin_id[133],*&sz_darwin_id[134],*&sz_darwin_id[135],*&sz_darwin_id[136],*&sz_darwin_id[137],*&sz_darwin_id[138],*&sz_darwin_id[139],*&sz_darwin_id[140],*&sz_darwin_id[141],*&sz_darwin_id[142],*&sz_darwin_id[143],*&sz_darwin_id[144],*&sz_darwin_id[145],*&sz_darwin_id[146],*&sz_darwin_id[147],*&sz_darwin_id[148],*&sz_darwin_id[149],*&sz_darwin_id[150],*&sz_darwin_id[151],*&sz_darwin_id[152],*&sz_darwin_id[153],*&sz_darwin_id[154],*&sz_darwin_id[155],*&sz_darwin_id[156],*&sz_darwin_id[157],*&sz_darwin_id[158],*&sz_darwin_id[159],*&sz_darwin_id[160],*&sz_darwin_id[161],*&sz_darwin_id[162],*&sz_darwin_id[163],*&sz_darwin_id[164],*&sz_darwin_id[165],*&sz_darwin_id[166],*&sz_darwin_id[167],*&sz_darwin_id[168],*&sz_darwin_id[169],*&sz_darwin_id[170],*&sz_darwin_id[171],*&sz_darwin_id[172],*&sz_darwin_id[173],*&sz_darwin_id[174],*&sz_darwin_id[175],*&sz_darwin_id[176],*&sz_darwin_id[177],*&sz_darwin_id[178],*&sz_darwin_id[179],*&sz_darwin_id[180],*&sz_darwin_id[181],*&sz_darwin_id[182],*&sz_darwin_id[183],*&sz_darwin_id[184],*&sz_darwin_id[185],*&sz_darwin_id[186],*&sz_darwin_id[187],*&sz_darwin_id[188],*&sz_darwin_id[189],*&sz_darwin_id[190],*&sz_darwin_id[191],*&sz_darwin_id[192],*&sz_darwin_id[193],*&sz_darwin_id[194],*&sz_darwin_id[195],*&sz_darwin_id[196],*&sz_darwin_id[197],*&sz_darwin_id[198],*&sz_darwin_id[199],*&sz_darwin_id[200],*&sz_darwin_id[201],*&sz_darwin_id[202],*&sz_darwin_id[203],*&sz_darwin_id[204],*&sz_darwin_id[205],*&sz_darwin_id[206],*&sz_darwin_id[207],*&sz_darwin_id[208],*&sz_darwin_id[209],*&sz_darwin_id[210],*&sz_darwin_id[211],*&sz_darwin_id[212],*&sz_darwin_id[213],*&sz_darwin_id[214],*&sz_darwin_id[215],*&sz_darwin_id[216],*&sz_darwin_id[217],*&sz_darwin_id[218],*&sz_darwin_id[219],*&sz_darwin_id[220],*&sz_darwin_id[221],*&sz_darwin_id[222],*&sz_darwin_id[223],*&sz_darwin_id[224],*&sz_darwin_id[225],*&sz_darwin_id[226],*&sz_darwin_id[227],*&sz_darwin_id[228],*&sz_darwin_id[229],*&sz_darwin_id[230],*&sz_darwin_id[231],*&sz_darwin_id[232],*&sz_darwin_id[233],*&sz_darwin_id[234],*&sz_darwin_id[235],*&sz_darwin_id[236],*&sz_darwin_id[237],*&sz_darwin_id[238],*&sz_darwin_id[239],*&sz_darwin_id[240],*&sz_darwin_id[241],*&sz_darwin_id[242],*&sz_darwin_id[243],*&sz_darwin_id[244],*&sz_darwin_id[245],*&sz_darwin_id[246],*&sz_darwin_id[247],*&sz_darwin_id[248],*&sz_darwin_id[249],*&sz_darwin_id[250],*&sz_darwin_id[251],*&sz_darwin_id[252],*&sz_darwin_id[253],*&sz_darwin_id[254],*&sz_darwin_id[255],*&sz_darwin_id[256],*&sz_darwin_id[257],*&sz_darwin_id[258],*&sz_darwin_id[259]];
        let szwDarwinID = [*&szw_darwin_id[0],*&szw_darwin_id[1],*&szw_darwin_id[2],*&szw_darwin_id[3],*&szw_darwin_id[4],*&szw_darwin_id[5],*&szw_darwin_id[6],*&szw_darwin_id[7],*&szw_darwin_id[8],*&szw_darwin_id[9],*&szw_darwin_id[10],*&szw_darwin_id[11],*&szw_darwin_id[12],*&szw_darwin_id[13],*&szw_darwin_id[14],*&szw_darwin_id[15],*&szw_darwin_id[16],*&szw_darwin_id[17],*&szw_darwin_id[18],*&szw_darwin_id[19],*&szw_darwin_id[20],*&szw_darwin_id[21],*&szw_darwin_id[22],*&szw_darwin_id[23],*&szw_darwin_id[24],*&szw_darwin_id[25],*&szw_darwin_id[26],*&szw_darwin_id[27],*&szw_darwin_id[28],*&szw_darwin_id[29],*&szw_darwin_id[30],*&szw_darwin_id[31],*&szw_darwin_id[32],*&szw_darwin_id[33],*&szw_darwin_id[34],*&szw_darwin_id[35],*&szw_darwin_id[36],*&szw_darwin_id[37],*&szw_darwin_id[38],*&szw_darwin_id[39],*&szw_darwin_id[40],*&szw_darwin_id[41],*&szw_darwin_id[42],*&szw_darwin_id[43],*&szw_darwin_id[44],*&szw_darwin_id[45],*&szw_darwin_id[46],*&szw_darwin_id[47],*&szw_darwin_id[48],*&szw_darwin_id[49],*&szw_darwin_id[50],*&szw_darwin_id[51],*&szw_darwin_id[52],*&szw_darwin_id[53],*&szw_darwin_id[54],*&szw_darwin_id[55],*&szw_darwin_id[56],*&szw_darwin_id[57],*&szw_darwin_id[58],*&szw_darwin_id[59],*&szw_darwin_id[60],*&szw_darwin_id[61],*&szw_darwin_id[62],*&szw_darwin_id[63],*&szw_darwin_id[64],*&szw_darwin_id[65],*&szw_darwin_id[66],*&szw_darwin_id[67],*&szw_darwin_id[68],*&szw_darwin_id[69],*&szw_darwin_id[70],*&szw_darwin_id[71],*&szw_darwin_id[72],*&szw_darwin_id[73],*&szw_darwin_id[74],*&szw_darwin_id[75],*&szw_darwin_id[76],*&szw_darwin_id[77],*&szw_darwin_id[78],*&szw_darwin_id[79],*&szw_darwin_id[80],*&szw_darwin_id[81],*&szw_darwin_id[82],*&szw_darwin_id[83],*&szw_darwin_id[84],*&szw_darwin_id[85],*&szw_darwin_id[86],*&szw_darwin_id[87],*&szw_darwin_id[88],*&szw_darwin_id[89],*&szw_darwin_id[90],*&szw_darwin_id[91],*&szw_darwin_id[92],*&szw_darwin_id[93],*&szw_darwin_id[94],*&szw_darwin_id[95],*&szw_darwin_id[96],*&szw_darwin_id[97],*&szw_darwin_id[98],*&szw_darwin_id[99],*&szw_darwin_id[100],*&szw_darwin_id[101],*&szw_darwin_id[102],*&szw_darwin_id[103],*&szw_darwin_id[104],*&szw_darwin_id[105],*&szw_darwin_id[106],*&szw_darwin_id[107],*&szw_darwin_id[108],*&szw_darwin_id[109],*&szw_darwin_id[110],*&szw_darwin_id[111],*&szw_darwin_id[112],*&szw_darwin_id[113],*&szw_darwin_id[114],*&szw_darwin_id[115],*&szw_darwin_id[116],*&szw_darwin_id[117],*&szw_darwin_id[118],*&szw_darwin_id[119],*&szw_darwin_id[120],*&szw_darwin_id[121],*&szw_darwin_id[122],*&szw_darwin_id[123],*&szw_darwin_id[124],*&szw_darwin_id[125],*&szw_darwin_id[126],*&szw_darwin_id[127],*&szw_darwin_id[128],*&szw_darwin_id[129],*&szw_darwin_id[130],*&szw_darwin_id[131],*&szw_darwin_id[132],*&szw_darwin_id[133],*&szw_darwin_id[134],*&szw_darwin_id[135],*&szw_darwin_id[136],*&szw_darwin_id[137],*&szw_darwin_id[138],*&szw_darwin_id[139],*&szw_darwin_id[140],*&szw_darwin_id[141],*&szw_darwin_id[142],*&szw_darwin_id[143],*&szw_darwin_id[144],*&szw_darwin_id[145],*&szw_darwin_id[146],*&szw_darwin_id[147],*&szw_darwin_id[148],*&szw_darwin_id[149],*&szw_darwin_id[150],*&szw_darwin_id[151],*&szw_darwin_id[152],*&szw_darwin_id[153],*&szw_darwin_id[154],*&szw_darwin_id[155],*&szw_darwin_id[156],*&szw_darwin_id[157],*&szw_darwin_id[158],*&szw_darwin_id[159],*&szw_darwin_id[160],*&szw_darwin_id[161],*&szw_darwin_id[162],*&szw_darwin_id[163],*&szw_darwin_id[164],*&szw_darwin_id[165],*&szw_darwin_id[166],*&szw_darwin_id[167],*&szw_darwin_id[168],*&szw_darwin_id[169],*&szw_darwin_id[170],*&szw_darwin_id[171],*&szw_darwin_id[172],*&szw_darwin_id[173],*&szw_darwin_id[174],*&szw_darwin_id[175],*&szw_darwin_id[176],*&szw_darwin_id[177],*&szw_darwin_id[178],*&szw_darwin_id[179],*&szw_darwin_id[180],*&szw_darwin_id[181],*&szw_darwin_id[182],*&szw_darwin_id[183],*&szw_darwin_id[184],*&szw_darwin_id[185],*&szw_darwin_id[186],*&szw_darwin_id[187],*&szw_darwin_id[188],*&szw_darwin_id[189],*&szw_darwin_id[190],*&szw_darwin_id[191],*&szw_darwin_id[192],*&szw_darwin_id[193],*&szw_darwin_id[194],*&szw_darwin_id[195],*&szw_darwin_id[196],*&szw_darwin_id[197],*&szw_darwin_id[198],*&szw_darwin_id[199],*&szw_darwin_id[200],*&szw_darwin_id[201],*&szw_darwin_id[202],*&szw_darwin_id[203],*&szw_darwin_id[204],*&szw_darwin_id[205],*&szw_darwin_id[206],*&szw_darwin_id[207],*&szw_darwin_id[208],*&szw_darwin_id[209],*&szw_darwin_id[210],*&szw_darwin_id[211],*&szw_darwin_id[212],*&szw_darwin_id[213],*&szw_darwin_id[214],*&szw_darwin_id[215],*&szw_darwin_id[216],*&szw_darwin_id[217],*&szw_darwin_id[218],*&szw_darwin_id[219],*&szw_darwin_id[220],*&szw_darwin_id[221],*&szw_darwin_id[222],*&szw_darwin_id[223],*&szw_darwin_id[224],*&szw_darwin_id[225],*&szw_darwin_id[226],*&szw_darwin_id[227],*&szw_darwin_id[228],*&szw_darwin_id[229],*&szw_darwin_id[230],*&szw_darwin_id[231],*&szw_darwin_id[232],*&szw_darwin_id[233],*&szw_darwin_id[234],*&szw_darwin_id[235],*&szw_darwin_id[236],*&szw_darwin_id[237],*&szw_darwin_id[238],*&szw_darwin_id[239],*&szw_darwin_id[240],*&szw_darwin_id[241],*&szw_darwin_id[242],*&szw_darwin_id[243],*&szw_darwin_id[244],*&szw_darwin_id[245],*&szw_darwin_id[246],*&szw_darwin_id[247],*&szw_darwin_id[248],*&szw_darwin_id[249],*&szw_darwin_id[250],*&szw_darwin_id[251],*&szw_darwin_id[252],*&szw_darwin_id[253],*&szw_darwin_id[254],*&szw_darwin_id[255],*&szw_darwin_id[256],*&szw_darwin_id[257],*&szw_darwin_id[258],*&szw_darwin_id[259]];
        windows_sys::Win32::UI::Shell::EXP_DARWIN_LINK { dbh, szDarwinID, szwDarwinID }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::EXP_DARWIN_LINK) -> Self {
        let windows_sys::Win32::UI::Shell::EXP_DARWIN_LINK { dbh, szDarwinID, szwDarwinID } = win32;
        let dbh = unsafe { DatablockHeader::from_win32(dbh) };
        let sz_darwin_id = [szDarwinID[0],szDarwinID[1],szDarwinID[2],szDarwinID[3],szDarwinID[4],szDarwinID[5],szDarwinID[6],szDarwinID[7],szDarwinID[8],szDarwinID[9],szDarwinID[10],szDarwinID[11],szDarwinID[12],szDarwinID[13],szDarwinID[14],szDarwinID[15],szDarwinID[16],szDarwinID[17],szDarwinID[18],szDarwinID[19],szDarwinID[20],szDarwinID[21],szDarwinID[22],szDarwinID[23],szDarwinID[24],szDarwinID[25],szDarwinID[26],szDarwinID[27],szDarwinID[28],szDarwinID[29],szDarwinID[30],szDarwinID[31],szDarwinID[32],szDarwinID[33],szDarwinID[34],szDarwinID[35],szDarwinID[36],szDarwinID[37],szDarwinID[38],szDarwinID[39],szDarwinID[40],szDarwinID[41],szDarwinID[42],szDarwinID[43],szDarwinID[44],szDarwinID[45],szDarwinID[46],szDarwinID[47],szDarwinID[48],szDarwinID[49],szDarwinID[50],szDarwinID[51],szDarwinID[52],szDarwinID[53],szDarwinID[54],szDarwinID[55],szDarwinID[56],szDarwinID[57],szDarwinID[58],szDarwinID[59],szDarwinID[60],szDarwinID[61],szDarwinID[62],szDarwinID[63],szDarwinID[64],szDarwinID[65],szDarwinID[66],szDarwinID[67],szDarwinID[68],szDarwinID[69],szDarwinID[70],szDarwinID[71],szDarwinID[72],szDarwinID[73],szDarwinID[74],szDarwinID[75],szDarwinID[76],szDarwinID[77],szDarwinID[78],szDarwinID[79],szDarwinID[80],szDarwinID[81],szDarwinID[82],szDarwinID[83],szDarwinID[84],szDarwinID[85],szDarwinID[86],szDarwinID[87],szDarwinID[88],szDarwinID[89],szDarwinID[90],szDarwinID[91],szDarwinID[92],szDarwinID[93],szDarwinID[94],szDarwinID[95],szDarwinID[96],szDarwinID[97],szDarwinID[98],szDarwinID[99],szDarwinID[100],szDarwinID[101],szDarwinID[102],szDarwinID[103],szDarwinID[104],szDarwinID[105],szDarwinID[106],szDarwinID[107],szDarwinID[108],szDarwinID[109],szDarwinID[110],szDarwinID[111],szDarwinID[112],szDarwinID[113],szDarwinID[114],szDarwinID[115],szDarwinID[116],szDarwinID[117],szDarwinID[118],szDarwinID[119],szDarwinID[120],szDarwinID[121],szDarwinID[122],szDarwinID[123],szDarwinID[124],szDarwinID[125],szDarwinID[126],szDarwinID[127],szDarwinID[128],szDarwinID[129],szDarwinID[130],szDarwinID[131],szDarwinID[132],szDarwinID[133],szDarwinID[134],szDarwinID[135],szDarwinID[136],szDarwinID[137],szDarwinID[138],szDarwinID[139],szDarwinID[140],szDarwinID[141],szDarwinID[142],szDarwinID[143],szDarwinID[144],szDarwinID[145],szDarwinID[146],szDarwinID[147],szDarwinID[148],szDarwinID[149],szDarwinID[150],szDarwinID[151],szDarwinID[152],szDarwinID[153],szDarwinID[154],szDarwinID[155],szDarwinID[156],szDarwinID[157],szDarwinID[158],szDarwinID[159],szDarwinID[160],szDarwinID[161],szDarwinID[162],szDarwinID[163],szDarwinID[164],szDarwinID[165],szDarwinID[166],szDarwinID[167],szDarwinID[168],szDarwinID[169],szDarwinID[170],szDarwinID[171],szDarwinID[172],szDarwinID[173],szDarwinID[174],szDarwinID[175],szDarwinID[176],szDarwinID[177],szDarwinID[178],szDarwinID[179],szDarwinID[180],szDarwinID[181],szDarwinID[182],szDarwinID[183],szDarwinID[184],szDarwinID[185],szDarwinID[186],szDarwinID[187],szDarwinID[188],szDarwinID[189],szDarwinID[190],szDarwinID[191],szDarwinID[192],szDarwinID[193],szDarwinID[194],szDarwinID[195],szDarwinID[196],szDarwinID[197],szDarwinID[198],szDarwinID[199],szDarwinID[200],szDarwinID[201],szDarwinID[202],szDarwinID[203],szDarwinID[204],szDarwinID[205],szDarwinID[206],szDarwinID[207],szDarwinID[208],szDarwinID[209],szDarwinID[210],szDarwinID[211],szDarwinID[212],szDarwinID[213],szDarwinID[214],szDarwinID[215],szDarwinID[216],szDarwinID[217],szDarwinID[218],szDarwinID[219],szDarwinID[220],szDarwinID[221],szDarwinID[222],szDarwinID[223],szDarwinID[224],szDarwinID[225],szDarwinID[226],szDarwinID[227],szDarwinID[228],szDarwinID[229],szDarwinID[230],szDarwinID[231],szDarwinID[232],szDarwinID[233],szDarwinID[234],szDarwinID[235],szDarwinID[236],szDarwinID[237],szDarwinID[238],szDarwinID[239],szDarwinID[240],szDarwinID[241],szDarwinID[242],szDarwinID[243],szDarwinID[244],szDarwinID[245],szDarwinID[246],szDarwinID[247],szDarwinID[248],szDarwinID[249],szDarwinID[250],szDarwinID[251],szDarwinID[252],szDarwinID[253],szDarwinID[254],szDarwinID[255],szDarwinID[256],szDarwinID[257],szDarwinID[258],szDarwinID[259]];
        let szw_darwin_id = [szwDarwinID[0],szwDarwinID[1],szwDarwinID[2],szwDarwinID[3],szwDarwinID[4],szwDarwinID[5],szwDarwinID[6],szwDarwinID[7],szwDarwinID[8],szwDarwinID[9],szwDarwinID[10],szwDarwinID[11],szwDarwinID[12],szwDarwinID[13],szwDarwinID[14],szwDarwinID[15],szwDarwinID[16],szwDarwinID[17],szwDarwinID[18],szwDarwinID[19],szwDarwinID[20],szwDarwinID[21],szwDarwinID[22],szwDarwinID[23],szwDarwinID[24],szwDarwinID[25],szwDarwinID[26],szwDarwinID[27],szwDarwinID[28],szwDarwinID[29],szwDarwinID[30],szwDarwinID[31],szwDarwinID[32],szwDarwinID[33],szwDarwinID[34],szwDarwinID[35],szwDarwinID[36],szwDarwinID[37],szwDarwinID[38],szwDarwinID[39],szwDarwinID[40],szwDarwinID[41],szwDarwinID[42],szwDarwinID[43],szwDarwinID[44],szwDarwinID[45],szwDarwinID[46],szwDarwinID[47],szwDarwinID[48],szwDarwinID[49],szwDarwinID[50],szwDarwinID[51],szwDarwinID[52],szwDarwinID[53],szwDarwinID[54],szwDarwinID[55],szwDarwinID[56],szwDarwinID[57],szwDarwinID[58],szwDarwinID[59],szwDarwinID[60],szwDarwinID[61],szwDarwinID[62],szwDarwinID[63],szwDarwinID[64],szwDarwinID[65],szwDarwinID[66],szwDarwinID[67],szwDarwinID[68],szwDarwinID[69],szwDarwinID[70],szwDarwinID[71],szwDarwinID[72],szwDarwinID[73],szwDarwinID[74],szwDarwinID[75],szwDarwinID[76],szwDarwinID[77],szwDarwinID[78],szwDarwinID[79],szwDarwinID[80],szwDarwinID[81],szwDarwinID[82],szwDarwinID[83],szwDarwinID[84],szwDarwinID[85],szwDarwinID[86],szwDarwinID[87],szwDarwinID[88],szwDarwinID[89],szwDarwinID[90],szwDarwinID[91],szwDarwinID[92],szwDarwinID[93],szwDarwinID[94],szwDarwinID[95],szwDarwinID[96],szwDarwinID[97],szwDarwinID[98],szwDarwinID[99],szwDarwinID[100],szwDarwinID[101],szwDarwinID[102],szwDarwinID[103],szwDarwinID[104],szwDarwinID[105],szwDarwinID[106],szwDarwinID[107],szwDarwinID[108],szwDarwinID[109],szwDarwinID[110],szwDarwinID[111],szwDarwinID[112],szwDarwinID[113],szwDarwinID[114],szwDarwinID[115],szwDarwinID[116],szwDarwinID[117],szwDarwinID[118],szwDarwinID[119],szwDarwinID[120],szwDarwinID[121],szwDarwinID[122],szwDarwinID[123],szwDarwinID[124],szwDarwinID[125],szwDarwinID[126],szwDarwinID[127],szwDarwinID[128],szwDarwinID[129],szwDarwinID[130],szwDarwinID[131],szwDarwinID[132],szwDarwinID[133],szwDarwinID[134],szwDarwinID[135],szwDarwinID[136],szwDarwinID[137],szwDarwinID[138],szwDarwinID[139],szwDarwinID[140],szwDarwinID[141],szwDarwinID[142],szwDarwinID[143],szwDarwinID[144],szwDarwinID[145],szwDarwinID[146],szwDarwinID[147],szwDarwinID[148],szwDarwinID[149],szwDarwinID[150],szwDarwinID[151],szwDarwinID[152],szwDarwinID[153],szwDarwinID[154],szwDarwinID[155],szwDarwinID[156],szwDarwinID[157],szwDarwinID[158],szwDarwinID[159],szwDarwinID[160],szwDarwinID[161],szwDarwinID[162],szwDarwinID[163],szwDarwinID[164],szwDarwinID[165],szwDarwinID[166],szwDarwinID[167],szwDarwinID[168],szwDarwinID[169],szwDarwinID[170],szwDarwinID[171],szwDarwinID[172],szwDarwinID[173],szwDarwinID[174],szwDarwinID[175],szwDarwinID[176],szwDarwinID[177],szwDarwinID[178],szwDarwinID[179],szwDarwinID[180],szwDarwinID[181],szwDarwinID[182],szwDarwinID[183],szwDarwinID[184],szwDarwinID[185],szwDarwinID[186],szwDarwinID[187],szwDarwinID[188],szwDarwinID[189],szwDarwinID[190],szwDarwinID[191],szwDarwinID[192],szwDarwinID[193],szwDarwinID[194],szwDarwinID[195],szwDarwinID[196],szwDarwinID[197],szwDarwinID[198],szwDarwinID[199],szwDarwinID[200],szwDarwinID[201],szwDarwinID[202],szwDarwinID[203],szwDarwinID[204],szwDarwinID[205],szwDarwinID[206],szwDarwinID[207],szwDarwinID[208],szwDarwinID[209],szwDarwinID[210],szwDarwinID[211],szwDarwinID[212],szwDarwinID[213],szwDarwinID[214],szwDarwinID[215],szwDarwinID[216],szwDarwinID[217],szwDarwinID[218],szwDarwinID[219],szwDarwinID[220],szwDarwinID[221],szwDarwinID[222],szwDarwinID[223],szwDarwinID[224],szwDarwinID[225],szwDarwinID[226],szwDarwinID[227],szwDarwinID[228],szwDarwinID[229],szwDarwinID[230],szwDarwinID[231],szwDarwinID[232],szwDarwinID[233],szwDarwinID[234],szwDarwinID[235],szwDarwinID[236],szwDarwinID[237],szwDarwinID[238],szwDarwinID[239],szwDarwinID[240],szwDarwinID[241],szwDarwinID[242],szwDarwinID[243],szwDarwinID[244],szwDarwinID[245],szwDarwinID[246],szwDarwinID[247],szwDarwinID[248],szwDarwinID[249],szwDarwinID[250],szwDarwinID[251],szwDarwinID[252],szwDarwinID[253],szwDarwinID[254],szwDarwinID[255],szwDarwinID[256],szwDarwinID[257],szwDarwinID[258],szwDarwinID[259]];
        Self { dbh, sz_darwin_id, szw_darwin_id }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct ExpPropertystorage {
    pub cb_size: u32,
    pub dw_signature: u32,
    pub ab_property_storage: [u8; 1],
}
impl ExpPropertystorage {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::EXP_PROPERTYSTORAGE {
        let Self { cb_size, dw_signature, ab_property_storage } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::EXP_PROPERTYSTORAGE>() as _;
        let dwSignature = *dw_signature;
        let abPropertyStorage = [*&ab_property_storage[0]];
        windows_sys::Win32::UI::Shell::EXP_PROPERTYSTORAGE { cbSize, dwSignature, abPropertyStorage }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::EXP_PROPERTYSTORAGE) -> Self {
        let windows_sys::Win32::UI::Shell::EXP_PROPERTYSTORAGE { cbSize, dwSignature, abPropertyStorage } = win32;
        let cb_size = cbSize;
        let dw_signature = dwSignature;
        let ab_property_storage = [abPropertyStorage[0]];
        Self { cb_size, dw_signature, ab_property_storage }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct ExpSpecialFolder {
    pub cb_size: u32,
    pub dw_signature: u32,
    pub id_special_folder: u32,
    pub cb_offset: u32,
}
impl ExpSpecialFolder {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::EXP_SPECIAL_FOLDER {
        let Self { cb_size, dw_signature, id_special_folder, cb_offset } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::EXP_SPECIAL_FOLDER>() as _;
        let dwSignature = *dw_signature;
        let idSpecialFolder = *id_special_folder;
        let cbOffset = *cb_offset;
        windows_sys::Win32::UI::Shell::EXP_SPECIAL_FOLDER { cbSize, dwSignature, idSpecialFolder, cbOffset }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::EXP_SPECIAL_FOLDER) -> Self {
        let windows_sys::Win32::UI::Shell::EXP_SPECIAL_FOLDER { cbSize, dwSignature, idSpecialFolder, cbOffset } = win32;
        let cb_size = cbSize;
        let dw_signature = dwSignature;
        let id_special_folder = idSpecialFolder;
        let cb_offset = cbOffset;
        Self { cb_size, dw_signature, id_special_folder, cb_offset }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct ExpSzLink {
    pub cb_size: u32,
    pub dw_signature: u32,
    pub sz_target: [CHAR; 260],
    pub swz_target: [u8; 260],
}
impl ExpSzLink {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::EXP_SZ_LINK {
        let Self { cb_size, dw_signature, sz_target, swz_target } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::EXP_SZ_LINK>() as _;
        let dwSignature = *dw_signature;
        let szTarget = [*&sz_target[0],*&sz_target[1],*&sz_target[2],*&sz_target[3],*&sz_target[4],*&sz_target[5],*&sz_target[6],*&sz_target[7],*&sz_target[8],*&sz_target[9],*&sz_target[10],*&sz_target[11],*&sz_target[12],*&sz_target[13],*&sz_target[14],*&sz_target[15],*&sz_target[16],*&sz_target[17],*&sz_target[18],*&sz_target[19],*&sz_target[20],*&sz_target[21],*&sz_target[22],*&sz_target[23],*&sz_target[24],*&sz_target[25],*&sz_target[26],*&sz_target[27],*&sz_target[28],*&sz_target[29],*&sz_target[30],*&sz_target[31],*&sz_target[32],*&sz_target[33],*&sz_target[34],*&sz_target[35],*&sz_target[36],*&sz_target[37],*&sz_target[38],*&sz_target[39],*&sz_target[40],*&sz_target[41],*&sz_target[42],*&sz_target[43],*&sz_target[44],*&sz_target[45],*&sz_target[46],*&sz_target[47],*&sz_target[48],*&sz_target[49],*&sz_target[50],*&sz_target[51],*&sz_target[52],*&sz_target[53],*&sz_target[54],*&sz_target[55],*&sz_target[56],*&sz_target[57],*&sz_target[58],*&sz_target[59],*&sz_target[60],*&sz_target[61],*&sz_target[62],*&sz_target[63],*&sz_target[64],*&sz_target[65],*&sz_target[66],*&sz_target[67],*&sz_target[68],*&sz_target[69],*&sz_target[70],*&sz_target[71],*&sz_target[72],*&sz_target[73],*&sz_target[74],*&sz_target[75],*&sz_target[76],*&sz_target[77],*&sz_target[78],*&sz_target[79],*&sz_target[80],*&sz_target[81],*&sz_target[82],*&sz_target[83],*&sz_target[84],*&sz_target[85],*&sz_target[86],*&sz_target[87],*&sz_target[88],*&sz_target[89],*&sz_target[90],*&sz_target[91],*&sz_target[92],*&sz_target[93],*&sz_target[94],*&sz_target[95],*&sz_target[96],*&sz_target[97],*&sz_target[98],*&sz_target[99],*&sz_target[100],*&sz_target[101],*&sz_target[102],*&sz_target[103],*&sz_target[104],*&sz_target[105],*&sz_target[106],*&sz_target[107],*&sz_target[108],*&sz_target[109],*&sz_target[110],*&sz_target[111],*&sz_target[112],*&sz_target[113],*&sz_target[114],*&sz_target[115],*&sz_target[116],*&sz_target[117],*&sz_target[118],*&sz_target[119],*&sz_target[120],*&sz_target[121],*&sz_target[122],*&sz_target[123],*&sz_target[124],*&sz_target[125],*&sz_target[126],*&sz_target[127],*&sz_target[128],*&sz_target[129],*&sz_target[130],*&sz_target[131],*&sz_target[132],*&sz_target[133],*&sz_target[134],*&sz_target[135],*&sz_target[136],*&sz_target[137],*&sz_target[138],*&sz_target[139],*&sz_target[140],*&sz_target[141],*&sz_target[142],*&sz_target[143],*&sz_target[144],*&sz_target[145],*&sz_target[146],*&sz_target[147],*&sz_target[148],*&sz_target[149],*&sz_target[150],*&sz_target[151],*&sz_target[152],*&sz_target[153],*&sz_target[154],*&sz_target[155],*&sz_target[156],*&sz_target[157],*&sz_target[158],*&sz_target[159],*&sz_target[160],*&sz_target[161],*&sz_target[162],*&sz_target[163],*&sz_target[164],*&sz_target[165],*&sz_target[166],*&sz_target[167],*&sz_target[168],*&sz_target[169],*&sz_target[170],*&sz_target[171],*&sz_target[172],*&sz_target[173],*&sz_target[174],*&sz_target[175],*&sz_target[176],*&sz_target[177],*&sz_target[178],*&sz_target[179],*&sz_target[180],*&sz_target[181],*&sz_target[182],*&sz_target[183],*&sz_target[184],*&sz_target[185],*&sz_target[186],*&sz_target[187],*&sz_target[188],*&sz_target[189],*&sz_target[190],*&sz_target[191],*&sz_target[192],*&sz_target[193],*&sz_target[194],*&sz_target[195],*&sz_target[196],*&sz_target[197],*&sz_target[198],*&sz_target[199],*&sz_target[200],*&sz_target[201],*&sz_target[202],*&sz_target[203],*&sz_target[204],*&sz_target[205],*&sz_target[206],*&sz_target[207],*&sz_target[208],*&sz_target[209],*&sz_target[210],*&sz_target[211],*&sz_target[212],*&sz_target[213],*&sz_target[214],*&sz_target[215],*&sz_target[216],*&sz_target[217],*&sz_target[218],*&sz_target[219],*&sz_target[220],*&sz_target[221],*&sz_target[222],*&sz_target[223],*&sz_target[224],*&sz_target[225],*&sz_target[226],*&sz_target[227],*&sz_target[228],*&sz_target[229],*&sz_target[230],*&sz_target[231],*&sz_target[232],*&sz_target[233],*&sz_target[234],*&sz_target[235],*&sz_target[236],*&sz_target[237],*&sz_target[238],*&sz_target[239],*&sz_target[240],*&sz_target[241],*&sz_target[242],*&sz_target[243],*&sz_target[244],*&sz_target[245],*&sz_target[246],*&sz_target[247],*&sz_target[248],*&sz_target[249],*&sz_target[250],*&sz_target[251],*&sz_target[252],*&sz_target[253],*&sz_target[254],*&sz_target[255],*&sz_target[256],*&sz_target[257],*&sz_target[258],*&sz_target[259]];
        let swzTarget = [*&swz_target[0],*&swz_target[1],*&swz_target[2],*&swz_target[3],*&swz_target[4],*&swz_target[5],*&swz_target[6],*&swz_target[7],*&swz_target[8],*&swz_target[9],*&swz_target[10],*&swz_target[11],*&swz_target[12],*&swz_target[13],*&swz_target[14],*&swz_target[15],*&swz_target[16],*&swz_target[17],*&swz_target[18],*&swz_target[19],*&swz_target[20],*&swz_target[21],*&swz_target[22],*&swz_target[23],*&swz_target[24],*&swz_target[25],*&swz_target[26],*&swz_target[27],*&swz_target[28],*&swz_target[29],*&swz_target[30],*&swz_target[31],*&swz_target[32],*&swz_target[33],*&swz_target[34],*&swz_target[35],*&swz_target[36],*&swz_target[37],*&swz_target[38],*&swz_target[39],*&swz_target[40],*&swz_target[41],*&swz_target[42],*&swz_target[43],*&swz_target[44],*&swz_target[45],*&swz_target[46],*&swz_target[47],*&swz_target[48],*&swz_target[49],*&swz_target[50],*&swz_target[51],*&swz_target[52],*&swz_target[53],*&swz_target[54],*&swz_target[55],*&swz_target[56],*&swz_target[57],*&swz_target[58],*&swz_target[59],*&swz_target[60],*&swz_target[61],*&swz_target[62],*&swz_target[63],*&swz_target[64],*&swz_target[65],*&swz_target[66],*&swz_target[67],*&swz_target[68],*&swz_target[69],*&swz_target[70],*&swz_target[71],*&swz_target[72],*&swz_target[73],*&swz_target[74],*&swz_target[75],*&swz_target[76],*&swz_target[77],*&swz_target[78],*&swz_target[79],*&swz_target[80],*&swz_target[81],*&swz_target[82],*&swz_target[83],*&swz_target[84],*&swz_target[85],*&swz_target[86],*&swz_target[87],*&swz_target[88],*&swz_target[89],*&swz_target[90],*&swz_target[91],*&swz_target[92],*&swz_target[93],*&swz_target[94],*&swz_target[95],*&swz_target[96],*&swz_target[97],*&swz_target[98],*&swz_target[99],*&swz_target[100],*&swz_target[101],*&swz_target[102],*&swz_target[103],*&swz_target[104],*&swz_target[105],*&swz_target[106],*&swz_target[107],*&swz_target[108],*&swz_target[109],*&swz_target[110],*&swz_target[111],*&swz_target[112],*&swz_target[113],*&swz_target[114],*&swz_target[115],*&swz_target[116],*&swz_target[117],*&swz_target[118],*&swz_target[119],*&swz_target[120],*&swz_target[121],*&swz_target[122],*&swz_target[123],*&swz_target[124],*&swz_target[125],*&swz_target[126],*&swz_target[127],*&swz_target[128],*&swz_target[129],*&swz_target[130],*&swz_target[131],*&swz_target[132],*&swz_target[133],*&swz_target[134],*&swz_target[135],*&swz_target[136],*&swz_target[137],*&swz_target[138],*&swz_target[139],*&swz_target[140],*&swz_target[141],*&swz_target[142],*&swz_target[143],*&swz_target[144],*&swz_target[145],*&swz_target[146],*&swz_target[147],*&swz_target[148],*&swz_target[149],*&swz_target[150],*&swz_target[151],*&swz_target[152],*&swz_target[153],*&swz_target[154],*&swz_target[155],*&swz_target[156],*&swz_target[157],*&swz_target[158],*&swz_target[159],*&swz_target[160],*&swz_target[161],*&swz_target[162],*&swz_target[163],*&swz_target[164],*&swz_target[165],*&swz_target[166],*&swz_target[167],*&swz_target[168],*&swz_target[169],*&swz_target[170],*&swz_target[171],*&swz_target[172],*&swz_target[173],*&swz_target[174],*&swz_target[175],*&swz_target[176],*&swz_target[177],*&swz_target[178],*&swz_target[179],*&swz_target[180],*&swz_target[181],*&swz_target[182],*&swz_target[183],*&swz_target[184],*&swz_target[185],*&swz_target[186],*&swz_target[187],*&swz_target[188],*&swz_target[189],*&swz_target[190],*&swz_target[191],*&swz_target[192],*&swz_target[193],*&swz_target[194],*&swz_target[195],*&swz_target[196],*&swz_target[197],*&swz_target[198],*&swz_target[199],*&swz_target[200],*&swz_target[201],*&swz_target[202],*&swz_target[203],*&swz_target[204],*&swz_target[205],*&swz_target[206],*&swz_target[207],*&swz_target[208],*&swz_target[209],*&swz_target[210],*&swz_target[211],*&swz_target[212],*&swz_target[213],*&swz_target[214],*&swz_target[215],*&swz_target[216],*&swz_target[217],*&swz_target[218],*&swz_target[219],*&swz_target[220],*&swz_target[221],*&swz_target[222],*&swz_target[223],*&swz_target[224],*&swz_target[225],*&swz_target[226],*&swz_target[227],*&swz_target[228],*&swz_target[229],*&swz_target[230],*&swz_target[231],*&swz_target[232],*&swz_target[233],*&swz_target[234],*&swz_target[235],*&swz_target[236],*&swz_target[237],*&swz_target[238],*&swz_target[239],*&swz_target[240],*&swz_target[241],*&swz_target[242],*&swz_target[243],*&swz_target[244],*&swz_target[245],*&swz_target[246],*&swz_target[247],*&swz_target[248],*&swz_target[249],*&swz_target[250],*&swz_target[251],*&swz_target[252],*&swz_target[253],*&swz_target[254],*&swz_target[255],*&swz_target[256],*&swz_target[257],*&swz_target[258],*&swz_target[259]];
        windows_sys::Win32::UI::Shell::EXP_SZ_LINK { cbSize, dwSignature, szTarget, swzTarget }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::EXP_SZ_LINK) -> Self {
        let windows_sys::Win32::UI::Shell::EXP_SZ_LINK { cbSize, dwSignature, szTarget, swzTarget } = win32;
        let cb_size = cbSize;
        let dw_signature = dwSignature;
        let sz_target = [szTarget[0],szTarget[1],szTarget[2],szTarget[3],szTarget[4],szTarget[5],szTarget[6],szTarget[7],szTarget[8],szTarget[9],szTarget[10],szTarget[11],szTarget[12],szTarget[13],szTarget[14],szTarget[15],szTarget[16],szTarget[17],szTarget[18],szTarget[19],szTarget[20],szTarget[21],szTarget[22],szTarget[23],szTarget[24],szTarget[25],szTarget[26],szTarget[27],szTarget[28],szTarget[29],szTarget[30],szTarget[31],szTarget[32],szTarget[33],szTarget[34],szTarget[35],szTarget[36],szTarget[37],szTarget[38],szTarget[39],szTarget[40],szTarget[41],szTarget[42],szTarget[43],szTarget[44],szTarget[45],szTarget[46],szTarget[47],szTarget[48],szTarget[49],szTarget[50],szTarget[51],szTarget[52],szTarget[53],szTarget[54],szTarget[55],szTarget[56],szTarget[57],szTarget[58],szTarget[59],szTarget[60],szTarget[61],szTarget[62],szTarget[63],szTarget[64],szTarget[65],szTarget[66],szTarget[67],szTarget[68],szTarget[69],szTarget[70],szTarget[71],szTarget[72],szTarget[73],szTarget[74],szTarget[75],szTarget[76],szTarget[77],szTarget[78],szTarget[79],szTarget[80],szTarget[81],szTarget[82],szTarget[83],szTarget[84],szTarget[85],szTarget[86],szTarget[87],szTarget[88],szTarget[89],szTarget[90],szTarget[91],szTarget[92],szTarget[93],szTarget[94],szTarget[95],szTarget[96],szTarget[97],szTarget[98],szTarget[99],szTarget[100],szTarget[101],szTarget[102],szTarget[103],szTarget[104],szTarget[105],szTarget[106],szTarget[107],szTarget[108],szTarget[109],szTarget[110],szTarget[111],szTarget[112],szTarget[113],szTarget[114],szTarget[115],szTarget[116],szTarget[117],szTarget[118],szTarget[119],szTarget[120],szTarget[121],szTarget[122],szTarget[123],szTarget[124],szTarget[125],szTarget[126],szTarget[127],szTarget[128],szTarget[129],szTarget[130],szTarget[131],szTarget[132],szTarget[133],szTarget[134],szTarget[135],szTarget[136],szTarget[137],szTarget[138],szTarget[139],szTarget[140],szTarget[141],szTarget[142],szTarget[143],szTarget[144],szTarget[145],szTarget[146],szTarget[147],szTarget[148],szTarget[149],szTarget[150],szTarget[151],szTarget[152],szTarget[153],szTarget[154],szTarget[155],szTarget[156],szTarget[157],szTarget[158],szTarget[159],szTarget[160],szTarget[161],szTarget[162],szTarget[163],szTarget[164],szTarget[165],szTarget[166],szTarget[167],szTarget[168],szTarget[169],szTarget[170],szTarget[171],szTarget[172],szTarget[173],szTarget[174],szTarget[175],szTarget[176],szTarget[177],szTarget[178],szTarget[179],szTarget[180],szTarget[181],szTarget[182],szTarget[183],szTarget[184],szTarget[185],szTarget[186],szTarget[187],szTarget[188],szTarget[189],szTarget[190],szTarget[191],szTarget[192],szTarget[193],szTarget[194],szTarget[195],szTarget[196],szTarget[197],szTarget[198],szTarget[199],szTarget[200],szTarget[201],szTarget[202],szTarget[203],szTarget[204],szTarget[205],szTarget[206],szTarget[207],szTarget[208],szTarget[209],szTarget[210],szTarget[211],szTarget[212],szTarget[213],szTarget[214],szTarget[215],szTarget[216],szTarget[217],szTarget[218],szTarget[219],szTarget[220],szTarget[221],szTarget[222],szTarget[223],szTarget[224],szTarget[225],szTarget[226],szTarget[227],szTarget[228],szTarget[229],szTarget[230],szTarget[231],szTarget[232],szTarget[233],szTarget[234],szTarget[235],szTarget[236],szTarget[237],szTarget[238],szTarget[239],szTarget[240],szTarget[241],szTarget[242],szTarget[243],szTarget[244],szTarget[245],szTarget[246],szTarget[247],szTarget[248],szTarget[249],szTarget[250],szTarget[251],szTarget[252],szTarget[253],szTarget[254],szTarget[255],szTarget[256],szTarget[257],szTarget[258],szTarget[259]];
        let swz_target = [swzTarget[0],swzTarget[1],swzTarget[2],swzTarget[3],swzTarget[4],swzTarget[5],swzTarget[6],swzTarget[7],swzTarget[8],swzTarget[9],swzTarget[10],swzTarget[11],swzTarget[12],swzTarget[13],swzTarget[14],swzTarget[15],swzTarget[16],swzTarget[17],swzTarget[18],swzTarget[19],swzTarget[20],swzTarget[21],swzTarget[22],swzTarget[23],swzTarget[24],swzTarget[25],swzTarget[26],swzTarget[27],swzTarget[28],swzTarget[29],swzTarget[30],swzTarget[31],swzTarget[32],swzTarget[33],swzTarget[34],swzTarget[35],swzTarget[36],swzTarget[37],swzTarget[38],swzTarget[39],swzTarget[40],swzTarget[41],swzTarget[42],swzTarget[43],swzTarget[44],swzTarget[45],swzTarget[46],swzTarget[47],swzTarget[48],swzTarget[49],swzTarget[50],swzTarget[51],swzTarget[52],swzTarget[53],swzTarget[54],swzTarget[55],swzTarget[56],swzTarget[57],swzTarget[58],swzTarget[59],swzTarget[60],swzTarget[61],swzTarget[62],swzTarget[63],swzTarget[64],swzTarget[65],swzTarget[66],swzTarget[67],swzTarget[68],swzTarget[69],swzTarget[70],swzTarget[71],swzTarget[72],swzTarget[73],swzTarget[74],swzTarget[75],swzTarget[76],swzTarget[77],swzTarget[78],swzTarget[79],swzTarget[80],swzTarget[81],swzTarget[82],swzTarget[83],swzTarget[84],swzTarget[85],swzTarget[86],swzTarget[87],swzTarget[88],swzTarget[89],swzTarget[90],swzTarget[91],swzTarget[92],swzTarget[93],swzTarget[94],swzTarget[95],swzTarget[96],swzTarget[97],swzTarget[98],swzTarget[99],swzTarget[100],swzTarget[101],swzTarget[102],swzTarget[103],swzTarget[104],swzTarget[105],swzTarget[106],swzTarget[107],swzTarget[108],swzTarget[109],swzTarget[110],swzTarget[111],swzTarget[112],swzTarget[113],swzTarget[114],swzTarget[115],swzTarget[116],swzTarget[117],swzTarget[118],swzTarget[119],swzTarget[120],swzTarget[121],swzTarget[122],swzTarget[123],swzTarget[124],swzTarget[125],swzTarget[126],swzTarget[127],swzTarget[128],swzTarget[129],swzTarget[130],swzTarget[131],swzTarget[132],swzTarget[133],swzTarget[134],swzTarget[135],swzTarget[136],swzTarget[137],swzTarget[138],swzTarget[139],swzTarget[140],swzTarget[141],swzTarget[142],swzTarget[143],swzTarget[144],swzTarget[145],swzTarget[146],swzTarget[147],swzTarget[148],swzTarget[149],swzTarget[150],swzTarget[151],swzTarget[152],swzTarget[153],swzTarget[154],swzTarget[155],swzTarget[156],swzTarget[157],swzTarget[158],swzTarget[159],swzTarget[160],swzTarget[161],swzTarget[162],swzTarget[163],swzTarget[164],swzTarget[165],swzTarget[166],swzTarget[167],swzTarget[168],swzTarget[169],swzTarget[170],swzTarget[171],swzTarget[172],swzTarget[173],swzTarget[174],swzTarget[175],swzTarget[176],swzTarget[177],swzTarget[178],swzTarget[179],swzTarget[180],swzTarget[181],swzTarget[182],swzTarget[183],swzTarget[184],swzTarget[185],swzTarget[186],swzTarget[187],swzTarget[188],swzTarget[189],swzTarget[190],swzTarget[191],swzTarget[192],swzTarget[193],swzTarget[194],swzTarget[195],swzTarget[196],swzTarget[197],swzTarget[198],swzTarget[199],swzTarget[200],swzTarget[201],swzTarget[202],swzTarget[203],swzTarget[204],swzTarget[205],swzTarget[206],swzTarget[207],swzTarget[208],swzTarget[209],swzTarget[210],swzTarget[211],swzTarget[212],swzTarget[213],swzTarget[214],swzTarget[215],swzTarget[216],swzTarget[217],swzTarget[218],swzTarget[219],swzTarget[220],swzTarget[221],swzTarget[222],swzTarget[223],swzTarget[224],swzTarget[225],swzTarget[226],swzTarget[227],swzTarget[228],swzTarget[229],swzTarget[230],swzTarget[231],swzTarget[232],swzTarget[233],swzTarget[234],swzTarget[235],swzTarget[236],swzTarget[237],swzTarget[238],swzTarget[239],swzTarget[240],swzTarget[241],swzTarget[242],swzTarget[243],swzTarget[244],swzTarget[245],swzTarget[246],swzTarget[247],swzTarget[248],swzTarget[249],swzTarget[250],swzTarget[251],swzTarget[252],swzTarget[253],swzTarget[254],swzTarget[255],swzTarget[256],swzTarget[257],swzTarget[258],swzTarget[259]];
        Self { cb_size, dw_signature, sz_target, swz_target }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Extlogfonta {
    pub elf_log_font: Logfonta,
    pub elf_full_name: [u8; 64],
    pub elf_style: [u8; 32],
    pub elf_version: u32,
    pub elf_style_size: u32,
    pub elf_match: u32,
    pub elf_reserved: u32,
    pub elf_vendor_id: [u8; 4],
    pub elf_culture: u32,
    pub elf_panose: Panose,
}
impl Extlogfonta {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EXTLOGFONTA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EXTLOGFONTA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Extlogfontw {
    pub elf_log_font: Logfontw,
    pub elf_full_name: [u16; 64],
    pub elf_style: [u16; 32],
    pub elf_version: u32,
    pub elf_style_size: u32,
    pub elf_match: u32,
    pub elf_reserved: u32,
    pub elf_vendor_id: [u16; 4],
    pub elf_culture: u32,
    pub elf_panose: Panose,
}
impl Extlogfontw {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EXTLOGFONTW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EXTLOGFONTW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Extlogpen {
    pub elp_pen_style: u32,
    pub elp_width: u32,
    pub elp_brush_style: u32,
    pub elp_color: u32,
    pub elp_hatch: usize,
    pub elp_num_entries: u32,
    pub elp_style_entry: [u32; 1],
}
impl Extlogpen {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EXTLOGPEN {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EXTLOGPEN) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Extlogpen32 {
    pub elp_pen_style: u32,
    pub elp_width: u32,
    pub elp_brush_style: u32,
    pub elp_color: u32,
    pub elp_hatch: u32,
    pub elp_num_entries: u32,
    pub elp_style_entry: [u32; 1],
}
impl Extlogpen32 {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::EXTLOGPEN32 {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::EXTLOGPEN32) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Extrasearch {
    pub guid_search: GUID,
    pub wsz_friendly_name: [u8; 80],
    pub wsz_url: [u8; 2084],
}
impl Extrasearch {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::EXTRASEARCH {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::EXTRASEARCH) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Filedescriptora {
    pub dw_flags: u32,
    pub clsid: GUID,
    pub sizel: Size,
    pub pointl: Pointl,
    pub dw_file_attributes: u32,
    pub ft_creation_time: Filetime,
    pub ft_last_access_time: Filetime,
    pub ft_last_write_time: Filetime,
    pub n_file_size_high: u32,
    pub n_file_size_low: u32,
    pub c_file_name: [CHAR; 260],
}
impl Filedescriptora {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::FILEDESCRIPTORA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::FILEDESCRIPTORA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Filedescriptorw {
    pub dw_flags: u32,
    pub clsid: GUID,
    pub sizel: Size,
    pub pointl: Pointl,
    pub dw_file_attributes: u32,
    pub ft_creation_time: Filetime,
    pub ft_last_access_time: Filetime,
    pub ft_last_write_time: Filetime,
    pub n_file_size_high: u32,
    pub n_file_size_low: u32,
    pub c_file_name: [u16; 260],
}
impl Filedescriptorw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::FILEDESCRIPTORW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::FILEDESCRIPTORW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Filegroupdescriptora {
    pub c_items: u32,
    pub fgd: [Filedescriptora; 1],
}
impl Filegroupdescriptora {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::FILEGROUPDESCRIPTORA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::FILEGROUPDESCRIPTORA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Filegroupdescriptorw {
    pub c_items: u32,
    pub fgd: [Filedescriptorw; 1],
}
impl Filegroupdescriptorw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::FILEGROUPDESCRIPTORW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::FILEGROUPDESCRIPTORW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Filetime {
    pub dw_low_date_time: u32,
    pub dw_high_date_time: u32,
}
impl Filetime {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::FILETIME {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::FILETIME) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct FileAttributesArray {
    pub c_items: u32,
    pub dw_sum_file_attributes: u32,
    pub dw_product_file_attributes: u32,
    pub rgdw_file_attributes: [u32; 1],
}
impl FileAttributesArray {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::FILE_ATTRIBUTES_ARRAY {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::FILE_ATTRIBUTES_ARRAY) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Fixed {
    pub fract: u16,
    pub value: i16,
}
impl Fixed {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::FIXED {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::FIXED) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Flashwinfo {
    pub cb_size: u32,
    pub hwnd: Option<Hwnd>,
    pub dw_flags: u32,
    pub u_count: u32,
    pub dw_timeout: u32,
}
impl Flashwinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::FLASHWINFO {
        let Self { cb_size, hwnd, dw_flags, u_count, dw_timeout } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::FLASHWINFO>() as _;
        let hwnd = hwnd.map_or(0, Hwnd::into_raw);
        let dwFlags = *dw_flags;
        let uCount = *u_count;
        let dwTimeout = *dw_timeout;
        windows_sys::Win32::UI::WindowsAndMessaging::FLASHWINFO { cbSize, hwnd, dwFlags, uCount, dwTimeout }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::FLASHWINFO) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::FLASHWINFO { cbSize, hwnd, dwFlags, uCount, dwTimeout } = win32;
        let cb_size = cbSize;
        let hwnd = unsafe { Hwnd::new_optional(hwnd) };
        let dw_flags = dwFlags;
        let u_count = uCount;
        let dw_timeout = dwTimeout;
        Self { cb_size, hwnd, dw_flags, u_count, dw_timeout }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Float128 {
    pub low_part: i64,
    pub high_part: i64,
}
impl Float128 {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::FLOAT128 {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::FLOAT128) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Foldersetdata {
    pub fs: Foldersettings,
    pub vid_restore: GUID,
    pub dw_view_priority: u32,
}
impl Foldersetdata {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::FOLDERSETDATA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::FOLDERSETDATA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Foldersettings {
    pub view_mode: u32,
    pub f_flags: u32,
}
impl Foldersettings {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::FOLDERSETTINGS {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::FOLDERSETTINGS) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Glyphmetrics {
    pub gm_black_box_x: u32,
    pub gm_black_box_y: u32,
    pub gmpt_glyph_origin: Point,
    pub gm_cell_inc_x: i16,
    pub gm_cell_inc_y: i16,
}
impl Glyphmetrics {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::GLYPHMETRICS {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::GLYPHMETRICS) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone)]
#[repr(C)]
pub struct Glyphmetricsfloat {
    pub gmf_black_box_x: f32,
    pub gmf_black_box_y: f32,
    pub gmfpt_glyph_origin: Pointfloat,
    pub gmf_cell_inc_x: f32,
    pub gmf_cell_inc_y: f32,
}
impl Glyphmetricsfloat {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::OpenGL::GLYPHMETRICSFLOAT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::OpenGL::GLYPHMETRICSFLOAT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Glyphset {
    pub cb_this: u32,
    pub fl_accel: u32,
    pub c_glyphs_supported: u32,
    pub c_ranges: u32,
    pub ranges: [Wcrange; 1],
}
impl Glyphset {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::GLYPHSET {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::GLYPHSET) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct GradientRect {
    pub upper_left: u32,
    pub lower_right: u32,
}
impl GradientRect {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::GRADIENT_RECT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::GRADIENT_RECT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct GradientTriangle {
    pub vertex1: u32,
    pub vertex2: u32,
    pub vertex3: u32,
}
impl GradientTriangle {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::GRADIENT_TRIANGLE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::GRADIENT_TRIANGLE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Guithreadinfo {
    pub cb_size: u32,
    pub flags: u32,
    pub hwnd_active: Option<Hwnd>,
    pub hwnd_focus: Option<Hwnd>,
    pub hwnd_capture: Option<Hwnd>,
    pub hwnd_menu_owner: Option<Hwnd>,
    pub hwnd_move_size: Option<Hwnd>,
    pub hwnd_caret: Option<Hwnd>,
    pub rc_caret: Rect,
}
impl Guithreadinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::GUITHREADINFO {
        let Self { cb_size, flags, hwnd_active, hwnd_focus, hwnd_capture, hwnd_menu_owner, hwnd_move_size, hwnd_caret, rc_caret } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::GUITHREADINFO>() as _;
        let flags = *flags;
        let hwndActive = hwnd_active.map_or(0, Hwnd::into_raw);
        let hwndFocus = hwnd_focus.map_or(0, Hwnd::into_raw);
        let hwndCapture = hwnd_capture.map_or(0, Hwnd::into_raw);
        let hwndMenuOwner = hwnd_menu_owner.map_or(0, Hwnd::into_raw);
        let hwndMoveSize = hwnd_move_size.map_or(0, Hwnd::into_raw);
        let hwndCaret = hwnd_caret.map_or(0, Hwnd::into_raw);
        let rcCaret = rc_caret.to_win32();
        windows_sys::Win32::UI::WindowsAndMessaging::GUITHREADINFO { cbSize, flags, hwndActive, hwndFocus, hwndCapture, hwndMenuOwner, hwndMoveSize, hwndCaret, rcCaret }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::GUITHREADINFO) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::GUITHREADINFO { cbSize, flags, hwndActive, hwndFocus, hwndCapture, hwndMenuOwner, hwndMoveSize, hwndCaret, rcCaret } = win32;
        let cb_size = cbSize;
        let flags = flags;
        let hwnd_active = unsafe { Hwnd::new_optional(hwndActive) };
        let hwnd_focus = unsafe { Hwnd::new_optional(hwndFocus) };
        let hwnd_capture = unsafe { Hwnd::new_optional(hwndCapture) };
        let hwnd_menu_owner = unsafe { Hwnd::new_optional(hwndMenuOwner) };
        let hwnd_move_size = unsafe { Hwnd::new_optional(hwndMoveSize) };
        let hwnd_caret = unsafe { Hwnd::new_optional(hwndCaret) };
        let rc_caret = unsafe { Rect::from_win32(rcCaret) };
        Self { cb_size, flags, hwnd_active, hwnd_focus, hwnd_capture, hwnd_menu_owner, hwnd_move_size, hwnd_caret, rc_caret }
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Haccel {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Haccel {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Haccel {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Haccel {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Handle {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Handle {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Handle {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Handle {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Handletable {
    pub object_handle: [Option<Hgdiobj>; 1],
}
impl Handletable {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::HANDLETABLE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::HANDLETABLE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Hardwarehookstruct {
    pub hwnd: Option<Hwnd>,
    pub message: u32,
    pub w_param: Wparam,
    pub l_param: Lparam,
}
impl Hardwarehookstruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::HARDWAREHOOKSTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::HARDWAREHOOKSTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hbitmap {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hbitmap {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hbitmap {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hbitmap {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hbrush {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hbrush {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hbrush {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hbrush {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hcursor {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hcursor {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hcursor {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hcursor {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hdc {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hdc {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hdc {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hdc {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Hdhittestinfo {
    pub pt: Point,
    pub flags: u32,
    pub i_item: i32,
}
impl Hdhittestinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::HDHITTESTINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::HDHITTESTINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
//  Not generated due to containing a void type
//  #[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Hditema<'a> {
//      pub mask: u32,
//      pub cxy: i32,
//      pub psz_text: Cow<'a, CStr>,
//      pub hbm: Option<Hbitmap>,
//      pub cch_text_max: i32,
//      pub fmt: i32,
//      pub l_param: Lparam,
//      pub i_image: i32,
//      pub i_order: i32,
//      pub r#type: u32,
//      pub pv_filter: &'a mut todo_void,
//      pub state: u32,
//  }
//  impl<'a> Hditema<'a> {
//      fn to_win32(&self) -> windows_sys::Win32::UI::Controls::HDITEMA {
//          let Self { mask, cxy, psz_text, hbm, cch_text_max, fmt, l_param, i_image, i_order, r#type, pv_filter, state } = self;
//          let mask = *mask;
//          let cxy = *cxy;
//          let pszText = psz_text.as_ptr() as _;
//          let hbm = hbm.map_or(0, Hbitmap::into_raw);
//          let cchTextMax = *cch_text_max;
//          let fmt = *fmt;
//          let lParam = l_param.into_inner();
//          let iImage = *i_image;
//          let iOrder = *i_order;
//          let r#type = *r#type;
//          let pvFilter = unsafe { &mut *(pv_filter as *mut _ as *mut _) };
//          let state = *state;
//          windows_sys::Win32::UI::Controls::HDITEMA { mask, cxy, pszText, hbm, cchTextMax, fmt, lParam, iImage, iOrder, r#type, pvFilter, state }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::HDITEMA) -> Self {
//          let windows_sys::Win32::UI::Controls::HDITEMA { mask, cxy, pszText, hbm, cchTextMax, fmt, lParam, iImage, iOrder, r#type, pvFilter, state } = win32;
//          let mask = mask;
//          let cxy = cxy;
//          let pszText = unsafe { CStr::from_ptr(pszText as *const _) };
//          let pszText = pszText.to_bytes_with_nul().to_vec();
//          let psz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(pszText) });
//          let hbm = unsafe { Hbitmap::new_optional(hbm) };
//          let cch_text_max = cchTextMax;
//          let fmt = fmt;
//          let l_param = unsafe { Lparam::from_inner(lParam) };
//          let i_image = iImage;
//          let i_order = iOrder;
//          let r#type = r#type;
//          let pv_filter = unsafe { &mut *(pvFilter as *mut _ as *mut _) };
//          let state = state;
//          Self { mask, cxy, psz_text, hbm, cch_text_max, fmt, l_param, i_image, i_order, r#type, pv_filter, state }
//      }
//  }
//  Not generated due to containing a void type
//  #[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Hditemw<'a> {
//      pub mask: u32,
//      pub cxy: i32,
//      pub psz_text: Cow<'a, [u16]>,
//      pub hbm: Option<Hbitmap>,
//      pub cch_text_max: i32,
//      pub fmt: i32,
//      pub l_param: Lparam,
//      pub i_image: i32,
//      pub i_order: i32,
//      pub r#type: u32,
//      pub pv_filter: &'a mut todo_void,
//      pub state: u32,
//  }
//  impl<'a> Hditemw<'a> {
//      fn to_win32(&self) -> windows_sys::Win32::UI::Controls::HDITEMW {
//          let Self { mask, cxy, psz_text, hbm, cch_text_max, fmt, l_param, i_image, i_order, r#type, pv_filter, state } = self;
//          let mask = *mask;
//          let cxy = *cxy;
//          assert_eq!(psz_text.last().copied(), Some(0));
//          let pszText = psz_text.as_ptr() as _;
//          let hbm = hbm.map_or(0, Hbitmap::into_raw);
//          let cchTextMax = *cch_text_max;
//          let fmt = *fmt;
//          let lParam = l_param.into_inner();
//          let iImage = *i_image;
//          let iOrder = *i_order;
//          let r#type = *r#type;
//          let pvFilter = unsafe { &mut *(pv_filter as *mut _ as *mut _) };
//          let state = *state;
//          windows_sys::Win32::UI::Controls::HDITEMW { mask, cxy, pszText, hbm, cchTextMax, fmt, lParam, iImage, iOrder, r#type, pvFilter, state }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::HDITEMW) -> Self {
//          let windows_sys::Win32::UI::Controls::HDITEMW { mask, cxy, pszText, hbm, cchTextMax, fmt, lParam, iImage, iOrder, r#type, pvFilter, state } = win32;
//          let mask = mask;
//          let cxy = cxy;
//          let slen = unsafe { wide_strlen(pszText as *const u16) };
//          let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
//          let psz_text = Cow::Owned(pszText.to_vec());
//          let hbm = unsafe { Hbitmap::new_optional(hbm) };
//          let cch_text_max = cchTextMax;
//          let fmt = fmt;
//          let l_param = unsafe { Lparam::from_inner(lParam) };
//          let i_image = iImage;
//          let i_order = iOrder;
//          let r#type = r#type;
//          let pv_filter = unsafe { &mut *(pvFilter as *mut _ as *mut _) };
//          let state = state;
//          Self { mask, cxy, psz_text, hbm, cch_text_max, fmt, l_param, i_image, i_order, r#type, pv_filter, state }
//      }
//  }
#[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Hdlayout<'a> {
    pub prc: &'a mut Rect,
    pub pwpos: &'a mut Windowpos,
}
impl<'a> Hdlayout<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::HDLAYOUT {
        let Self { prc, pwpos } = self;
        let prc = unsafe { &mut *(prc as *mut _ as *mut _) };
        let pwpos = unsafe { &mut *(pwpos as *mut _ as *mut _) };
        windows_sys::Win32::UI::Controls::HDLAYOUT { prc, pwpos }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::HDLAYOUT) -> Self {
        let windows_sys::Win32::UI::Controls::HDLAYOUT { prc, pwpos } = win32;
        let prc = unsafe { &mut *(prc as *mut _ as *mut _) };
        let pwpos = unsafe { &mut *(pwpos as *mut _ as *mut _) };
        Self { prc, pwpos }
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hdpa {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hdpa {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hdpa {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hdpa {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hdrop {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hdrop {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hdrop {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hdrop {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hdsa {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hdsa {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hdsa {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hdsa {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct HdTextfiltera<'a> {
    pub psz_text: Cow<'a, CStr>,
    pub cch_text_max: i32,
}
impl<'a> HdTextfiltera<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::HD_TEXTFILTERA {
        let Self { psz_text, cch_text_max } = self;
        let pszText = psz_text.as_ptr() as _;
        let cchTextMax = *cch_text_max;
        windows_sys::Win32::UI::Controls::HD_TEXTFILTERA { pszText, cchTextMax }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::HD_TEXTFILTERA) -> Self {
        let windows_sys::Win32::UI::Controls::HD_TEXTFILTERA { pszText, cchTextMax } = win32;
        let pszText = unsafe { CStr::from_ptr(pszText as *const _) };
        let pszText = pszText.to_bytes_with_nul().to_vec();
        let psz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(pszText) });
        let cch_text_max = cchTextMax;
        Self { psz_text, cch_text_max }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct HdTextfilterw<'a> {
    pub psz_text: Cow<'a, [u16]>,
    pub cch_text_max: i32,
}
impl<'a> HdTextfilterw<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::HD_TEXTFILTERW {
        let Self { psz_text, cch_text_max } = self;
        assert_eq!(psz_text.last().copied(), Some(0));
        let pszText = psz_text.as_ptr() as _;
        let cchTextMax = *cch_text_max;
        windows_sys::Win32::UI::Controls::HD_TEXTFILTERW { pszText, cchTextMax }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::HD_TEXTFILTERW) -> Self {
        let windows_sys::Win32::UI::Controls::HD_TEXTFILTERW { pszText, cchTextMax } = win32;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = Cow::Owned(pszText.to_vec());
        let cch_text_max = cchTextMax;
        Self { psz_text, cch_text_max }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Helpinfo {
    pub cb_size: u32,
    pub i_context_type: i32,
    pub i_ctrl_id: i32,
    pub h_item_handle: Option<Handle>,
    pub dw_context_id: usize,
    pub mouse_pos: Point,
}
impl Helpinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::HELPINFO {
        let Self { cb_size, i_context_type, i_ctrl_id, h_item_handle, dw_context_id, mouse_pos } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::HELPINFO>() as _;
        let iContextType = *i_context_type;
        let iCtrlId = *i_ctrl_id;
        let hItemHandle = h_item_handle.map_or(0, Handle::into_raw);
        let dwContextId = *dw_context_id;
        let MousePos = mouse_pos.to_win32();
        windows_sys::Win32::UI::Shell::HELPINFO { cbSize, iContextType, iCtrlId, hItemHandle, dwContextId, MousePos }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::HELPINFO) -> Self {
        let windows_sys::Win32::UI::Shell::HELPINFO { cbSize, iContextType, iCtrlId, hItemHandle, dwContextId, MousePos } = win32;
        let cb_size = cbSize;
        let i_context_type = iContextType;
        let i_ctrl_id = iCtrlId;
        let h_item_handle = unsafe { Handle::new_optional(hItemHandle) };
        let dw_context_id = dwContextId;
        let mouse_pos = unsafe { Point::from_win32(MousePos) };
        Self { cb_size, i_context_type, i_ctrl_id, h_item_handle, dw_context_id, mouse_pos }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Helpwininfoa {
    pub w_struct_size: i32,
    pub x: i32,
    pub y: i32,
    pub dx: i32,
    pub dy: i32,
    pub w_max: i32,
    pub rgch_member: [CHAR; 2],
}
impl Helpwininfoa {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::HELPWININFOA {
        let Self { w_struct_size, x, y, dx, dy, w_max, rgch_member } = self;
        let wStructSize = mem::size_of::<windows_sys::Win32::UI::Shell::HELPWININFOA>() as _;
        let x = *x;
        let y = *y;
        let dx = *dx;
        let dy = *dy;
        let wMax = *w_max;
        let rgchMember = [*&rgch_member[0],*&rgch_member[1]];
        windows_sys::Win32::UI::Shell::HELPWININFOA { wStructSize, x, y, dx, dy, wMax, rgchMember }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::HELPWININFOA) -> Self {
        let windows_sys::Win32::UI::Shell::HELPWININFOA { wStructSize, x, y, dx, dy, wMax, rgchMember } = win32;
        let w_struct_size = wStructSize;
        let x = x;
        let y = y;
        let dx = dx;
        let dy = dy;
        let w_max = wMax;
        let rgch_member = [rgchMember[0],rgchMember[1]];
        Self { w_struct_size, x, y, dx, dy, w_max, rgch_member }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Helpwininfow {
    pub w_struct_size: i32,
    pub x: i32,
    pub y: i32,
    pub dx: i32,
    pub dy: i32,
    pub w_max: i32,
    pub rgch_member: [u8; 2],
}
impl Helpwininfow {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::HELPWININFOW {
        let Self { w_struct_size, x, y, dx, dy, w_max, rgch_member } = self;
        let wStructSize = mem::size_of::<windows_sys::Win32::UI::Shell::HELPWININFOW>() as _;
        let x = *x;
        let y = *y;
        let dx = *dx;
        let dy = *dy;
        let wMax = *w_max;
        let rgchMember = [*&rgch_member[0],*&rgch_member[1]];
        windows_sys::Win32::UI::Shell::HELPWININFOW { wStructSize, x, y, dx, dy, wMax, rgchMember }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::HELPWININFOW) -> Self {
        let windows_sys::Win32::UI::Shell::HELPWININFOW { wStructSize, x, y, dx, dy, wMax, rgchMember } = win32;
        let w_struct_size = wStructSize;
        let x = x;
        let y = y;
        let dx = dx;
        let dy = dy;
        let w_max = wMax;
        let rgch_member = [rgchMember[0],rgchMember[1]];
        Self { w_struct_size, x, y, dx, dy, w_max, rgch_member }
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Henhmetafile {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Henhmetafile {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Henhmetafile {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Henhmetafile {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hfont {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hfont {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hfont {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hfont {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hgdiobj {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hgdiobj {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hgdiobj {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hgdiobj {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hglrc {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hglrc {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hglrc {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hglrc {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hhook {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hhook {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hhook {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hhook {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hicon {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hicon {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hicon {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hicon {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Himagelist {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Himagelist {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Himagelist {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Himagelist {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hinstance {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hinstance {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hinstance {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hinstance {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hkey {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hkey {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hkey {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hkey {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Hlbwinfo {
    pub cb_size: u32,
    pub grf_hlbwif: u32,
    pub rc_frame_pos: Rect,
    pub rc_doc_pos: Rect,
    pub hltbinfo: Hltbinfo,
}
impl Hlbwinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::HLBWINFO {
        let Self { cb_size, grf_hlbwif, rc_frame_pos, rc_doc_pos, hltbinfo } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::HLBWINFO>() as _;
        let grfHLBWIF = *grf_hlbwif;
        let rcFramePos = rc_frame_pos.to_win32();
        let rcDocPos = rc_doc_pos.to_win32();
        let hltbinfo = hltbinfo.to_win32();
        windows_sys::Win32::UI::Shell::HLBWINFO { cbSize, grfHLBWIF, rcFramePos, rcDocPos, hltbinfo }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::HLBWINFO) -> Self {
        let windows_sys::Win32::UI::Shell::HLBWINFO { cbSize, grfHLBWIF, rcFramePos, rcDocPos, hltbinfo } = win32;
        let cb_size = cbSize;
        let grf_hlbwif = grfHLBWIF;
        let rc_frame_pos = unsafe { Rect::from_win32(rcFramePos) };
        let rc_doc_pos = unsafe { Rect::from_win32(rcDocPos) };
        let hltbinfo = unsafe { Hltbinfo::from_win32(hltbinfo) };
        Self { cb_size, grf_hlbwif, rc_frame_pos, rc_doc_pos, hltbinfo }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Hlitem<'a> {
    pub u_hlid: u32,
    pub pwz_friendly_name: Cow<'a, [u16]>,
}
impl<'a> Hlitem<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::HLITEM {
        let Self { u_hlid, pwz_friendly_name } = self;
        let uHLID = *u_hlid;
        assert_eq!(pwz_friendly_name.last().copied(), Some(0));
        let pwzFriendlyName = pwz_friendly_name.as_ptr() as _;
        windows_sys::Win32::UI::Shell::HLITEM { uHLID, pwzFriendlyName }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::HLITEM) -> Self {
        let windows_sys::Win32::UI::Shell::HLITEM { uHLID, pwzFriendlyName } = win32;
        let u_hlid = uHLID;
        let slen = unsafe { wide_strlen(pwzFriendlyName as *const u16) };
        let pwzFriendlyName = unsafe { slice::from_raw_parts(pwzFriendlyName, slen + 1) };
        let pwz_friendly_name = Cow::Owned(pwzFriendlyName.to_vec());
        Self { u_hlid, pwz_friendly_name }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Hlsurf {
    pub unused: i32,
}
impl Hlsurf {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::HLSURF__ {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::HLSURF__) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Hltbinfo {
    pub u_dock_type: u32,
    pub rc_tb_pos: Rect,
}
impl Hltbinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::HLTBINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::HLTBINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hmenu {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hmenu {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hmenu {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hmenu {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hmetafile {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hmetafile {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hmetafile {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hmetafile {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hmonitor {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hmonitor {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hmonitor {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hmonitor {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hpalette {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hpalette {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hpalette {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hpalette {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hpen {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hpen {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hpen {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hpen {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hpropsheetpage {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hpropsheetpage {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hpropsheetpage {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hpropsheetpage {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hpsxa {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hpsxa {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hpsxa {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hpsxa {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hrgn {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hrgn {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hrgn {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hrgn {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hrsrc {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hrsrc {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hrsrc {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hrsrc {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Hsprite {
    pub unused: i32,
}
impl Hsprite {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::HSPRITE__ {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::HSPRITE__) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Hstr {
    pub unused: i32,
}
impl Hstr {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::HSTR__ {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::HSTR__) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hsyntheticpointerdevice {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hsyntheticpointerdevice {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hsyntheticpointerdevice {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hsyntheticpointerdevice {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Htreeitem {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Htreeitem {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Htreeitem {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Htreeitem {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Humpd {
    pub unused: i32,
}
impl Humpd {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::HUMPD__ {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::HUMPD__) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hwnd {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl Hwnd {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for Hwnd {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for Hwnd {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct HdcMetdataEnhFileHandle {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl HdcMetdataEnhFileHandle {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for HdcMetdataEnhFileHandle {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for HdcMetdataEnhFileHandle {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct HdcMetdataFileHandle {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl HdcMetdataFileHandle {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for HdcMetdataFileHandle {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for HdcMetdataFileHandle {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Iconinfo {
    pub f_icon: BOOL,
    pub x_hotspot: u32,
    pub y_hotspot: u32,
    pub hbm_mask: Option<Hbitmap>,
    pub hbm_color: Option<Hbitmap>,
}
impl Iconinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::ICONINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::ICONINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Iconinfoexa {
    pub cb_size: u32,
    pub f_icon: BOOL,
    pub x_hotspot: u32,
    pub y_hotspot: u32,
    pub hbm_mask: Option<Hbitmap>,
    pub hbm_color: Option<Hbitmap>,
    pub w_res_id: u16,
    pub sz_mod_name: [CHAR; 260],
    pub sz_res_name: [CHAR; 260],
}
impl Iconinfoexa {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::ICONINFOEXA {
        let Self { cb_size, f_icon, x_hotspot, y_hotspot, hbm_mask, hbm_color, w_res_id, sz_mod_name, sz_res_name } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::ICONINFOEXA>() as _;
        let fIcon = *f_icon;
        let xHotspot = *x_hotspot;
        let yHotspot = *y_hotspot;
        let hbmMask = hbm_mask.map_or(0, Hbitmap::into_raw);
        let hbmColor = hbm_color.map_or(0, Hbitmap::into_raw);
        let wResID = *w_res_id;
        let szModName = [*&sz_mod_name[0],*&sz_mod_name[1],*&sz_mod_name[2],*&sz_mod_name[3],*&sz_mod_name[4],*&sz_mod_name[5],*&sz_mod_name[6],*&sz_mod_name[7],*&sz_mod_name[8],*&sz_mod_name[9],*&sz_mod_name[10],*&sz_mod_name[11],*&sz_mod_name[12],*&sz_mod_name[13],*&sz_mod_name[14],*&sz_mod_name[15],*&sz_mod_name[16],*&sz_mod_name[17],*&sz_mod_name[18],*&sz_mod_name[19],*&sz_mod_name[20],*&sz_mod_name[21],*&sz_mod_name[22],*&sz_mod_name[23],*&sz_mod_name[24],*&sz_mod_name[25],*&sz_mod_name[26],*&sz_mod_name[27],*&sz_mod_name[28],*&sz_mod_name[29],*&sz_mod_name[30],*&sz_mod_name[31],*&sz_mod_name[32],*&sz_mod_name[33],*&sz_mod_name[34],*&sz_mod_name[35],*&sz_mod_name[36],*&sz_mod_name[37],*&sz_mod_name[38],*&sz_mod_name[39],*&sz_mod_name[40],*&sz_mod_name[41],*&sz_mod_name[42],*&sz_mod_name[43],*&sz_mod_name[44],*&sz_mod_name[45],*&sz_mod_name[46],*&sz_mod_name[47],*&sz_mod_name[48],*&sz_mod_name[49],*&sz_mod_name[50],*&sz_mod_name[51],*&sz_mod_name[52],*&sz_mod_name[53],*&sz_mod_name[54],*&sz_mod_name[55],*&sz_mod_name[56],*&sz_mod_name[57],*&sz_mod_name[58],*&sz_mod_name[59],*&sz_mod_name[60],*&sz_mod_name[61],*&sz_mod_name[62],*&sz_mod_name[63],*&sz_mod_name[64],*&sz_mod_name[65],*&sz_mod_name[66],*&sz_mod_name[67],*&sz_mod_name[68],*&sz_mod_name[69],*&sz_mod_name[70],*&sz_mod_name[71],*&sz_mod_name[72],*&sz_mod_name[73],*&sz_mod_name[74],*&sz_mod_name[75],*&sz_mod_name[76],*&sz_mod_name[77],*&sz_mod_name[78],*&sz_mod_name[79],*&sz_mod_name[80],*&sz_mod_name[81],*&sz_mod_name[82],*&sz_mod_name[83],*&sz_mod_name[84],*&sz_mod_name[85],*&sz_mod_name[86],*&sz_mod_name[87],*&sz_mod_name[88],*&sz_mod_name[89],*&sz_mod_name[90],*&sz_mod_name[91],*&sz_mod_name[92],*&sz_mod_name[93],*&sz_mod_name[94],*&sz_mod_name[95],*&sz_mod_name[96],*&sz_mod_name[97],*&sz_mod_name[98],*&sz_mod_name[99],*&sz_mod_name[100],*&sz_mod_name[101],*&sz_mod_name[102],*&sz_mod_name[103],*&sz_mod_name[104],*&sz_mod_name[105],*&sz_mod_name[106],*&sz_mod_name[107],*&sz_mod_name[108],*&sz_mod_name[109],*&sz_mod_name[110],*&sz_mod_name[111],*&sz_mod_name[112],*&sz_mod_name[113],*&sz_mod_name[114],*&sz_mod_name[115],*&sz_mod_name[116],*&sz_mod_name[117],*&sz_mod_name[118],*&sz_mod_name[119],*&sz_mod_name[120],*&sz_mod_name[121],*&sz_mod_name[122],*&sz_mod_name[123],*&sz_mod_name[124],*&sz_mod_name[125],*&sz_mod_name[126],*&sz_mod_name[127],*&sz_mod_name[128],*&sz_mod_name[129],*&sz_mod_name[130],*&sz_mod_name[131],*&sz_mod_name[132],*&sz_mod_name[133],*&sz_mod_name[134],*&sz_mod_name[135],*&sz_mod_name[136],*&sz_mod_name[137],*&sz_mod_name[138],*&sz_mod_name[139],*&sz_mod_name[140],*&sz_mod_name[141],*&sz_mod_name[142],*&sz_mod_name[143],*&sz_mod_name[144],*&sz_mod_name[145],*&sz_mod_name[146],*&sz_mod_name[147],*&sz_mod_name[148],*&sz_mod_name[149],*&sz_mod_name[150],*&sz_mod_name[151],*&sz_mod_name[152],*&sz_mod_name[153],*&sz_mod_name[154],*&sz_mod_name[155],*&sz_mod_name[156],*&sz_mod_name[157],*&sz_mod_name[158],*&sz_mod_name[159],*&sz_mod_name[160],*&sz_mod_name[161],*&sz_mod_name[162],*&sz_mod_name[163],*&sz_mod_name[164],*&sz_mod_name[165],*&sz_mod_name[166],*&sz_mod_name[167],*&sz_mod_name[168],*&sz_mod_name[169],*&sz_mod_name[170],*&sz_mod_name[171],*&sz_mod_name[172],*&sz_mod_name[173],*&sz_mod_name[174],*&sz_mod_name[175],*&sz_mod_name[176],*&sz_mod_name[177],*&sz_mod_name[178],*&sz_mod_name[179],*&sz_mod_name[180],*&sz_mod_name[181],*&sz_mod_name[182],*&sz_mod_name[183],*&sz_mod_name[184],*&sz_mod_name[185],*&sz_mod_name[186],*&sz_mod_name[187],*&sz_mod_name[188],*&sz_mod_name[189],*&sz_mod_name[190],*&sz_mod_name[191],*&sz_mod_name[192],*&sz_mod_name[193],*&sz_mod_name[194],*&sz_mod_name[195],*&sz_mod_name[196],*&sz_mod_name[197],*&sz_mod_name[198],*&sz_mod_name[199],*&sz_mod_name[200],*&sz_mod_name[201],*&sz_mod_name[202],*&sz_mod_name[203],*&sz_mod_name[204],*&sz_mod_name[205],*&sz_mod_name[206],*&sz_mod_name[207],*&sz_mod_name[208],*&sz_mod_name[209],*&sz_mod_name[210],*&sz_mod_name[211],*&sz_mod_name[212],*&sz_mod_name[213],*&sz_mod_name[214],*&sz_mod_name[215],*&sz_mod_name[216],*&sz_mod_name[217],*&sz_mod_name[218],*&sz_mod_name[219],*&sz_mod_name[220],*&sz_mod_name[221],*&sz_mod_name[222],*&sz_mod_name[223],*&sz_mod_name[224],*&sz_mod_name[225],*&sz_mod_name[226],*&sz_mod_name[227],*&sz_mod_name[228],*&sz_mod_name[229],*&sz_mod_name[230],*&sz_mod_name[231],*&sz_mod_name[232],*&sz_mod_name[233],*&sz_mod_name[234],*&sz_mod_name[235],*&sz_mod_name[236],*&sz_mod_name[237],*&sz_mod_name[238],*&sz_mod_name[239],*&sz_mod_name[240],*&sz_mod_name[241],*&sz_mod_name[242],*&sz_mod_name[243],*&sz_mod_name[244],*&sz_mod_name[245],*&sz_mod_name[246],*&sz_mod_name[247],*&sz_mod_name[248],*&sz_mod_name[249],*&sz_mod_name[250],*&sz_mod_name[251],*&sz_mod_name[252],*&sz_mod_name[253],*&sz_mod_name[254],*&sz_mod_name[255],*&sz_mod_name[256],*&sz_mod_name[257],*&sz_mod_name[258],*&sz_mod_name[259]];
        let szResName = [*&sz_res_name[0],*&sz_res_name[1],*&sz_res_name[2],*&sz_res_name[3],*&sz_res_name[4],*&sz_res_name[5],*&sz_res_name[6],*&sz_res_name[7],*&sz_res_name[8],*&sz_res_name[9],*&sz_res_name[10],*&sz_res_name[11],*&sz_res_name[12],*&sz_res_name[13],*&sz_res_name[14],*&sz_res_name[15],*&sz_res_name[16],*&sz_res_name[17],*&sz_res_name[18],*&sz_res_name[19],*&sz_res_name[20],*&sz_res_name[21],*&sz_res_name[22],*&sz_res_name[23],*&sz_res_name[24],*&sz_res_name[25],*&sz_res_name[26],*&sz_res_name[27],*&sz_res_name[28],*&sz_res_name[29],*&sz_res_name[30],*&sz_res_name[31],*&sz_res_name[32],*&sz_res_name[33],*&sz_res_name[34],*&sz_res_name[35],*&sz_res_name[36],*&sz_res_name[37],*&sz_res_name[38],*&sz_res_name[39],*&sz_res_name[40],*&sz_res_name[41],*&sz_res_name[42],*&sz_res_name[43],*&sz_res_name[44],*&sz_res_name[45],*&sz_res_name[46],*&sz_res_name[47],*&sz_res_name[48],*&sz_res_name[49],*&sz_res_name[50],*&sz_res_name[51],*&sz_res_name[52],*&sz_res_name[53],*&sz_res_name[54],*&sz_res_name[55],*&sz_res_name[56],*&sz_res_name[57],*&sz_res_name[58],*&sz_res_name[59],*&sz_res_name[60],*&sz_res_name[61],*&sz_res_name[62],*&sz_res_name[63],*&sz_res_name[64],*&sz_res_name[65],*&sz_res_name[66],*&sz_res_name[67],*&sz_res_name[68],*&sz_res_name[69],*&sz_res_name[70],*&sz_res_name[71],*&sz_res_name[72],*&sz_res_name[73],*&sz_res_name[74],*&sz_res_name[75],*&sz_res_name[76],*&sz_res_name[77],*&sz_res_name[78],*&sz_res_name[79],*&sz_res_name[80],*&sz_res_name[81],*&sz_res_name[82],*&sz_res_name[83],*&sz_res_name[84],*&sz_res_name[85],*&sz_res_name[86],*&sz_res_name[87],*&sz_res_name[88],*&sz_res_name[89],*&sz_res_name[90],*&sz_res_name[91],*&sz_res_name[92],*&sz_res_name[93],*&sz_res_name[94],*&sz_res_name[95],*&sz_res_name[96],*&sz_res_name[97],*&sz_res_name[98],*&sz_res_name[99],*&sz_res_name[100],*&sz_res_name[101],*&sz_res_name[102],*&sz_res_name[103],*&sz_res_name[104],*&sz_res_name[105],*&sz_res_name[106],*&sz_res_name[107],*&sz_res_name[108],*&sz_res_name[109],*&sz_res_name[110],*&sz_res_name[111],*&sz_res_name[112],*&sz_res_name[113],*&sz_res_name[114],*&sz_res_name[115],*&sz_res_name[116],*&sz_res_name[117],*&sz_res_name[118],*&sz_res_name[119],*&sz_res_name[120],*&sz_res_name[121],*&sz_res_name[122],*&sz_res_name[123],*&sz_res_name[124],*&sz_res_name[125],*&sz_res_name[126],*&sz_res_name[127],*&sz_res_name[128],*&sz_res_name[129],*&sz_res_name[130],*&sz_res_name[131],*&sz_res_name[132],*&sz_res_name[133],*&sz_res_name[134],*&sz_res_name[135],*&sz_res_name[136],*&sz_res_name[137],*&sz_res_name[138],*&sz_res_name[139],*&sz_res_name[140],*&sz_res_name[141],*&sz_res_name[142],*&sz_res_name[143],*&sz_res_name[144],*&sz_res_name[145],*&sz_res_name[146],*&sz_res_name[147],*&sz_res_name[148],*&sz_res_name[149],*&sz_res_name[150],*&sz_res_name[151],*&sz_res_name[152],*&sz_res_name[153],*&sz_res_name[154],*&sz_res_name[155],*&sz_res_name[156],*&sz_res_name[157],*&sz_res_name[158],*&sz_res_name[159],*&sz_res_name[160],*&sz_res_name[161],*&sz_res_name[162],*&sz_res_name[163],*&sz_res_name[164],*&sz_res_name[165],*&sz_res_name[166],*&sz_res_name[167],*&sz_res_name[168],*&sz_res_name[169],*&sz_res_name[170],*&sz_res_name[171],*&sz_res_name[172],*&sz_res_name[173],*&sz_res_name[174],*&sz_res_name[175],*&sz_res_name[176],*&sz_res_name[177],*&sz_res_name[178],*&sz_res_name[179],*&sz_res_name[180],*&sz_res_name[181],*&sz_res_name[182],*&sz_res_name[183],*&sz_res_name[184],*&sz_res_name[185],*&sz_res_name[186],*&sz_res_name[187],*&sz_res_name[188],*&sz_res_name[189],*&sz_res_name[190],*&sz_res_name[191],*&sz_res_name[192],*&sz_res_name[193],*&sz_res_name[194],*&sz_res_name[195],*&sz_res_name[196],*&sz_res_name[197],*&sz_res_name[198],*&sz_res_name[199],*&sz_res_name[200],*&sz_res_name[201],*&sz_res_name[202],*&sz_res_name[203],*&sz_res_name[204],*&sz_res_name[205],*&sz_res_name[206],*&sz_res_name[207],*&sz_res_name[208],*&sz_res_name[209],*&sz_res_name[210],*&sz_res_name[211],*&sz_res_name[212],*&sz_res_name[213],*&sz_res_name[214],*&sz_res_name[215],*&sz_res_name[216],*&sz_res_name[217],*&sz_res_name[218],*&sz_res_name[219],*&sz_res_name[220],*&sz_res_name[221],*&sz_res_name[222],*&sz_res_name[223],*&sz_res_name[224],*&sz_res_name[225],*&sz_res_name[226],*&sz_res_name[227],*&sz_res_name[228],*&sz_res_name[229],*&sz_res_name[230],*&sz_res_name[231],*&sz_res_name[232],*&sz_res_name[233],*&sz_res_name[234],*&sz_res_name[235],*&sz_res_name[236],*&sz_res_name[237],*&sz_res_name[238],*&sz_res_name[239],*&sz_res_name[240],*&sz_res_name[241],*&sz_res_name[242],*&sz_res_name[243],*&sz_res_name[244],*&sz_res_name[245],*&sz_res_name[246],*&sz_res_name[247],*&sz_res_name[248],*&sz_res_name[249],*&sz_res_name[250],*&sz_res_name[251],*&sz_res_name[252],*&sz_res_name[253],*&sz_res_name[254],*&sz_res_name[255],*&sz_res_name[256],*&sz_res_name[257],*&sz_res_name[258],*&sz_res_name[259]];
        windows_sys::Win32::UI::WindowsAndMessaging::ICONINFOEXA { cbSize, fIcon, xHotspot, yHotspot, hbmMask, hbmColor, wResID, szModName, szResName }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::ICONINFOEXA) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::ICONINFOEXA { cbSize, fIcon, xHotspot, yHotspot, hbmMask, hbmColor, wResID, szModName, szResName } = win32;
        let cb_size = cbSize;
        let f_icon = fIcon;
        let x_hotspot = xHotspot;
        let y_hotspot = yHotspot;
        let hbm_mask = unsafe { Hbitmap::new_optional(hbmMask) };
        let hbm_color = unsafe { Hbitmap::new_optional(hbmColor) };
        let w_res_id = wResID;
        let sz_mod_name = [szModName[0],szModName[1],szModName[2],szModName[3],szModName[4],szModName[5],szModName[6],szModName[7],szModName[8],szModName[9],szModName[10],szModName[11],szModName[12],szModName[13],szModName[14],szModName[15],szModName[16],szModName[17],szModName[18],szModName[19],szModName[20],szModName[21],szModName[22],szModName[23],szModName[24],szModName[25],szModName[26],szModName[27],szModName[28],szModName[29],szModName[30],szModName[31],szModName[32],szModName[33],szModName[34],szModName[35],szModName[36],szModName[37],szModName[38],szModName[39],szModName[40],szModName[41],szModName[42],szModName[43],szModName[44],szModName[45],szModName[46],szModName[47],szModName[48],szModName[49],szModName[50],szModName[51],szModName[52],szModName[53],szModName[54],szModName[55],szModName[56],szModName[57],szModName[58],szModName[59],szModName[60],szModName[61],szModName[62],szModName[63],szModName[64],szModName[65],szModName[66],szModName[67],szModName[68],szModName[69],szModName[70],szModName[71],szModName[72],szModName[73],szModName[74],szModName[75],szModName[76],szModName[77],szModName[78],szModName[79],szModName[80],szModName[81],szModName[82],szModName[83],szModName[84],szModName[85],szModName[86],szModName[87],szModName[88],szModName[89],szModName[90],szModName[91],szModName[92],szModName[93],szModName[94],szModName[95],szModName[96],szModName[97],szModName[98],szModName[99],szModName[100],szModName[101],szModName[102],szModName[103],szModName[104],szModName[105],szModName[106],szModName[107],szModName[108],szModName[109],szModName[110],szModName[111],szModName[112],szModName[113],szModName[114],szModName[115],szModName[116],szModName[117],szModName[118],szModName[119],szModName[120],szModName[121],szModName[122],szModName[123],szModName[124],szModName[125],szModName[126],szModName[127],szModName[128],szModName[129],szModName[130],szModName[131],szModName[132],szModName[133],szModName[134],szModName[135],szModName[136],szModName[137],szModName[138],szModName[139],szModName[140],szModName[141],szModName[142],szModName[143],szModName[144],szModName[145],szModName[146],szModName[147],szModName[148],szModName[149],szModName[150],szModName[151],szModName[152],szModName[153],szModName[154],szModName[155],szModName[156],szModName[157],szModName[158],szModName[159],szModName[160],szModName[161],szModName[162],szModName[163],szModName[164],szModName[165],szModName[166],szModName[167],szModName[168],szModName[169],szModName[170],szModName[171],szModName[172],szModName[173],szModName[174],szModName[175],szModName[176],szModName[177],szModName[178],szModName[179],szModName[180],szModName[181],szModName[182],szModName[183],szModName[184],szModName[185],szModName[186],szModName[187],szModName[188],szModName[189],szModName[190],szModName[191],szModName[192],szModName[193],szModName[194],szModName[195],szModName[196],szModName[197],szModName[198],szModName[199],szModName[200],szModName[201],szModName[202],szModName[203],szModName[204],szModName[205],szModName[206],szModName[207],szModName[208],szModName[209],szModName[210],szModName[211],szModName[212],szModName[213],szModName[214],szModName[215],szModName[216],szModName[217],szModName[218],szModName[219],szModName[220],szModName[221],szModName[222],szModName[223],szModName[224],szModName[225],szModName[226],szModName[227],szModName[228],szModName[229],szModName[230],szModName[231],szModName[232],szModName[233],szModName[234],szModName[235],szModName[236],szModName[237],szModName[238],szModName[239],szModName[240],szModName[241],szModName[242],szModName[243],szModName[244],szModName[245],szModName[246],szModName[247],szModName[248],szModName[249],szModName[250],szModName[251],szModName[252],szModName[253],szModName[254],szModName[255],szModName[256],szModName[257],szModName[258],szModName[259]];
        let sz_res_name = [szResName[0],szResName[1],szResName[2],szResName[3],szResName[4],szResName[5],szResName[6],szResName[7],szResName[8],szResName[9],szResName[10],szResName[11],szResName[12],szResName[13],szResName[14],szResName[15],szResName[16],szResName[17],szResName[18],szResName[19],szResName[20],szResName[21],szResName[22],szResName[23],szResName[24],szResName[25],szResName[26],szResName[27],szResName[28],szResName[29],szResName[30],szResName[31],szResName[32],szResName[33],szResName[34],szResName[35],szResName[36],szResName[37],szResName[38],szResName[39],szResName[40],szResName[41],szResName[42],szResName[43],szResName[44],szResName[45],szResName[46],szResName[47],szResName[48],szResName[49],szResName[50],szResName[51],szResName[52],szResName[53],szResName[54],szResName[55],szResName[56],szResName[57],szResName[58],szResName[59],szResName[60],szResName[61],szResName[62],szResName[63],szResName[64],szResName[65],szResName[66],szResName[67],szResName[68],szResName[69],szResName[70],szResName[71],szResName[72],szResName[73],szResName[74],szResName[75],szResName[76],szResName[77],szResName[78],szResName[79],szResName[80],szResName[81],szResName[82],szResName[83],szResName[84],szResName[85],szResName[86],szResName[87],szResName[88],szResName[89],szResName[90],szResName[91],szResName[92],szResName[93],szResName[94],szResName[95],szResName[96],szResName[97],szResName[98],szResName[99],szResName[100],szResName[101],szResName[102],szResName[103],szResName[104],szResName[105],szResName[106],szResName[107],szResName[108],szResName[109],szResName[110],szResName[111],szResName[112],szResName[113],szResName[114],szResName[115],szResName[116],szResName[117],szResName[118],szResName[119],szResName[120],szResName[121],szResName[122],szResName[123],szResName[124],szResName[125],szResName[126],szResName[127],szResName[128],szResName[129],szResName[130],szResName[131],szResName[132],szResName[133],szResName[134],szResName[135],szResName[136],szResName[137],szResName[138],szResName[139],szResName[140],szResName[141],szResName[142],szResName[143],szResName[144],szResName[145],szResName[146],szResName[147],szResName[148],szResName[149],szResName[150],szResName[151],szResName[152],szResName[153],szResName[154],szResName[155],szResName[156],szResName[157],szResName[158],szResName[159],szResName[160],szResName[161],szResName[162],szResName[163],szResName[164],szResName[165],szResName[166],szResName[167],szResName[168],szResName[169],szResName[170],szResName[171],szResName[172],szResName[173],szResName[174],szResName[175],szResName[176],szResName[177],szResName[178],szResName[179],szResName[180],szResName[181],szResName[182],szResName[183],szResName[184],szResName[185],szResName[186],szResName[187],szResName[188],szResName[189],szResName[190],szResName[191],szResName[192],szResName[193],szResName[194],szResName[195],szResName[196],szResName[197],szResName[198],szResName[199],szResName[200],szResName[201],szResName[202],szResName[203],szResName[204],szResName[205],szResName[206],szResName[207],szResName[208],szResName[209],szResName[210],szResName[211],szResName[212],szResName[213],szResName[214],szResName[215],szResName[216],szResName[217],szResName[218],szResName[219],szResName[220],szResName[221],szResName[222],szResName[223],szResName[224],szResName[225],szResName[226],szResName[227],szResName[228],szResName[229],szResName[230],szResName[231],szResName[232],szResName[233],szResName[234],szResName[235],szResName[236],szResName[237],szResName[238],szResName[239],szResName[240],szResName[241],szResName[242],szResName[243],szResName[244],szResName[245],szResName[246],szResName[247],szResName[248],szResName[249],szResName[250],szResName[251],szResName[252],szResName[253],szResName[254],szResName[255],szResName[256],szResName[257],szResName[258],szResName[259]];
        Self { cb_size, f_icon, x_hotspot, y_hotspot, hbm_mask, hbm_color, w_res_id, sz_mod_name, sz_res_name }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Iconinfoexw {
    pub cb_size: u32,
    pub f_icon: BOOL,
    pub x_hotspot: u32,
    pub y_hotspot: u32,
    pub hbm_mask: Option<Hbitmap>,
    pub hbm_color: Option<Hbitmap>,
    pub w_res_id: u16,
    pub sz_mod_name: [u8; 260],
    pub sz_res_name: [u8; 260],
}
impl Iconinfoexw {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::ICONINFOEXW {
        let Self { cb_size, f_icon, x_hotspot, y_hotspot, hbm_mask, hbm_color, w_res_id, sz_mod_name, sz_res_name } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::ICONINFOEXW>() as _;
        let fIcon = *f_icon;
        let xHotspot = *x_hotspot;
        let yHotspot = *y_hotspot;
        let hbmMask = hbm_mask.map_or(0, Hbitmap::into_raw);
        let hbmColor = hbm_color.map_or(0, Hbitmap::into_raw);
        let wResID = *w_res_id;
        let szModName = [*&sz_mod_name[0],*&sz_mod_name[1],*&sz_mod_name[2],*&sz_mod_name[3],*&sz_mod_name[4],*&sz_mod_name[5],*&sz_mod_name[6],*&sz_mod_name[7],*&sz_mod_name[8],*&sz_mod_name[9],*&sz_mod_name[10],*&sz_mod_name[11],*&sz_mod_name[12],*&sz_mod_name[13],*&sz_mod_name[14],*&sz_mod_name[15],*&sz_mod_name[16],*&sz_mod_name[17],*&sz_mod_name[18],*&sz_mod_name[19],*&sz_mod_name[20],*&sz_mod_name[21],*&sz_mod_name[22],*&sz_mod_name[23],*&sz_mod_name[24],*&sz_mod_name[25],*&sz_mod_name[26],*&sz_mod_name[27],*&sz_mod_name[28],*&sz_mod_name[29],*&sz_mod_name[30],*&sz_mod_name[31],*&sz_mod_name[32],*&sz_mod_name[33],*&sz_mod_name[34],*&sz_mod_name[35],*&sz_mod_name[36],*&sz_mod_name[37],*&sz_mod_name[38],*&sz_mod_name[39],*&sz_mod_name[40],*&sz_mod_name[41],*&sz_mod_name[42],*&sz_mod_name[43],*&sz_mod_name[44],*&sz_mod_name[45],*&sz_mod_name[46],*&sz_mod_name[47],*&sz_mod_name[48],*&sz_mod_name[49],*&sz_mod_name[50],*&sz_mod_name[51],*&sz_mod_name[52],*&sz_mod_name[53],*&sz_mod_name[54],*&sz_mod_name[55],*&sz_mod_name[56],*&sz_mod_name[57],*&sz_mod_name[58],*&sz_mod_name[59],*&sz_mod_name[60],*&sz_mod_name[61],*&sz_mod_name[62],*&sz_mod_name[63],*&sz_mod_name[64],*&sz_mod_name[65],*&sz_mod_name[66],*&sz_mod_name[67],*&sz_mod_name[68],*&sz_mod_name[69],*&sz_mod_name[70],*&sz_mod_name[71],*&sz_mod_name[72],*&sz_mod_name[73],*&sz_mod_name[74],*&sz_mod_name[75],*&sz_mod_name[76],*&sz_mod_name[77],*&sz_mod_name[78],*&sz_mod_name[79],*&sz_mod_name[80],*&sz_mod_name[81],*&sz_mod_name[82],*&sz_mod_name[83],*&sz_mod_name[84],*&sz_mod_name[85],*&sz_mod_name[86],*&sz_mod_name[87],*&sz_mod_name[88],*&sz_mod_name[89],*&sz_mod_name[90],*&sz_mod_name[91],*&sz_mod_name[92],*&sz_mod_name[93],*&sz_mod_name[94],*&sz_mod_name[95],*&sz_mod_name[96],*&sz_mod_name[97],*&sz_mod_name[98],*&sz_mod_name[99],*&sz_mod_name[100],*&sz_mod_name[101],*&sz_mod_name[102],*&sz_mod_name[103],*&sz_mod_name[104],*&sz_mod_name[105],*&sz_mod_name[106],*&sz_mod_name[107],*&sz_mod_name[108],*&sz_mod_name[109],*&sz_mod_name[110],*&sz_mod_name[111],*&sz_mod_name[112],*&sz_mod_name[113],*&sz_mod_name[114],*&sz_mod_name[115],*&sz_mod_name[116],*&sz_mod_name[117],*&sz_mod_name[118],*&sz_mod_name[119],*&sz_mod_name[120],*&sz_mod_name[121],*&sz_mod_name[122],*&sz_mod_name[123],*&sz_mod_name[124],*&sz_mod_name[125],*&sz_mod_name[126],*&sz_mod_name[127],*&sz_mod_name[128],*&sz_mod_name[129],*&sz_mod_name[130],*&sz_mod_name[131],*&sz_mod_name[132],*&sz_mod_name[133],*&sz_mod_name[134],*&sz_mod_name[135],*&sz_mod_name[136],*&sz_mod_name[137],*&sz_mod_name[138],*&sz_mod_name[139],*&sz_mod_name[140],*&sz_mod_name[141],*&sz_mod_name[142],*&sz_mod_name[143],*&sz_mod_name[144],*&sz_mod_name[145],*&sz_mod_name[146],*&sz_mod_name[147],*&sz_mod_name[148],*&sz_mod_name[149],*&sz_mod_name[150],*&sz_mod_name[151],*&sz_mod_name[152],*&sz_mod_name[153],*&sz_mod_name[154],*&sz_mod_name[155],*&sz_mod_name[156],*&sz_mod_name[157],*&sz_mod_name[158],*&sz_mod_name[159],*&sz_mod_name[160],*&sz_mod_name[161],*&sz_mod_name[162],*&sz_mod_name[163],*&sz_mod_name[164],*&sz_mod_name[165],*&sz_mod_name[166],*&sz_mod_name[167],*&sz_mod_name[168],*&sz_mod_name[169],*&sz_mod_name[170],*&sz_mod_name[171],*&sz_mod_name[172],*&sz_mod_name[173],*&sz_mod_name[174],*&sz_mod_name[175],*&sz_mod_name[176],*&sz_mod_name[177],*&sz_mod_name[178],*&sz_mod_name[179],*&sz_mod_name[180],*&sz_mod_name[181],*&sz_mod_name[182],*&sz_mod_name[183],*&sz_mod_name[184],*&sz_mod_name[185],*&sz_mod_name[186],*&sz_mod_name[187],*&sz_mod_name[188],*&sz_mod_name[189],*&sz_mod_name[190],*&sz_mod_name[191],*&sz_mod_name[192],*&sz_mod_name[193],*&sz_mod_name[194],*&sz_mod_name[195],*&sz_mod_name[196],*&sz_mod_name[197],*&sz_mod_name[198],*&sz_mod_name[199],*&sz_mod_name[200],*&sz_mod_name[201],*&sz_mod_name[202],*&sz_mod_name[203],*&sz_mod_name[204],*&sz_mod_name[205],*&sz_mod_name[206],*&sz_mod_name[207],*&sz_mod_name[208],*&sz_mod_name[209],*&sz_mod_name[210],*&sz_mod_name[211],*&sz_mod_name[212],*&sz_mod_name[213],*&sz_mod_name[214],*&sz_mod_name[215],*&sz_mod_name[216],*&sz_mod_name[217],*&sz_mod_name[218],*&sz_mod_name[219],*&sz_mod_name[220],*&sz_mod_name[221],*&sz_mod_name[222],*&sz_mod_name[223],*&sz_mod_name[224],*&sz_mod_name[225],*&sz_mod_name[226],*&sz_mod_name[227],*&sz_mod_name[228],*&sz_mod_name[229],*&sz_mod_name[230],*&sz_mod_name[231],*&sz_mod_name[232],*&sz_mod_name[233],*&sz_mod_name[234],*&sz_mod_name[235],*&sz_mod_name[236],*&sz_mod_name[237],*&sz_mod_name[238],*&sz_mod_name[239],*&sz_mod_name[240],*&sz_mod_name[241],*&sz_mod_name[242],*&sz_mod_name[243],*&sz_mod_name[244],*&sz_mod_name[245],*&sz_mod_name[246],*&sz_mod_name[247],*&sz_mod_name[248],*&sz_mod_name[249],*&sz_mod_name[250],*&sz_mod_name[251],*&sz_mod_name[252],*&sz_mod_name[253],*&sz_mod_name[254],*&sz_mod_name[255],*&sz_mod_name[256],*&sz_mod_name[257],*&sz_mod_name[258],*&sz_mod_name[259]];
        let szResName = [*&sz_res_name[0],*&sz_res_name[1],*&sz_res_name[2],*&sz_res_name[3],*&sz_res_name[4],*&sz_res_name[5],*&sz_res_name[6],*&sz_res_name[7],*&sz_res_name[8],*&sz_res_name[9],*&sz_res_name[10],*&sz_res_name[11],*&sz_res_name[12],*&sz_res_name[13],*&sz_res_name[14],*&sz_res_name[15],*&sz_res_name[16],*&sz_res_name[17],*&sz_res_name[18],*&sz_res_name[19],*&sz_res_name[20],*&sz_res_name[21],*&sz_res_name[22],*&sz_res_name[23],*&sz_res_name[24],*&sz_res_name[25],*&sz_res_name[26],*&sz_res_name[27],*&sz_res_name[28],*&sz_res_name[29],*&sz_res_name[30],*&sz_res_name[31],*&sz_res_name[32],*&sz_res_name[33],*&sz_res_name[34],*&sz_res_name[35],*&sz_res_name[36],*&sz_res_name[37],*&sz_res_name[38],*&sz_res_name[39],*&sz_res_name[40],*&sz_res_name[41],*&sz_res_name[42],*&sz_res_name[43],*&sz_res_name[44],*&sz_res_name[45],*&sz_res_name[46],*&sz_res_name[47],*&sz_res_name[48],*&sz_res_name[49],*&sz_res_name[50],*&sz_res_name[51],*&sz_res_name[52],*&sz_res_name[53],*&sz_res_name[54],*&sz_res_name[55],*&sz_res_name[56],*&sz_res_name[57],*&sz_res_name[58],*&sz_res_name[59],*&sz_res_name[60],*&sz_res_name[61],*&sz_res_name[62],*&sz_res_name[63],*&sz_res_name[64],*&sz_res_name[65],*&sz_res_name[66],*&sz_res_name[67],*&sz_res_name[68],*&sz_res_name[69],*&sz_res_name[70],*&sz_res_name[71],*&sz_res_name[72],*&sz_res_name[73],*&sz_res_name[74],*&sz_res_name[75],*&sz_res_name[76],*&sz_res_name[77],*&sz_res_name[78],*&sz_res_name[79],*&sz_res_name[80],*&sz_res_name[81],*&sz_res_name[82],*&sz_res_name[83],*&sz_res_name[84],*&sz_res_name[85],*&sz_res_name[86],*&sz_res_name[87],*&sz_res_name[88],*&sz_res_name[89],*&sz_res_name[90],*&sz_res_name[91],*&sz_res_name[92],*&sz_res_name[93],*&sz_res_name[94],*&sz_res_name[95],*&sz_res_name[96],*&sz_res_name[97],*&sz_res_name[98],*&sz_res_name[99],*&sz_res_name[100],*&sz_res_name[101],*&sz_res_name[102],*&sz_res_name[103],*&sz_res_name[104],*&sz_res_name[105],*&sz_res_name[106],*&sz_res_name[107],*&sz_res_name[108],*&sz_res_name[109],*&sz_res_name[110],*&sz_res_name[111],*&sz_res_name[112],*&sz_res_name[113],*&sz_res_name[114],*&sz_res_name[115],*&sz_res_name[116],*&sz_res_name[117],*&sz_res_name[118],*&sz_res_name[119],*&sz_res_name[120],*&sz_res_name[121],*&sz_res_name[122],*&sz_res_name[123],*&sz_res_name[124],*&sz_res_name[125],*&sz_res_name[126],*&sz_res_name[127],*&sz_res_name[128],*&sz_res_name[129],*&sz_res_name[130],*&sz_res_name[131],*&sz_res_name[132],*&sz_res_name[133],*&sz_res_name[134],*&sz_res_name[135],*&sz_res_name[136],*&sz_res_name[137],*&sz_res_name[138],*&sz_res_name[139],*&sz_res_name[140],*&sz_res_name[141],*&sz_res_name[142],*&sz_res_name[143],*&sz_res_name[144],*&sz_res_name[145],*&sz_res_name[146],*&sz_res_name[147],*&sz_res_name[148],*&sz_res_name[149],*&sz_res_name[150],*&sz_res_name[151],*&sz_res_name[152],*&sz_res_name[153],*&sz_res_name[154],*&sz_res_name[155],*&sz_res_name[156],*&sz_res_name[157],*&sz_res_name[158],*&sz_res_name[159],*&sz_res_name[160],*&sz_res_name[161],*&sz_res_name[162],*&sz_res_name[163],*&sz_res_name[164],*&sz_res_name[165],*&sz_res_name[166],*&sz_res_name[167],*&sz_res_name[168],*&sz_res_name[169],*&sz_res_name[170],*&sz_res_name[171],*&sz_res_name[172],*&sz_res_name[173],*&sz_res_name[174],*&sz_res_name[175],*&sz_res_name[176],*&sz_res_name[177],*&sz_res_name[178],*&sz_res_name[179],*&sz_res_name[180],*&sz_res_name[181],*&sz_res_name[182],*&sz_res_name[183],*&sz_res_name[184],*&sz_res_name[185],*&sz_res_name[186],*&sz_res_name[187],*&sz_res_name[188],*&sz_res_name[189],*&sz_res_name[190],*&sz_res_name[191],*&sz_res_name[192],*&sz_res_name[193],*&sz_res_name[194],*&sz_res_name[195],*&sz_res_name[196],*&sz_res_name[197],*&sz_res_name[198],*&sz_res_name[199],*&sz_res_name[200],*&sz_res_name[201],*&sz_res_name[202],*&sz_res_name[203],*&sz_res_name[204],*&sz_res_name[205],*&sz_res_name[206],*&sz_res_name[207],*&sz_res_name[208],*&sz_res_name[209],*&sz_res_name[210],*&sz_res_name[211],*&sz_res_name[212],*&sz_res_name[213],*&sz_res_name[214],*&sz_res_name[215],*&sz_res_name[216],*&sz_res_name[217],*&sz_res_name[218],*&sz_res_name[219],*&sz_res_name[220],*&sz_res_name[221],*&sz_res_name[222],*&sz_res_name[223],*&sz_res_name[224],*&sz_res_name[225],*&sz_res_name[226],*&sz_res_name[227],*&sz_res_name[228],*&sz_res_name[229],*&sz_res_name[230],*&sz_res_name[231],*&sz_res_name[232],*&sz_res_name[233],*&sz_res_name[234],*&sz_res_name[235],*&sz_res_name[236],*&sz_res_name[237],*&sz_res_name[238],*&sz_res_name[239],*&sz_res_name[240],*&sz_res_name[241],*&sz_res_name[242],*&sz_res_name[243],*&sz_res_name[244],*&sz_res_name[245],*&sz_res_name[246],*&sz_res_name[247],*&sz_res_name[248],*&sz_res_name[249],*&sz_res_name[250],*&sz_res_name[251],*&sz_res_name[252],*&sz_res_name[253],*&sz_res_name[254],*&sz_res_name[255],*&sz_res_name[256],*&sz_res_name[257],*&sz_res_name[258],*&sz_res_name[259]];
        windows_sys::Win32::UI::WindowsAndMessaging::ICONINFOEXW { cbSize, fIcon, xHotspot, yHotspot, hbmMask, hbmColor, wResID, szModName, szResName }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::ICONINFOEXW) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::ICONINFOEXW { cbSize, fIcon, xHotspot, yHotspot, hbmMask, hbmColor, wResID, szModName, szResName } = win32;
        let cb_size = cbSize;
        let f_icon = fIcon;
        let x_hotspot = xHotspot;
        let y_hotspot = yHotspot;
        let hbm_mask = unsafe { Hbitmap::new_optional(hbmMask) };
        let hbm_color = unsafe { Hbitmap::new_optional(hbmColor) };
        let w_res_id = wResID;
        let sz_mod_name = [szModName[0],szModName[1],szModName[2],szModName[3],szModName[4],szModName[5],szModName[6],szModName[7],szModName[8],szModName[9],szModName[10],szModName[11],szModName[12],szModName[13],szModName[14],szModName[15],szModName[16],szModName[17],szModName[18],szModName[19],szModName[20],szModName[21],szModName[22],szModName[23],szModName[24],szModName[25],szModName[26],szModName[27],szModName[28],szModName[29],szModName[30],szModName[31],szModName[32],szModName[33],szModName[34],szModName[35],szModName[36],szModName[37],szModName[38],szModName[39],szModName[40],szModName[41],szModName[42],szModName[43],szModName[44],szModName[45],szModName[46],szModName[47],szModName[48],szModName[49],szModName[50],szModName[51],szModName[52],szModName[53],szModName[54],szModName[55],szModName[56],szModName[57],szModName[58],szModName[59],szModName[60],szModName[61],szModName[62],szModName[63],szModName[64],szModName[65],szModName[66],szModName[67],szModName[68],szModName[69],szModName[70],szModName[71],szModName[72],szModName[73],szModName[74],szModName[75],szModName[76],szModName[77],szModName[78],szModName[79],szModName[80],szModName[81],szModName[82],szModName[83],szModName[84],szModName[85],szModName[86],szModName[87],szModName[88],szModName[89],szModName[90],szModName[91],szModName[92],szModName[93],szModName[94],szModName[95],szModName[96],szModName[97],szModName[98],szModName[99],szModName[100],szModName[101],szModName[102],szModName[103],szModName[104],szModName[105],szModName[106],szModName[107],szModName[108],szModName[109],szModName[110],szModName[111],szModName[112],szModName[113],szModName[114],szModName[115],szModName[116],szModName[117],szModName[118],szModName[119],szModName[120],szModName[121],szModName[122],szModName[123],szModName[124],szModName[125],szModName[126],szModName[127],szModName[128],szModName[129],szModName[130],szModName[131],szModName[132],szModName[133],szModName[134],szModName[135],szModName[136],szModName[137],szModName[138],szModName[139],szModName[140],szModName[141],szModName[142],szModName[143],szModName[144],szModName[145],szModName[146],szModName[147],szModName[148],szModName[149],szModName[150],szModName[151],szModName[152],szModName[153],szModName[154],szModName[155],szModName[156],szModName[157],szModName[158],szModName[159],szModName[160],szModName[161],szModName[162],szModName[163],szModName[164],szModName[165],szModName[166],szModName[167],szModName[168],szModName[169],szModName[170],szModName[171],szModName[172],szModName[173],szModName[174],szModName[175],szModName[176],szModName[177],szModName[178],szModName[179],szModName[180],szModName[181],szModName[182],szModName[183],szModName[184],szModName[185],szModName[186],szModName[187],szModName[188],szModName[189],szModName[190],szModName[191],szModName[192],szModName[193],szModName[194],szModName[195],szModName[196],szModName[197],szModName[198],szModName[199],szModName[200],szModName[201],szModName[202],szModName[203],szModName[204],szModName[205],szModName[206],szModName[207],szModName[208],szModName[209],szModName[210],szModName[211],szModName[212],szModName[213],szModName[214],szModName[215],szModName[216],szModName[217],szModName[218],szModName[219],szModName[220],szModName[221],szModName[222],szModName[223],szModName[224],szModName[225],szModName[226],szModName[227],szModName[228],szModName[229],szModName[230],szModName[231],szModName[232],szModName[233],szModName[234],szModName[235],szModName[236],szModName[237],szModName[238],szModName[239],szModName[240],szModName[241],szModName[242],szModName[243],szModName[244],szModName[245],szModName[246],szModName[247],szModName[248],szModName[249],szModName[250],szModName[251],szModName[252],szModName[253],szModName[254],szModName[255],szModName[256],szModName[257],szModName[258],szModName[259]];
        let sz_res_name = [szResName[0],szResName[1],szResName[2],szResName[3],szResName[4],szResName[5],szResName[6],szResName[7],szResName[8],szResName[9],szResName[10],szResName[11],szResName[12],szResName[13],szResName[14],szResName[15],szResName[16],szResName[17],szResName[18],szResName[19],szResName[20],szResName[21],szResName[22],szResName[23],szResName[24],szResName[25],szResName[26],szResName[27],szResName[28],szResName[29],szResName[30],szResName[31],szResName[32],szResName[33],szResName[34],szResName[35],szResName[36],szResName[37],szResName[38],szResName[39],szResName[40],szResName[41],szResName[42],szResName[43],szResName[44],szResName[45],szResName[46],szResName[47],szResName[48],szResName[49],szResName[50],szResName[51],szResName[52],szResName[53],szResName[54],szResName[55],szResName[56],szResName[57],szResName[58],szResName[59],szResName[60],szResName[61],szResName[62],szResName[63],szResName[64],szResName[65],szResName[66],szResName[67],szResName[68],szResName[69],szResName[70],szResName[71],szResName[72],szResName[73],szResName[74],szResName[75],szResName[76],szResName[77],szResName[78],szResName[79],szResName[80],szResName[81],szResName[82],szResName[83],szResName[84],szResName[85],szResName[86],szResName[87],szResName[88],szResName[89],szResName[90],szResName[91],szResName[92],szResName[93],szResName[94],szResName[95],szResName[96],szResName[97],szResName[98],szResName[99],szResName[100],szResName[101],szResName[102],szResName[103],szResName[104],szResName[105],szResName[106],szResName[107],szResName[108],szResName[109],szResName[110],szResName[111],szResName[112],szResName[113],szResName[114],szResName[115],szResName[116],szResName[117],szResName[118],szResName[119],szResName[120],szResName[121],szResName[122],szResName[123],szResName[124],szResName[125],szResName[126],szResName[127],szResName[128],szResName[129],szResName[130],szResName[131],szResName[132],szResName[133],szResName[134],szResName[135],szResName[136],szResName[137],szResName[138],szResName[139],szResName[140],szResName[141],szResName[142],szResName[143],szResName[144],szResName[145],szResName[146],szResName[147],szResName[148],szResName[149],szResName[150],szResName[151],szResName[152],szResName[153],szResName[154],szResName[155],szResName[156],szResName[157],szResName[158],szResName[159],szResName[160],szResName[161],szResName[162],szResName[163],szResName[164],szResName[165],szResName[166],szResName[167],szResName[168],szResName[169],szResName[170],szResName[171],szResName[172],szResName[173],szResName[174],szResName[175],szResName[176],szResName[177],szResName[178],szResName[179],szResName[180],szResName[181],szResName[182],szResName[183],szResName[184],szResName[185],szResName[186],szResName[187],szResName[188],szResName[189],szResName[190],szResName[191],szResName[192],szResName[193],szResName[194],szResName[195],szResName[196],szResName[197],szResName[198],szResName[199],szResName[200],szResName[201],szResName[202],szResName[203],szResName[204],szResName[205],szResName[206],szResName[207],szResName[208],szResName[209],szResName[210],szResName[211],szResName[212],szResName[213],szResName[214],szResName[215],szResName[216],szResName[217],szResName[218],szResName[219],szResName[220],szResName[221],szResName[222],szResName[223],szResName[224],szResName[225],szResName[226],szResName[227],szResName[228],szResName[229],szResName[230],szResName[231],szResName[232],szResName[233],szResName[234],szResName[235],szResName[236],szResName[237],szResName[238],szResName[239],szResName[240],szResName[241],szResName[242],szResName[243],szResName[244],szResName[245],szResName[246],szResName[247],szResName[248],szResName[249],szResName[250],szResName[251],szResName[252],szResName[253],szResName[254],szResName[255],szResName[256],szResName[257],szResName[258],szResName[259]];
        Self { cb_size, f_icon, x_hotspot, y_hotspot, hbm_mask, hbm_color, w_res_id, sz_mod_name, sz_res_name }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Iconmetricsa {
    pub cb_size: u32,
    pub i_horz_spacing: i32,
    pub i_vert_spacing: i32,
    pub i_title_wrap: i32,
    pub lf_font: Logfonta,
}
impl Iconmetricsa {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::ICONMETRICSA {
        let Self { cb_size, i_horz_spacing, i_vert_spacing, i_title_wrap, lf_font } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::ICONMETRICSA>() as _;
        let iHorzSpacing = *i_horz_spacing;
        let iVertSpacing = *i_vert_spacing;
        let iTitleWrap = *i_title_wrap;
        let lfFont = lf_font.to_win32();
        windows_sys::Win32::UI::WindowsAndMessaging::ICONMETRICSA { cbSize, iHorzSpacing, iVertSpacing, iTitleWrap, lfFont }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::ICONMETRICSA) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::ICONMETRICSA { cbSize, iHorzSpacing, iVertSpacing, iTitleWrap, lfFont } = win32;
        let cb_size = cbSize;
        let i_horz_spacing = iHorzSpacing;
        let i_vert_spacing = iVertSpacing;
        let i_title_wrap = iTitleWrap;
        let lf_font = unsafe { Logfonta::from_win32(lfFont) };
        Self { cb_size, i_horz_spacing, i_vert_spacing, i_title_wrap, lf_font }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Iconmetricsw {
    pub cb_size: u32,
    pub i_horz_spacing: i32,
    pub i_vert_spacing: i32,
    pub i_title_wrap: i32,
    pub lf_font: Logfontw,
}
impl Iconmetricsw {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::ICONMETRICSW {
        let Self { cb_size, i_horz_spacing, i_vert_spacing, i_title_wrap, lf_font } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::ICONMETRICSW>() as _;
        let iHorzSpacing = *i_horz_spacing;
        let iVertSpacing = *i_vert_spacing;
        let iTitleWrap = *i_title_wrap;
        let lfFont = lf_font.to_win32();
        windows_sys::Win32::UI::WindowsAndMessaging::ICONMETRICSW { cbSize, iHorzSpacing, iVertSpacing, iTitleWrap, lfFont }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::ICONMETRICSW) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::ICONMETRICSW { cbSize, iHorzSpacing, iVertSpacing, iTitleWrap, lfFont } = win32;
        let cb_size = cbSize;
        let i_horz_spacing = iHorzSpacing;
        let i_vert_spacing = iVertSpacing;
        let i_title_wrap = iTitleWrap;
        let lf_font = unsafe { Logfontw::from_win32(lfFont) };
        Self { cb_size, i_horz_spacing, i_vert_spacing, i_title_wrap, lf_font }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Imageinfo {
    pub hbm_image: Option<Hbitmap>,
    pub hbm_mask: Option<Hbitmap>,
    pub unused1: i32,
    pub unused2: i32,
    pub rc_image: Rect,
}
impl Imageinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::IMAGEINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::IMAGEINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Imagelistdrawparams {
    pub cb_size: u32,
    pub himl: Option<Himagelist>,
    pub i: i32,
    pub hdc_dst: Option<Hdc>,
    pub x: i32,
    pub y: i32,
    pub cx: i32,
    pub cy: i32,
    pub x_bitmap: i32,
    pub y_bitmap: i32,
    pub rgb_bk: u32,
    pub rgb_fg: u32,
    pub f_style: u32,
    pub dw_rop: u32,
    pub f_state: u32,
    pub frame: u32,
    pub cr_effect: u32,
}
impl Imagelistdrawparams {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::IMAGELISTDRAWPARAMS {
        let Self { cb_size, himl, i, hdc_dst, x, y, cx, cy, x_bitmap, y_bitmap, rgb_bk, rgb_fg, f_style, dw_rop, f_state, frame, cr_effect } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::IMAGELISTDRAWPARAMS>() as _;
        let himl = himl.map_or(0, Himagelist::into_raw);
        let i = *i;
        let hdcDst = hdc_dst.map_or(0, Hdc::into_raw);
        let x = *x;
        let y = *y;
        let cx = *cx;
        let cy = *cy;
        let xBitmap = *x_bitmap;
        let yBitmap = *y_bitmap;
        let rgbBk = *rgb_bk;
        let rgbFg = *rgb_fg;
        let fStyle = *f_style;
        let dwRop = *dw_rop;
        let fState = *f_state;
        let Frame = *frame;
        let crEffect = *cr_effect;
        windows_sys::Win32::UI::Controls::IMAGELISTDRAWPARAMS { cbSize, himl, i, hdcDst, x, y, cx, cy, xBitmap, yBitmap, rgbBk, rgbFg, fStyle, dwRop, fState, Frame, crEffect }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::IMAGELISTDRAWPARAMS) -> Self {
        let windows_sys::Win32::UI::Controls::IMAGELISTDRAWPARAMS { cbSize, himl, i, hdcDst, x, y, cx, cy, xBitmap, yBitmap, rgbBk, rgbFg, fStyle, dwRop, fState, Frame, crEffect } = win32;
        let cb_size = cbSize;
        let himl = unsafe { Himagelist::new_optional(himl) };
        let i = i;
        let hdc_dst = unsafe { Hdc::new_optional(hdcDst) };
        let x = x;
        let y = y;
        let cx = cx;
        let cy = cy;
        let x_bitmap = xBitmap;
        let y_bitmap = yBitmap;
        let rgb_bk = rgbBk;
        let rgb_fg = rgbFg;
        let f_style = fStyle;
        let dw_rop = dwRop;
        let f_state = fState;
        let frame = Frame;
        let cr_effect = crEffect;
        Self { cb_size, himl, i, hdc_dst, x, y, cx, cy, x_bitmap, y_bitmap, rgb_bk, rgb_fg, f_style, dw_rop, f_state, frame, cr_effect }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Imageliststats {
    pub cb_size: u32,
    pub c_alloc: i32,
    pub c_used: i32,
    pub c_standby: i32,
}
impl Imageliststats {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::IMAGELISTSTATS {
        let Self { cb_size, c_alloc, c_used, c_standby } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::IMAGELISTSTATS>() as _;
        let cAlloc = *c_alloc;
        let cUsed = *c_used;
        let cStandby = *c_standby;
        windows_sys::Win32::UI::Controls::IMAGELISTSTATS { cbSize, cAlloc, cUsed, cStandby }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::IMAGELISTSTATS) -> Self {
        let windows_sys::Win32::UI::Controls::IMAGELISTSTATS { cbSize, cAlloc, cUsed, cStandby } = win32;
        let cb_size = cbSize;
        let c_alloc = cAlloc;
        let c_used = cUsed;
        let c_standby = cStandby;
        Self { cb_size, c_alloc, c_used, c_standby }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Initcommoncontrolsex {
    pub dw_size: u32,
    pub dw_icc: u32,
}
impl Initcommoncontrolsex {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::INITCOMMONCONTROLSEX {
        let Self { dw_size, dw_icc } = self;
        let dwSize = mem::size_of::<windows_sys::Win32::UI::Controls::INITCOMMONCONTROLSEX>() as _;
        let dwICC = *dw_icc;
        windows_sys::Win32::UI::Controls::INITCOMMONCONTROLSEX { dwSize, dwICC }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::INITCOMMONCONTROLSEX) -> Self {
        let windows_sys::Win32::UI::Controls::INITCOMMONCONTROLSEX { dwSize, dwICC } = win32;
        let dw_size = dwSize;
        let dw_icc = dwICC;
        Self { dw_size, dw_icc }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct InputInjectionValue {
    pub page: u16,
    pub usage: u16,
    pub value: i32,
    pub index: u16,
}
impl InputInjectionValue {
    fn to_win32(&self) -> windows_sys::Win32::UI::Input::Pointer::INPUT_INJECTION_VALUE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Input::Pointer::INPUT_INJECTION_VALUE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Intlist {
    pub i_value_count: i32,
    pub i_values: [i32; 402],
}
impl Intlist {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::INTLIST {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::INTLIST) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Itemspacing {
    pub cx_small: i32,
    pub cy_small: i32,
    pub cx_large: i32,
    pub cy_large: i32,
}
impl Itemspacing {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::ITEMSPACING {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::ITEMSPACING) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Kbdllhookstruct {
    pub vk_code: u32,
    pub scan_code: u32,
    pub flags: u32,
    pub time: u32,
    pub dw_extra_info: usize,
}
impl Kbdllhookstruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::KBDLLHOOKSTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::KBDLLHOOKSTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Kerningpair {
    pub w_first: u16,
    pub w_second: u16,
    pub i_kern_amount: i32,
}
impl Kerningpair {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::KERNINGPAIR {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::KERNINGPAIR) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct KnownfolderDefinition<'a> {
    pub category: i32,
    pub psz_name: Cow<'a, [u16]>,
    pub psz_description: Cow<'a, [u16]>,
    pub fid_parent: GUID,
    pub psz_relative_path: Cow<'a, [u16]>,
    pub psz_parsing_name: Cow<'a, [u16]>,
    pub psz_tooltip: Cow<'a, [u16]>,
    pub psz_localized_name: Cow<'a, [u16]>,
    pub psz_icon: Cow<'a, [u16]>,
    pub psz_security: Cow<'a, [u16]>,
    pub dw_attributes: u32,
    pub kfd_flags: u32,
    pub ftid_type: GUID,
}
impl<'a> KnownfolderDefinition<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::KNOWNFOLDER_DEFINITION {
        let Self { category, psz_name, psz_description, fid_parent, psz_relative_path, psz_parsing_name, psz_tooltip, psz_localized_name, psz_icon, psz_security, dw_attributes, kfd_flags, ftid_type } = self;
        let category = *category;
        assert_eq!(psz_name.last().copied(), Some(0));
        let pszName = psz_name.as_ptr() as _;
        assert_eq!(psz_description.last().copied(), Some(0));
        let pszDescription = psz_description.as_ptr() as _;
        let fidParent = *fid_parent;
        assert_eq!(psz_relative_path.last().copied(), Some(0));
        let pszRelativePath = psz_relative_path.as_ptr() as _;
        assert_eq!(psz_parsing_name.last().copied(), Some(0));
        let pszParsingName = psz_parsing_name.as_ptr() as _;
        assert_eq!(psz_tooltip.last().copied(), Some(0));
        let pszTooltip = psz_tooltip.as_ptr() as _;
        assert_eq!(psz_localized_name.last().copied(), Some(0));
        let pszLocalizedName = psz_localized_name.as_ptr() as _;
        assert_eq!(psz_icon.last().copied(), Some(0));
        let pszIcon = psz_icon.as_ptr() as _;
        assert_eq!(psz_security.last().copied(), Some(0));
        let pszSecurity = psz_security.as_ptr() as _;
        let dwAttributes = *dw_attributes;
        let kfdFlags = *kfd_flags;
        let ftidType = *ftid_type;
        windows_sys::Win32::UI::Shell::KNOWNFOLDER_DEFINITION { category, pszName, pszDescription, fidParent, pszRelativePath, pszParsingName, pszTooltip, pszLocalizedName, pszIcon, pszSecurity, dwAttributes, kfdFlags, ftidType }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::KNOWNFOLDER_DEFINITION) -> Self {
        let windows_sys::Win32::UI::Shell::KNOWNFOLDER_DEFINITION { category, pszName, pszDescription, fidParent, pszRelativePath, pszParsingName, pszTooltip, pszLocalizedName, pszIcon, pszSecurity, dwAttributes, kfdFlags, ftidType } = win32;
        let category = category;
        let slen = unsafe { wide_strlen(pszName as *const u16) };
        let pszName = unsafe { slice::from_raw_parts(pszName, slen + 1) };
        let psz_name = Cow::Owned(pszName.to_vec());
        let slen = unsafe { wide_strlen(pszDescription as *const u16) };
        let pszDescription = unsafe { slice::from_raw_parts(pszDescription, slen + 1) };
        let psz_description = Cow::Owned(pszDescription.to_vec());
        let fid_parent = fidParent;
        let slen = unsafe { wide_strlen(pszRelativePath as *const u16) };
        let pszRelativePath = unsafe { slice::from_raw_parts(pszRelativePath, slen + 1) };
        let psz_relative_path = Cow::Owned(pszRelativePath.to_vec());
        let slen = unsafe { wide_strlen(pszParsingName as *const u16) };
        let pszParsingName = unsafe { slice::from_raw_parts(pszParsingName, slen + 1) };
        let psz_parsing_name = Cow::Owned(pszParsingName.to_vec());
        let slen = unsafe { wide_strlen(pszTooltip as *const u16) };
        let pszTooltip = unsafe { slice::from_raw_parts(pszTooltip, slen + 1) };
        let psz_tooltip = Cow::Owned(pszTooltip.to_vec());
        let slen = unsafe { wide_strlen(pszLocalizedName as *const u16) };
        let pszLocalizedName = unsafe { slice::from_raw_parts(pszLocalizedName, slen + 1) };
        let psz_localized_name = Cow::Owned(pszLocalizedName.to_vec());
        let slen = unsafe { wide_strlen(pszIcon as *const u16) };
        let pszIcon = unsafe { slice::from_raw_parts(pszIcon, slen + 1) };
        let psz_icon = Cow::Owned(pszIcon.to_vec());
        let slen = unsafe { wide_strlen(pszSecurity as *const u16) };
        let pszSecurity = unsafe { slice::from_raw_parts(pszSecurity, slen + 1) };
        let psz_security = Cow::Owned(pszSecurity.to_vec());
        let dw_attributes = dwAttributes;
        let kfd_flags = kfdFlags;
        let ftid_type = ftidType;
        Self { category, psz_name, psz_description, fid_parent, psz_relative_path, psz_parsing_name, psz_tooltip, psz_localized_name, psz_icon, psz_security, dw_attributes, kfd_flags, ftid_type }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Layerplanedescriptor {
    pub n_size: u16,
    pub n_version: u16,
    pub dw_flags: u32,
    pub i_pixel_type: u8,
    pub c_color_bits: u8,
    pub c_red_bits: u8,
    pub c_red_shift: u8,
    pub c_green_bits: u8,
    pub c_green_shift: u8,
    pub c_blue_bits: u8,
    pub c_blue_shift: u8,
    pub c_alpha_bits: u8,
    pub c_alpha_shift: u8,
    pub c_accum_bits: u8,
    pub c_accum_red_bits: u8,
    pub c_accum_green_bits: u8,
    pub c_accum_blue_bits: u8,
    pub c_accum_alpha_bits: u8,
    pub c_depth_bits: u8,
    pub c_stencil_bits: u8,
    pub c_aux_buffers: u8,
    pub i_layer_plane: u8,
    pub b_reserved: u8,
    pub cr_transparent: u32,
}
impl Layerplanedescriptor {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::OpenGL::LAYERPLANEDESCRIPTOR {
        let Self { n_size, n_version, dw_flags, i_pixel_type, c_color_bits, c_red_bits, c_red_shift, c_green_bits, c_green_shift, c_blue_bits, c_blue_shift, c_alpha_bits, c_alpha_shift, c_accum_bits, c_accum_red_bits, c_accum_green_bits, c_accum_blue_bits, c_accum_alpha_bits, c_depth_bits, c_stencil_bits, c_aux_buffers, i_layer_plane, b_reserved, cr_transparent } = self;
        let nSize = mem::size_of::<windows_sys::Win32::Graphics::OpenGL::LAYERPLANEDESCRIPTOR>() as _;
        let nVersion = *n_version;
        let dwFlags = *dw_flags;
        let iPixelType = *i_pixel_type;
        let cColorBits = *c_color_bits;
        let cRedBits = *c_red_bits;
        let cRedShift = *c_red_shift;
        let cGreenBits = *c_green_bits;
        let cGreenShift = *c_green_shift;
        let cBlueBits = *c_blue_bits;
        let cBlueShift = *c_blue_shift;
        let cAlphaBits = *c_alpha_bits;
        let cAlphaShift = *c_alpha_shift;
        let cAccumBits = *c_accum_bits;
        let cAccumRedBits = *c_accum_red_bits;
        let cAccumGreenBits = *c_accum_green_bits;
        let cAccumBlueBits = *c_accum_blue_bits;
        let cAccumAlphaBits = *c_accum_alpha_bits;
        let cDepthBits = *c_depth_bits;
        let cStencilBits = *c_stencil_bits;
        let cAuxBuffers = *c_aux_buffers;
        let iLayerPlane = *i_layer_plane;
        let bReserved = *b_reserved;
        let crTransparent = *cr_transparent;
        windows_sys::Win32::Graphics::OpenGL::LAYERPLANEDESCRIPTOR { nSize, nVersion, dwFlags, iPixelType, cColorBits, cRedBits, cRedShift, cGreenBits, cGreenShift, cBlueBits, cBlueShift, cAlphaBits, cAlphaShift, cAccumBits, cAccumRedBits, cAccumGreenBits, cAccumBlueBits, cAccumAlphaBits, cDepthBits, cStencilBits, cAuxBuffers, iLayerPlane, bReserved, crTransparent }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::OpenGL::LAYERPLANEDESCRIPTOR) -> Self {
        let windows_sys::Win32::Graphics::OpenGL::LAYERPLANEDESCRIPTOR { nSize, nVersion, dwFlags, iPixelType, cColorBits, cRedBits, cRedShift, cGreenBits, cGreenShift, cBlueBits, cBlueShift, cAlphaBits, cAlphaShift, cAccumBits, cAccumRedBits, cAccumGreenBits, cAccumBlueBits, cAccumAlphaBits, cDepthBits, cStencilBits, cAuxBuffers, iLayerPlane, bReserved, crTransparent } = win32;
        let n_size = nSize;
        let n_version = nVersion;
        let dw_flags = dwFlags;
        let i_pixel_type = iPixelType;
        let c_color_bits = cColorBits;
        let c_red_bits = cRedBits;
        let c_red_shift = cRedShift;
        let c_green_bits = cGreenBits;
        let c_green_shift = cGreenShift;
        let c_blue_bits = cBlueBits;
        let c_blue_shift = cBlueShift;
        let c_alpha_bits = cAlphaBits;
        let c_alpha_shift = cAlphaShift;
        let c_accum_bits = cAccumBits;
        let c_accum_red_bits = cAccumRedBits;
        let c_accum_green_bits = cAccumGreenBits;
        let c_accum_blue_bits = cAccumBlueBits;
        let c_accum_alpha_bits = cAccumAlphaBits;
        let c_depth_bits = cDepthBits;
        let c_stencil_bits = cStencilBits;
        let c_aux_buffers = cAuxBuffers;
        let i_layer_plane = iLayerPlane;
        let b_reserved = bReserved;
        let cr_transparent = crTransparent;
        Self { n_size, n_version, dw_flags, i_pixel_type, c_color_bits, c_red_bits, c_red_shift, c_green_bits, c_green_shift, c_blue_bits, c_blue_shift, c_alpha_bits, c_alpha_shift, c_accum_bits, c_accum_red_bits, c_accum_green_bits, c_accum_blue_bits, c_accum_alpha_bits, c_depth_bits, c_stencil_bits, c_aux_buffers, i_layer_plane, b_reserved, cr_transparent }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lhittestinfo {
    pub pt: Point,
    pub item: Litem,
}
impl Lhittestinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LHITTESTINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LHITTESTINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Litem {
    pub mask: u32,
    pub i_link: i32,
    pub state: u32,
    pub state_mask: u32,
    pub sz_id: [u8; 48],
    pub sz_url: [u8; 2084],
}
impl Litem {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LITEM {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LITEM) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Logbrush {
    pub lb_style: u32,
    pub lb_color: u32,
    pub lb_hatch: usize,
}
impl Logbrush {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::LOGBRUSH {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::LOGBRUSH) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Logbrush32 {
    pub lb_style: u32,
    pub lb_color: u32,
    pub lb_hatch: u32,
}
impl Logbrush32 {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::LOGBRUSH32 {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::LOGBRUSH32) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Logfonta {
    pub lf_height: i32,
    pub lf_width: i32,
    pub lf_escapement: i32,
    pub lf_orientation: i32,
    pub lf_weight: i32,
    pub lf_italic: u8,
    pub lf_underline: u8,
    pub lf_strike_out: u8,
    pub lf_char_set: u8,
    pub lf_out_precision: u8,
    pub lf_clip_precision: u8,
    pub lf_quality: u8,
    pub lf_pitch_and_family: u8,
    pub lf_face_name: [CHAR; 32],
}
impl Logfonta {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::LOGFONTA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::LOGFONTA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Logfontw {
    pub lf_height: i32,
    pub lf_width: i32,
    pub lf_escapement: i32,
    pub lf_orientation: i32,
    pub lf_weight: i32,
    pub lf_italic: u8,
    pub lf_underline: u8,
    pub lf_strike_out: u8,
    pub lf_char_set: u8,
    pub lf_out_precision: u8,
    pub lf_clip_precision: u8,
    pub lf_quality: u8,
    pub lf_pitch_and_family: u8,
    pub lf_face_name: [u16; 32],
}
impl Logfontw {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::LOGFONTW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::LOGFONTW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Logpalette {
    pub pal_version: u16,
    pub pal_num_entries: u16,
    pub pal_pal_entry: [Paletteentry; 1],
}
impl Logpalette {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::LOGPALETTE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::LOGPALETTE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Logpen {
    pub lopn_style: u32,
    pub lopn_width: Point,
    pub lopn_color: u32,
}
impl Logpen {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::LOGPEN {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::LOGPEN) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Luid {
    pub low_part: u32,
    pub high_part: i32,
}
impl Luid {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::LUID {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::LUID) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvbkimagea<'a> {
    pub ul_flags: u32,
    pub hbm: Option<Hbitmap>,
    pub psz_image: Cow<'a, CStr>,
    pub cch_image_max: u32,
    pub x_offset_percent: i32,
    pub y_offset_percent: i32,
}
impl<'a> Lvbkimagea<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVBKIMAGEA {
        let Self { ul_flags, hbm, psz_image, cch_image_max, x_offset_percent, y_offset_percent } = self;
        let ulFlags = *ul_flags;
        let hbm = hbm.map_or(0, Hbitmap::into_raw);
        let pszImage = psz_image.as_ptr() as _;
        let cchImageMax = *cch_image_max;
        let xOffsetPercent = *x_offset_percent;
        let yOffsetPercent = *y_offset_percent;
        windows_sys::Win32::UI::Controls::LVBKIMAGEA { ulFlags, hbm, pszImage, cchImageMax, xOffsetPercent, yOffsetPercent }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVBKIMAGEA) -> Self {
        let windows_sys::Win32::UI::Controls::LVBKIMAGEA { ulFlags, hbm, pszImage, cchImageMax, xOffsetPercent, yOffsetPercent } = win32;
        let ul_flags = ulFlags;
        let hbm = unsafe { Hbitmap::new_optional(hbm) };
        let pszImage = unsafe { CStr::from_ptr(pszImage as *const _) };
        let pszImage = pszImage.to_bytes_with_nul().to_vec();
        let psz_image = Cow::Owned(unsafe { CString::from_vec_unchecked(pszImage) });
        let cch_image_max = cchImageMax;
        let x_offset_percent = xOffsetPercent;
        let y_offset_percent = yOffsetPercent;
        Self { ul_flags, hbm, psz_image, cch_image_max, x_offset_percent, y_offset_percent }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvbkimagew<'a> {
    pub ul_flags: u32,
    pub hbm: Option<Hbitmap>,
    pub psz_image: Cow<'a, [u16]>,
    pub cch_image_max: u32,
    pub x_offset_percent: i32,
    pub y_offset_percent: i32,
}
impl<'a> Lvbkimagew<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVBKIMAGEW {
        let Self { ul_flags, hbm, psz_image, cch_image_max, x_offset_percent, y_offset_percent } = self;
        let ulFlags = *ul_flags;
        let hbm = hbm.map_or(0, Hbitmap::into_raw);
        assert_eq!(psz_image.last().copied(), Some(0));
        let pszImage = psz_image.as_ptr() as _;
        let cchImageMax = *cch_image_max;
        let xOffsetPercent = *x_offset_percent;
        let yOffsetPercent = *y_offset_percent;
        windows_sys::Win32::UI::Controls::LVBKIMAGEW { ulFlags, hbm, pszImage, cchImageMax, xOffsetPercent, yOffsetPercent }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVBKIMAGEW) -> Self {
        let windows_sys::Win32::UI::Controls::LVBKIMAGEW { ulFlags, hbm, pszImage, cchImageMax, xOffsetPercent, yOffsetPercent } = win32;
        let ul_flags = ulFlags;
        let hbm = unsafe { Hbitmap::new_optional(hbm) };
        let slen = unsafe { wide_strlen(pszImage as *const u16) };
        let pszImage = unsafe { slice::from_raw_parts(pszImage, slen + 1) };
        let psz_image = Cow::Owned(pszImage.to_vec());
        let cch_image_max = cchImageMax;
        let x_offset_percent = xOffsetPercent;
        let y_offset_percent = yOffsetPercent;
        Self { ul_flags, hbm, psz_image, cch_image_max, x_offset_percent, y_offset_percent }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvcolumna<'a> {
    pub mask: u32,
    pub fmt: u32,
    pub cx: i32,
    pub psz_text: Cow<'a, CStr>,
    pub cch_text_max: i32,
    pub i_sub_item: i32,
    pub i_image: i32,
    pub i_order: i32,
    pub cx_min: i32,
    pub cx_default: i32,
    pub cx_ideal: i32,
}
impl<'a> Lvcolumna<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVCOLUMNA {
        let Self { mask, fmt, cx, psz_text, cch_text_max, i_sub_item, i_image, i_order, cx_min, cx_default, cx_ideal } = self;
        let mask = *mask;
        let fmt = *fmt;
        let cx = *cx;
        let pszText = psz_text.as_ptr() as _;
        let cchTextMax = *cch_text_max;
        let iSubItem = *i_sub_item;
        let iImage = *i_image;
        let iOrder = *i_order;
        let cxMin = *cx_min;
        let cxDefault = *cx_default;
        let cxIdeal = *cx_ideal;
        windows_sys::Win32::UI::Controls::LVCOLUMNA { mask, fmt, cx, pszText, cchTextMax, iSubItem, iImage, iOrder, cxMin, cxDefault, cxIdeal }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVCOLUMNA) -> Self {
        let windows_sys::Win32::UI::Controls::LVCOLUMNA { mask, fmt, cx, pszText, cchTextMax, iSubItem, iImage, iOrder, cxMin, cxDefault, cxIdeal } = win32;
        let mask = mask;
        let fmt = fmt;
        let cx = cx;
        let pszText = unsafe { CStr::from_ptr(pszText as *const _) };
        let pszText = pszText.to_bytes_with_nul().to_vec();
        let psz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(pszText) });
        let cch_text_max = cchTextMax;
        let i_sub_item = iSubItem;
        let i_image = iImage;
        let i_order = iOrder;
        let cx_min = cxMin;
        let cx_default = cxDefault;
        let cx_ideal = cxIdeal;
        Self { mask, fmt, cx, psz_text, cch_text_max, i_sub_item, i_image, i_order, cx_min, cx_default, cx_ideal }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvcolumnw<'a> {
    pub mask: u32,
    pub fmt: u32,
    pub cx: i32,
    pub psz_text: Cow<'a, [u16]>,
    pub cch_text_max: i32,
    pub i_sub_item: i32,
    pub i_image: i32,
    pub i_order: i32,
    pub cx_min: i32,
    pub cx_default: i32,
    pub cx_ideal: i32,
}
impl<'a> Lvcolumnw<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVCOLUMNW {
        let Self { mask, fmt, cx, psz_text, cch_text_max, i_sub_item, i_image, i_order, cx_min, cx_default, cx_ideal } = self;
        let mask = *mask;
        let fmt = *fmt;
        let cx = *cx;
        assert_eq!(psz_text.last().copied(), Some(0));
        let pszText = psz_text.as_ptr() as _;
        let cchTextMax = *cch_text_max;
        let iSubItem = *i_sub_item;
        let iImage = *i_image;
        let iOrder = *i_order;
        let cxMin = *cx_min;
        let cxDefault = *cx_default;
        let cxIdeal = *cx_ideal;
        windows_sys::Win32::UI::Controls::LVCOLUMNW { mask, fmt, cx, pszText, cchTextMax, iSubItem, iImage, iOrder, cxMin, cxDefault, cxIdeal }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVCOLUMNW) -> Self {
        let windows_sys::Win32::UI::Controls::LVCOLUMNW { mask, fmt, cx, pszText, cchTextMax, iSubItem, iImage, iOrder, cxMin, cxDefault, cxIdeal } = win32;
        let mask = mask;
        let fmt = fmt;
        let cx = cx;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = Cow::Owned(pszText.to_vec());
        let cch_text_max = cchTextMax;
        let i_sub_item = iSubItem;
        let i_image = iImage;
        let i_order = iOrder;
        let cx_min = cxMin;
        let cx_default = cxDefault;
        let cx_ideal = cxIdeal;
        Self { mask, fmt, cx, psz_text, cch_text_max, i_sub_item, i_image, i_order, cx_min, cx_default, cx_ideal }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvfindinfoa<'a> {
    pub flags: u32,
    pub psz: Cow<'a, CStr>,
    pub l_param: Lparam,
    pub pt: Point,
    pub vk_direction: u32,
}
impl<'a> Lvfindinfoa<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVFINDINFOA {
        let Self { flags, psz, l_param, pt, vk_direction } = self;
        let flags = *flags;
        let psz = psz.as_ptr() as _;
        let lParam = l_param.into_inner();
        let pt = pt.to_win32();
        let vkDirection = *vk_direction;
        windows_sys::Win32::UI::Controls::LVFINDINFOA { flags, psz, lParam, pt, vkDirection }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVFINDINFOA) -> Self {
        let windows_sys::Win32::UI::Controls::LVFINDINFOA { flags, psz, lParam, pt, vkDirection } = win32;
        let flags = flags;
        let psz = unsafe { CStr::from_ptr(psz as *const _) };
        let psz = psz.to_bytes_with_nul().to_vec();
        let psz = Cow::Owned(unsafe { CString::from_vec_unchecked(psz) });
        let l_param = unsafe { Lparam::from_inner(lParam) };
        let pt = unsafe { Point::from_win32(pt) };
        let vk_direction = vkDirection;
        Self { flags, psz, l_param, pt, vk_direction }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvfindinfow<'a> {
    pub flags: u32,
    pub psz: Cow<'a, [u16]>,
    pub l_param: Lparam,
    pub pt: Point,
    pub vk_direction: u32,
}
impl<'a> Lvfindinfow<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVFINDINFOW {
        let Self { flags, psz, l_param, pt, vk_direction } = self;
        let flags = *flags;
        assert_eq!(psz.last().copied(), Some(0));
        let psz = psz.as_ptr() as _;
        let lParam = l_param.into_inner();
        let pt = pt.to_win32();
        let vkDirection = *vk_direction;
        windows_sys::Win32::UI::Controls::LVFINDINFOW { flags, psz, lParam, pt, vkDirection }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVFINDINFOW) -> Self {
        let windows_sys::Win32::UI::Controls::LVFINDINFOW { flags, psz, lParam, pt, vkDirection } = win32;
        let flags = flags;
        let slen = unsafe { wide_strlen(psz as *const u16) };
        let psz = unsafe { slice::from_raw_parts(psz, slen + 1) };
        let psz = Cow::Owned(psz.to_vec());
        let l_param = unsafe { Lparam::from_inner(lParam) };
        let pt = unsafe { Point::from_win32(pt) };
        let vk_direction = vkDirection;
        Self { flags, psz, l_param, pt, vk_direction }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvfooterinfo<'a> {
    pub mask: u32,
    pub psz_text: Cow<'a, [u16]>,
    pub cch_text_max: i32,
    pub c_items: u32,
}
impl<'a> Lvfooterinfo<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVFOOTERINFO {
        let Self { mask, psz_text, cch_text_max, c_items } = self;
        let mask = *mask;
        assert_eq!(psz_text.last().copied(), Some(0));
        let pszText = psz_text.as_ptr() as _;
        let cchTextMax = *cch_text_max;
        let cItems = *c_items;
        windows_sys::Win32::UI::Controls::LVFOOTERINFO { mask, pszText, cchTextMax, cItems }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVFOOTERINFO) -> Self {
        let windows_sys::Win32::UI::Controls::LVFOOTERINFO { mask, pszText, cchTextMax, cItems } = win32;
        let mask = mask;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = Cow::Owned(pszText.to_vec());
        let cch_text_max = cchTextMax;
        let c_items = cItems;
        Self { mask, psz_text, cch_text_max, c_items }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvfooteritem<'a> {
    pub mask: u32,
    pub i_item: i32,
    pub psz_text: Cow<'a, [u16]>,
    pub cch_text_max: i32,
    pub state: u32,
    pub state_mask: u32,
}
impl<'a> Lvfooteritem<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVFOOTERITEM {
        let Self { mask, i_item, psz_text, cch_text_max, state, state_mask } = self;
        let mask = *mask;
        let iItem = *i_item;
        assert_eq!(psz_text.last().copied(), Some(0));
        let pszText = psz_text.as_ptr() as _;
        let cchTextMax = *cch_text_max;
        let state = *state;
        let stateMask = *state_mask;
        windows_sys::Win32::UI::Controls::LVFOOTERITEM { mask, iItem, pszText, cchTextMax, state, stateMask }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVFOOTERITEM) -> Self {
        let windows_sys::Win32::UI::Controls::LVFOOTERITEM { mask, iItem, pszText, cchTextMax, state, stateMask } = win32;
        let mask = mask;
        let i_item = iItem;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = Cow::Owned(pszText.to_vec());
        let cch_text_max = cchTextMax;
        let state = state;
        let state_mask = stateMask;
        Self { mask, i_item, psz_text, cch_text_max, state, state_mask }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvgroup<'a> {
    pub cb_size: u32,
    pub mask: u32,
    pub psz_header: Cow<'a, [u16]>,
    pub cch_header: i32,
    pub psz_footer: Cow<'a, [u16]>,
    pub cch_footer: i32,
    pub i_group_id: i32,
    pub state_mask: u32,
    pub state: u32,
    pub u_align: u32,
    pub psz_subtitle: Cow<'a, [u16]>,
    pub cch_subtitle: u32,
    pub psz_task: Cow<'a, [u16]>,
    pub cch_task: u32,
    pub psz_description_top: Cow<'a, [u16]>,
    pub cch_description_top: u32,
    pub psz_description_bottom: Cow<'a, [u16]>,
    pub cch_description_bottom: u32,
    pub i_title_image: i32,
    pub i_extended_image: i32,
    pub i_first_item: i32,
    pub c_items: u32,
    pub psz_subset_title: Cow<'a, [u16]>,
    pub cch_subset_title: u32,
}
impl<'a> Lvgroup<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVGROUP {
        let Self { cb_size, mask, psz_header, cch_header, psz_footer, cch_footer, i_group_id, state_mask, state, u_align, psz_subtitle, cch_subtitle, psz_task, cch_task, psz_description_top, cch_description_top, psz_description_bottom, cch_description_bottom, i_title_image, i_extended_image, i_first_item, c_items, psz_subset_title, cch_subset_title } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::LVGROUP>() as _;
        let mask = *mask;
        assert_eq!(psz_header.last().copied(), Some(0));
        let pszHeader = psz_header.as_ptr() as _;
        let cchHeader = *cch_header;
        assert_eq!(psz_footer.last().copied(), Some(0));
        let pszFooter = psz_footer.as_ptr() as _;
        let cchFooter = *cch_footer;
        let iGroupId = *i_group_id;
        let stateMask = *state_mask;
        let state = *state;
        let uAlign = *u_align;
        assert_eq!(psz_subtitle.last().copied(), Some(0));
        let pszSubtitle = psz_subtitle.as_ptr() as _;
        let cchSubtitle = *cch_subtitle;
        assert_eq!(psz_task.last().copied(), Some(0));
        let pszTask = psz_task.as_ptr() as _;
        let cchTask = *cch_task;
        assert_eq!(psz_description_top.last().copied(), Some(0));
        let pszDescriptionTop = psz_description_top.as_ptr() as _;
        let cchDescriptionTop = *cch_description_top;
        assert_eq!(psz_description_bottom.last().copied(), Some(0));
        let pszDescriptionBottom = psz_description_bottom.as_ptr() as _;
        let cchDescriptionBottom = *cch_description_bottom;
        let iTitleImage = *i_title_image;
        let iExtendedImage = *i_extended_image;
        let iFirstItem = *i_first_item;
        let cItems = *c_items;
        assert_eq!(psz_subset_title.last().copied(), Some(0));
        let pszSubsetTitle = psz_subset_title.as_ptr() as _;
        let cchSubsetTitle = *cch_subset_title;
        windows_sys::Win32::UI::Controls::LVGROUP { cbSize, mask, pszHeader, cchHeader, pszFooter, cchFooter, iGroupId, stateMask, state, uAlign, pszSubtitle, cchSubtitle, pszTask, cchTask, pszDescriptionTop, cchDescriptionTop, pszDescriptionBottom, cchDescriptionBottom, iTitleImage, iExtendedImage, iFirstItem, cItems, pszSubsetTitle, cchSubsetTitle }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVGROUP) -> Self {
        let windows_sys::Win32::UI::Controls::LVGROUP { cbSize, mask, pszHeader, cchHeader, pszFooter, cchFooter, iGroupId, stateMask, state, uAlign, pszSubtitle, cchSubtitle, pszTask, cchTask, pszDescriptionTop, cchDescriptionTop, pszDescriptionBottom, cchDescriptionBottom, iTitleImage, iExtendedImage, iFirstItem, cItems, pszSubsetTitle, cchSubsetTitle } = win32;
        let cb_size = cbSize;
        let mask = mask;
        let slen = unsafe { wide_strlen(pszHeader as *const u16) };
        let pszHeader = unsafe { slice::from_raw_parts(pszHeader, slen + 1) };
        let psz_header = Cow::Owned(pszHeader.to_vec());
        let cch_header = cchHeader;
        let slen = unsafe { wide_strlen(pszFooter as *const u16) };
        let pszFooter = unsafe { slice::from_raw_parts(pszFooter, slen + 1) };
        let psz_footer = Cow::Owned(pszFooter.to_vec());
        let cch_footer = cchFooter;
        let i_group_id = iGroupId;
        let state_mask = stateMask;
        let state = state;
        let u_align = uAlign;
        let slen = unsafe { wide_strlen(pszSubtitle as *const u16) };
        let pszSubtitle = unsafe { slice::from_raw_parts(pszSubtitle, slen + 1) };
        let psz_subtitle = Cow::Owned(pszSubtitle.to_vec());
        let cch_subtitle = cchSubtitle;
        let slen = unsafe { wide_strlen(pszTask as *const u16) };
        let pszTask = unsafe { slice::from_raw_parts(pszTask, slen + 1) };
        let psz_task = Cow::Owned(pszTask.to_vec());
        let cch_task = cchTask;
        let slen = unsafe { wide_strlen(pszDescriptionTop as *const u16) };
        let pszDescriptionTop = unsafe { slice::from_raw_parts(pszDescriptionTop, slen + 1) };
        let psz_description_top = Cow::Owned(pszDescriptionTop.to_vec());
        let cch_description_top = cchDescriptionTop;
        let slen = unsafe { wide_strlen(pszDescriptionBottom as *const u16) };
        let pszDescriptionBottom = unsafe { slice::from_raw_parts(pszDescriptionBottom, slen + 1) };
        let psz_description_bottom = Cow::Owned(pszDescriptionBottom.to_vec());
        let cch_description_bottom = cchDescriptionBottom;
        let i_title_image = iTitleImage;
        let i_extended_image = iExtendedImage;
        let i_first_item = iFirstItem;
        let c_items = cItems;
        let slen = unsafe { wide_strlen(pszSubsetTitle as *const u16) };
        let pszSubsetTitle = unsafe { slice::from_raw_parts(pszSubsetTitle, slen + 1) };
        let psz_subset_title = Cow::Owned(pszSubsetTitle.to_vec());
        let cch_subset_title = cchSubsetTitle;
        Self { cb_size, mask, psz_header, cch_header, psz_footer, cch_footer, i_group_id, state_mask, state, u_align, psz_subtitle, cch_subtitle, psz_task, cch_task, psz_description_top, cch_description_top, psz_description_bottom, cch_description_bottom, i_title_image, i_extended_image, i_first_item, c_items, psz_subset_title, cch_subset_title }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvgroupmetrics {
    pub cb_size: u32,
    pub mask: u32,
    pub left: u32,
    pub top: u32,
    pub right: u32,
    pub bottom: u32,
    pub cr_left: u32,
    pub cr_top: u32,
    pub cr_right: u32,
    pub cr_bottom: u32,
    pub cr_header: u32,
    pub cr_footer: u32,
}
impl Lvgroupmetrics {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVGROUPMETRICS {
        let Self { cb_size, mask, left, top, right, bottom, cr_left, cr_top, cr_right, cr_bottom, cr_header, cr_footer } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::LVGROUPMETRICS>() as _;
        let mask = *mask;
        let Left = *left;
        let Top = *top;
        let Right = *right;
        let Bottom = *bottom;
        let crLeft = *cr_left;
        let crTop = *cr_top;
        let crRight = *cr_right;
        let crBottom = *cr_bottom;
        let crHeader = *cr_header;
        let crFooter = *cr_footer;
        windows_sys::Win32::UI::Controls::LVGROUPMETRICS { cbSize, mask, Left, Top, Right, Bottom, crLeft, crTop, crRight, crBottom, crHeader, crFooter }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVGROUPMETRICS) -> Self {
        let windows_sys::Win32::UI::Controls::LVGROUPMETRICS { cbSize, mask, Left, Top, Right, Bottom, crLeft, crTop, crRight, crBottom, crHeader, crFooter } = win32;
        let cb_size = cbSize;
        let mask = mask;
        let left = Left;
        let top = Top;
        let right = Right;
        let bottom = Bottom;
        let cr_left = crLeft;
        let cr_top = crTop;
        let cr_right = crRight;
        let cr_bottom = crBottom;
        let cr_header = crHeader;
        let cr_footer = crFooter;
        Self { cb_size, mask, left, top, right, bottom, cr_left, cr_top, cr_right, cr_bottom, cr_header, cr_footer }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvhittestinfo {
    pub pt: Point,
    pub flags: u32,
    pub i_item: i32,
    pub i_sub_item: i32,
    pub i_group: i32,
}
impl Lvhittestinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVHITTESTINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVHITTESTINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
//  Not generated due to containing a void type
//  #[derive(Debug, PartialEq, Default)]
//  #[repr(C)]
//  pub struct Lvinsertgroupsorted<'a> {
//      pub pfn_group_compare: Option<unsafe extern "system" fn(i32, i32, *mut c_void) -> i32>,
//      pub pv_data: &'a mut todo_void,
//      pub lv_group: Lvgroup<'a>,
//  }
//  impl<'a> Lvinsertgroupsorted<'a> {
//      fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVINSERTGROUPSORTED {
//          let Self { pfn_group_compare, pv_data, lv_group } = self;
//          let pfnGroupCompare = *pfn_group_compare;
//          let pvData = unsafe { &mut *(pv_data as *mut _ as *mut _) };
//          let lvGroup = lv_group.to_win32();
//          windows_sys::Win32::UI::Controls::LVINSERTGROUPSORTED { pfnGroupCompare, pvData, lvGroup }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVINSERTGROUPSORTED) -> Self {
//          let windows_sys::Win32::UI::Controls::LVINSERTGROUPSORTED { pfnGroupCompare, pvData, lvGroup } = win32;
//          let pfn_group_compare = pfnGroupCompare;
//          let pv_data = unsafe { &mut *(pvData as *mut _ as *mut _) };
//          let lv_group = unsafe { Lvgroup::from_win32(lvGroup) };
//          Self { pfn_group_compare, pv_data, lv_group }
//      }
//  }
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvinsertmark {
    pub cb_size: u32,
    pub dw_flags: u32,
    pub i_item: i32,
    pub dw_reserved: u32,
}
impl Lvinsertmark {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVINSERTMARK {
        let Self { cb_size, dw_flags, i_item, dw_reserved } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::LVINSERTMARK>() as _;
        let dwFlags = *dw_flags;
        let iItem = *i_item;
        let dwReserved = *dw_reserved;
        windows_sys::Win32::UI::Controls::LVINSERTMARK { cbSize, dwFlags, iItem, dwReserved }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVINSERTMARK) -> Self {
        let windows_sys::Win32::UI::Controls::LVINSERTMARK { cbSize, dwFlags, iItem, dwReserved } = win32;
        let cb_size = cbSize;
        let dw_flags = dwFlags;
        let i_item = iItem;
        let dw_reserved = dwReserved;
        Self { cb_size, dw_flags, i_item, dw_reserved }
    }
}
#[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvitema<'a> {
    pub mask: u32,
    pub i_item: i32,
    pub i_sub_item: i32,
    pub state: u32,
    pub state_mask: u32,
    pub psz_text: Cow<'a, CStr>,
    pub cch_text_max: i32,
    pub i_image: i32,
    pub l_param: Lparam,
    pub i_indent: i32,
    pub i_group_id: i32,
    pub c_columns: u32,
    pub pu_columns: &'a mut u32,
    pub pi_col_fmt: &'a mut i32,
    pub i_group: i32,
}
impl<'a> Lvitema<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVITEMA {
        let Self { mask, i_item, i_sub_item, state, state_mask, psz_text, cch_text_max, i_image, l_param, i_indent, i_group_id, c_columns, pu_columns, pi_col_fmt, i_group } = self;
        let mask = *mask;
        let iItem = *i_item;
        let iSubItem = *i_sub_item;
        let state = *state;
        let stateMask = *state_mask;
        let pszText = psz_text.as_ptr() as _;
        let cchTextMax = *cch_text_max;
        let iImage = *i_image;
        let lParam = l_param.into_inner();
        let iIndent = *i_indent;
        let iGroupId = *i_group_id;
        let cColumns = *c_columns;
        let puColumns = unsafe { &mut *(pu_columns as *mut _ as *mut _) };
        let piColFmt = unsafe { &mut *(pi_col_fmt as *mut _ as *mut _) };
        let iGroup = *i_group;
        windows_sys::Win32::UI::Controls::LVITEMA { mask, iItem, iSubItem, state, stateMask, pszText, cchTextMax, iImage, lParam, iIndent, iGroupId, cColumns, puColumns, piColFmt, iGroup }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVITEMA) -> Self {
        let windows_sys::Win32::UI::Controls::LVITEMA { mask, iItem, iSubItem, state, stateMask, pszText, cchTextMax, iImage, lParam, iIndent, iGroupId, cColumns, puColumns, piColFmt, iGroup } = win32;
        let mask = mask;
        let i_item = iItem;
        let i_sub_item = iSubItem;
        let state = state;
        let state_mask = stateMask;
        let pszText = unsafe { CStr::from_ptr(pszText as *const _) };
        let pszText = pszText.to_bytes_with_nul().to_vec();
        let psz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(pszText) });
        let cch_text_max = cchTextMax;
        let i_image = iImage;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        let i_indent = iIndent;
        let i_group_id = iGroupId;
        let c_columns = cColumns;
        let pu_columns = unsafe { &mut *(puColumns as *mut _ as *mut _) };
        let pi_col_fmt = unsafe { &mut *(piColFmt as *mut _ as *mut _) };
        let i_group = iGroup;
        Self { mask, i_item, i_sub_item, state, state_mask, psz_text, cch_text_max, i_image, l_param, i_indent, i_group_id, c_columns, pu_columns, pi_col_fmt, i_group }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvitemindex {
    pub i_item: i32,
    pub i_group: i32,
}
impl Lvitemindex {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVITEMINDEX {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVITEMINDEX) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvitemw<'a> {
    pub mask: u32,
    pub i_item: i32,
    pub i_sub_item: i32,
    pub state: u32,
    pub state_mask: u32,
    pub psz_text: Cow<'a, [u16]>,
    pub cch_text_max: i32,
    pub i_image: i32,
    pub l_param: Lparam,
    pub i_indent: i32,
    pub i_group_id: i32,
    pub c_columns: u32,
    pub pu_columns: &'a mut u32,
    pub pi_col_fmt: &'a mut i32,
    pub i_group: i32,
}
impl<'a> Lvitemw<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVITEMW {
        let Self { mask, i_item, i_sub_item, state, state_mask, psz_text, cch_text_max, i_image, l_param, i_indent, i_group_id, c_columns, pu_columns, pi_col_fmt, i_group } = self;
        let mask = *mask;
        let iItem = *i_item;
        let iSubItem = *i_sub_item;
        let state = *state;
        let stateMask = *state_mask;
        assert_eq!(psz_text.last().copied(), Some(0));
        let pszText = psz_text.as_ptr() as _;
        let cchTextMax = *cch_text_max;
        let iImage = *i_image;
        let lParam = l_param.into_inner();
        let iIndent = *i_indent;
        let iGroupId = *i_group_id;
        let cColumns = *c_columns;
        let puColumns = unsafe { &mut *(pu_columns as *mut _ as *mut _) };
        let piColFmt = unsafe { &mut *(pi_col_fmt as *mut _ as *mut _) };
        let iGroup = *i_group;
        windows_sys::Win32::UI::Controls::LVITEMW { mask, iItem, iSubItem, state, stateMask, pszText, cchTextMax, iImage, lParam, iIndent, iGroupId, cColumns, puColumns, piColFmt, iGroup }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVITEMW) -> Self {
        let windows_sys::Win32::UI::Controls::LVITEMW { mask, iItem, iSubItem, state, stateMask, pszText, cchTextMax, iImage, lParam, iIndent, iGroupId, cColumns, puColumns, piColFmt, iGroup } = win32;
        let mask = mask;
        let i_item = iItem;
        let i_sub_item = iSubItem;
        let state = state;
        let state_mask = stateMask;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = Cow::Owned(pszText.to_vec());
        let cch_text_max = cchTextMax;
        let i_image = iImage;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        let i_indent = iIndent;
        let i_group_id = iGroupId;
        let c_columns = cColumns;
        let pu_columns = unsafe { &mut *(puColumns as *mut _ as *mut _) };
        let pi_col_fmt = unsafe { &mut *(piColFmt as *mut _ as *mut _) };
        let i_group = iGroup;
        Self { mask, i_item, i_sub_item, state, state_mask, psz_text, cch_text_max, i_image, l_param, i_indent, i_group_id, c_columns, pu_columns, pi_col_fmt, i_group }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvsetinfotip<'a> {
    pub cb_size: u32,
    pub dw_flags: u32,
    pub psz_text: Cow<'a, [u16]>,
    pub i_item: i32,
    pub i_sub_item: i32,
}
impl<'a> Lvsetinfotip<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVSETINFOTIP {
        let Self { cb_size, dw_flags, psz_text, i_item, i_sub_item } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::LVSETINFOTIP>() as _;
        let dwFlags = *dw_flags;
        assert_eq!(psz_text.last().copied(), Some(0));
        let pszText = psz_text.as_ptr() as _;
        let iItem = *i_item;
        let iSubItem = *i_sub_item;
        windows_sys::Win32::UI::Controls::LVSETINFOTIP { cbSize, dwFlags, pszText, iItem, iSubItem }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVSETINFOTIP) -> Self {
        let windows_sys::Win32::UI::Controls::LVSETINFOTIP { cbSize, dwFlags, pszText, iItem, iSubItem } = win32;
        let cb_size = cbSize;
        let dw_flags = dwFlags;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = Cow::Owned(pszText.to_vec());
        let i_item = iItem;
        let i_sub_item = iSubItem;
        Self { cb_size, dw_flags, psz_text, i_item, i_sub_item }
    }
}
#[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvtileinfo<'a> {
    pub cb_size: u32,
    pub i_item: i32,
    pub c_columns: u32,
    pub pu_columns: &'a mut u32,
    pub pi_col_fmt: &'a mut i32,
}
impl<'a> Lvtileinfo<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVTILEINFO {
        let Self { cb_size, i_item, c_columns, pu_columns, pi_col_fmt } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::LVTILEINFO>() as _;
        let iItem = *i_item;
        let cColumns = *c_columns;
        let puColumns = unsafe { &mut *(pu_columns as *mut _ as *mut _) };
        let piColFmt = unsafe { &mut *(pi_col_fmt as *mut _ as *mut _) };
        windows_sys::Win32::UI::Controls::LVTILEINFO { cbSize, iItem, cColumns, puColumns, piColFmt }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVTILEINFO) -> Self {
        let windows_sys::Win32::UI::Controls::LVTILEINFO { cbSize, iItem, cColumns, puColumns, piColFmt } = win32;
        let cb_size = cbSize;
        let i_item = iItem;
        let c_columns = cColumns;
        let pu_columns = unsafe { &mut *(puColumns as *mut _ as *mut _) };
        let pi_col_fmt = unsafe { &mut *(piColFmt as *mut _ as *mut _) };
        Self { cb_size, i_item, c_columns, pu_columns, pi_col_fmt }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Lvtileviewinfo {
    pub cb_size: u32,
    pub dw_mask: u32,
    pub dw_flags: u32,
    pub size_tile: Size,
    pub c_lines: i32,
    pub rc_label_margin: Rect,
}
impl Lvtileviewinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::LVTILEVIEWINFO {
        let Self { cb_size, dw_mask, dw_flags, size_tile, c_lines, rc_label_margin } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::LVTILEVIEWINFO>() as _;
        let dwMask = *dw_mask;
        let dwFlags = *dw_flags;
        let sizeTile = size_tile.to_win32();
        let cLines = *c_lines;
        let rcLabelMargin = rc_label_margin.to_win32();
        windows_sys::Win32::UI::Controls::LVTILEVIEWINFO { cbSize, dwMask, dwFlags, sizeTile, cLines, rcLabelMargin }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::LVTILEVIEWINFO) -> Self {
        let windows_sys::Win32::UI::Controls::LVTILEVIEWINFO { cbSize, dwMask, dwFlags, sizeTile, cLines, rcLabelMargin } = win32;
        let cb_size = cbSize;
        let dw_mask = dwMask;
        let dw_flags = dwFlags;
        let size_tile = unsafe { Size::from_win32(sizeTile) };
        let c_lines = cLines;
        let rc_label_margin = unsafe { Rect::from_win32(rcLabelMargin) };
        Self { cb_size, dw_mask, dw_flags, size_tile, c_lines, rc_label_margin }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Margins {
    pub cx_left_width: i32,
    pub cx_right_width: i32,
    pub cy_top_height: i32,
    pub cy_bottom_height: i32,
}
impl Margins {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::MARGINS {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::MARGINS) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Mat2 {
    pub e_m11: Fixed,
    pub e_m12: Fixed,
    pub e_m21: Fixed,
    pub e_m22: Fixed,
}
impl Mat2 {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::MAT2 {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::MAT2) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Mcgridinfo<'a> {
    pub cb_size: u32,
    pub dw_part: u32,
    pub dw_flags: u32,
    pub i_calendar: i32,
    pub i_row: i32,
    pub i_col: i32,
    pub b_selected: BOOL,
    pub st_start: Systemtime,
    pub st_end: Systemtime,
    pub rc: Rect,
    pub psz_name: Cow<'a, [u16]>,
    pub cch_name: usize,
}
impl<'a> Mcgridinfo<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::MCGRIDINFO {
        let Self { cb_size, dw_part, dw_flags, i_calendar, i_row, i_col, b_selected, st_start, st_end, rc, psz_name, cch_name } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::MCGRIDINFO>() as _;
        let dwPart = *dw_part;
        let dwFlags = *dw_flags;
        let iCalendar = *i_calendar;
        let iRow = *i_row;
        let iCol = *i_col;
        let bSelected = *b_selected;
        let stStart = st_start.to_win32();
        let stEnd = st_end.to_win32();
        let rc = rc.to_win32();
        assert_eq!(psz_name.last().copied(), Some(0));
        let pszName = psz_name.as_ptr() as _;
        let cchName = *cch_name;
        windows_sys::Win32::UI::Controls::MCGRIDINFO { cbSize, dwPart, dwFlags, iCalendar, iRow, iCol, bSelected, stStart, stEnd, rc, pszName, cchName }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::MCGRIDINFO) -> Self {
        let windows_sys::Win32::UI::Controls::MCGRIDINFO { cbSize, dwPart, dwFlags, iCalendar, iRow, iCol, bSelected, stStart, stEnd, rc, pszName, cchName } = win32;
        let cb_size = cbSize;
        let dw_part = dwPart;
        let dw_flags = dwFlags;
        let i_calendar = iCalendar;
        let i_row = iRow;
        let i_col = iCol;
        let b_selected = bSelected;
        let st_start = unsafe { Systemtime::from_win32(stStart) };
        let st_end = unsafe { Systemtime::from_win32(stEnd) };
        let rc = unsafe { Rect::from_win32(rc) };
        let slen = unsafe { wide_strlen(pszName as *const u16) };
        let pszName = unsafe { slice::from_raw_parts(pszName, slen + 1) };
        let psz_name = Cow::Owned(pszName.to_vec());
        let cch_name = cchName;
        Self { cb_size, dw_part, dw_flags, i_calendar, i_row, i_col, b_selected, st_start, st_end, rc, psz_name, cch_name }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Mchittestinfo {
    pub cb_size: u32,
    pub pt: Point,
    pub u_hit: u32,
    pub st: Systemtime,
    pub rc: Rect,
    pub i_offset: i32,
    pub i_row: i32,
    pub i_col: i32,
}
impl Mchittestinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::MCHITTESTINFO {
        let Self { cb_size, pt, u_hit, st, rc, i_offset, i_row, i_col } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::MCHITTESTINFO>() as _;
        let pt = pt.to_win32();
        let uHit = *u_hit;
        let st = st.to_win32();
        let rc = rc.to_win32();
        let iOffset = *i_offset;
        let iRow = *i_row;
        let iCol = *i_col;
        windows_sys::Win32::UI::Controls::MCHITTESTINFO { cbSize, pt, uHit, st, rc, iOffset, iRow, iCol }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::MCHITTESTINFO) -> Self {
        let windows_sys::Win32::UI::Controls::MCHITTESTINFO { cbSize, pt, uHit, st, rc, iOffset, iRow, iCol } = win32;
        let cb_size = cbSize;
        let pt = unsafe { Point::from_win32(pt) };
        let u_hit = uHit;
        let st = unsafe { Systemtime::from_win32(st) };
        let rc = unsafe { Rect::from_win32(rc) };
        let i_offset = iOffset;
        let i_row = iRow;
        let i_col = iCol;
        Self { cb_size, pt, u_hit, st, rc, i_offset, i_row, i_col }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Mdicreatestructa<'a> {
    pub sz_class: Cow<'a, CStr>,
    pub sz_title: Cow<'a, CStr>,
    pub h_owner: Option<Handle>,
    pub x: i32,
    pub y: i32,
    pub cx: i32,
    pub cy: i32,
    pub style: u32,
    pub l_param: Lparam,
}
impl<'a> Mdicreatestructa<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MDICREATESTRUCTA {
        let Self { sz_class, sz_title, h_owner, x, y, cx, cy, style, l_param } = self;
        let szClass = sz_class.as_ptr() as _;
        let szTitle = sz_title.as_ptr() as _;
        let hOwner = h_owner.map_or(0, Handle::into_raw);
        let x = *x;
        let y = *y;
        let cx = *cx;
        let cy = *cy;
        let style = *style;
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::WindowsAndMessaging::MDICREATESTRUCTA { szClass, szTitle, hOwner, x, y, cx, cy, style, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MDICREATESTRUCTA) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::MDICREATESTRUCTA { szClass, szTitle, hOwner, x, y, cx, cy, style, lParam } = win32;
        let szClass = unsafe { CStr::from_ptr(szClass as *const _) };
        let szClass = szClass.to_bytes_with_nul().to_vec();
        let sz_class = Cow::Owned(unsafe { CString::from_vec_unchecked(szClass) });
        let szTitle = unsafe { CStr::from_ptr(szTitle as *const _) };
        let szTitle = szTitle.to_bytes_with_nul().to_vec();
        let sz_title = Cow::Owned(unsafe { CString::from_vec_unchecked(szTitle) });
        let h_owner = unsafe { Handle::new_optional(hOwner) };
        let x = x;
        let y = y;
        let cx = cx;
        let cy = cy;
        let style = style;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { sz_class, sz_title, h_owner, x, y, cx, cy, style, l_param }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Mdicreatestructw<'a> {
    pub sz_class: Cow<'a, [u16]>,
    pub sz_title: Cow<'a, [u16]>,
    pub h_owner: Option<Handle>,
    pub x: i32,
    pub y: i32,
    pub cx: i32,
    pub cy: i32,
    pub style: u32,
    pub l_param: Lparam,
}
impl<'a> Mdicreatestructw<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MDICREATESTRUCTW {
        let Self { sz_class, sz_title, h_owner, x, y, cx, cy, style, l_param } = self;
        assert_eq!(sz_class.last().copied(), Some(0));
        let szClass = sz_class.as_ptr() as _;
        assert_eq!(sz_title.last().copied(), Some(0));
        let szTitle = sz_title.as_ptr() as _;
        let hOwner = h_owner.map_or(0, Handle::into_raw);
        let x = *x;
        let y = *y;
        let cx = *cx;
        let cy = *cy;
        let style = *style;
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::WindowsAndMessaging::MDICREATESTRUCTW { szClass, szTitle, hOwner, x, y, cx, cy, style, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MDICREATESTRUCTW) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::MDICREATESTRUCTW { szClass, szTitle, hOwner, x, y, cx, cy, style, lParam } = win32;
        let slen = unsafe { wide_strlen(szClass as *const u16) };
        let szClass = unsafe { slice::from_raw_parts(szClass, slen + 1) };
        let sz_class = Cow::Owned(szClass.to_vec());
        let slen = unsafe { wide_strlen(szTitle as *const u16) };
        let szTitle = unsafe { slice::from_raw_parts(szTitle, slen + 1) };
        let sz_title = Cow::Owned(szTitle.to_vec());
        let h_owner = unsafe { Handle::new_optional(hOwner) };
        let x = x;
        let y = y;
        let cx = cx;
        let cy = cy;
        let style = style;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { sz_class, sz_title, h_owner, x, y, cx, cy, style, l_param }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Mdinextmenu {
    pub hmenu_in: Option<Hmenu>,
    pub hmenu_next: Option<Hmenu>,
    pub hwnd_next: Option<Hwnd>,
}
impl Mdinextmenu {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MDINEXTMENU {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MDINEXTMENU) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Measureitemstruct {
    pub ctl_type: u32,
    pub ctl_id: u32,
    pub item_id: u32,
    pub item_width: u32,
    pub item_height: u32,
    pub item_data: usize,
}
impl Measureitemstruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::MEASUREITEMSTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::MEASUREITEMSTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Menubarinfo {
    pub cb_size: u32,
    pub rc_bar: Rect,
    pub h_menu: Option<Hmenu>,
    pub hwnd_menu: Option<Hwnd>,
    pub bitfield: i32,
}
impl Menubarinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MENUBARINFO {
        let Self { cb_size, rc_bar, h_menu, hwnd_menu, bitfield } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::MENUBARINFO>() as _;
        let rcBar = rc_bar.to_win32();
        let hMenu = h_menu.map_or(0, Hmenu::into_raw);
        let hwndMenu = hwnd_menu.map_or(0, Hwnd::into_raw);
        let _bitfield = *bitfield;
        windows_sys::Win32::UI::WindowsAndMessaging::MENUBARINFO { cbSize, rcBar, hMenu, hwndMenu, _bitfield }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MENUBARINFO) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::MENUBARINFO { cbSize, rcBar, hMenu, hwndMenu, _bitfield } = win32;
        let cb_size = cbSize;
        let rc_bar = unsafe { Rect::from_win32(rcBar) };
        let h_menu = unsafe { Hmenu::new_optional(hMenu) };
        let hwnd_menu = unsafe { Hwnd::new_optional(hwndMenu) };
        let bitfield = _bitfield;
        Self { cb_size, rc_bar, h_menu, hwnd_menu, bitfield }
    }
}
//  Not generated due to containing a void type
//  #[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Menugetobjectinfo<'a> {
//      pub dw_flags: u32,
//      pub u_pos: u32,
//      pub hmenu: Option<Hmenu>,
//      pub riid: &'a mut todo_void,
//      pub pv_obj: &'a mut todo_void,
//  }
//  impl<'a> Menugetobjectinfo<'a> {
//      fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MENUGETOBJECTINFO {
//          let Self { dw_flags, u_pos, hmenu, riid, pv_obj } = self;
//          let dwFlags = *dw_flags;
//          let uPos = *u_pos;
//          let hmenu = hmenu.map_or(0, Hmenu::into_raw);
//          let riid = unsafe { &mut *(riid as *mut _ as *mut _) };
//          let pvObj = unsafe { &mut *(pv_obj as *mut _ as *mut _) };
//          windows_sys::Win32::UI::WindowsAndMessaging::MENUGETOBJECTINFO { dwFlags, uPos, hmenu, riid, pvObj }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MENUGETOBJECTINFO) -> Self {
//          let windows_sys::Win32::UI::WindowsAndMessaging::MENUGETOBJECTINFO { dwFlags, uPos, hmenu, riid, pvObj } = win32;
//          let dw_flags = dwFlags;
//          let u_pos = uPos;
//          let hmenu = unsafe { Hmenu::new_optional(hmenu) };
//          let riid = unsafe { &mut *(riid as *mut _ as *mut _) };
//          let pv_obj = unsafe { &mut *(pvObj as *mut _ as *mut _) };
//          Self { dw_flags, u_pos, hmenu, riid, pv_obj }
//      }
//  }
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Menuinfo {
    pub cb_size: u32,
    pub f_mask: u32,
    pub dw_style: u32,
    pub cy_max: u32,
    pub hbr_back: Option<Hbrush>,
    pub dw_context_help_id: u32,
    pub dw_menu_data: usize,
}
impl Menuinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MENUINFO {
        let Self { cb_size, f_mask, dw_style, cy_max, hbr_back, dw_context_help_id, dw_menu_data } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::MENUINFO>() as _;
        let fMask = *f_mask;
        let dwStyle = *dw_style;
        let cyMax = *cy_max;
        let hbrBack = hbr_back.map_or(0, Hbrush::into_raw);
        let dwContextHelpID = *dw_context_help_id;
        let dwMenuData = *dw_menu_data;
        windows_sys::Win32::UI::WindowsAndMessaging::MENUINFO { cbSize, fMask, dwStyle, cyMax, hbrBack, dwContextHelpID, dwMenuData }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MENUINFO) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::MENUINFO { cbSize, fMask, dwStyle, cyMax, hbrBack, dwContextHelpID, dwMenuData } = win32;
        let cb_size = cbSize;
        let f_mask = fMask;
        let dw_style = dwStyle;
        let cy_max = cyMax;
        let hbr_back = unsafe { Hbrush::new_optional(hbrBack) };
        let dw_context_help_id = dwContextHelpID;
        let dw_menu_data = dwMenuData;
        Self { cb_size, f_mask, dw_style, cy_max, hbr_back, dw_context_help_id, dw_menu_data }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Menuiteminfoa<'a> {
    pub cb_size: u32,
    pub f_mask: u32,
    pub f_type: u32,
    pub f_state: u32,
    pub w_id: u32,
    pub h_sub_menu: Option<Hmenu>,
    pub hbmp_checked: Option<Hbitmap>,
    pub hbmp_unchecked: Option<Hbitmap>,
    pub dw_item_data: usize,
    pub dw_type_data: Cow<'a, CStr>,
    pub cch: u32,
    pub hbmp_item: Option<Hbitmap>,
}
impl<'a> Menuiteminfoa<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMINFOA {
        let Self { cb_size, f_mask, f_type, f_state, w_id, h_sub_menu, hbmp_checked, hbmp_unchecked, dw_item_data, dw_type_data, cch, hbmp_item } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMINFOA>() as _;
        let fMask = *f_mask;
        let fType = *f_type;
        let fState = *f_state;
        let wID = *w_id;
        let hSubMenu = h_sub_menu.map_or(0, Hmenu::into_raw);
        let hbmpChecked = hbmp_checked.map_or(0, Hbitmap::into_raw);
        let hbmpUnchecked = hbmp_unchecked.map_or(0, Hbitmap::into_raw);
        let dwItemData = *dw_item_data;
        let dwTypeData = dw_type_data.as_ptr() as _;
        let cch = *cch;
        let hbmpItem = hbmp_item.map_or(0, Hbitmap::into_raw);
        windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMINFOA { cbSize, fMask, fType, fState, wID, hSubMenu, hbmpChecked, hbmpUnchecked, dwItemData, dwTypeData, cch, hbmpItem }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMINFOA) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMINFOA { cbSize, fMask, fType, fState, wID, hSubMenu, hbmpChecked, hbmpUnchecked, dwItemData, dwTypeData, cch, hbmpItem } = win32;
        let cb_size = cbSize;
        let f_mask = fMask;
        let f_type = fType;
        let f_state = fState;
        let w_id = wID;
        let h_sub_menu = unsafe { Hmenu::new_optional(hSubMenu) };
        let hbmp_checked = unsafe { Hbitmap::new_optional(hbmpChecked) };
        let hbmp_unchecked = unsafe { Hbitmap::new_optional(hbmpUnchecked) };
        let dw_item_data = dwItemData;
        let dwTypeData = unsafe { CStr::from_ptr(dwTypeData as *const _) };
        let dwTypeData = dwTypeData.to_bytes_with_nul().to_vec();
        let dw_type_data = Cow::Owned(unsafe { CString::from_vec_unchecked(dwTypeData) });
        let cch = cch;
        let hbmp_item = unsafe { Hbitmap::new_optional(hbmpItem) };
        Self { cb_size, f_mask, f_type, f_state, w_id, h_sub_menu, hbmp_checked, hbmp_unchecked, dw_item_data, dw_type_data, cch, hbmp_item }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Menuiteminfow<'a> {
    pub cb_size: u32,
    pub f_mask: u32,
    pub f_type: u32,
    pub f_state: u32,
    pub w_id: u32,
    pub h_sub_menu: Option<Hmenu>,
    pub hbmp_checked: Option<Hbitmap>,
    pub hbmp_unchecked: Option<Hbitmap>,
    pub dw_item_data: usize,
    pub dw_type_data: Cow<'a, [u16]>,
    pub cch: u32,
    pub hbmp_item: Option<Hbitmap>,
}
impl<'a> Menuiteminfow<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMINFOW {
        let Self { cb_size, f_mask, f_type, f_state, w_id, h_sub_menu, hbmp_checked, hbmp_unchecked, dw_item_data, dw_type_data, cch, hbmp_item } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMINFOW>() as _;
        let fMask = *f_mask;
        let fType = *f_type;
        let fState = *f_state;
        let wID = *w_id;
        let hSubMenu = h_sub_menu.map_or(0, Hmenu::into_raw);
        let hbmpChecked = hbmp_checked.map_or(0, Hbitmap::into_raw);
        let hbmpUnchecked = hbmp_unchecked.map_or(0, Hbitmap::into_raw);
        let dwItemData = *dw_item_data;
        assert_eq!(dw_type_data.last().copied(), Some(0));
        let dwTypeData = dw_type_data.as_ptr() as _;
        let cch = *cch;
        let hbmpItem = hbmp_item.map_or(0, Hbitmap::into_raw);
        windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMINFOW { cbSize, fMask, fType, fState, wID, hSubMenu, hbmpChecked, hbmpUnchecked, dwItemData, dwTypeData, cch, hbmpItem }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMINFOW) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMINFOW { cbSize, fMask, fType, fState, wID, hSubMenu, hbmpChecked, hbmpUnchecked, dwItemData, dwTypeData, cch, hbmpItem } = win32;
        let cb_size = cbSize;
        let f_mask = fMask;
        let f_type = fType;
        let f_state = fState;
        let w_id = wID;
        let h_sub_menu = unsafe { Hmenu::new_optional(hSubMenu) };
        let hbmp_checked = unsafe { Hbitmap::new_optional(hbmpChecked) };
        let hbmp_unchecked = unsafe { Hbitmap::new_optional(hbmpUnchecked) };
        let dw_item_data = dwItemData;
        let slen = unsafe { wide_strlen(dwTypeData as *const u16) };
        let dwTypeData = unsafe { slice::from_raw_parts(dwTypeData, slen + 1) };
        let dw_type_data = Cow::Owned(dwTypeData.to_vec());
        let cch = cch;
        let hbmp_item = unsafe { Hbitmap::new_optional(hbmpItem) };
        Self { cb_size, f_mask, f_type, f_state, w_id, h_sub_menu, hbmp_checked, hbmp_unchecked, dw_item_data, dw_type_data, cch, hbmp_item }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Menuitemtemplate {
    pub mt_option: u16,
    pub mt_id: u16,
    pub mt_string: [u8; 1],
}
impl Menuitemtemplate {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMTEMPLATE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMTEMPLATE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Menuitemtemplateheader {
    pub version_number: u16,
    pub offset: u16,
}
impl Menuitemtemplateheader {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMTEMPLATEHEADER {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MENUITEMTEMPLATEHEADER) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct MessageResourceBlock {
    pub low_id: u32,
    pub high_id: u32,
    pub offset_to_entries: u32,
}
impl MessageResourceBlock {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MESSAGE_RESOURCE_BLOCK {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MESSAGE_RESOURCE_BLOCK) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct MessageResourceData {
    pub number_of_blocks: u32,
    pub blocks: [MessageResourceBlock; 1],
}
impl MessageResourceData {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MESSAGE_RESOURCE_DATA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MESSAGE_RESOURCE_DATA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct MessageResourceEntry {
    pub length: u16,
    pub flags: u16,
    pub text: [u8; 1],
}
impl MessageResourceEntry {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MESSAGE_RESOURCE_ENTRY {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MESSAGE_RESOURCE_ENTRY) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(2))]
pub struct Metaheader {
    pub mt_type: u16,
    pub mt_header_size: u16,
    pub mt_version: u16,
    pub mt_size: u32,
    pub mt_no_objects: u16,
    pub mt_max_record: u32,
    pub mt_no_parameters: u16,
}
impl Metaheader {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::METAHEADER {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::METAHEADER) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Metarecord {
    pub rd_size: u32,
    pub rd_function: u16,
    pub rd_parm: [u16; 1],
}
impl Metarecord {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::METARECORD {
        let Self { rd_size, rd_function, rd_parm } = self;
        let rdSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::METARECORD>() as _;
        let rdFunction = *rd_function;
        let rdParm = [*&rd_parm[0]];
        windows_sys::Win32::Graphics::Gdi::METARECORD { rdSize, rdFunction, rdParm }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::METARECORD) -> Self {
        let windows_sys::Win32::Graphics::Gdi::METARECORD { rdSize, rdFunction, rdParm } = win32;
        let rd_size = rdSize;
        let rd_function = rdFunction;
        let rd_parm = [rdParm[0]];
        Self { rd_size, rd_function, rd_parm }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Minimizedmetrics {
    pub cb_size: u32,
    pub i_width: i32,
    pub i_horz_gap: i32,
    pub i_vert_gap: i32,
    pub i_arrange: i32,
}
impl Minimizedmetrics {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MINIMIZEDMETRICS {
        let Self { cb_size, i_width, i_horz_gap, i_vert_gap, i_arrange } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::MINIMIZEDMETRICS>() as _;
        let iWidth = *i_width;
        let iHorzGap = *i_horz_gap;
        let iVertGap = *i_vert_gap;
        let iArrange = *i_arrange;
        windows_sys::Win32::UI::WindowsAndMessaging::MINIMIZEDMETRICS { cbSize, iWidth, iHorzGap, iVertGap, iArrange }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MINIMIZEDMETRICS) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::MINIMIZEDMETRICS { cbSize, iWidth, iHorzGap, iVertGap, iArrange } = win32;
        let cb_size = cbSize;
        let i_width = iWidth;
        let i_horz_gap = iHorzGap;
        let i_vert_gap = iVertGap;
        let i_arrange = iArrange;
        Self { cb_size, i_width, i_horz_gap, i_vert_gap, i_arrange }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Minmaxinfo {
    pub pt_reserved: Point,
    pub pt_max_size: Point,
    pub pt_max_position: Point,
    pub pt_min_track_size: Point,
    pub pt_max_track_size: Point,
}
impl Minmaxinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MINMAXINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MINMAXINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Monitorinfo {
    pub cb_size: u32,
    pub rc_monitor: Rect,
    pub rc_work: Rect,
    pub dw_flags: u32,
}
impl Monitorinfo {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::MONITORINFO {
        let Self { cb_size, rc_monitor, rc_work, dw_flags } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::MONITORINFO>() as _;
        let rcMonitor = rc_monitor.to_win32();
        let rcWork = rc_work.to_win32();
        let dwFlags = *dw_flags;
        windows_sys::Win32::Graphics::Gdi::MONITORINFO { cbSize, rcMonitor, rcWork, dwFlags }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::MONITORINFO) -> Self {
        let windows_sys::Win32::Graphics::Gdi::MONITORINFO { cbSize, rcMonitor, rcWork, dwFlags } = win32;
        let cb_size = cbSize;
        let rc_monitor = unsafe { Rect::from_win32(rcMonitor) };
        let rc_work = unsafe { Rect::from_win32(rcWork) };
        let dw_flags = dwFlags;
        Self { cb_size, rc_monitor, rc_work, dw_flags }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Monitorinfoexa {
    pub monitor_info: Monitorinfo,
    pub sz_device: [CHAR; 32],
}
impl Monitorinfoexa {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::MONITORINFOEXA {
        let Self { monitor_info, sz_device } = self;
        let monitorInfo = monitor_info.to_win32();
        let szDevice = [*&sz_device[0],*&sz_device[1],*&sz_device[2],*&sz_device[3],*&sz_device[4],*&sz_device[5],*&sz_device[6],*&sz_device[7],*&sz_device[8],*&sz_device[9],*&sz_device[10],*&sz_device[11],*&sz_device[12],*&sz_device[13],*&sz_device[14],*&sz_device[15],*&sz_device[16],*&sz_device[17],*&sz_device[18],*&sz_device[19],*&sz_device[20],*&sz_device[21],*&sz_device[22],*&sz_device[23],*&sz_device[24],*&sz_device[25],*&sz_device[26],*&sz_device[27],*&sz_device[28],*&sz_device[29],*&sz_device[30],*&sz_device[31]];
        windows_sys::Win32::Graphics::Gdi::MONITORINFOEXA { monitorInfo, szDevice }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::MONITORINFOEXA) -> Self {
        let windows_sys::Win32::Graphics::Gdi::MONITORINFOEXA { monitorInfo, szDevice } = win32;
        let monitor_info = unsafe { Monitorinfo::from_win32(monitorInfo) };
        let sz_device = [szDevice[0],szDevice[1],szDevice[2],szDevice[3],szDevice[4],szDevice[5],szDevice[6],szDevice[7],szDevice[8],szDevice[9],szDevice[10],szDevice[11],szDevice[12],szDevice[13],szDevice[14],szDevice[15],szDevice[16],szDevice[17],szDevice[18],szDevice[19],szDevice[20],szDevice[21],szDevice[22],szDevice[23],szDevice[24],szDevice[25],szDevice[26],szDevice[27],szDevice[28],szDevice[29],szDevice[30],szDevice[31]];
        Self { monitor_info, sz_device }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Monitorinfoexw {
    pub monitor_info: Monitorinfo,
    pub sz_device: [u8; 32],
}
impl Monitorinfoexw {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::MONITORINFOEXW {
        let Self { monitor_info, sz_device } = self;
        let monitorInfo = monitor_info.to_win32();
        let szDevice = [*&sz_device[0],*&sz_device[1],*&sz_device[2],*&sz_device[3],*&sz_device[4],*&sz_device[5],*&sz_device[6],*&sz_device[7],*&sz_device[8],*&sz_device[9],*&sz_device[10],*&sz_device[11],*&sz_device[12],*&sz_device[13],*&sz_device[14],*&sz_device[15],*&sz_device[16],*&sz_device[17],*&sz_device[18],*&sz_device[19],*&sz_device[20],*&sz_device[21],*&sz_device[22],*&sz_device[23],*&sz_device[24],*&sz_device[25],*&sz_device[26],*&sz_device[27],*&sz_device[28],*&sz_device[29],*&sz_device[30],*&sz_device[31]];
        windows_sys::Win32::Graphics::Gdi::MONITORINFOEXW { monitorInfo, szDevice }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::MONITORINFOEXW) -> Self {
        let windows_sys::Win32::Graphics::Gdi::MONITORINFOEXW { monitorInfo, szDevice } = win32;
        let monitor_info = unsafe { Monitorinfo::from_win32(monitorInfo) };
        let sz_device = [szDevice[0],szDevice[1],szDevice[2],szDevice[3],szDevice[4],szDevice[5],szDevice[6],szDevice[7],szDevice[8],szDevice[9],szDevice[10],szDevice[11],szDevice[12],szDevice[13],szDevice[14],szDevice[15],szDevice[16],szDevice[17],szDevice[18],szDevice[19],szDevice[20],szDevice[21],szDevice[22],szDevice[23],szDevice[24],szDevice[25],szDevice[26],szDevice[27],szDevice[28],szDevice[29],szDevice[30],szDevice[31]];
        Self { monitor_info, sz_device }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Mousehookstruct {
    pub pt: Point,
    pub hwnd: Option<Hwnd>,
    pub w_hit_test_code: u32,
    pub dw_extra_info: usize,
}
impl Mousehookstruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MOUSEHOOKSTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MOUSEHOOKSTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Mousehookstructex {
    pub anonymous_base_winuser_l1166_c46: Mousehookstruct,
    pub mouse_data: u32,
}
impl Mousehookstructex {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MOUSEHOOKSTRUCTEX {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MOUSEHOOKSTRUCTEX) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Msg {
    pub hwnd: Option<Hwnd>,
    pub message: u32,
    pub w_param: Wparam,
    pub l_param: Lparam,
    pub time: u32,
    pub pt: Point,
}
impl Msg {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MSG {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MSG) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Clone)]
#[repr(C)]
pub struct Msgboxparamsa<'a> {
    pub cb_size: u32,
    pub hwnd_owner: Option<Hwnd>,
    pub h_instance: Option<Hinstance>,
    pub lpsz_text: Cow<'a, CStr>,
    pub lpsz_caption: Cow<'a, CStr>,
    pub dw_style: u32,
    pub lpsz_icon: Cow<'a, CStr>,
    pub dw_context_help_id: usize,
    pub lpfn_msg_box_callback: Option<unsafe extern "system" fn(*mut windows_sys::Win32::UI::Shell::HELPINFO)>,
    pub dw_language_id: u32,
}
impl<'a> Msgboxparamsa<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MSGBOXPARAMSA {
        let Self { cb_size, hwnd_owner, h_instance, lpsz_text, lpsz_caption, dw_style, lpsz_icon, dw_context_help_id, lpfn_msg_box_callback, dw_language_id } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::MSGBOXPARAMSA>() as _;
        let hwndOwner = hwnd_owner.map_or(0, Hwnd::into_raw);
        let hInstance = h_instance.map_or(0, Hinstance::into_raw);
        let lpszText = lpsz_text.as_ptr() as _;
        let lpszCaption = lpsz_caption.as_ptr() as _;
        let dwStyle = *dw_style;
        let lpszIcon = lpsz_icon.as_ptr() as _;
        let dwContextHelpId = *dw_context_help_id;
        let lpfnMsgBoxCallback = *lpfn_msg_box_callback;
        let dwLanguageId = *dw_language_id;
        windows_sys::Win32::UI::WindowsAndMessaging::MSGBOXPARAMSA { cbSize, hwndOwner, hInstance, lpszText, lpszCaption, dwStyle, lpszIcon, dwContextHelpId, lpfnMsgBoxCallback, dwLanguageId }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MSGBOXPARAMSA) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::MSGBOXPARAMSA { cbSize, hwndOwner, hInstance, lpszText, lpszCaption, dwStyle, lpszIcon, dwContextHelpId, lpfnMsgBoxCallback, dwLanguageId } = win32;
        let cb_size = cbSize;
        let hwnd_owner = unsafe { Hwnd::new_optional(hwndOwner) };
        let h_instance = unsafe { Hinstance::new_optional(hInstance) };
        let lpszText = unsafe { CStr::from_ptr(lpszText as *const _) };
        let lpszText = lpszText.to_bytes_with_nul().to_vec();
        let lpsz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(lpszText) });
        let lpszCaption = unsafe { CStr::from_ptr(lpszCaption as *const _) };
        let lpszCaption = lpszCaption.to_bytes_with_nul().to_vec();
        let lpsz_caption = Cow::Owned(unsafe { CString::from_vec_unchecked(lpszCaption) });
        let dw_style = dwStyle;
        let lpszIcon = unsafe { CStr::from_ptr(lpszIcon as *const _) };
        let lpszIcon = lpszIcon.to_bytes_with_nul().to_vec();
        let lpsz_icon = Cow::Owned(unsafe { CString::from_vec_unchecked(lpszIcon) });
        let dw_context_help_id = dwContextHelpId;
        let lpfn_msg_box_callback = lpfnMsgBoxCallback;
        let dw_language_id = dwLanguageId;
        Self { cb_size, hwnd_owner, h_instance, lpsz_text, lpsz_caption, dw_style, lpsz_icon, dw_context_help_id, lpfn_msg_box_callback, dw_language_id }
    }
}
#[derive(Debug, PartialEq, Default, Clone)]
#[repr(C)]
pub struct Msgboxparamsw<'a> {
    pub cb_size: u32,
    pub hwnd_owner: Option<Hwnd>,
    pub h_instance: Option<Hinstance>,
    pub lpsz_text: Cow<'a, [u16]>,
    pub lpsz_caption: Cow<'a, [u16]>,
    pub dw_style: u32,
    pub lpsz_icon: Cow<'a, [u16]>,
    pub dw_context_help_id: usize,
    pub lpfn_msg_box_callback: Option<unsafe extern "system" fn(*mut windows_sys::Win32::UI::Shell::HELPINFO)>,
    pub dw_language_id: u32,
}
impl<'a> Msgboxparamsw<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MSGBOXPARAMSW {
        let Self { cb_size, hwnd_owner, h_instance, lpsz_text, lpsz_caption, dw_style, lpsz_icon, dw_context_help_id, lpfn_msg_box_callback, dw_language_id } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::MSGBOXPARAMSW>() as _;
        let hwndOwner = hwnd_owner.map_or(0, Hwnd::into_raw);
        let hInstance = h_instance.map_or(0, Hinstance::into_raw);
        assert_eq!(lpsz_text.last().copied(), Some(0));
        let lpszText = lpsz_text.as_ptr() as _;
        assert_eq!(lpsz_caption.last().copied(), Some(0));
        let lpszCaption = lpsz_caption.as_ptr() as _;
        let dwStyle = *dw_style;
        assert_eq!(lpsz_icon.last().copied(), Some(0));
        let lpszIcon = lpsz_icon.as_ptr() as _;
        let dwContextHelpId = *dw_context_help_id;
        let lpfnMsgBoxCallback = *lpfn_msg_box_callback;
        let dwLanguageId = *dw_language_id;
        windows_sys::Win32::UI::WindowsAndMessaging::MSGBOXPARAMSW { cbSize, hwndOwner, hInstance, lpszText, lpszCaption, dwStyle, lpszIcon, dwContextHelpId, lpfnMsgBoxCallback, dwLanguageId }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MSGBOXPARAMSW) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::MSGBOXPARAMSW { cbSize, hwndOwner, hInstance, lpszText, lpszCaption, dwStyle, lpszIcon, dwContextHelpId, lpfnMsgBoxCallback, dwLanguageId } = win32;
        let cb_size = cbSize;
        let hwnd_owner = unsafe { Hwnd::new_optional(hwndOwner) };
        let h_instance = unsafe { Hinstance::new_optional(hInstance) };
        let slen = unsafe { wide_strlen(lpszText as *const u16) };
        let lpszText = unsafe { slice::from_raw_parts(lpszText, slen + 1) };
        let lpsz_text = Cow::Owned(lpszText.to_vec());
        let slen = unsafe { wide_strlen(lpszCaption as *const u16) };
        let lpszCaption = unsafe { slice::from_raw_parts(lpszCaption, slen + 1) };
        let lpsz_caption = Cow::Owned(lpszCaption.to_vec());
        let dw_style = dwStyle;
        let slen = unsafe { wide_strlen(lpszIcon as *const u16) };
        let lpszIcon = unsafe { slice::from_raw_parts(lpszIcon, slen + 1) };
        let lpsz_icon = Cow::Owned(lpszIcon.to_vec());
        let dw_context_help_id = dwContextHelpId;
        let lpfn_msg_box_callback = lpfnMsgBoxCallback;
        let dw_language_id = dwLanguageId;
        Self { cb_size, hwnd_owner, h_instance, lpsz_text, lpsz_caption, dw_style, lpsz_icon, dw_context_help_id, lpfn_msg_box_callback, dw_language_id }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Msllhookstruct {
    pub pt: Point,
    pub mouse_data: u32,
    pub flags: u32,
    pub time: u32,
    pub dw_extra_info: usize,
}
impl Msllhookstruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::MSLLHOOKSTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::MSLLHOOKSTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Multikeyhelpa {
    pub mk_size: u32,
    pub mk_keylist: CHAR,
    pub sz_keyphrase: [CHAR; 1],
}
impl Multikeyhelpa {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::MULTIKEYHELPA {
        let Self { mk_size, mk_keylist, sz_keyphrase } = self;
        let mkSize = mem::size_of::<windows_sys::Win32::UI::Shell::MULTIKEYHELPA>() as _;
        let mkKeylist = *mk_keylist;
        let szKeyphrase = [*&sz_keyphrase[0]];
        windows_sys::Win32::UI::Shell::MULTIKEYHELPA { mkSize, mkKeylist, szKeyphrase }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::MULTIKEYHELPA) -> Self {
        let windows_sys::Win32::UI::Shell::MULTIKEYHELPA { mkSize, mkKeylist, szKeyphrase } = win32;
        let mk_size = mkSize;
        let mk_keylist = mkKeylist;
        let sz_keyphrase = [szKeyphrase[0]];
        Self { mk_size, mk_keylist, sz_keyphrase }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Multikeyhelpw {
    pub mk_size: u32,
    pub mk_keylist: u8,
    pub sz_keyphrase: [u8; 1],
}
impl Multikeyhelpw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::MULTIKEYHELPW {
        let Self { mk_size, mk_keylist, sz_keyphrase } = self;
        let mkSize = mem::size_of::<windows_sys::Win32::UI::Shell::MULTIKEYHELPW>() as _;
        let mkKeylist = *mk_keylist;
        let szKeyphrase = [*&sz_keyphrase[0]];
        windows_sys::Win32::UI::Shell::MULTIKEYHELPW { mkSize, mkKeylist, szKeyphrase }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::MULTIKEYHELPW) -> Self {
        let windows_sys::Win32::UI::Shell::MULTIKEYHELPW { mkSize, mkKeylist, szKeyphrase } = win32;
        let mk_size = mkSize;
        let mk_keylist = mkKeylist;
        let sz_keyphrase = [szKeyphrase[0]];
        Self { mk_size, mk_keylist, sz_keyphrase }
    }
}
#[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct NccalcsizeParams<'a> {
    pub rgrc: [Rect; 3],
    pub lppos: &'a mut Windowpos,
}
impl<'a> NccalcsizeParams<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::NCCALCSIZE_PARAMS {
        let Self { rgrc, lppos } = self;
        let rgrc = [rgrc[0].to_win32(),rgrc[1].to_win32(),rgrc[2].to_win32()];
        let lppos = unsafe { &mut *(lppos as *mut _ as *mut _) };
        windows_sys::Win32::UI::WindowsAndMessaging::NCCALCSIZE_PARAMS { rgrc, lppos }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::NCCALCSIZE_PARAMS) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::NCCALCSIZE_PARAMS { rgrc, lppos } = win32;
        let rgrc = [unsafe { Rect::from_win32(rgrc[0]) },unsafe { Rect::from_win32(rgrc[1]) },unsafe { Rect::from_win32(rgrc[2]) }];
        let lppos = unsafe { &mut *(lppos as *mut _ as *mut _) };
        Self { rgrc, lppos }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Newcplinfoa {
    pub dw_size: u32,
    pub dw_flags: u32,
    pub dw_help_context: u32,
    pub l_data: isize,
    pub h_icon: Option<Hicon>,
    pub sz_name: [CHAR; 32],
    pub sz_info: [CHAR; 64],
    pub sz_help_file: [CHAR; 128],
}
impl Newcplinfoa {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::NEWCPLINFOA {
        let Self { dw_size, dw_flags, dw_help_context, l_data, h_icon, sz_name, sz_info, sz_help_file } = self;
        let dwSize = mem::size_of::<windows_sys::Win32::UI::Shell::NEWCPLINFOA>() as _;
        let dwFlags = *dw_flags;
        let dwHelpContext = *dw_help_context;
        let lData = *l_data;
        let hIcon = h_icon.map_or(0, Hicon::into_raw);
        let szName = [*&sz_name[0],*&sz_name[1],*&sz_name[2],*&sz_name[3],*&sz_name[4],*&sz_name[5],*&sz_name[6],*&sz_name[7],*&sz_name[8],*&sz_name[9],*&sz_name[10],*&sz_name[11],*&sz_name[12],*&sz_name[13],*&sz_name[14],*&sz_name[15],*&sz_name[16],*&sz_name[17],*&sz_name[18],*&sz_name[19],*&sz_name[20],*&sz_name[21],*&sz_name[22],*&sz_name[23],*&sz_name[24],*&sz_name[25],*&sz_name[26],*&sz_name[27],*&sz_name[28],*&sz_name[29],*&sz_name[30],*&sz_name[31]];
        let szInfo = [*&sz_info[0],*&sz_info[1],*&sz_info[2],*&sz_info[3],*&sz_info[4],*&sz_info[5],*&sz_info[6],*&sz_info[7],*&sz_info[8],*&sz_info[9],*&sz_info[10],*&sz_info[11],*&sz_info[12],*&sz_info[13],*&sz_info[14],*&sz_info[15],*&sz_info[16],*&sz_info[17],*&sz_info[18],*&sz_info[19],*&sz_info[20],*&sz_info[21],*&sz_info[22],*&sz_info[23],*&sz_info[24],*&sz_info[25],*&sz_info[26],*&sz_info[27],*&sz_info[28],*&sz_info[29],*&sz_info[30],*&sz_info[31],*&sz_info[32],*&sz_info[33],*&sz_info[34],*&sz_info[35],*&sz_info[36],*&sz_info[37],*&sz_info[38],*&sz_info[39],*&sz_info[40],*&sz_info[41],*&sz_info[42],*&sz_info[43],*&sz_info[44],*&sz_info[45],*&sz_info[46],*&sz_info[47],*&sz_info[48],*&sz_info[49],*&sz_info[50],*&sz_info[51],*&sz_info[52],*&sz_info[53],*&sz_info[54],*&sz_info[55],*&sz_info[56],*&sz_info[57],*&sz_info[58],*&sz_info[59],*&sz_info[60],*&sz_info[61],*&sz_info[62],*&sz_info[63]];
        let szHelpFile = [*&sz_help_file[0],*&sz_help_file[1],*&sz_help_file[2],*&sz_help_file[3],*&sz_help_file[4],*&sz_help_file[5],*&sz_help_file[6],*&sz_help_file[7],*&sz_help_file[8],*&sz_help_file[9],*&sz_help_file[10],*&sz_help_file[11],*&sz_help_file[12],*&sz_help_file[13],*&sz_help_file[14],*&sz_help_file[15],*&sz_help_file[16],*&sz_help_file[17],*&sz_help_file[18],*&sz_help_file[19],*&sz_help_file[20],*&sz_help_file[21],*&sz_help_file[22],*&sz_help_file[23],*&sz_help_file[24],*&sz_help_file[25],*&sz_help_file[26],*&sz_help_file[27],*&sz_help_file[28],*&sz_help_file[29],*&sz_help_file[30],*&sz_help_file[31],*&sz_help_file[32],*&sz_help_file[33],*&sz_help_file[34],*&sz_help_file[35],*&sz_help_file[36],*&sz_help_file[37],*&sz_help_file[38],*&sz_help_file[39],*&sz_help_file[40],*&sz_help_file[41],*&sz_help_file[42],*&sz_help_file[43],*&sz_help_file[44],*&sz_help_file[45],*&sz_help_file[46],*&sz_help_file[47],*&sz_help_file[48],*&sz_help_file[49],*&sz_help_file[50],*&sz_help_file[51],*&sz_help_file[52],*&sz_help_file[53],*&sz_help_file[54],*&sz_help_file[55],*&sz_help_file[56],*&sz_help_file[57],*&sz_help_file[58],*&sz_help_file[59],*&sz_help_file[60],*&sz_help_file[61],*&sz_help_file[62],*&sz_help_file[63],*&sz_help_file[64],*&sz_help_file[65],*&sz_help_file[66],*&sz_help_file[67],*&sz_help_file[68],*&sz_help_file[69],*&sz_help_file[70],*&sz_help_file[71],*&sz_help_file[72],*&sz_help_file[73],*&sz_help_file[74],*&sz_help_file[75],*&sz_help_file[76],*&sz_help_file[77],*&sz_help_file[78],*&sz_help_file[79],*&sz_help_file[80],*&sz_help_file[81],*&sz_help_file[82],*&sz_help_file[83],*&sz_help_file[84],*&sz_help_file[85],*&sz_help_file[86],*&sz_help_file[87],*&sz_help_file[88],*&sz_help_file[89],*&sz_help_file[90],*&sz_help_file[91],*&sz_help_file[92],*&sz_help_file[93],*&sz_help_file[94],*&sz_help_file[95],*&sz_help_file[96],*&sz_help_file[97],*&sz_help_file[98],*&sz_help_file[99],*&sz_help_file[100],*&sz_help_file[101],*&sz_help_file[102],*&sz_help_file[103],*&sz_help_file[104],*&sz_help_file[105],*&sz_help_file[106],*&sz_help_file[107],*&sz_help_file[108],*&sz_help_file[109],*&sz_help_file[110],*&sz_help_file[111],*&sz_help_file[112],*&sz_help_file[113],*&sz_help_file[114],*&sz_help_file[115],*&sz_help_file[116],*&sz_help_file[117],*&sz_help_file[118],*&sz_help_file[119],*&sz_help_file[120],*&sz_help_file[121],*&sz_help_file[122],*&sz_help_file[123],*&sz_help_file[124],*&sz_help_file[125],*&sz_help_file[126],*&sz_help_file[127]];
        windows_sys::Win32::UI::Shell::NEWCPLINFOA { dwSize, dwFlags, dwHelpContext, lData, hIcon, szName, szInfo, szHelpFile }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::NEWCPLINFOA) -> Self {
        let windows_sys::Win32::UI::Shell::NEWCPLINFOA { dwSize, dwFlags, dwHelpContext, lData, hIcon, szName, szInfo, szHelpFile } = win32;
        let dw_size = dwSize;
        let dw_flags = dwFlags;
        let dw_help_context = dwHelpContext;
        let l_data = lData;
        let h_icon = unsafe { Hicon::new_optional(hIcon) };
        let sz_name = [szName[0],szName[1],szName[2],szName[3],szName[4],szName[5],szName[6],szName[7],szName[8],szName[9],szName[10],szName[11],szName[12],szName[13],szName[14],szName[15],szName[16],szName[17],szName[18],szName[19],szName[20],szName[21],szName[22],szName[23],szName[24],szName[25],szName[26],szName[27],szName[28],szName[29],szName[30],szName[31]];
        let sz_info = [szInfo[0],szInfo[1],szInfo[2],szInfo[3],szInfo[4],szInfo[5],szInfo[6],szInfo[7],szInfo[8],szInfo[9],szInfo[10],szInfo[11],szInfo[12],szInfo[13],szInfo[14],szInfo[15],szInfo[16],szInfo[17],szInfo[18],szInfo[19],szInfo[20],szInfo[21],szInfo[22],szInfo[23],szInfo[24],szInfo[25],szInfo[26],szInfo[27],szInfo[28],szInfo[29],szInfo[30],szInfo[31],szInfo[32],szInfo[33],szInfo[34],szInfo[35],szInfo[36],szInfo[37],szInfo[38],szInfo[39],szInfo[40],szInfo[41],szInfo[42],szInfo[43],szInfo[44],szInfo[45],szInfo[46],szInfo[47],szInfo[48],szInfo[49],szInfo[50],szInfo[51],szInfo[52],szInfo[53],szInfo[54],szInfo[55],szInfo[56],szInfo[57],szInfo[58],szInfo[59],szInfo[60],szInfo[61],szInfo[62],szInfo[63]];
        let sz_help_file = [szHelpFile[0],szHelpFile[1],szHelpFile[2],szHelpFile[3],szHelpFile[4],szHelpFile[5],szHelpFile[6],szHelpFile[7],szHelpFile[8],szHelpFile[9],szHelpFile[10],szHelpFile[11],szHelpFile[12],szHelpFile[13],szHelpFile[14],szHelpFile[15],szHelpFile[16],szHelpFile[17],szHelpFile[18],szHelpFile[19],szHelpFile[20],szHelpFile[21],szHelpFile[22],szHelpFile[23],szHelpFile[24],szHelpFile[25],szHelpFile[26],szHelpFile[27],szHelpFile[28],szHelpFile[29],szHelpFile[30],szHelpFile[31],szHelpFile[32],szHelpFile[33],szHelpFile[34],szHelpFile[35],szHelpFile[36],szHelpFile[37],szHelpFile[38],szHelpFile[39],szHelpFile[40],szHelpFile[41],szHelpFile[42],szHelpFile[43],szHelpFile[44],szHelpFile[45],szHelpFile[46],szHelpFile[47],szHelpFile[48],szHelpFile[49],szHelpFile[50],szHelpFile[51],szHelpFile[52],szHelpFile[53],szHelpFile[54],szHelpFile[55],szHelpFile[56],szHelpFile[57],szHelpFile[58],szHelpFile[59],szHelpFile[60],szHelpFile[61],szHelpFile[62],szHelpFile[63],szHelpFile[64],szHelpFile[65],szHelpFile[66],szHelpFile[67],szHelpFile[68],szHelpFile[69],szHelpFile[70],szHelpFile[71],szHelpFile[72],szHelpFile[73],szHelpFile[74],szHelpFile[75],szHelpFile[76],szHelpFile[77],szHelpFile[78],szHelpFile[79],szHelpFile[80],szHelpFile[81],szHelpFile[82],szHelpFile[83],szHelpFile[84],szHelpFile[85],szHelpFile[86],szHelpFile[87],szHelpFile[88],szHelpFile[89],szHelpFile[90],szHelpFile[91],szHelpFile[92],szHelpFile[93],szHelpFile[94],szHelpFile[95],szHelpFile[96],szHelpFile[97],szHelpFile[98],szHelpFile[99],szHelpFile[100],szHelpFile[101],szHelpFile[102],szHelpFile[103],szHelpFile[104],szHelpFile[105],szHelpFile[106],szHelpFile[107],szHelpFile[108],szHelpFile[109],szHelpFile[110],szHelpFile[111],szHelpFile[112],szHelpFile[113],szHelpFile[114],szHelpFile[115],szHelpFile[116],szHelpFile[117],szHelpFile[118],szHelpFile[119],szHelpFile[120],szHelpFile[121],szHelpFile[122],szHelpFile[123],szHelpFile[124],szHelpFile[125],szHelpFile[126],szHelpFile[127]];
        Self { dw_size, dw_flags, dw_help_context, l_data, h_icon, sz_name, sz_info, sz_help_file }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Newcplinfow {
    pub dw_size: u32,
    pub dw_flags: u32,
    pub dw_help_context: u32,
    pub l_data: isize,
    pub h_icon: Option<Hicon>,
    pub sz_name: [u8; 32],
    pub sz_info: [u8; 64],
    pub sz_help_file: [u8; 128],
}
impl Newcplinfow {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::NEWCPLINFOW {
        let Self { dw_size, dw_flags, dw_help_context, l_data, h_icon, sz_name, sz_info, sz_help_file } = self;
        let dwSize = mem::size_of::<windows_sys::Win32::UI::Shell::NEWCPLINFOW>() as _;
        let dwFlags = *dw_flags;
        let dwHelpContext = *dw_help_context;
        let lData = *l_data;
        let hIcon = h_icon.map_or(0, Hicon::into_raw);
        let szName = [*&sz_name[0],*&sz_name[1],*&sz_name[2],*&sz_name[3],*&sz_name[4],*&sz_name[5],*&sz_name[6],*&sz_name[7],*&sz_name[8],*&sz_name[9],*&sz_name[10],*&sz_name[11],*&sz_name[12],*&sz_name[13],*&sz_name[14],*&sz_name[15],*&sz_name[16],*&sz_name[17],*&sz_name[18],*&sz_name[19],*&sz_name[20],*&sz_name[21],*&sz_name[22],*&sz_name[23],*&sz_name[24],*&sz_name[25],*&sz_name[26],*&sz_name[27],*&sz_name[28],*&sz_name[29],*&sz_name[30],*&sz_name[31]];
        let szInfo = [*&sz_info[0],*&sz_info[1],*&sz_info[2],*&sz_info[3],*&sz_info[4],*&sz_info[5],*&sz_info[6],*&sz_info[7],*&sz_info[8],*&sz_info[9],*&sz_info[10],*&sz_info[11],*&sz_info[12],*&sz_info[13],*&sz_info[14],*&sz_info[15],*&sz_info[16],*&sz_info[17],*&sz_info[18],*&sz_info[19],*&sz_info[20],*&sz_info[21],*&sz_info[22],*&sz_info[23],*&sz_info[24],*&sz_info[25],*&sz_info[26],*&sz_info[27],*&sz_info[28],*&sz_info[29],*&sz_info[30],*&sz_info[31],*&sz_info[32],*&sz_info[33],*&sz_info[34],*&sz_info[35],*&sz_info[36],*&sz_info[37],*&sz_info[38],*&sz_info[39],*&sz_info[40],*&sz_info[41],*&sz_info[42],*&sz_info[43],*&sz_info[44],*&sz_info[45],*&sz_info[46],*&sz_info[47],*&sz_info[48],*&sz_info[49],*&sz_info[50],*&sz_info[51],*&sz_info[52],*&sz_info[53],*&sz_info[54],*&sz_info[55],*&sz_info[56],*&sz_info[57],*&sz_info[58],*&sz_info[59],*&sz_info[60],*&sz_info[61],*&sz_info[62],*&sz_info[63]];
        let szHelpFile = [*&sz_help_file[0],*&sz_help_file[1],*&sz_help_file[2],*&sz_help_file[3],*&sz_help_file[4],*&sz_help_file[5],*&sz_help_file[6],*&sz_help_file[7],*&sz_help_file[8],*&sz_help_file[9],*&sz_help_file[10],*&sz_help_file[11],*&sz_help_file[12],*&sz_help_file[13],*&sz_help_file[14],*&sz_help_file[15],*&sz_help_file[16],*&sz_help_file[17],*&sz_help_file[18],*&sz_help_file[19],*&sz_help_file[20],*&sz_help_file[21],*&sz_help_file[22],*&sz_help_file[23],*&sz_help_file[24],*&sz_help_file[25],*&sz_help_file[26],*&sz_help_file[27],*&sz_help_file[28],*&sz_help_file[29],*&sz_help_file[30],*&sz_help_file[31],*&sz_help_file[32],*&sz_help_file[33],*&sz_help_file[34],*&sz_help_file[35],*&sz_help_file[36],*&sz_help_file[37],*&sz_help_file[38],*&sz_help_file[39],*&sz_help_file[40],*&sz_help_file[41],*&sz_help_file[42],*&sz_help_file[43],*&sz_help_file[44],*&sz_help_file[45],*&sz_help_file[46],*&sz_help_file[47],*&sz_help_file[48],*&sz_help_file[49],*&sz_help_file[50],*&sz_help_file[51],*&sz_help_file[52],*&sz_help_file[53],*&sz_help_file[54],*&sz_help_file[55],*&sz_help_file[56],*&sz_help_file[57],*&sz_help_file[58],*&sz_help_file[59],*&sz_help_file[60],*&sz_help_file[61],*&sz_help_file[62],*&sz_help_file[63],*&sz_help_file[64],*&sz_help_file[65],*&sz_help_file[66],*&sz_help_file[67],*&sz_help_file[68],*&sz_help_file[69],*&sz_help_file[70],*&sz_help_file[71],*&sz_help_file[72],*&sz_help_file[73],*&sz_help_file[74],*&sz_help_file[75],*&sz_help_file[76],*&sz_help_file[77],*&sz_help_file[78],*&sz_help_file[79],*&sz_help_file[80],*&sz_help_file[81],*&sz_help_file[82],*&sz_help_file[83],*&sz_help_file[84],*&sz_help_file[85],*&sz_help_file[86],*&sz_help_file[87],*&sz_help_file[88],*&sz_help_file[89],*&sz_help_file[90],*&sz_help_file[91],*&sz_help_file[92],*&sz_help_file[93],*&sz_help_file[94],*&sz_help_file[95],*&sz_help_file[96],*&sz_help_file[97],*&sz_help_file[98],*&sz_help_file[99],*&sz_help_file[100],*&sz_help_file[101],*&sz_help_file[102],*&sz_help_file[103],*&sz_help_file[104],*&sz_help_file[105],*&sz_help_file[106],*&sz_help_file[107],*&sz_help_file[108],*&sz_help_file[109],*&sz_help_file[110],*&sz_help_file[111],*&sz_help_file[112],*&sz_help_file[113],*&sz_help_file[114],*&sz_help_file[115],*&sz_help_file[116],*&sz_help_file[117],*&sz_help_file[118],*&sz_help_file[119],*&sz_help_file[120],*&sz_help_file[121],*&sz_help_file[122],*&sz_help_file[123],*&sz_help_file[124],*&sz_help_file[125],*&sz_help_file[126],*&sz_help_file[127]];
        windows_sys::Win32::UI::Shell::NEWCPLINFOW { dwSize, dwFlags, dwHelpContext, lData, hIcon, szName, szInfo, szHelpFile }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::NEWCPLINFOW) -> Self {
        let windows_sys::Win32::UI::Shell::NEWCPLINFOW { dwSize, dwFlags, dwHelpContext, lData, hIcon, szName, szInfo, szHelpFile } = win32;
        let dw_size = dwSize;
        let dw_flags = dwFlags;
        let dw_help_context = dwHelpContext;
        let l_data = lData;
        let h_icon = unsafe { Hicon::new_optional(hIcon) };
        let sz_name = [szName[0],szName[1],szName[2],szName[3],szName[4],szName[5],szName[6],szName[7],szName[8],szName[9],szName[10],szName[11],szName[12],szName[13],szName[14],szName[15],szName[16],szName[17],szName[18],szName[19],szName[20],szName[21],szName[22],szName[23],szName[24],szName[25],szName[26],szName[27],szName[28],szName[29],szName[30],szName[31]];
        let sz_info = [szInfo[0],szInfo[1],szInfo[2],szInfo[3],szInfo[4],szInfo[5],szInfo[6],szInfo[7],szInfo[8],szInfo[9],szInfo[10],szInfo[11],szInfo[12],szInfo[13],szInfo[14],szInfo[15],szInfo[16],szInfo[17],szInfo[18],szInfo[19],szInfo[20],szInfo[21],szInfo[22],szInfo[23],szInfo[24],szInfo[25],szInfo[26],szInfo[27],szInfo[28],szInfo[29],szInfo[30],szInfo[31],szInfo[32],szInfo[33],szInfo[34],szInfo[35],szInfo[36],szInfo[37],szInfo[38],szInfo[39],szInfo[40],szInfo[41],szInfo[42],szInfo[43],szInfo[44],szInfo[45],szInfo[46],szInfo[47],szInfo[48],szInfo[49],szInfo[50],szInfo[51],szInfo[52],szInfo[53],szInfo[54],szInfo[55],szInfo[56],szInfo[57],szInfo[58],szInfo[59],szInfo[60],szInfo[61],szInfo[62],szInfo[63]];
        let sz_help_file = [szHelpFile[0],szHelpFile[1],szHelpFile[2],szHelpFile[3],szHelpFile[4],szHelpFile[5],szHelpFile[6],szHelpFile[7],szHelpFile[8],szHelpFile[9],szHelpFile[10],szHelpFile[11],szHelpFile[12],szHelpFile[13],szHelpFile[14],szHelpFile[15],szHelpFile[16],szHelpFile[17],szHelpFile[18],szHelpFile[19],szHelpFile[20],szHelpFile[21],szHelpFile[22],szHelpFile[23],szHelpFile[24],szHelpFile[25],szHelpFile[26],szHelpFile[27],szHelpFile[28],szHelpFile[29],szHelpFile[30],szHelpFile[31],szHelpFile[32],szHelpFile[33],szHelpFile[34],szHelpFile[35],szHelpFile[36],szHelpFile[37],szHelpFile[38],szHelpFile[39],szHelpFile[40],szHelpFile[41],szHelpFile[42],szHelpFile[43],szHelpFile[44],szHelpFile[45],szHelpFile[46],szHelpFile[47],szHelpFile[48],szHelpFile[49],szHelpFile[50],szHelpFile[51],szHelpFile[52],szHelpFile[53],szHelpFile[54],szHelpFile[55],szHelpFile[56],szHelpFile[57],szHelpFile[58],szHelpFile[59],szHelpFile[60],szHelpFile[61],szHelpFile[62],szHelpFile[63],szHelpFile[64],szHelpFile[65],szHelpFile[66],szHelpFile[67],szHelpFile[68],szHelpFile[69],szHelpFile[70],szHelpFile[71],szHelpFile[72],szHelpFile[73],szHelpFile[74],szHelpFile[75],szHelpFile[76],szHelpFile[77],szHelpFile[78],szHelpFile[79],szHelpFile[80],szHelpFile[81],szHelpFile[82],szHelpFile[83],szHelpFile[84],szHelpFile[85],szHelpFile[86],szHelpFile[87],szHelpFile[88],szHelpFile[89],szHelpFile[90],szHelpFile[91],szHelpFile[92],szHelpFile[93],szHelpFile[94],szHelpFile[95],szHelpFile[96],szHelpFile[97],szHelpFile[98],szHelpFile[99],szHelpFile[100],szHelpFile[101],szHelpFile[102],szHelpFile[103],szHelpFile[104],szHelpFile[105],szHelpFile[106],szHelpFile[107],szHelpFile[108],szHelpFile[109],szHelpFile[110],szHelpFile[111],szHelpFile[112],szHelpFile[113],szHelpFile[114],szHelpFile[115],szHelpFile[116],szHelpFile[117],szHelpFile[118],szHelpFile[119],szHelpFile[120],szHelpFile[121],szHelpFile[122],szHelpFile[123],szHelpFile[124],szHelpFile[125],szHelpFile[126],szHelpFile[127]];
        Self { dw_size, dw_flags, dw_help_context, l_data, h_icon, sz_name, sz_info, sz_help_file }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Newtextmetrica {
    pub tm_height: i32,
    pub tm_ascent: i32,
    pub tm_descent: i32,
    pub tm_internal_leading: i32,
    pub tm_external_leading: i32,
    pub tm_ave_char_width: i32,
    pub tm_max_char_width: i32,
    pub tm_weight: i32,
    pub tm_overhang: i32,
    pub tm_digitized_aspect_x: i32,
    pub tm_digitized_aspect_y: i32,
    pub tm_first_char: u8,
    pub tm_last_char: u8,
    pub tm_default_char: u8,
    pub tm_break_char: u8,
    pub tm_italic: u8,
    pub tm_underlined: u8,
    pub tm_struck_out: u8,
    pub tm_pitch_and_family: u8,
    pub tm_char_set: u8,
    pub ntm_flags: u32,
    pub ntm_size_em: u32,
    pub ntm_cell_height: u32,
    pub ntm_avg_width: u32,
}
impl Newtextmetrica {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::NEWTEXTMETRICA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::NEWTEXTMETRICA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Newtextmetricw {
    pub tm_height: i32,
    pub tm_ascent: i32,
    pub tm_descent: i32,
    pub tm_internal_leading: i32,
    pub tm_external_leading: i32,
    pub tm_ave_char_width: i32,
    pub tm_max_char_width: i32,
    pub tm_weight: i32,
    pub tm_overhang: i32,
    pub tm_digitized_aspect_x: i32,
    pub tm_digitized_aspect_y: i32,
    pub tm_first_char: u8,
    pub tm_last_char: u8,
    pub tm_default_char: u8,
    pub tm_break_char: u8,
    pub tm_italic: u8,
    pub tm_underlined: u8,
    pub tm_struck_out: u8,
    pub tm_pitch_and_family: u8,
    pub tm_char_set: u8,
    pub ntm_flags: u32,
    pub ntm_size_em: u32,
    pub ntm_cell_height: u32,
    pub ntm_avg_width: u32,
}
impl Newtextmetricw {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::NEWTEXTMETRICW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::NEWTEXTMETRICW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmcbedragbegina {
    pub hdr: Nmhdr,
    pub i_itemid: i32,
    pub sz_text: [CHAR; 260],
}
impl Nmcbedragbegina {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMCBEDRAGBEGINA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMCBEDRAGBEGINA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmcbedragbeginw {
    pub hdr: Nmhdr,
    pub i_itemid: i32,
    pub sz_text: [u8; 260],
}
impl Nmcbedragbeginw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMCBEDRAGBEGINW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMCBEDRAGBEGINW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmcbeendedita {
    pub hdr: Nmhdr,
    pub f_changed: BOOL,
    pub i_new_selection: i32,
    pub sz_text: [CHAR; 260],
    pub i_why: i32,
}
impl Nmcbeendedita {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMCBEENDEDITA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMCBEENDEDITA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmcbeendeditw {
    pub hdr: Nmhdr,
    pub f_changed: BOOL,
    pub i_new_selection: i32,
    pub sz_text: [u8; 260],
    pub i_why: i32,
}
impl Nmcbeendeditw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMCBEENDEDITW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMCBEENDEDITW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmchar {
    pub hdr: Nmhdr,
    pub ch: u32,
    pub dw_item_prev: u32,
    pub dw_item_next: u32,
}
impl Nmchar {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMCHAR {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMCHAR) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmcustomdraw {
    pub hdr: Nmhdr,
    pub dw_draw_stage: u32,
    pub hdc: Option<Hdc>,
    pub rc: Rect,
    pub dw_item_spec: usize,
    pub u_item_state: u32,
    pub l_iteml_param: Lparam,
}
impl Nmcustomdraw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMCUSTOMDRAW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMCUSTOMDRAW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmcustomsplitrectinfo {
    pub hdr: Nmhdr,
    pub rc_client: Rect,
    pub rc_button: Rect,
    pub rc_split: Rect,
}
impl Nmcustomsplitrectinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMCUSTOMSPLITRECTINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMCUSTOMSPLITRECTINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmcustomtext<'a> {
    pub hdr: Nmhdr,
    pub h_dc: Option<Hdc>,
    pub lp_string: Cow<'a, [u16]>,
    pub n_count: i32,
    pub lp_rect: &'a mut Rect,
    pub u_format: u32,
    pub f_link: BOOL,
}
impl<'a> Nmcustomtext<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMCUSTOMTEXT {
        let Self { hdr, h_dc, lp_string, n_count, lp_rect, u_format, f_link } = self;
        let hdr = hdr.to_win32();
        let hDC = h_dc.map_or(0, Hdc::into_raw);
        assert_eq!(lp_string.last().copied(), Some(0));
        let lpString = lp_string.as_ptr() as _;
        let nCount = *n_count;
        let lpRect = unsafe { &mut *(lp_rect as *mut _ as *mut _) };
        let uFormat = *u_format;
        let fLink = *f_link;
        windows_sys::Win32::UI::Controls::NMCUSTOMTEXT { hdr, hDC, lpString, nCount, lpRect, uFormat, fLink }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMCUSTOMTEXT) -> Self {
        let windows_sys::Win32::UI::Controls::NMCUSTOMTEXT { hdr, hDC, lpString, nCount, lpRect, uFormat, fLink } = win32;
        let hdr = unsafe { Nmhdr::from_win32(hdr) };
        let h_dc = unsafe { Hdc::new_optional(hDC) };
        let slen = unsafe { wide_strlen(lpString as *const u16) };
        let lpString = unsafe { slice::from_raw_parts(lpString, slen + 1) };
        let lp_string = Cow::Owned(lpString.to_vec());
        let n_count = nCount;
        let lp_rect = unsafe { &mut *(lpRect as *mut _ as *mut _) };
        let u_format = uFormat;
        let f_link = fLink;
        Self { hdr, h_dc, lp_string, n_count, lp_rect, u_format, f_link }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmdatetimechange {
    pub nmhdr: Nmhdr,
    pub dw_flags: u32,
    pub st: Systemtime,
}
impl Nmdatetimechange {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMDATETIMECHANGE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMDATETIMECHANGE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmdatetimeformata<'a> {
    pub nmhdr: Nmhdr,
    pub psz_format: Cow<'a, CStr>,
    pub st: Systemtime,
    pub psz_display: Cow<'a, CStr>,
    pub sz_display: [CHAR; 64],
}
impl<'a> Nmdatetimeformata<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMDATETIMEFORMATA {
        let Self { nmhdr, psz_format, st, psz_display, sz_display } = self;
        let nmhdr = nmhdr.to_win32();
        let pszFormat = psz_format.as_ptr() as _;
        let st = st.to_win32();
        let pszDisplay = psz_display.as_ptr() as _;
        let szDisplay = [*&sz_display[0],*&sz_display[1],*&sz_display[2],*&sz_display[3],*&sz_display[4],*&sz_display[5],*&sz_display[6],*&sz_display[7],*&sz_display[8],*&sz_display[9],*&sz_display[10],*&sz_display[11],*&sz_display[12],*&sz_display[13],*&sz_display[14],*&sz_display[15],*&sz_display[16],*&sz_display[17],*&sz_display[18],*&sz_display[19],*&sz_display[20],*&sz_display[21],*&sz_display[22],*&sz_display[23],*&sz_display[24],*&sz_display[25],*&sz_display[26],*&sz_display[27],*&sz_display[28],*&sz_display[29],*&sz_display[30],*&sz_display[31],*&sz_display[32],*&sz_display[33],*&sz_display[34],*&sz_display[35],*&sz_display[36],*&sz_display[37],*&sz_display[38],*&sz_display[39],*&sz_display[40],*&sz_display[41],*&sz_display[42],*&sz_display[43],*&sz_display[44],*&sz_display[45],*&sz_display[46],*&sz_display[47],*&sz_display[48],*&sz_display[49],*&sz_display[50],*&sz_display[51],*&sz_display[52],*&sz_display[53],*&sz_display[54],*&sz_display[55],*&sz_display[56],*&sz_display[57],*&sz_display[58],*&sz_display[59],*&sz_display[60],*&sz_display[61],*&sz_display[62],*&sz_display[63]];
        windows_sys::Win32::UI::Controls::NMDATETIMEFORMATA { nmhdr, pszFormat, st, pszDisplay, szDisplay }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMDATETIMEFORMATA) -> Self {
        let windows_sys::Win32::UI::Controls::NMDATETIMEFORMATA { nmhdr, pszFormat, st, pszDisplay, szDisplay } = win32;
        let nmhdr = unsafe { Nmhdr::from_win32(nmhdr) };
        let pszFormat = unsafe { CStr::from_ptr(pszFormat as *const _) };
        let pszFormat = pszFormat.to_bytes_with_nul().to_vec();
        let psz_format = Cow::Owned(unsafe { CString::from_vec_unchecked(pszFormat) });
        let st = unsafe { Systemtime::from_win32(st) };
        let pszDisplay = unsafe { CStr::from_ptr(pszDisplay as *const _) };
        let pszDisplay = pszDisplay.to_bytes_with_nul().to_vec();
        let psz_display = Cow::Owned(unsafe { CString::from_vec_unchecked(pszDisplay) });
        let sz_display = [szDisplay[0],szDisplay[1],szDisplay[2],szDisplay[3],szDisplay[4],szDisplay[5],szDisplay[6],szDisplay[7],szDisplay[8],szDisplay[9],szDisplay[10],szDisplay[11],szDisplay[12],szDisplay[13],szDisplay[14],szDisplay[15],szDisplay[16],szDisplay[17],szDisplay[18],szDisplay[19],szDisplay[20],szDisplay[21],szDisplay[22],szDisplay[23],szDisplay[24],szDisplay[25],szDisplay[26],szDisplay[27],szDisplay[28],szDisplay[29],szDisplay[30],szDisplay[31],szDisplay[32],szDisplay[33],szDisplay[34],szDisplay[35],szDisplay[36],szDisplay[37],szDisplay[38],szDisplay[39],szDisplay[40],szDisplay[41],szDisplay[42],szDisplay[43],szDisplay[44],szDisplay[45],szDisplay[46],szDisplay[47],szDisplay[48],szDisplay[49],szDisplay[50],szDisplay[51],szDisplay[52],szDisplay[53],szDisplay[54],szDisplay[55],szDisplay[56],szDisplay[57],szDisplay[58],szDisplay[59],szDisplay[60],szDisplay[61],szDisplay[62],szDisplay[63]];
        Self { nmhdr, psz_format, st, psz_display, sz_display }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmdatetimeformatquerya<'a> {
    pub nmhdr: Nmhdr,
    pub psz_format: Cow<'a, CStr>,
    pub sz_max: Size,
}
impl<'a> Nmdatetimeformatquerya<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMDATETIMEFORMATQUERYA {
        let Self { nmhdr, psz_format, sz_max } = self;
        let nmhdr = nmhdr.to_win32();
        let pszFormat = psz_format.as_ptr() as _;
        let szMax = sz_max.to_win32();
        windows_sys::Win32::UI::Controls::NMDATETIMEFORMATQUERYA { nmhdr, pszFormat, szMax }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMDATETIMEFORMATQUERYA) -> Self {
        let windows_sys::Win32::UI::Controls::NMDATETIMEFORMATQUERYA { nmhdr, pszFormat, szMax } = win32;
        let nmhdr = unsafe { Nmhdr::from_win32(nmhdr) };
        let pszFormat = unsafe { CStr::from_ptr(pszFormat as *const _) };
        let pszFormat = pszFormat.to_bytes_with_nul().to_vec();
        let psz_format = Cow::Owned(unsafe { CString::from_vec_unchecked(pszFormat) });
        let sz_max = unsafe { Size::from_win32(szMax) };
        Self { nmhdr, psz_format, sz_max }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmdatetimeformatqueryw<'a> {
    pub nmhdr: Nmhdr,
    pub psz_format: Cow<'a, [u16]>,
    pub sz_max: Size,
}
impl<'a> Nmdatetimeformatqueryw<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMDATETIMEFORMATQUERYW {
        let Self { nmhdr, psz_format, sz_max } = self;
        let nmhdr = nmhdr.to_win32();
        assert_eq!(psz_format.last().copied(), Some(0));
        let pszFormat = psz_format.as_ptr() as _;
        let szMax = sz_max.to_win32();
        windows_sys::Win32::UI::Controls::NMDATETIMEFORMATQUERYW { nmhdr, pszFormat, szMax }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMDATETIMEFORMATQUERYW) -> Self {
        let windows_sys::Win32::UI::Controls::NMDATETIMEFORMATQUERYW { nmhdr, pszFormat, szMax } = win32;
        let nmhdr = unsafe { Nmhdr::from_win32(nmhdr) };
        let slen = unsafe { wide_strlen(pszFormat as *const u16) };
        let pszFormat = unsafe { slice::from_raw_parts(pszFormat, slen + 1) };
        let psz_format = Cow::Owned(pszFormat.to_vec());
        let sz_max = unsafe { Size::from_win32(szMax) };
        Self { nmhdr, psz_format, sz_max }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmdatetimeformatw<'a> {
    pub nmhdr: Nmhdr,
    pub psz_format: Cow<'a, [u16]>,
    pub st: Systemtime,
    pub psz_display: Cow<'a, [u16]>,
    pub sz_display: [u8; 64],
}
impl<'a> Nmdatetimeformatw<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMDATETIMEFORMATW {
        let Self { nmhdr, psz_format, st, psz_display, sz_display } = self;
        let nmhdr = nmhdr.to_win32();
        assert_eq!(psz_format.last().copied(), Some(0));
        let pszFormat = psz_format.as_ptr() as _;
        let st = st.to_win32();
        assert_eq!(psz_display.last().copied(), Some(0));
        let pszDisplay = psz_display.as_ptr() as _;
        let szDisplay = [*&sz_display[0],*&sz_display[1],*&sz_display[2],*&sz_display[3],*&sz_display[4],*&sz_display[5],*&sz_display[6],*&sz_display[7],*&sz_display[8],*&sz_display[9],*&sz_display[10],*&sz_display[11],*&sz_display[12],*&sz_display[13],*&sz_display[14],*&sz_display[15],*&sz_display[16],*&sz_display[17],*&sz_display[18],*&sz_display[19],*&sz_display[20],*&sz_display[21],*&sz_display[22],*&sz_display[23],*&sz_display[24],*&sz_display[25],*&sz_display[26],*&sz_display[27],*&sz_display[28],*&sz_display[29],*&sz_display[30],*&sz_display[31],*&sz_display[32],*&sz_display[33],*&sz_display[34],*&sz_display[35],*&sz_display[36],*&sz_display[37],*&sz_display[38],*&sz_display[39],*&sz_display[40],*&sz_display[41],*&sz_display[42],*&sz_display[43],*&sz_display[44],*&sz_display[45],*&sz_display[46],*&sz_display[47],*&sz_display[48],*&sz_display[49],*&sz_display[50],*&sz_display[51],*&sz_display[52],*&sz_display[53],*&sz_display[54],*&sz_display[55],*&sz_display[56],*&sz_display[57],*&sz_display[58],*&sz_display[59],*&sz_display[60],*&sz_display[61],*&sz_display[62],*&sz_display[63]];
        windows_sys::Win32::UI::Controls::NMDATETIMEFORMATW { nmhdr, pszFormat, st, pszDisplay, szDisplay }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMDATETIMEFORMATW) -> Self {
        let windows_sys::Win32::UI::Controls::NMDATETIMEFORMATW { nmhdr, pszFormat, st, pszDisplay, szDisplay } = win32;
        let nmhdr = unsafe { Nmhdr::from_win32(nmhdr) };
        let slen = unsafe { wide_strlen(pszFormat as *const u16) };
        let pszFormat = unsafe { slice::from_raw_parts(pszFormat, slen + 1) };
        let psz_format = Cow::Owned(pszFormat.to_vec());
        let st = unsafe { Systemtime::from_win32(st) };
        let slen = unsafe { wide_strlen(pszDisplay as *const u16) };
        let pszDisplay = unsafe { slice::from_raw_parts(pszDisplay, slen + 1) };
        let psz_display = Cow::Owned(pszDisplay.to_vec());
        let sz_display = [szDisplay[0],szDisplay[1],szDisplay[2],szDisplay[3],szDisplay[4],szDisplay[5],szDisplay[6],szDisplay[7],szDisplay[8],szDisplay[9],szDisplay[10],szDisplay[11],szDisplay[12],szDisplay[13],szDisplay[14],szDisplay[15],szDisplay[16],szDisplay[17],szDisplay[18],szDisplay[19],szDisplay[20],szDisplay[21],szDisplay[22],szDisplay[23],szDisplay[24],szDisplay[25],szDisplay[26],szDisplay[27],szDisplay[28],szDisplay[29],szDisplay[30],szDisplay[31],szDisplay[32],szDisplay[33],szDisplay[34],szDisplay[35],szDisplay[36],szDisplay[37],szDisplay[38],szDisplay[39],szDisplay[40],szDisplay[41],szDisplay[42],szDisplay[43],szDisplay[44],szDisplay[45],szDisplay[46],szDisplay[47],szDisplay[48],szDisplay[49],szDisplay[50],szDisplay[51],szDisplay[52],szDisplay[53],szDisplay[54],szDisplay[55],szDisplay[56],szDisplay[57],szDisplay[58],szDisplay[59],szDisplay[60],szDisplay[61],szDisplay[62],szDisplay[63]];
        Self { nmhdr, psz_format, st, psz_display, sz_display }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmdatetimestringa<'a> {
    pub nmhdr: Nmhdr,
    pub psz_user_string: Cow<'a, CStr>,
    pub st: Systemtime,
    pub dw_flags: u32,
}
impl<'a> Nmdatetimestringa<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMDATETIMESTRINGA {
        let Self { nmhdr, psz_user_string, st, dw_flags } = self;
        let nmhdr = nmhdr.to_win32();
        let pszUserString = psz_user_string.as_ptr() as _;
        let st = st.to_win32();
        let dwFlags = *dw_flags;
        windows_sys::Win32::UI::Controls::NMDATETIMESTRINGA { nmhdr, pszUserString, st, dwFlags }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMDATETIMESTRINGA) -> Self {
        let windows_sys::Win32::UI::Controls::NMDATETIMESTRINGA { nmhdr, pszUserString, st, dwFlags } = win32;
        let nmhdr = unsafe { Nmhdr::from_win32(nmhdr) };
        let pszUserString = unsafe { CStr::from_ptr(pszUserString as *const _) };
        let pszUserString = pszUserString.to_bytes_with_nul().to_vec();
        let psz_user_string = Cow::Owned(unsafe { CString::from_vec_unchecked(pszUserString) });
        let st = unsafe { Systemtime::from_win32(st) };
        let dw_flags = dwFlags;
        Self { nmhdr, psz_user_string, st, dw_flags }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmdatetimestringw<'a> {
    pub nmhdr: Nmhdr,
    pub psz_user_string: Cow<'a, [u16]>,
    pub st: Systemtime,
    pub dw_flags: u32,
}
impl<'a> Nmdatetimestringw<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMDATETIMESTRINGW {
        let Self { nmhdr, psz_user_string, st, dw_flags } = self;
        let nmhdr = nmhdr.to_win32();
        assert_eq!(psz_user_string.last().copied(), Some(0));
        let pszUserString = psz_user_string.as_ptr() as _;
        let st = st.to_win32();
        let dwFlags = *dw_flags;
        windows_sys::Win32::UI::Controls::NMDATETIMESTRINGW { nmhdr, pszUserString, st, dwFlags }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMDATETIMESTRINGW) -> Self {
        let windows_sys::Win32::UI::Controls::NMDATETIMESTRINGW { nmhdr, pszUserString, st, dwFlags } = win32;
        let nmhdr = unsafe { Nmhdr::from_win32(nmhdr) };
        let slen = unsafe { wide_strlen(pszUserString as *const u16) };
        let pszUserString = unsafe { slice::from_raw_parts(pszUserString, slen + 1) };
        let psz_user_string = Cow::Owned(pszUserString.to_vec());
        let st = unsafe { Systemtime::from_win32(st) };
        let dw_flags = dwFlags;
        Self { nmhdr, psz_user_string, st, dw_flags }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmdatetimewmkeydowna<'a> {
    pub nmhdr: Nmhdr,
    pub n_virt_key: i32,
    pub psz_format: Cow<'a, CStr>,
    pub st: Systemtime,
}
impl<'a> Nmdatetimewmkeydowna<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMDATETIMEWMKEYDOWNA {
        let Self { nmhdr, n_virt_key, psz_format, st } = self;
        let nmhdr = nmhdr.to_win32();
        let nVirtKey = *n_virt_key;
        let pszFormat = psz_format.as_ptr() as _;
        let st = st.to_win32();
        windows_sys::Win32::UI::Controls::NMDATETIMEWMKEYDOWNA { nmhdr, nVirtKey, pszFormat, st }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMDATETIMEWMKEYDOWNA) -> Self {
        let windows_sys::Win32::UI::Controls::NMDATETIMEWMKEYDOWNA { nmhdr, nVirtKey, pszFormat, st } = win32;
        let nmhdr = unsafe { Nmhdr::from_win32(nmhdr) };
        let n_virt_key = nVirtKey;
        let pszFormat = unsafe { CStr::from_ptr(pszFormat as *const _) };
        let pszFormat = pszFormat.to_bytes_with_nul().to_vec();
        let psz_format = Cow::Owned(unsafe { CString::from_vec_unchecked(pszFormat) });
        let st = unsafe { Systemtime::from_win32(st) };
        Self { nmhdr, n_virt_key, psz_format, st }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmdatetimewmkeydownw<'a> {
    pub nmhdr: Nmhdr,
    pub n_virt_key: i32,
    pub psz_format: Cow<'a, [u16]>,
    pub st: Systemtime,
}
impl<'a> Nmdatetimewmkeydownw<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMDATETIMEWMKEYDOWNW {
        let Self { nmhdr, n_virt_key, psz_format, st } = self;
        let nmhdr = nmhdr.to_win32();
        let nVirtKey = *n_virt_key;
        assert_eq!(psz_format.last().copied(), Some(0));
        let pszFormat = psz_format.as_ptr() as _;
        let st = st.to_win32();
        windows_sys::Win32::UI::Controls::NMDATETIMEWMKEYDOWNW { nmhdr, nVirtKey, pszFormat, st }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMDATETIMEWMKEYDOWNW) -> Self {
        let windows_sys::Win32::UI::Controls::NMDATETIMEWMKEYDOWNW { nmhdr, nVirtKey, pszFormat, st } = win32;
        let nmhdr = unsafe { Nmhdr::from_win32(nmhdr) };
        let n_virt_key = nVirtKey;
        let slen = unsafe { wide_strlen(pszFormat as *const u16) };
        let pszFormat = unsafe { slice::from_raw_parts(pszFormat, slen + 1) };
        let psz_format = Cow::Owned(pszFormat.to_vec());
        let st = unsafe { Systemtime::from_win32(st) };
        Self { nmhdr, n_virt_key, psz_format, st }
    }
}
#[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmdaystate<'a> {
    pub nmhdr: Nmhdr,
    pub st_start: Systemtime,
    pub c_day_state: i32,
    pub prg_day_state: &'a mut u32,
}
impl<'a> Nmdaystate<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMDAYSTATE {
        let Self { nmhdr, st_start, c_day_state, prg_day_state } = self;
        let nmhdr = nmhdr.to_win32();
        let stStart = st_start.to_win32();
        let cDayState = *c_day_state;
        let prgDayState = unsafe { &mut *(prg_day_state as *mut _ as *mut _) };
        windows_sys::Win32::UI::Controls::NMDAYSTATE { nmhdr, stStart, cDayState, prgDayState }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMDAYSTATE) -> Self {
        let windows_sys::Win32::UI::Controls::NMDAYSTATE { nmhdr, stStart, cDayState, prgDayState } = win32;
        let nmhdr = unsafe { Nmhdr::from_win32(nmhdr) };
        let st_start = unsafe { Systemtime::from_win32(stStart) };
        let c_day_state = cDayState;
        let prg_day_state = unsafe { &mut *(prgDayState as *mut _ as *mut _) };
        Self { nmhdr, st_start, c_day_state, prg_day_state }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmhddispinfoa<'a> {
    pub hdr: Nmhdr,
    pub i_item: i32,
    pub mask: u32,
    pub psz_text: Cow<'a, CStr>,
    pub cch_text_max: i32,
    pub i_image: i32,
    pub l_param: Lparam,
}
impl<'a> Nmhddispinfoa<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMHDDISPINFOA {
        let Self { hdr, i_item, mask, psz_text, cch_text_max, i_image, l_param } = self;
        let hdr = hdr.to_win32();
        let iItem = *i_item;
        let mask = *mask;
        let pszText = psz_text.as_ptr() as _;
        let cchTextMax = *cch_text_max;
        let iImage = *i_image;
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::Controls::NMHDDISPINFOA { hdr, iItem, mask, pszText, cchTextMax, iImage, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMHDDISPINFOA) -> Self {
        let windows_sys::Win32::UI::Controls::NMHDDISPINFOA { hdr, iItem, mask, pszText, cchTextMax, iImage, lParam } = win32;
        let hdr = unsafe { Nmhdr::from_win32(hdr) };
        let i_item = iItem;
        let mask = mask;
        let pszText = unsafe { CStr::from_ptr(pszText as *const _) };
        let pszText = pszText.to_bytes_with_nul().to_vec();
        let psz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(pszText) });
        let cch_text_max = cchTextMax;
        let i_image = iImage;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { hdr, i_item, mask, psz_text, cch_text_max, i_image, l_param }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmhddispinfow<'a> {
    pub hdr: Nmhdr,
    pub i_item: i32,
    pub mask: u32,
    pub psz_text: Cow<'a, [u16]>,
    pub cch_text_max: i32,
    pub i_image: i32,
    pub l_param: Lparam,
}
impl<'a> Nmhddispinfow<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMHDDISPINFOW {
        let Self { hdr, i_item, mask, psz_text, cch_text_max, i_image, l_param } = self;
        let hdr = hdr.to_win32();
        let iItem = *i_item;
        let mask = *mask;
        assert_eq!(psz_text.last().copied(), Some(0));
        let pszText = psz_text.as_ptr() as _;
        let cchTextMax = *cch_text_max;
        let iImage = *i_image;
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::Controls::NMHDDISPINFOW { hdr, iItem, mask, pszText, cchTextMax, iImage, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMHDDISPINFOW) -> Self {
        let windows_sys::Win32::UI::Controls::NMHDDISPINFOW { hdr, iItem, mask, pszText, cchTextMax, iImage, lParam } = win32;
        let hdr = unsafe { Nmhdr::from_win32(hdr) };
        let i_item = iItem;
        let mask = mask;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = Cow::Owned(pszText.to_vec());
        let cch_text_max = cchTextMax;
        let i_image = iImage;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { hdr, i_item, mask, psz_text, cch_text_max, i_image, l_param }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmhdfilterbtnclick {
    pub hdr: Nmhdr,
    pub i_item: i32,
    pub rc: Rect,
}
impl Nmhdfilterbtnclick {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMHDFILTERBTNCLICK {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMHDFILTERBTNCLICK) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmhdr {
    pub hwnd_from: Option<Hwnd>,
    pub id_from: usize,
    pub code: u32,
}
impl Nmhdr {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMHDR {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMHDR) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmipaddress {
    pub hdr: Nmhdr,
    pub i_field: i32,
    pub i_value: i32,
}
impl Nmipaddress {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMIPADDRESS {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMIPADDRESS) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmitemactivate {
    pub hdr: Nmhdr,
    pub i_item: i32,
    pub i_sub_item: i32,
    pub u_new_state: u32,
    pub u_old_state: u32,
    pub u_changed: u32,
    pub pt_action: Point,
    pub l_param: Lparam,
    pub u_key_flags: u32,
}
impl Nmitemactivate {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMITEMACTIVATE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMITEMACTIVATE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmkey {
    pub hdr: Nmhdr,
    pub n_v_key: u32,
    pub u_flags: u32,
}
impl Nmkey {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMKEY {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMKEY) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlink {
    pub hdr: Nmhdr,
    pub item: Litem,
}
impl Nmlink {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLINK {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLINK) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlistview {
    pub hdr: Nmhdr,
    pub i_item: i32,
    pub i_sub_item: i32,
    pub u_new_state: u32,
    pub u_old_state: u32,
    pub u_changed: u32,
    pub pt_action: Point,
    pub l_param: Lparam,
}
impl Nmlistview {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLISTVIEW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLISTVIEW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlvcachehint {
    pub hdr: Nmhdr,
    pub i_from: i32,
    pub i_to: i32,
}
impl Nmlvcachehint {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVCACHEHINT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVCACHEHINT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlvcustomdraw {
    pub nmcd: Nmcustomdraw,
    pub clr_text: u32,
    pub clr_text_bk: u32,
    pub i_sub_item: i32,
    pub dw_item_type: u32,
    pub clr_face: u32,
    pub i_icon_effect: i32,
    pub i_icon_phase: i32,
    pub i_part_id: i32,
    pub i_state_id: i32,
    pub rc_text: Rect,
    pub u_align: u32,
}
impl Nmlvcustomdraw {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVCUSTOMDRAW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVCUSTOMDRAW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlvdispinfoa<'a> {
    pub hdr: Nmhdr,
    pub item: Lvitema<'a>,
}
impl<'a> Nmlvdispinfoa<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVDISPINFOA {
        let Self { hdr, item } = self;
        let hdr = hdr.to_win32();
        let item = item.to_win32();
        windows_sys::Win32::UI::Controls::NMLVDISPINFOA { hdr, item }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVDISPINFOA) -> Self {
        let windows_sys::Win32::UI::Controls::NMLVDISPINFOA { hdr, item } = win32;
        let hdr = unsafe { Nmhdr::from_win32(hdr) };
        let item = unsafe { Lvitema::from_win32(item) };
        Self { hdr, item }
    }
}
#[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlvdispinfow<'a> {
    pub hdr: Nmhdr,
    pub item: Lvitemw<'a>,
}
impl<'a> Nmlvdispinfow<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVDISPINFOW {
        let Self { hdr, item } = self;
        let hdr = hdr.to_win32();
        let item = item.to_win32();
        windows_sys::Win32::UI::Controls::NMLVDISPINFOW { hdr, item }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVDISPINFOW) -> Self {
        let windows_sys::Win32::UI::Controls::NMLVDISPINFOW { hdr, item } = win32;
        let hdr = unsafe { Nmhdr::from_win32(hdr) };
        let item = unsafe { Lvitemw::from_win32(item) };
        Self { hdr, item }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlvemptymarkup {
    pub hdr: Nmhdr,
    pub dw_flags: u32,
    pub sz_markup: [u8; 2084],
}
impl Nmlvemptymarkup {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVEMPTYMARKUP {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVEMPTYMARKUP) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlvfinditema<'a> {
    pub hdr: Nmhdr,
    pub i_start: i32,
    pub lvfi: Lvfindinfoa<'a>,
}
impl<'a> Nmlvfinditema<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVFINDITEMA {
        let Self { hdr, i_start, lvfi } = self;
        let hdr = hdr.to_win32();
        let iStart = *i_start;
        let lvfi = lvfi.to_win32();
        windows_sys::Win32::UI::Controls::NMLVFINDITEMA { hdr, iStart, lvfi }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVFINDITEMA) -> Self {
        let windows_sys::Win32::UI::Controls::NMLVFINDITEMA { hdr, iStart, lvfi } = win32;
        let hdr = unsafe { Nmhdr::from_win32(hdr) };
        let i_start = iStart;
        let lvfi = unsafe { Lvfindinfoa::from_win32(lvfi) };
        Self { hdr, i_start, lvfi }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlvfinditemw<'a> {
    pub hdr: Nmhdr,
    pub i_start: i32,
    pub lvfi: Lvfindinfow<'a>,
}
impl<'a> Nmlvfinditemw<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVFINDITEMW {
        let Self { hdr, i_start, lvfi } = self;
        let hdr = hdr.to_win32();
        let iStart = *i_start;
        let lvfi = lvfi.to_win32();
        windows_sys::Win32::UI::Controls::NMLVFINDITEMW { hdr, iStart, lvfi }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVFINDITEMW) -> Self {
        let windows_sys::Win32::UI::Controls::NMLVFINDITEMW { hdr, iStart, lvfi } = win32;
        let hdr = unsafe { Nmhdr::from_win32(hdr) };
        let i_start = iStart;
        let lvfi = unsafe { Lvfindinfow::from_win32(lvfi) };
        Self { hdr, i_start, lvfi }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlvgetinfotipa<'a> {
    pub hdr: Nmhdr,
    pub dw_flags: u32,
    pub psz_text: Cow<'a, CStr>,
    pub cch_text_max: i32,
    pub i_item: i32,
    pub i_sub_item: i32,
    pub l_param: Lparam,
}
impl<'a> Nmlvgetinfotipa<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVGETINFOTIPA {
        let Self { hdr, dw_flags, psz_text, cch_text_max, i_item, i_sub_item, l_param } = self;
        let hdr = hdr.to_win32();
        let dwFlags = *dw_flags;
        let pszText = psz_text.as_ptr() as _;
        let cchTextMax = *cch_text_max;
        let iItem = *i_item;
        let iSubItem = *i_sub_item;
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::Controls::NMLVGETINFOTIPA { hdr, dwFlags, pszText, cchTextMax, iItem, iSubItem, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVGETINFOTIPA) -> Self {
        let windows_sys::Win32::UI::Controls::NMLVGETINFOTIPA { hdr, dwFlags, pszText, cchTextMax, iItem, iSubItem, lParam } = win32;
        let hdr = unsafe { Nmhdr::from_win32(hdr) };
        let dw_flags = dwFlags;
        let pszText = unsafe { CStr::from_ptr(pszText as *const _) };
        let pszText = pszText.to_bytes_with_nul().to_vec();
        let psz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(pszText) });
        let cch_text_max = cchTextMax;
        let i_item = iItem;
        let i_sub_item = iSubItem;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { hdr, dw_flags, psz_text, cch_text_max, i_item, i_sub_item, l_param }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlvgetinfotipw<'a> {
    pub hdr: Nmhdr,
    pub dw_flags: u32,
    pub psz_text: Cow<'a, [u16]>,
    pub cch_text_max: i32,
    pub i_item: i32,
    pub i_sub_item: i32,
    pub l_param: Lparam,
}
impl<'a> Nmlvgetinfotipw<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVGETINFOTIPW {
        let Self { hdr, dw_flags, psz_text, cch_text_max, i_item, i_sub_item, l_param } = self;
        let hdr = hdr.to_win32();
        let dwFlags = *dw_flags;
        assert_eq!(psz_text.last().copied(), Some(0));
        let pszText = psz_text.as_ptr() as _;
        let cchTextMax = *cch_text_max;
        let iItem = *i_item;
        let iSubItem = *i_sub_item;
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::Controls::NMLVGETINFOTIPW { hdr, dwFlags, pszText, cchTextMax, iItem, iSubItem, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVGETINFOTIPW) -> Self {
        let windows_sys::Win32::UI::Controls::NMLVGETINFOTIPW { hdr, dwFlags, pszText, cchTextMax, iItem, iSubItem, lParam } = win32;
        let hdr = unsafe { Nmhdr::from_win32(hdr) };
        let dw_flags = dwFlags;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = Cow::Owned(pszText.to_vec());
        let cch_text_max = cchTextMax;
        let i_item = iItem;
        let i_sub_item = iSubItem;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { hdr, dw_flags, psz_text, cch_text_max, i_item, i_sub_item, l_param }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Nmlvkeydown {
    pub hdr: Nmhdr,
    pub w_v_key: u16,
    pub flags: u32,
}
impl Nmlvkeydown {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVKEYDOWN {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVKEYDOWN) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlvlink {
    pub hdr: Nmhdr,
    pub link: Litem,
    pub i_item: i32,
    pub i_sub_item: i32,
}
impl Nmlvlink {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVLINK {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVLINK) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlvodstatechange {
    pub hdr: Nmhdr,
    pub i_from: i32,
    pub i_to: i32,
    pub u_new_state: u32,
    pub u_old_state: u32,
}
impl Nmlvodstatechange {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVODSTATECHANGE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVODSTATECHANGE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmlvscroll {
    pub hdr: Nmhdr,
    pub dx: i32,
    pub dy: i32,
}
impl Nmlvscroll {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMLVSCROLL {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMLVSCROLL) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmmouse {
    pub hdr: Nmhdr,
    pub dw_item_spec: usize,
    pub dw_item_data: usize,
    pub pt: Point,
    pub dw_hit_info: Lparam,
}
impl Nmmouse {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMMOUSE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMMOUSE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
//  Not generated due to containing a void type
//  #[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Nmobjectnotify<'a> {
//      pub hdr: Nmhdr,
//      pub i_item: i32,
//      pub piid: Cow<'a, GUID>,
//      pub p_object: &'a mut todo_void,
//      pub h_result: HRESULT,
//      pub dw_flags: u32,
//  }
//  impl<'a> Nmobjectnotify<'a> {
//      fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMOBJECTNOTIFY {
//          let Self { hdr, i_item, piid, p_object, h_result, dw_flags } = self;
//          let hdr = hdr.to_win32();
//          let iItem = *i_item;
//          let piid = unsafe { &*(&**piid as *const _ as *const _) };
//          let pObject = unsafe { &mut *(p_object as *mut _ as *mut _) };
//          let hResult = *h_result;
//          let dwFlags = *dw_flags;
//          windows_sys::Win32::UI::Controls::NMOBJECTNOTIFY { hdr, iItem, piid, pObject, hResult, dwFlags }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMOBJECTNOTIFY) -> Self {
//          let windows_sys::Win32::UI::Controls::NMOBJECTNOTIFY { hdr, iItem, piid, pObject, hResult, dwFlags } = win32;
//          let hdr = unsafe { Nmhdr::from_win32(hdr) };
//          let i_item = iItem;
//          let piid = Cow::Borrowed(unsafe { &*(piid as *const _ as *const _) });
//          let p_object = unsafe { &mut *(pObject as *mut _ as *mut _) };
//          let h_result = hResult;
//          let dw_flags = dwFlags;
//          Self { hdr, i_item, piid, p_object, h_result, dw_flags }
//      }
//  }
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmpgcalcsize {
    pub hdr: Nmhdr,
    pub dw_flag: u32,
    pub i_width: i32,
    pub i_height: i32,
}
impl Nmpgcalcsize {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMPGCALCSIZE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMPGCALCSIZE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmpghotitem {
    pub hdr: Nmhdr,
    pub id_old: i32,
    pub id_new: i32,
    pub dw_flags: u32,
}
impl Nmpghotitem {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMPGHOTITEM {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMPGHOTITEM) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Nmpgscroll {
    pub hdr: Nmhdr,
    pub fw_keys: u16,
    pub rc_parent: Rect,
    pub i_dir: u32,
    pub i_xpos: i32,
    pub i_ypos: i32,
    pub i_scroll: i32,
}
impl Nmpgscroll {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMPGSCROLL {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMPGSCROLL) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmrbautosize {
    pub hdr: Nmhdr,
    pub f_changed: BOOL,
    pub rc_target: Rect,
    pub rc_actual: Rect,
}
impl Nmrbautosize {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMRBAUTOSIZE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMRBAUTOSIZE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmrebar {
    pub hdr: Nmhdr,
    pub dw_mask: u32,
    pub u_band: u32,
    pub f_style: u32,
    pub w_id: u32,
    pub l_param: Lparam,
}
impl Nmrebar {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMREBAR {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMREBAR) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmrebarautobreak {
    pub hdr: Nmhdr,
    pub u_band: u32,
    pub w_id: u32,
    pub l_param: Lparam,
    pub u_msg: u32,
    pub f_style_current: u32,
    pub f_auto_break: BOOL,
}
impl Nmrebarautobreak {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMREBARAUTOBREAK {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMREBARAUTOBREAK) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmrebarchevron {
    pub hdr: Nmhdr,
    pub u_band: u32,
    pub w_id: u32,
    pub l_param: Lparam,
    pub rc: Rect,
    pub l_param_nm: Lparam,
}
impl Nmrebarchevron {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMREBARCHEVRON {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMREBARCHEVRON) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmrebarchildsize {
    pub hdr: Nmhdr,
    pub u_band: u32,
    pub w_id: u32,
    pub rc_child: Rect,
    pub rc_band: Rect,
}
impl Nmrebarchildsize {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMREBARCHILDSIZE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMREBARCHILDSIZE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmrebarsplitter {
    pub hdr: Nmhdr,
    pub rc_sizing: Rect,
}
impl Nmrebarsplitter {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMREBARSPLITTER {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMREBARSPLITTER) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmsearchweb {
    pub hdr: Nmhdr,
    pub entrypoint: i32,
    pub has_query_text: BOOL,
    pub invoke_succeeded: BOOL,
}
impl Nmsearchweb {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMSEARCHWEB {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMSEARCHWEB) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmselchange {
    pub nmhdr: Nmhdr,
    pub st_sel_start: Systemtime,
    pub st_sel_end: Systemtime,
}
impl Nmselchange {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMSELCHANGE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMSELCHANGE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmupdown {
    pub hdr: Nmhdr,
    pub i_pos: i32,
    pub i_delta: i32,
}
impl Nmupdown {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMUPDOWN {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMUPDOWN) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nmviewchange {
    pub nmhdr: Nmhdr,
    pub dw_old_view: u32,
    pub dw_new_view: u32,
}
impl Nmviewchange {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::NMVIEWCHANGE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::NMVIEWCHANGE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nonclientmetricsa {
    pub cb_size: u32,
    pub i_border_width: i32,
    pub i_scroll_width: i32,
    pub i_scroll_height: i32,
    pub i_caption_width: i32,
    pub i_caption_height: i32,
    pub lf_caption_font: Logfonta,
    pub i_sm_caption_width: i32,
    pub i_sm_caption_height: i32,
    pub lf_sm_caption_font: Logfonta,
    pub i_menu_width: i32,
    pub i_menu_height: i32,
    pub lf_menu_font: Logfonta,
    pub lf_status_font: Logfonta,
    pub lf_message_font: Logfonta,
    pub i_padded_border_width: i32,
}
impl Nonclientmetricsa {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::NONCLIENTMETRICSA {
        let Self { cb_size, i_border_width, i_scroll_width, i_scroll_height, i_caption_width, i_caption_height, lf_caption_font, i_sm_caption_width, i_sm_caption_height, lf_sm_caption_font, i_menu_width, i_menu_height, lf_menu_font, lf_status_font, lf_message_font, i_padded_border_width } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::NONCLIENTMETRICSA>() as _;
        let iBorderWidth = *i_border_width;
        let iScrollWidth = *i_scroll_width;
        let iScrollHeight = *i_scroll_height;
        let iCaptionWidth = *i_caption_width;
        let iCaptionHeight = *i_caption_height;
        let lfCaptionFont = lf_caption_font.to_win32();
        let iSmCaptionWidth = *i_sm_caption_width;
        let iSmCaptionHeight = *i_sm_caption_height;
        let lfSmCaptionFont = lf_sm_caption_font.to_win32();
        let iMenuWidth = *i_menu_width;
        let iMenuHeight = *i_menu_height;
        let lfMenuFont = lf_menu_font.to_win32();
        let lfStatusFont = lf_status_font.to_win32();
        let lfMessageFont = lf_message_font.to_win32();
        let iPaddedBorderWidth = *i_padded_border_width;
        windows_sys::Win32::UI::WindowsAndMessaging::NONCLIENTMETRICSA { cbSize, iBorderWidth, iScrollWidth, iScrollHeight, iCaptionWidth, iCaptionHeight, lfCaptionFont, iSmCaptionWidth, iSmCaptionHeight, lfSmCaptionFont, iMenuWidth, iMenuHeight, lfMenuFont, lfStatusFont, lfMessageFont, iPaddedBorderWidth }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::NONCLIENTMETRICSA) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::NONCLIENTMETRICSA { cbSize, iBorderWidth, iScrollWidth, iScrollHeight, iCaptionWidth, iCaptionHeight, lfCaptionFont, iSmCaptionWidth, iSmCaptionHeight, lfSmCaptionFont, iMenuWidth, iMenuHeight, lfMenuFont, lfStatusFont, lfMessageFont, iPaddedBorderWidth } = win32;
        let cb_size = cbSize;
        let i_border_width = iBorderWidth;
        let i_scroll_width = iScrollWidth;
        let i_scroll_height = iScrollHeight;
        let i_caption_width = iCaptionWidth;
        let i_caption_height = iCaptionHeight;
        let lf_caption_font = unsafe { Logfonta::from_win32(lfCaptionFont) };
        let i_sm_caption_width = iSmCaptionWidth;
        let i_sm_caption_height = iSmCaptionHeight;
        let lf_sm_caption_font = unsafe { Logfonta::from_win32(lfSmCaptionFont) };
        let i_menu_width = iMenuWidth;
        let i_menu_height = iMenuHeight;
        let lf_menu_font = unsafe { Logfonta::from_win32(lfMenuFont) };
        let lf_status_font = unsafe { Logfonta::from_win32(lfStatusFont) };
        let lf_message_font = unsafe { Logfonta::from_win32(lfMessageFont) };
        let i_padded_border_width = iPaddedBorderWidth;
        Self { cb_size, i_border_width, i_scroll_width, i_scroll_height, i_caption_width, i_caption_height, lf_caption_font, i_sm_caption_width, i_sm_caption_height, lf_sm_caption_font, i_menu_width, i_menu_height, lf_menu_font, lf_status_font, lf_message_font, i_padded_border_width }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Nonclientmetricsw {
    pub cb_size: u32,
    pub i_border_width: i32,
    pub i_scroll_width: i32,
    pub i_scroll_height: i32,
    pub i_caption_width: i32,
    pub i_caption_height: i32,
    pub lf_caption_font: Logfontw,
    pub i_sm_caption_width: i32,
    pub i_sm_caption_height: i32,
    pub lf_sm_caption_font: Logfontw,
    pub i_menu_width: i32,
    pub i_menu_height: i32,
    pub lf_menu_font: Logfontw,
    pub lf_status_font: Logfontw,
    pub lf_message_font: Logfontw,
    pub i_padded_border_width: i32,
}
impl Nonclientmetricsw {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::NONCLIENTMETRICSW {
        let Self { cb_size, i_border_width, i_scroll_width, i_scroll_height, i_caption_width, i_caption_height, lf_caption_font, i_sm_caption_width, i_sm_caption_height, lf_sm_caption_font, i_menu_width, i_menu_height, lf_menu_font, lf_status_font, lf_message_font, i_padded_border_width } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::NONCLIENTMETRICSW>() as _;
        let iBorderWidth = *i_border_width;
        let iScrollWidth = *i_scroll_width;
        let iScrollHeight = *i_scroll_height;
        let iCaptionWidth = *i_caption_width;
        let iCaptionHeight = *i_caption_height;
        let lfCaptionFont = lf_caption_font.to_win32();
        let iSmCaptionWidth = *i_sm_caption_width;
        let iSmCaptionHeight = *i_sm_caption_height;
        let lfSmCaptionFont = lf_sm_caption_font.to_win32();
        let iMenuWidth = *i_menu_width;
        let iMenuHeight = *i_menu_height;
        let lfMenuFont = lf_menu_font.to_win32();
        let lfStatusFont = lf_status_font.to_win32();
        let lfMessageFont = lf_message_font.to_win32();
        let iPaddedBorderWidth = *i_padded_border_width;
        windows_sys::Win32::UI::WindowsAndMessaging::NONCLIENTMETRICSW { cbSize, iBorderWidth, iScrollWidth, iScrollHeight, iCaptionWidth, iCaptionHeight, lfCaptionFont, iSmCaptionWidth, iSmCaptionHeight, lfSmCaptionFont, iMenuWidth, iMenuHeight, lfMenuFont, lfStatusFont, lfMessageFont, iPaddedBorderWidth }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::NONCLIENTMETRICSW) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::NONCLIENTMETRICSW { cbSize, iBorderWidth, iScrollWidth, iScrollHeight, iCaptionWidth, iCaptionHeight, lfCaptionFont, iSmCaptionWidth, iSmCaptionHeight, lfSmCaptionFont, iMenuWidth, iMenuHeight, lfMenuFont, lfStatusFont, lfMessageFont, iPaddedBorderWidth } = win32;
        let cb_size = cbSize;
        let i_border_width = iBorderWidth;
        let i_scroll_width = iScrollWidth;
        let i_scroll_height = iScrollHeight;
        let i_caption_width = iCaptionWidth;
        let i_caption_height = iCaptionHeight;
        let lf_caption_font = unsafe { Logfontw::from_win32(lfCaptionFont) };
        let i_sm_caption_width = iSmCaptionWidth;
        let i_sm_caption_height = iSmCaptionHeight;
        let lf_sm_caption_font = unsafe { Logfontw::from_win32(lfSmCaptionFont) };
        let i_menu_width = iMenuWidth;
        let i_menu_height = iMenuHeight;
        let lf_menu_font = unsafe { Logfontw::from_win32(lfMenuFont) };
        let lf_status_font = unsafe { Logfontw::from_win32(lfStatusFont) };
        let lf_message_font = unsafe { Logfontw::from_win32(lfMessageFont) };
        let i_padded_border_width = iPaddedBorderWidth;
        Self { cb_size, i_border_width, i_scroll_width, i_scroll_height, i_caption_width, i_caption_height, lf_caption_font, i_sm_caption_width, i_sm_caption_height, lf_sm_caption_font, i_menu_width, i_menu_height, lf_menu_font, lf_status_font, lf_message_font, i_padded_border_width }
    }
}
//  Not generated because it involves stubs, crate should manually define type
//  #[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C, packed(1))]
//  pub struct Notifyicondataa {
//      STUBBED OUT
//  }
//  Not generated because it involves stubs, crate should manually define type
//  #[repr(C)]
//  pub union Notifyicondataa5 {
//      STUBBED OUT
//  }
//  Not generated because it involves stubs, crate should manually define type
//  #[repr(C)]
//  pub union Notifyicondataa6 {
//      STUBBED OUT
//  }
//  Not generated because it involves stubs, crate should manually define type
//  #[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C, packed(1))]
//  pub struct Notifyicondataw {
//      STUBBED OUT
//  }
//  Not generated because it involves stubs, crate should manually define type
//  #[repr(C)]
//  pub union Notifyicondataw7 {
//      STUBBED OUT
//  }
//  Not generated because it involves stubs, crate should manually define type
//  #[repr(C)]
//  pub union Notifyicondataw8 {
//      STUBBED OUT
//  }
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct Notifyiconidentifier {
    pub cb_size: u32,
    pub h_wnd: Option<Hwnd>,
    pub u_id: u32,
    pub guid_item: GUID,
}
impl Notifyiconidentifier {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::NOTIFYICONIDENTIFIER {
        let Self { cb_size, h_wnd, u_id, guid_item } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::NOTIFYICONIDENTIFIER>() as _;
        let hWnd = h_wnd.map_or(0, Hwnd::into_raw);
        let uID = *u_id;
        let guidItem = *guid_item;
        windows_sys::Win32::UI::Shell::NOTIFYICONIDENTIFIER { cbSize, hWnd, uID, guidItem }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::NOTIFYICONIDENTIFIER) -> Self {
        let windows_sys::Win32::UI::Shell::NOTIFYICONIDENTIFIER { cbSize, hWnd, uID, guidItem } = win32;
        let cb_size = cbSize;
        let h_wnd = unsafe { Hwnd::new_optional(hWnd) };
        let u_id = uID;
        let guid_item = guidItem;
        Self { cb_size, h_wnd, u_id, guid_item }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct NtFeConsoleProps {
    pub dbh: DatablockHeader,
    pub u_code_page: u32,
}
impl NtFeConsoleProps {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::NT_FE_CONSOLE_PROPS {
        let Self { dbh, u_code_page } = self;
        let dbh = dbh.to_win32();
        let uCodePage = *u_code_page;
        windows_sys::Win32::UI::Shell::NT_FE_CONSOLE_PROPS { dbh, uCodePage }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::NT_FE_CONSOLE_PROPS) -> Self {
        let windows_sys::Win32::UI::Shell::NT_FE_CONSOLE_PROPS { dbh, uCodePage } = win32;
        let dbh = unsafe { DatablockHeader::from_win32(dbh) };
        let u_code_page = uCodePage;
        Self { dbh, u_code_page }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Openasinfo<'a> {
    pub pcsz_file: Cow<'a, [u16]>,
    pub pcsz_class: Cow<'a, [u16]>,
    pub oaif_in_flags: u32,
}
impl<'a> Openasinfo<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::OPENASINFO {
        let Self { pcsz_file, pcsz_class, oaif_in_flags } = self;
        assert_eq!(pcsz_file.last().copied(), Some(0));
        let pcszFile = pcsz_file.as_ptr() as _;
        assert_eq!(pcsz_class.last().copied(), Some(0));
        let pcszClass = pcsz_class.as_ptr() as _;
        let oaifInFlags = *oaif_in_flags;
        windows_sys::Win32::UI::Shell::OPENASINFO { pcszFile, pcszClass, oaifInFlags }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::OPENASINFO) -> Self {
        let windows_sys::Win32::UI::Shell::OPENASINFO { pcszFile, pcszClass, oaifInFlags } = win32;
        let slen = unsafe { wide_strlen(pcszFile as *const u16) };
        let pcszFile = unsafe { slice::from_raw_parts(pcszFile, slen + 1) };
        let pcsz_file = Cow::Owned(pcszFile.to_vec());
        let slen = unsafe { wide_strlen(pcszClass as *const u16) };
        let pcszClass = unsafe { slice::from_raw_parts(pcszClass, slen + 1) };
        let pcsz_class = Cow::Owned(pcszClass.to_vec());
        let oaif_in_flags = oaifInFlags;
        Self { pcsz_file, pcsz_class, oaif_in_flags }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct OpenPrinterPropsInfoa<'a> {
    pub dw_size: u32,
    pub psz_sheet_name: Cow<'a, CStr>,
    pub u_sheet_index: u32,
    pub dw_flags: u32,
    pub b_modal: BOOL,
}
impl<'a> OpenPrinterPropsInfoa<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::OPEN_PRINTER_PROPS_INFOA {
        let Self { dw_size, psz_sheet_name, u_sheet_index, dw_flags, b_modal } = self;
        let dwSize = mem::size_of::<windows_sys::Win32::UI::Shell::OPEN_PRINTER_PROPS_INFOA>() as _;
        let pszSheetName = psz_sheet_name.as_ptr() as _;
        let uSheetIndex = *u_sheet_index;
        let dwFlags = *dw_flags;
        let bModal = *b_modal;
        windows_sys::Win32::UI::Shell::OPEN_PRINTER_PROPS_INFOA { dwSize, pszSheetName, uSheetIndex, dwFlags, bModal }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::OPEN_PRINTER_PROPS_INFOA) -> Self {
        let windows_sys::Win32::UI::Shell::OPEN_PRINTER_PROPS_INFOA { dwSize, pszSheetName, uSheetIndex, dwFlags, bModal } = win32;
        let dw_size = dwSize;
        let pszSheetName = unsafe { CStr::from_ptr(pszSheetName as *const _) };
        let pszSheetName = pszSheetName.to_bytes_with_nul().to_vec();
        let psz_sheet_name = Cow::Owned(unsafe { CString::from_vec_unchecked(pszSheetName) });
        let u_sheet_index = uSheetIndex;
        let dw_flags = dwFlags;
        let b_modal = bModal;
        Self { dw_size, psz_sheet_name, u_sheet_index, dw_flags, b_modal }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C, packed(1))]
pub struct OpenPrinterPropsInfow<'a> {
    pub dw_size: u32,
    pub psz_sheet_name: Cow<'a, [u16]>,
    pub u_sheet_index: u32,
    pub dw_flags: u32,
    pub b_modal: BOOL,
}
impl<'a> OpenPrinterPropsInfow<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::OPEN_PRINTER_PROPS_INFOW {
        let Self { dw_size, psz_sheet_name, u_sheet_index, dw_flags, b_modal } = self;
        let dwSize = mem::size_of::<windows_sys::Win32::UI::Shell::OPEN_PRINTER_PROPS_INFOW>() as _;
        assert_eq!(psz_sheet_name.last().copied(), Some(0));
        let pszSheetName = psz_sheet_name.as_ptr() as _;
        let uSheetIndex = *u_sheet_index;
        let dwFlags = *dw_flags;
        let bModal = *b_modal;
        windows_sys::Win32::UI::Shell::OPEN_PRINTER_PROPS_INFOW { dwSize, pszSheetName, uSheetIndex, dwFlags, bModal }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::OPEN_PRINTER_PROPS_INFOW) -> Self {
        let windows_sys::Win32::UI::Shell::OPEN_PRINTER_PROPS_INFOW { dwSize, pszSheetName, uSheetIndex, dwFlags, bModal } = win32;
        let dw_size = dwSize;
        let slen = unsafe { wide_strlen(pszSheetName as *const u16) };
        let pszSheetName = unsafe { slice::from_raw_parts(pszSheetName, slen + 1) };
        let psz_sheet_name = Cow::Owned(pszSheetName.to_vec());
        let u_sheet_index = uSheetIndex;
        let dw_flags = dwFlags;
        let b_modal = bModal;
        Self { dw_size, psz_sheet_name, u_sheet_index, dw_flags, b_modal }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Outlinetextmetrica<'a> {
    pub otm_size: u32,
    pub otm_text_metrics: Textmetrica,
    pub otm_filler: u8,
    pub otm_panose_number: Panose,
    pub otmfs_selection: u32,
    pub otmfs_type: u32,
    pub otms_char_slope_rise: i32,
    pub otms_char_slope_run: i32,
    pub otm_italic_angle: i32,
    pub otm_em_square: u32,
    pub otm_ascent: i32,
    pub otm_descent: i32,
    pub otm_line_gap: u32,
    pub otms_cap_em_height: u32,
    pub otms_x_height: u32,
    pub otmrc_font_box: Rect,
    pub otm_mac_ascent: i32,
    pub otm_mac_descent: i32,
    pub otm_mac_line_gap: u32,
    pub otmus_minimum_ppem: u32,
    pub otmpt_subscript_size: Point,
    pub otmpt_subscript_offset: Point,
    pub otmpt_superscript_size: Point,
    pub otmpt_superscript_offset: Point,
    pub otms_strikeout_size: u32,
    pub otms_strikeout_position: i32,
    pub otms_underscore_size: i32,
    pub otms_underscore_position: i32,
    pub otmp_family_name: Cow<'a, CStr>,
    pub otmp_face_name: Cow<'a, CStr>,
    pub otmp_style_name: Cow<'a, CStr>,
    pub otmp_full_name: Cow<'a, CStr>,
}
impl<'a> Outlinetextmetrica<'a> {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::OUTLINETEXTMETRICA {
        let Self { otm_size, otm_text_metrics, otm_filler, otm_panose_number, otmfs_selection, otmfs_type, otms_char_slope_rise, otms_char_slope_run, otm_italic_angle, otm_em_square, otm_ascent, otm_descent, otm_line_gap, otms_cap_em_height, otms_x_height, otmrc_font_box, otm_mac_ascent, otm_mac_descent, otm_mac_line_gap, otmus_minimum_ppem, otmpt_subscript_size, otmpt_subscript_offset, otmpt_superscript_size, otmpt_superscript_offset, otms_strikeout_size, otms_strikeout_position, otms_underscore_size, otms_underscore_position, otmp_family_name, otmp_face_name, otmp_style_name, otmp_full_name } = self;
        let otmSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::OUTLINETEXTMETRICA>() as _;
        let otmTextMetrics = otm_text_metrics.to_win32();
        let otmFiller = *otm_filler;
        let otmPanoseNumber = otm_panose_number.to_win32();
        let otmfsSelection = *otmfs_selection;
        let otmfsType = *otmfs_type;
        let otmsCharSlopeRise = *otms_char_slope_rise;
        let otmsCharSlopeRun = *otms_char_slope_run;
        let otmItalicAngle = *otm_italic_angle;
        let otmEMSquare = *otm_em_square;
        let otmAscent = *otm_ascent;
        let otmDescent = *otm_descent;
        let otmLineGap = *otm_line_gap;
        let otmsCapEmHeight = *otms_cap_em_height;
        let otmsXHeight = *otms_x_height;
        let otmrcFontBox = otmrc_font_box.to_win32();
        let otmMacAscent = *otm_mac_ascent;
        let otmMacDescent = *otm_mac_descent;
        let otmMacLineGap = *otm_mac_line_gap;
        let otmusMinimumPPEM = *otmus_minimum_ppem;
        let otmptSubscriptSize = otmpt_subscript_size.to_win32();
        let otmptSubscriptOffset = otmpt_subscript_offset.to_win32();
        let otmptSuperscriptSize = otmpt_superscript_size.to_win32();
        let otmptSuperscriptOffset = otmpt_superscript_offset.to_win32();
        let otmsStrikeoutSize = *otms_strikeout_size;
        let otmsStrikeoutPosition = *otms_strikeout_position;
        let otmsUnderscoreSize = *otms_underscore_size;
        let otmsUnderscorePosition = *otms_underscore_position;
        let otmpFamilyName = otmp_family_name.as_ptr() as _;
        let otmpFaceName = otmp_face_name.as_ptr() as _;
        let otmpStyleName = otmp_style_name.as_ptr() as _;
        let otmpFullName = otmp_full_name.as_ptr() as _;
        windows_sys::Win32::Graphics::Gdi::OUTLINETEXTMETRICA { otmSize, otmTextMetrics, otmFiller, otmPanoseNumber, otmfsSelection, otmfsType, otmsCharSlopeRise, otmsCharSlopeRun, otmItalicAngle, otmEMSquare, otmAscent, otmDescent, otmLineGap, otmsCapEmHeight, otmsXHeight, otmrcFontBox, otmMacAscent, otmMacDescent, otmMacLineGap, otmusMinimumPPEM, otmptSubscriptSize, otmptSubscriptOffset, otmptSuperscriptSize, otmptSuperscriptOffset, otmsStrikeoutSize, otmsStrikeoutPosition, otmsUnderscoreSize, otmsUnderscorePosition, otmpFamilyName, otmpFaceName, otmpStyleName, otmpFullName }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::OUTLINETEXTMETRICA) -> Self {
        let windows_sys::Win32::Graphics::Gdi::OUTLINETEXTMETRICA { otmSize, otmTextMetrics, otmFiller, otmPanoseNumber, otmfsSelection, otmfsType, otmsCharSlopeRise, otmsCharSlopeRun, otmItalicAngle, otmEMSquare, otmAscent, otmDescent, otmLineGap, otmsCapEmHeight, otmsXHeight, otmrcFontBox, otmMacAscent, otmMacDescent, otmMacLineGap, otmusMinimumPPEM, otmptSubscriptSize, otmptSubscriptOffset, otmptSuperscriptSize, otmptSuperscriptOffset, otmsStrikeoutSize, otmsStrikeoutPosition, otmsUnderscoreSize, otmsUnderscorePosition, otmpFamilyName, otmpFaceName, otmpStyleName, otmpFullName } = win32;
        let otm_size = otmSize;
        let otm_text_metrics = unsafe { Textmetrica::from_win32(otmTextMetrics) };
        let otm_filler = otmFiller;
        let otm_panose_number = unsafe { Panose::from_win32(otmPanoseNumber) };
        let otmfs_selection = otmfsSelection;
        let otmfs_type = otmfsType;
        let otms_char_slope_rise = otmsCharSlopeRise;
        let otms_char_slope_run = otmsCharSlopeRun;
        let otm_italic_angle = otmItalicAngle;
        let otm_em_square = otmEMSquare;
        let otm_ascent = otmAscent;
        let otm_descent = otmDescent;
        let otm_line_gap = otmLineGap;
        let otms_cap_em_height = otmsCapEmHeight;
        let otms_x_height = otmsXHeight;
        let otmrc_font_box = unsafe { Rect::from_win32(otmrcFontBox) };
        let otm_mac_ascent = otmMacAscent;
        let otm_mac_descent = otmMacDescent;
        let otm_mac_line_gap = otmMacLineGap;
        let otmus_minimum_ppem = otmusMinimumPPEM;
        let otmpt_subscript_size = unsafe { Point::from_win32(otmptSubscriptSize) };
        let otmpt_subscript_offset = unsafe { Point::from_win32(otmptSubscriptOffset) };
        let otmpt_superscript_size = unsafe { Point::from_win32(otmptSuperscriptSize) };
        let otmpt_superscript_offset = unsafe { Point::from_win32(otmptSuperscriptOffset) };
        let otms_strikeout_size = otmsStrikeoutSize;
        let otms_strikeout_position = otmsStrikeoutPosition;
        let otms_underscore_size = otmsUnderscoreSize;
        let otms_underscore_position = otmsUnderscorePosition;
        let otmpFamilyName = unsafe { CStr::from_ptr(otmpFamilyName as *const _) };
        let otmpFamilyName = otmpFamilyName.to_bytes_with_nul().to_vec();
        let otmp_family_name = Cow::Owned(unsafe { CString::from_vec_unchecked(otmpFamilyName) });
        let otmpFaceName = unsafe { CStr::from_ptr(otmpFaceName as *const _) };
        let otmpFaceName = otmpFaceName.to_bytes_with_nul().to_vec();
        let otmp_face_name = Cow::Owned(unsafe { CString::from_vec_unchecked(otmpFaceName) });
        let otmpStyleName = unsafe { CStr::from_ptr(otmpStyleName as *const _) };
        let otmpStyleName = otmpStyleName.to_bytes_with_nul().to_vec();
        let otmp_style_name = Cow::Owned(unsafe { CString::from_vec_unchecked(otmpStyleName) });
        let otmpFullName = unsafe { CStr::from_ptr(otmpFullName as *const _) };
        let otmpFullName = otmpFullName.to_bytes_with_nul().to_vec();
        let otmp_full_name = Cow::Owned(unsafe { CString::from_vec_unchecked(otmpFullName) });
        Self { otm_size, otm_text_metrics, otm_filler, otm_panose_number, otmfs_selection, otmfs_type, otms_char_slope_rise, otms_char_slope_run, otm_italic_angle, otm_em_square, otm_ascent, otm_descent, otm_line_gap, otms_cap_em_height, otms_x_height, otmrc_font_box, otm_mac_ascent, otm_mac_descent, otm_mac_line_gap, otmus_minimum_ppem, otmpt_subscript_size, otmpt_subscript_offset, otmpt_superscript_size, otmpt_superscript_offset, otms_strikeout_size, otms_strikeout_position, otms_underscore_size, otms_underscore_position, otmp_family_name, otmp_face_name, otmp_style_name, otmp_full_name }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Outlinetextmetricw<'a> {
    pub otm_size: u32,
    pub otm_text_metrics: Textmetricw,
    pub otm_filler: u8,
    pub otm_panose_number: Panose,
    pub otmfs_selection: u32,
    pub otmfs_type: u32,
    pub otms_char_slope_rise: i32,
    pub otms_char_slope_run: i32,
    pub otm_italic_angle: i32,
    pub otm_em_square: u32,
    pub otm_ascent: i32,
    pub otm_descent: i32,
    pub otm_line_gap: u32,
    pub otms_cap_em_height: u32,
    pub otms_x_height: u32,
    pub otmrc_font_box: Rect,
    pub otm_mac_ascent: i32,
    pub otm_mac_descent: i32,
    pub otm_mac_line_gap: u32,
    pub otmus_minimum_ppem: u32,
    pub otmpt_subscript_size: Point,
    pub otmpt_subscript_offset: Point,
    pub otmpt_superscript_size: Point,
    pub otmpt_superscript_offset: Point,
    pub otms_strikeout_size: u32,
    pub otms_strikeout_position: i32,
    pub otms_underscore_size: i32,
    pub otms_underscore_position: i32,
    pub otmp_family_name: Cow<'a, CStr>,
    pub otmp_face_name: Cow<'a, CStr>,
    pub otmp_style_name: Cow<'a, CStr>,
    pub otmp_full_name: Cow<'a, CStr>,
}
impl<'a> Outlinetextmetricw<'a> {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::OUTLINETEXTMETRICW {
        let Self { otm_size, otm_text_metrics, otm_filler, otm_panose_number, otmfs_selection, otmfs_type, otms_char_slope_rise, otms_char_slope_run, otm_italic_angle, otm_em_square, otm_ascent, otm_descent, otm_line_gap, otms_cap_em_height, otms_x_height, otmrc_font_box, otm_mac_ascent, otm_mac_descent, otm_mac_line_gap, otmus_minimum_ppem, otmpt_subscript_size, otmpt_subscript_offset, otmpt_superscript_size, otmpt_superscript_offset, otms_strikeout_size, otms_strikeout_position, otms_underscore_size, otms_underscore_position, otmp_family_name, otmp_face_name, otmp_style_name, otmp_full_name } = self;
        let otmSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::OUTLINETEXTMETRICW>() as _;
        let otmTextMetrics = otm_text_metrics.to_win32();
        let otmFiller = *otm_filler;
        let otmPanoseNumber = otm_panose_number.to_win32();
        let otmfsSelection = *otmfs_selection;
        let otmfsType = *otmfs_type;
        let otmsCharSlopeRise = *otms_char_slope_rise;
        let otmsCharSlopeRun = *otms_char_slope_run;
        let otmItalicAngle = *otm_italic_angle;
        let otmEMSquare = *otm_em_square;
        let otmAscent = *otm_ascent;
        let otmDescent = *otm_descent;
        let otmLineGap = *otm_line_gap;
        let otmsCapEmHeight = *otms_cap_em_height;
        let otmsXHeight = *otms_x_height;
        let otmrcFontBox = otmrc_font_box.to_win32();
        let otmMacAscent = *otm_mac_ascent;
        let otmMacDescent = *otm_mac_descent;
        let otmMacLineGap = *otm_mac_line_gap;
        let otmusMinimumPPEM = *otmus_minimum_ppem;
        let otmptSubscriptSize = otmpt_subscript_size.to_win32();
        let otmptSubscriptOffset = otmpt_subscript_offset.to_win32();
        let otmptSuperscriptSize = otmpt_superscript_size.to_win32();
        let otmptSuperscriptOffset = otmpt_superscript_offset.to_win32();
        let otmsStrikeoutSize = *otms_strikeout_size;
        let otmsStrikeoutPosition = *otms_strikeout_position;
        let otmsUnderscoreSize = *otms_underscore_size;
        let otmsUnderscorePosition = *otms_underscore_position;
        let otmpFamilyName = otmp_family_name.as_ptr() as _;
        let otmpFaceName = otmp_face_name.as_ptr() as _;
        let otmpStyleName = otmp_style_name.as_ptr() as _;
        let otmpFullName = otmp_full_name.as_ptr() as _;
        windows_sys::Win32::Graphics::Gdi::OUTLINETEXTMETRICW { otmSize, otmTextMetrics, otmFiller, otmPanoseNumber, otmfsSelection, otmfsType, otmsCharSlopeRise, otmsCharSlopeRun, otmItalicAngle, otmEMSquare, otmAscent, otmDescent, otmLineGap, otmsCapEmHeight, otmsXHeight, otmrcFontBox, otmMacAscent, otmMacDescent, otmMacLineGap, otmusMinimumPPEM, otmptSubscriptSize, otmptSubscriptOffset, otmptSuperscriptSize, otmptSuperscriptOffset, otmsStrikeoutSize, otmsStrikeoutPosition, otmsUnderscoreSize, otmsUnderscorePosition, otmpFamilyName, otmpFaceName, otmpStyleName, otmpFullName }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::OUTLINETEXTMETRICW) -> Self {
        let windows_sys::Win32::Graphics::Gdi::OUTLINETEXTMETRICW { otmSize, otmTextMetrics, otmFiller, otmPanoseNumber, otmfsSelection, otmfsType, otmsCharSlopeRise, otmsCharSlopeRun, otmItalicAngle, otmEMSquare, otmAscent, otmDescent, otmLineGap, otmsCapEmHeight, otmsXHeight, otmrcFontBox, otmMacAscent, otmMacDescent, otmMacLineGap, otmusMinimumPPEM, otmptSubscriptSize, otmptSubscriptOffset, otmptSuperscriptSize, otmptSuperscriptOffset, otmsStrikeoutSize, otmsStrikeoutPosition, otmsUnderscoreSize, otmsUnderscorePosition, otmpFamilyName, otmpFaceName, otmpStyleName, otmpFullName } = win32;
        let otm_size = otmSize;
        let otm_text_metrics = unsafe { Textmetricw::from_win32(otmTextMetrics) };
        let otm_filler = otmFiller;
        let otm_panose_number = unsafe { Panose::from_win32(otmPanoseNumber) };
        let otmfs_selection = otmfsSelection;
        let otmfs_type = otmfsType;
        let otms_char_slope_rise = otmsCharSlopeRise;
        let otms_char_slope_run = otmsCharSlopeRun;
        let otm_italic_angle = otmItalicAngle;
        let otm_em_square = otmEMSquare;
        let otm_ascent = otmAscent;
        let otm_descent = otmDescent;
        let otm_line_gap = otmLineGap;
        let otms_cap_em_height = otmsCapEmHeight;
        let otms_x_height = otmsXHeight;
        let otmrc_font_box = unsafe { Rect::from_win32(otmrcFontBox) };
        let otm_mac_ascent = otmMacAscent;
        let otm_mac_descent = otmMacDescent;
        let otm_mac_line_gap = otmMacLineGap;
        let otmus_minimum_ppem = otmusMinimumPPEM;
        let otmpt_subscript_size = unsafe { Point::from_win32(otmptSubscriptSize) };
        let otmpt_subscript_offset = unsafe { Point::from_win32(otmptSubscriptOffset) };
        let otmpt_superscript_size = unsafe { Point::from_win32(otmptSuperscriptSize) };
        let otmpt_superscript_offset = unsafe { Point::from_win32(otmptSuperscriptOffset) };
        let otms_strikeout_size = otmsStrikeoutSize;
        let otms_strikeout_position = otmsStrikeoutPosition;
        let otms_underscore_size = otmsUnderscoreSize;
        let otms_underscore_position = otmsUnderscorePosition;
        let otmpFamilyName = unsafe { CStr::from_ptr(otmpFamilyName as *const _) };
        let otmpFamilyName = otmpFamilyName.to_bytes_with_nul().to_vec();
        let otmp_family_name = Cow::Owned(unsafe { CString::from_vec_unchecked(otmpFamilyName) });
        let otmpFaceName = unsafe { CStr::from_ptr(otmpFaceName as *const _) };
        let otmpFaceName = otmpFaceName.to_bytes_with_nul().to_vec();
        let otmp_face_name = Cow::Owned(unsafe { CString::from_vec_unchecked(otmpFaceName) });
        let otmpStyleName = unsafe { CStr::from_ptr(otmpStyleName as *const _) };
        let otmpStyleName = otmpStyleName.to_bytes_with_nul().to_vec();
        let otmp_style_name = Cow::Owned(unsafe { CString::from_vec_unchecked(otmpStyleName) });
        let otmpFullName = unsafe { CStr::from_ptr(otmpFullName as *const _) };
        let otmpFullName = otmpFullName.to_bytes_with_nul().to_vec();
        let otmp_full_name = Cow::Owned(unsafe { CString::from_vec_unchecked(otmpFullName) });
        Self { otm_size, otm_text_metrics, otm_filler, otm_panose_number, otmfs_selection, otmfs_type, otms_char_slope_rise, otms_char_slope_run, otm_italic_angle, otm_em_square, otm_ascent, otm_descent, otm_line_gap, otms_cap_em_height, otms_x_height, otmrc_font_box, otm_mac_ascent, otm_mac_descent, otm_mac_line_gap, otmus_minimum_ppem, otmpt_subscript_size, otmpt_subscript_offset, otmpt_superscript_size, otmpt_superscript_offset, otms_strikeout_size, otms_strikeout_position, otms_underscore_size, otms_underscore_position, otmp_family_name, otmp_face_name, otmp_style_name, otmp_full_name }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Paintstruct {
    pub hdc: Option<Hdc>,
    pub f_erase: BOOL,
    pub rc_paint: Rect,
    pub f_restore: BOOL,
    pub f_inc_update: BOOL,
    pub rgb_reserved: [u8; 32],
}
impl Paintstruct {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::PAINTSTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::PAINTSTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Paletteentry {
    pub pe_red: u8,
    pub pe_green: u8,
    pub pe_blue: u8,
    pub pe_flags: u8,
}
impl Paletteentry {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::PALETTEENTRY {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::PALETTEENTRY) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Panose {
    pub b_family_type: u8,
    pub b_serif_style: u8,
    pub b_weight: u8,
    pub b_proportion: u8,
    pub b_contrast: u8,
    pub b_stroke_variation: u8,
    pub b_arm_style: u8,
    pub b_letterform: u8,
    pub b_midline: u8,
    pub b_x_height: u8,
}
impl Panose {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::PANOSE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::PANOSE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Parsedurla<'a> {
    pub cb_size: u32,
    pub psz_protocol: Cow<'a, CStr>,
    pub cch_protocol: u32,
    pub psz_suffix: Cow<'a, CStr>,
    pub cch_suffix: u32,
    pub n_scheme: u32,
}
impl<'a> Parsedurla<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::PARSEDURLA {
        let Self { cb_size, psz_protocol, cch_protocol, psz_suffix, cch_suffix, n_scheme } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::PARSEDURLA>() as _;
        let pszProtocol = psz_protocol.as_ptr() as _;
        let cchProtocol = *cch_protocol;
        let pszSuffix = psz_suffix.as_ptr() as _;
        let cchSuffix = *cch_suffix;
        let nScheme = *n_scheme;
        windows_sys::Win32::UI::Shell::PARSEDURLA { cbSize, pszProtocol, cchProtocol, pszSuffix, cchSuffix, nScheme }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::PARSEDURLA) -> Self {
        let windows_sys::Win32::UI::Shell::PARSEDURLA { cbSize, pszProtocol, cchProtocol, pszSuffix, cchSuffix, nScheme } = win32;
        let cb_size = cbSize;
        let pszProtocol = unsafe { CStr::from_ptr(pszProtocol as *const _) };
        let pszProtocol = pszProtocol.to_bytes_with_nul().to_vec();
        let psz_protocol = Cow::Owned(unsafe { CString::from_vec_unchecked(pszProtocol) });
        let cch_protocol = cchProtocol;
        let pszSuffix = unsafe { CStr::from_ptr(pszSuffix as *const _) };
        let pszSuffix = pszSuffix.to_bytes_with_nul().to_vec();
        let psz_suffix = Cow::Owned(unsafe { CString::from_vec_unchecked(pszSuffix) });
        let cch_suffix = cchSuffix;
        let n_scheme = nScheme;
        Self { cb_size, psz_protocol, cch_protocol, psz_suffix, cch_suffix, n_scheme }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Parsedurlw<'a> {
    pub cb_size: u32,
    pub psz_protocol: Cow<'a, [u16]>,
    pub cch_protocol: u32,
    pub psz_suffix: Cow<'a, [u16]>,
    pub cch_suffix: u32,
    pub n_scheme: u32,
}
impl<'a> Parsedurlw<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::PARSEDURLW {
        let Self { cb_size, psz_protocol, cch_protocol, psz_suffix, cch_suffix, n_scheme } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::PARSEDURLW>() as _;
        assert_eq!(psz_protocol.last().copied(), Some(0));
        let pszProtocol = psz_protocol.as_ptr() as _;
        let cchProtocol = *cch_protocol;
        assert_eq!(psz_suffix.last().copied(), Some(0));
        let pszSuffix = psz_suffix.as_ptr() as _;
        let cchSuffix = *cch_suffix;
        let nScheme = *n_scheme;
        windows_sys::Win32::UI::Shell::PARSEDURLW { cbSize, pszProtocol, cchProtocol, pszSuffix, cchSuffix, nScheme }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::PARSEDURLW) -> Self {
        let windows_sys::Win32::UI::Shell::PARSEDURLW { cbSize, pszProtocol, cchProtocol, pszSuffix, cchSuffix, nScheme } = win32;
        let cb_size = cbSize;
        let slen = unsafe { wide_strlen(pszProtocol as *const u16) };
        let pszProtocol = unsafe { slice::from_raw_parts(pszProtocol, slen + 1) };
        let psz_protocol = Cow::Owned(pszProtocol.to_vec());
        let cch_protocol = cchProtocol;
        let slen = unsafe { wide_strlen(pszSuffix as *const u16) };
        let pszSuffix = unsafe { slice::from_raw_parts(pszSuffix, slen + 1) };
        let psz_suffix = Cow::Owned(pszSuffix.to_vec());
        let cch_suffix = cchSuffix;
        let n_scheme = nScheme;
        Self { cb_size, psz_protocol, cch_protocol, psz_suffix, cch_suffix, n_scheme }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Pbrange {
    pub i_low: i32,
    pub i_high: i32,
}
impl Pbrange {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::PBRANGE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::PBRANGE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Pelarray {
    pub pa_x_count: i32,
    pub pa_y_count: i32,
    pub pa_x_ext: i32,
    pub pa_y_ext: i32,
    pub pa_rg_bs: u8,
}
impl Pelarray {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::PELARRAY {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::PELARRAY) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Pixelformatdescriptor {
    pub n_size: u16,
    pub n_version: u16,
    pub dw_flags: u32,
    pub i_pixel_type: i8,
    pub c_color_bits: u8,
    pub c_red_bits: u8,
    pub c_red_shift: u8,
    pub c_green_bits: u8,
    pub c_green_shift: u8,
    pub c_blue_bits: u8,
    pub c_blue_shift: u8,
    pub c_alpha_bits: u8,
    pub c_alpha_shift: u8,
    pub c_accum_bits: u8,
    pub c_accum_red_bits: u8,
    pub c_accum_green_bits: u8,
    pub c_accum_blue_bits: u8,
    pub c_accum_alpha_bits: u8,
    pub c_depth_bits: u8,
    pub c_stencil_bits: u8,
    pub c_aux_buffers: u8,
    pub i_layer_type: i8,
    pub b_reserved: u8,
    pub dw_layer_mask: u32,
    pub dw_visible_mask: u32,
    pub dw_damage_mask: u32,
}
impl Pixelformatdescriptor {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::OpenGL::PIXELFORMATDESCRIPTOR {
        let Self { n_size, n_version, dw_flags, i_pixel_type, c_color_bits, c_red_bits, c_red_shift, c_green_bits, c_green_shift, c_blue_bits, c_blue_shift, c_alpha_bits, c_alpha_shift, c_accum_bits, c_accum_red_bits, c_accum_green_bits, c_accum_blue_bits, c_accum_alpha_bits, c_depth_bits, c_stencil_bits, c_aux_buffers, i_layer_type, b_reserved, dw_layer_mask, dw_visible_mask, dw_damage_mask } = self;
        let nSize = mem::size_of::<windows_sys::Win32::Graphics::OpenGL::PIXELFORMATDESCRIPTOR>() as _;
        let nVersion = *n_version;
        let dwFlags = *dw_flags;
        let iPixelType = *i_pixel_type;
        let cColorBits = *c_color_bits;
        let cRedBits = *c_red_bits;
        let cRedShift = *c_red_shift;
        let cGreenBits = *c_green_bits;
        let cGreenShift = *c_green_shift;
        let cBlueBits = *c_blue_bits;
        let cBlueShift = *c_blue_shift;
        let cAlphaBits = *c_alpha_bits;
        let cAlphaShift = *c_alpha_shift;
        let cAccumBits = *c_accum_bits;
        let cAccumRedBits = *c_accum_red_bits;
        let cAccumGreenBits = *c_accum_green_bits;
        let cAccumBlueBits = *c_accum_blue_bits;
        let cAccumAlphaBits = *c_accum_alpha_bits;
        let cDepthBits = *c_depth_bits;
        let cStencilBits = *c_stencil_bits;
        let cAuxBuffers = *c_aux_buffers;
        let iLayerType = *i_layer_type;
        let bReserved = *b_reserved;
        let dwLayerMask = *dw_layer_mask;
        let dwVisibleMask = *dw_visible_mask;
        let dwDamageMask = *dw_damage_mask;
        windows_sys::Win32::Graphics::OpenGL::PIXELFORMATDESCRIPTOR { nSize, nVersion, dwFlags, iPixelType, cColorBits, cRedBits, cRedShift, cGreenBits, cGreenShift, cBlueBits, cBlueShift, cAlphaBits, cAlphaShift, cAccumBits, cAccumRedBits, cAccumGreenBits, cAccumBlueBits, cAccumAlphaBits, cDepthBits, cStencilBits, cAuxBuffers, iLayerType, bReserved, dwLayerMask, dwVisibleMask, dwDamageMask }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::OpenGL::PIXELFORMATDESCRIPTOR) -> Self {
        let windows_sys::Win32::Graphics::OpenGL::PIXELFORMATDESCRIPTOR { nSize, nVersion, dwFlags, iPixelType, cColorBits, cRedBits, cRedShift, cGreenBits, cGreenShift, cBlueBits, cBlueShift, cAlphaBits, cAlphaShift, cAccumBits, cAccumRedBits, cAccumGreenBits, cAccumBlueBits, cAccumAlphaBits, cDepthBits, cStencilBits, cAuxBuffers, iLayerType, bReserved, dwLayerMask, dwVisibleMask, dwDamageMask } = win32;
        let n_size = nSize;
        let n_version = nVersion;
        let dw_flags = dwFlags;
        let i_pixel_type = iPixelType;
        let c_color_bits = cColorBits;
        let c_red_bits = cRedBits;
        let c_red_shift = cRedShift;
        let c_green_bits = cGreenBits;
        let c_green_shift = cGreenShift;
        let c_blue_bits = cBlueBits;
        let c_blue_shift = cBlueShift;
        let c_alpha_bits = cAlphaBits;
        let c_alpha_shift = cAlphaShift;
        let c_accum_bits = cAccumBits;
        let c_accum_red_bits = cAccumRedBits;
        let c_accum_green_bits = cAccumGreenBits;
        let c_accum_blue_bits = cAccumBlueBits;
        let c_accum_alpha_bits = cAccumAlphaBits;
        let c_depth_bits = cDepthBits;
        let c_stencil_bits = cStencilBits;
        let c_aux_buffers = cAuxBuffers;
        let i_layer_type = iLayerType;
        let b_reserved = bReserved;
        let dw_layer_mask = dwLayerMask;
        let dw_visible_mask = dwVisibleMask;
        let dw_damage_mask = dwDamageMask;
        Self { n_size, n_version, dw_flags, i_pixel_type, c_color_bits, c_red_bits, c_red_shift, c_green_bits, c_green_shift, c_blue_bits, c_blue_shift, c_alpha_bits, c_alpha_shift, c_accum_bits, c_accum_red_bits, c_accum_green_bits, c_accum_blue_bits, c_accum_alpha_bits, c_depth_bits, c_stencil_bits, c_aux_buffers, i_layer_type, b_reserved, dw_layer_mask, dw_visible_mask, dw_damage_mask }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Point {
    pub x: i32,
    pub y: i32,
}
impl Point {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::POINT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::POINT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct PointerDeviceCursorInfo {
    pub cursor_id: u32,
    pub cursor: i32,
}
impl PointerDeviceCursorInfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::POINTER_DEVICE_CURSOR_INFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::POINTER_DEVICE_CURSOR_INFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct PointerDeviceInfo {
    pub display_orientation: u32,
    pub device: Option<Handle>,
    pub pointer_device_type: i32,
    pub monitor: Option<Hmonitor>,
    pub starting_cursor_id: u32,
    pub max_active_contacts: u16,
    pub product_string: [u8; 520],
}
impl PointerDeviceInfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::POINTER_DEVICE_INFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::POINTER_DEVICE_INFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct PointerDeviceProperty {
    pub logical_min: i32,
    pub logical_max: i32,
    pub physical_min: i32,
    pub physical_max: i32,
    pub unit: u32,
    pub unit_exponent: u32,
    pub usage_page_id: u16,
    pub usage_id: u16,
}
impl PointerDeviceProperty {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::POINTER_DEVICE_PROPERTY {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::POINTER_DEVICE_PROPERTY) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct PointerInfo {
    pub pointer_type: i32,
    pub pointer_id: u32,
    pub frame_id: u32,
    pub pointer_flags: u32,
    pub source_device: Option<Handle>,
    pub hwnd_target: Option<Hwnd>,
    pub pt_pixel_location: Point,
    pub pt_himetric_location: Point,
    pub pt_pixel_location_raw: Point,
    pub pt_himetric_location_raw: Point,
    pub dw_time: u32,
    pub history_count: u32,
    pub input_data: i32,
    pub dw_key_states: u32,
    pub performance_count: u64,
    pub button_change_type: i32,
}
impl PointerInfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Input::Pointer::POINTER_INFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Input::Pointer::POINTER_INFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct PointerPenInfo {
    pub pointer_info: PointerInfo,
    pub pen_flags: u32,
    pub pen_mask: u32,
    pub pressure: u32,
    pub rotation: u32,
    pub tilt_x: i32,
    pub tilt_y: i32,
}
impl PointerPenInfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Input::Pointer::POINTER_PEN_INFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Input::Pointer::POINTER_PEN_INFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct PointerTouchInfo {
    pub pointer_info: PointerInfo,
    pub touch_flags: u32,
    pub touch_mask: u32,
    pub rc_contact: Rect,
    pub rc_contact_raw: Rect,
    pub orientation: u32,
    pub pressure: u32,
}
impl PointerTouchInfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Input::Pointer::POINTER_TOUCH_INFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Input::Pointer::POINTER_TOUCH_INFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
//  Not generated because it involves stubs, crate should manually define type
//  #[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct PointerTypeInfo {
//      STUBBED OUT
//  }
//  Not generated because it involves stubs, crate should manually define type
//  #[repr(C)]
//  pub union PointerTypeInfo4 {
//      STUBBED OUT
//  }
#[derive(Debug, PartialEq, Default, Copy, Clone)]
#[repr(C)]
pub struct Pointfloat {
    pub x: f32,
    pub y: f32,
}
impl Pointfloat {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::OpenGL::POINTFLOAT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::OpenGL::POINTFLOAT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Pointfx {
    pub x: Fixed,
    pub y: Fixed,
}
impl Pointfx {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::POINTFX {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::POINTFX) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Pointl {
    pub x: i32,
    pub y: i32,
}
impl Pointl {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::POINTL {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::POINTL) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Points {
    pub x: i16,
    pub y: i16,
}
impl Points {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::POINTS {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::POINTS) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Polytexta<'a> {
    pub x: i32,
    pub y: i32,
    pub n: u32,
    pub lpstr: Cow<'a, CStr>,
    pub ui_flags: u32,
    pub rcl: Rect,
    pub pdx: &'a mut i32,
}
impl<'a> Polytexta<'a> {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::POLYTEXTA {
        let Self { x, y, n, lpstr, ui_flags, rcl, pdx } = self;
        let x = *x;
        let y = *y;
        let n = *n;
        let lpstr = lpstr.as_ptr() as _;
        let uiFlags = *ui_flags;
        let rcl = rcl.to_win32();
        let pdx = unsafe { &mut *(pdx as *mut _ as *mut _) };
        windows_sys::Win32::Graphics::Gdi::POLYTEXTA { x, y, n, lpstr, uiFlags, rcl, pdx }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::POLYTEXTA) -> Self {
        let windows_sys::Win32::Graphics::Gdi::POLYTEXTA { x, y, n, lpstr, uiFlags, rcl, pdx } = win32;
        let x = x;
        let y = y;
        let n = n;
        let lpstr = unsafe { CStr::from_ptr(lpstr as *const _) };
        let lpstr = lpstr.to_bytes_with_nul().to_vec();
        let lpstr = Cow::Owned(unsafe { CString::from_vec_unchecked(lpstr) });
        let ui_flags = uiFlags;
        let rcl = unsafe { Rect::from_win32(rcl) };
        let pdx = unsafe { &mut *(pdx as *mut _ as *mut _) };
        Self { x, y, n, lpstr, ui_flags, rcl, pdx }
    }
}
#[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Polytextw<'a> {
    pub x: i32,
    pub y: i32,
    pub n: u32,
    pub lpstr: Cow<'a, [u16]>,
    pub ui_flags: u32,
    pub rcl: Rect,
    pub pdx: &'a mut i32,
}
impl<'a> Polytextw<'a> {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::POLYTEXTW {
        let Self { x, y, n, lpstr, ui_flags, rcl, pdx } = self;
        let x = *x;
        let y = *y;
        let n = *n;
        assert_eq!(lpstr.last().copied(), Some(0));
        let lpstr = lpstr.as_ptr() as _;
        let uiFlags = *ui_flags;
        let rcl = rcl.to_win32();
        let pdx = unsafe { &mut *(pdx as *mut _ as *mut _) };
        windows_sys::Win32::Graphics::Gdi::POLYTEXTW { x, y, n, lpstr, uiFlags, rcl, pdx }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::POLYTEXTW) -> Self {
        let windows_sys::Win32::Graphics::Gdi::POLYTEXTW { x, y, n, lpstr, uiFlags, rcl, pdx } = win32;
        let x = x;
        let y = y;
        let n = n;
        let slen = unsafe { wide_strlen(lpstr as *const u16) };
        let lpstr = unsafe { slice::from_raw_parts(lpstr, slen + 1) };
        let lpstr = Cow::Owned(lpstr.to_vec());
        let ui_flags = uiFlags;
        let rcl = unsafe { Rect::from_win32(rcl) };
        let pdx = unsafe { &mut *(pdx as *mut _ as *mut _) };
        Self { x, y, n, lpstr, ui_flags, rcl, pdx }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Previewhandlerframeinfo {
    pub haccel: Option<Haccel>,
    pub c_accel_entries: u32,
}
impl Previewhandlerframeinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::PREVIEWHANDLERFRAMEINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::PREVIEWHANDLERFRAMEINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Profileinfoa<'a> {
    pub dw_size: u32,
    pub dw_flags: u32,
    pub lp_user_name: Cow<'a, CStr>,
    pub lp_profile_path: Cow<'a, CStr>,
    pub lp_default_path: Cow<'a, CStr>,
    pub lp_server_name: Cow<'a, CStr>,
    pub lp_policy_path: Cow<'a, CStr>,
    pub h_profile: Option<Handle>,
}
impl<'a> Profileinfoa<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::PROFILEINFOA {
        let Self { dw_size, dw_flags, lp_user_name, lp_profile_path, lp_default_path, lp_server_name, lp_policy_path, h_profile } = self;
        let dwSize = mem::size_of::<windows_sys::Win32::UI::Shell::PROFILEINFOA>() as _;
        let dwFlags = *dw_flags;
        let lpUserName = lp_user_name.as_ptr() as _;
        let lpProfilePath = lp_profile_path.as_ptr() as _;
        let lpDefaultPath = lp_default_path.as_ptr() as _;
        let lpServerName = lp_server_name.as_ptr() as _;
        let lpPolicyPath = lp_policy_path.as_ptr() as _;
        let hProfile = h_profile.map_or(0, Handle::into_raw);
        windows_sys::Win32::UI::Shell::PROFILEINFOA { dwSize, dwFlags, lpUserName, lpProfilePath, lpDefaultPath, lpServerName, lpPolicyPath, hProfile }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::PROFILEINFOA) -> Self {
        let windows_sys::Win32::UI::Shell::PROFILEINFOA { dwSize, dwFlags, lpUserName, lpProfilePath, lpDefaultPath, lpServerName, lpPolicyPath, hProfile } = win32;
        let dw_size = dwSize;
        let dw_flags = dwFlags;
        let lpUserName = unsafe { CStr::from_ptr(lpUserName as *const _) };
        let lpUserName = lpUserName.to_bytes_with_nul().to_vec();
        let lp_user_name = Cow::Owned(unsafe { CString::from_vec_unchecked(lpUserName) });
        let lpProfilePath = unsafe { CStr::from_ptr(lpProfilePath as *const _) };
        let lpProfilePath = lpProfilePath.to_bytes_with_nul().to_vec();
        let lp_profile_path = Cow::Owned(unsafe { CString::from_vec_unchecked(lpProfilePath) });
        let lpDefaultPath = unsafe { CStr::from_ptr(lpDefaultPath as *const _) };
        let lpDefaultPath = lpDefaultPath.to_bytes_with_nul().to_vec();
        let lp_default_path = Cow::Owned(unsafe { CString::from_vec_unchecked(lpDefaultPath) });
        let lpServerName = unsafe { CStr::from_ptr(lpServerName as *const _) };
        let lpServerName = lpServerName.to_bytes_with_nul().to_vec();
        let lp_server_name = Cow::Owned(unsafe { CString::from_vec_unchecked(lpServerName) });
        let lpPolicyPath = unsafe { CStr::from_ptr(lpPolicyPath as *const _) };
        let lpPolicyPath = lpPolicyPath.to_bytes_with_nul().to_vec();
        let lp_policy_path = Cow::Owned(unsafe { CString::from_vec_unchecked(lpPolicyPath) });
        let h_profile = unsafe { Handle::new_optional(hProfile) };
        Self { dw_size, dw_flags, lp_user_name, lp_profile_path, lp_default_path, lp_server_name, lp_policy_path, h_profile }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Profileinfow<'a> {
    pub dw_size: u32,
    pub dw_flags: u32,
    pub lp_user_name: Cow<'a, [u16]>,
    pub lp_profile_path: Cow<'a, [u16]>,
    pub lp_default_path: Cow<'a, [u16]>,
    pub lp_server_name: Cow<'a, [u16]>,
    pub lp_policy_path: Cow<'a, [u16]>,
    pub h_profile: Option<Handle>,
}
impl<'a> Profileinfow<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::PROFILEINFOW {
        let Self { dw_size, dw_flags, lp_user_name, lp_profile_path, lp_default_path, lp_server_name, lp_policy_path, h_profile } = self;
        let dwSize = mem::size_of::<windows_sys::Win32::UI::Shell::PROFILEINFOW>() as _;
        let dwFlags = *dw_flags;
        assert_eq!(lp_user_name.last().copied(), Some(0));
        let lpUserName = lp_user_name.as_ptr() as _;
        assert_eq!(lp_profile_path.last().copied(), Some(0));
        let lpProfilePath = lp_profile_path.as_ptr() as _;
        assert_eq!(lp_default_path.last().copied(), Some(0));
        let lpDefaultPath = lp_default_path.as_ptr() as _;
        assert_eq!(lp_server_name.last().copied(), Some(0));
        let lpServerName = lp_server_name.as_ptr() as _;
        assert_eq!(lp_policy_path.last().copied(), Some(0));
        let lpPolicyPath = lp_policy_path.as_ptr() as _;
        let hProfile = h_profile.map_or(0, Handle::into_raw);
        windows_sys::Win32::UI::Shell::PROFILEINFOW { dwSize, dwFlags, lpUserName, lpProfilePath, lpDefaultPath, lpServerName, lpPolicyPath, hProfile }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::PROFILEINFOW) -> Self {
        let windows_sys::Win32::UI::Shell::PROFILEINFOW { dwSize, dwFlags, lpUserName, lpProfilePath, lpDefaultPath, lpServerName, lpPolicyPath, hProfile } = win32;
        let dw_size = dwSize;
        let dw_flags = dwFlags;
        let slen = unsafe { wide_strlen(lpUserName as *const u16) };
        let lpUserName = unsafe { slice::from_raw_parts(lpUserName, slen + 1) };
        let lp_user_name = Cow::Owned(lpUserName.to_vec());
        let slen = unsafe { wide_strlen(lpProfilePath as *const u16) };
        let lpProfilePath = unsafe { slice::from_raw_parts(lpProfilePath, slen + 1) };
        let lp_profile_path = Cow::Owned(lpProfilePath.to_vec());
        let slen = unsafe { wide_strlen(lpDefaultPath as *const u16) };
        let lpDefaultPath = unsafe { slice::from_raw_parts(lpDefaultPath, slen + 1) };
        let lp_default_path = Cow::Owned(lpDefaultPath.to_vec());
        let slen = unsafe { wide_strlen(lpServerName as *const u16) };
        let lpServerName = unsafe { slice::from_raw_parts(lpServerName, slen + 1) };
        let lp_server_name = Cow::Owned(lpServerName.to_vec());
        let slen = unsafe { wide_strlen(lpPolicyPath as *const u16) };
        let lpPolicyPath = unsafe { slice::from_raw_parts(lpPolicyPath, slen + 1) };
        let lp_policy_path = Cow::Owned(lpPolicyPath.to_vec());
        let h_profile = unsafe { Handle::new_optional(hProfile) };
        Self { dw_size, dw_flags, lp_user_name, lp_profile_path, lp_default_path, lp_server_name, lp_policy_path, h_profile }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Pshnotify {
    pub hdr: Nmhdr,
    pub l_param: Lparam,
}
impl Pshnotify {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::PSHNOTIFY {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::PSHNOTIFY) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Pubappinfo<'a> {
    pub cb_size: u32,
    pub dw_mask: u32,
    pub psz_source: Cow<'a, [u16]>,
    pub st_assigned: Systemtime,
    pub st_published: Systemtime,
    pub st_scheduled: Systemtime,
    pub st_expire: Systemtime,
}
impl<'a> Pubappinfo<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::PUBAPPINFO {
        let Self { cb_size, dw_mask, psz_source, st_assigned, st_published, st_scheduled, st_expire } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Shell::PUBAPPINFO>() as _;
        let dwMask = *dw_mask;
        assert_eq!(psz_source.last().copied(), Some(0));
        let pszSource = psz_source.as_ptr() as _;
        let stAssigned = st_assigned.to_win32();
        let stPublished = st_published.to_win32();
        let stScheduled = st_scheduled.to_win32();
        let stExpire = st_expire.to_win32();
        windows_sys::Win32::UI::Shell::PUBAPPINFO { cbSize, dwMask, pszSource, stAssigned, stPublished, stScheduled, stExpire }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::PUBAPPINFO) -> Self {
        let windows_sys::Win32::UI::Shell::PUBAPPINFO { cbSize, dwMask, pszSource, stAssigned, stPublished, stScheduled, stExpire } = win32;
        let cb_size = cbSize;
        let dw_mask = dwMask;
        let slen = unsafe { wide_strlen(pszSource as *const u16) };
        let pszSource = unsafe { slice::from_raw_parts(pszSource, slen + 1) };
        let psz_source = Cow::Owned(pszSource.to_vec());
        let st_assigned = unsafe { Systemtime::from_win32(stAssigned) };
        let st_published = unsafe { Systemtime::from_win32(stPublished) };
        let st_scheduled = unsafe { Systemtime::from_win32(stScheduled) };
        let st_expire = unsafe { Systemtime::from_win32(stExpire) };
        Self { cb_size, dw_mask, psz_source, st_assigned, st_published, st_scheduled, st_expire }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Qcminfo<'a> {
    pub hmenu: Option<Hmenu>,
    pub index_menu: u32,
    pub id_cmd_first: u32,
    pub id_cmd_last: u32,
    pub p_id_map: Cow<'a, QcminfoIdmap>,
}
impl<'a> Qcminfo<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::QCMINFO {
        let Self { hmenu, index_menu, id_cmd_first, id_cmd_last, p_id_map } = self;
        let hmenu = hmenu.map_or(0, Hmenu::into_raw);
        let indexMenu = *index_menu;
        let idCmdFirst = *id_cmd_first;
        let idCmdLast = *id_cmd_last;
        let pIdMap = unsafe { &*(&**p_id_map as *const _ as *const _) };
        windows_sys::Win32::UI::Shell::QCMINFO { hmenu, indexMenu, idCmdFirst, idCmdLast, pIdMap }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::QCMINFO) -> Self {
        let windows_sys::Win32::UI::Shell::QCMINFO { hmenu, indexMenu, idCmdFirst, idCmdLast, pIdMap } = win32;
        let hmenu = unsafe { Hmenu::new_optional(hmenu) };
        let index_menu = indexMenu;
        let id_cmd_first = idCmdFirst;
        let id_cmd_last = idCmdLast;
        let p_id_map = Cow::Borrowed(unsafe { &*(pIdMap as *const _ as *const _) });
        Self { hmenu, index_menu, id_cmd_first, id_cmd_last, p_id_map }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct QcminfoIdmap {
    pub n_max_ids: u32,
    pub p_id_list: [QcminfoIdmapPlacement; 1],
}
impl QcminfoIdmap {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::QCMINFO_IDMAP {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::QCMINFO_IDMAP) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct QcminfoIdmapPlacement {
    pub id: u32,
    pub f_flags: u32,
}
impl QcminfoIdmapPlacement {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::QCMINFO_IDMAP_PLACEMENT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::QCMINFO_IDMAP_PLACEMENT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Qitab<'a> {
    pub piid: Cow<'a, GUID>,
    pub dw_offset: u32,
}
impl<'a> Qitab<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::QITAB {
        let Self { piid, dw_offset } = self;
        let piid = unsafe { &*(&**piid as *const _ as *const _) };
        let dwOffset = *dw_offset;
        windows_sys::Win32::UI::Shell::QITAB { piid, dwOffset }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::QITAB) -> Self {
        let windows_sys::Win32::UI::Shell::QITAB { piid, dwOffset } = win32;
        let piid = Cow::Borrowed(unsafe { &*(piid as *const _ as *const _) });
        let dw_offset = dwOffset;
        Self { piid, dw_offset }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct RasterizerStatus {
    pub n_size: i16,
    pub w_flags: i16,
    pub n_language_id: i16,
}
impl RasterizerStatus {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::RASTERIZER_STATUS {
        let Self { n_size, w_flags, n_language_id } = self;
        let nSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::RASTERIZER_STATUS>() as _;
        let wFlags = *w_flags;
        let nLanguageID = *n_language_id;
        windows_sys::Win32::Graphics::Gdi::RASTERIZER_STATUS { nSize, wFlags, nLanguageID }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::RASTERIZER_STATUS) -> Self {
        let windows_sys::Win32::Graphics::Gdi::RASTERIZER_STATUS { nSize, wFlags, nLanguageID } = win32;
        let n_size = nSize;
        let w_flags = wFlags;
        let n_language_id = nLanguageID;
        Self { n_size, w_flags, n_language_id }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Rbhittestinfo {
    pub pt: Point,
    pub flags: u32,
    pub i_band: i32,
}
impl Rbhittestinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::RBHITTESTINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::RBHITTESTINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Rebarbandinfoa<'a> {
    pub cb_size: u32,
    pub f_mask: u32,
    pub f_style: u32,
    pub clr_fore: u32,
    pub clr_back: u32,
    pub lp_text: Cow<'a, CStr>,
    pub cch: u32,
    pub i_image: i32,
    pub hwnd_child: Option<Hwnd>,
    pub cx_min_child: u32,
    pub cy_min_child: u32,
    pub cx: u32,
    pub hbm_back: Option<Hbitmap>,
    pub w_id: u32,
    pub cy_child: u32,
    pub cy_max_child: u32,
    pub cy_integral: u32,
    pub cx_ideal: u32,
    pub l_param: Lparam,
    pub cx_header: u32,
    pub rc_chevron_location: Rect,
    pub u_chevron_state: u32,
}
impl<'a> Rebarbandinfoa<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::REBARBANDINFOA {
        let Self { cb_size, f_mask, f_style, clr_fore, clr_back, lp_text, cch, i_image, hwnd_child, cx_min_child, cy_min_child, cx, hbm_back, w_id, cy_child, cy_max_child, cy_integral, cx_ideal, l_param, cx_header, rc_chevron_location, u_chevron_state } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::REBARBANDINFOA>() as _;
        let fMask = *f_mask;
        let fStyle = *f_style;
        let clrFore = *clr_fore;
        let clrBack = *clr_back;
        let lpText = lp_text.as_ptr() as _;
        let cch = *cch;
        let iImage = *i_image;
        let hwndChild = hwnd_child.map_or(0, Hwnd::into_raw);
        let cxMinChild = *cx_min_child;
        let cyMinChild = *cy_min_child;
        let cx = *cx;
        let hbmBack = hbm_back.map_or(0, Hbitmap::into_raw);
        let wID = *w_id;
        let cyChild = *cy_child;
        let cyMaxChild = *cy_max_child;
        let cyIntegral = *cy_integral;
        let cxIdeal = *cx_ideal;
        let lParam = l_param.into_inner();
        let cxHeader = *cx_header;
        let rcChevronLocation = rc_chevron_location.to_win32();
        let uChevronState = *u_chevron_state;
        windows_sys::Win32::UI::Controls::REBARBANDINFOA { cbSize, fMask, fStyle, clrFore, clrBack, lpText, cch, iImage, hwndChild, cxMinChild, cyMinChild, cx, hbmBack, wID, cyChild, cyMaxChild, cyIntegral, cxIdeal, lParam, cxHeader, rcChevronLocation, uChevronState }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::REBARBANDINFOA) -> Self {
        let windows_sys::Win32::UI::Controls::REBARBANDINFOA { cbSize, fMask, fStyle, clrFore, clrBack, lpText, cch, iImage, hwndChild, cxMinChild, cyMinChild, cx, hbmBack, wID, cyChild, cyMaxChild, cyIntegral, cxIdeal, lParam, cxHeader, rcChevronLocation, uChevronState } = win32;
        let cb_size = cbSize;
        let f_mask = fMask;
        let f_style = fStyle;
        let clr_fore = clrFore;
        let clr_back = clrBack;
        let lpText = unsafe { CStr::from_ptr(lpText as *const _) };
        let lpText = lpText.to_bytes_with_nul().to_vec();
        let lp_text = Cow::Owned(unsafe { CString::from_vec_unchecked(lpText) });
        let cch = cch;
        let i_image = iImage;
        let hwnd_child = unsafe { Hwnd::new_optional(hwndChild) };
        let cx_min_child = cxMinChild;
        let cy_min_child = cyMinChild;
        let cx = cx;
        let hbm_back = unsafe { Hbitmap::new_optional(hbmBack) };
        let w_id = wID;
        let cy_child = cyChild;
        let cy_max_child = cyMaxChild;
        let cy_integral = cyIntegral;
        let cx_ideal = cxIdeal;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        let cx_header = cxHeader;
        let rc_chevron_location = unsafe { Rect::from_win32(rcChevronLocation) };
        let u_chevron_state = uChevronState;
        Self { cb_size, f_mask, f_style, clr_fore, clr_back, lp_text, cch, i_image, hwnd_child, cx_min_child, cy_min_child, cx, hbm_back, w_id, cy_child, cy_max_child, cy_integral, cx_ideal, l_param, cx_header, rc_chevron_location, u_chevron_state }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Rebarbandinfow<'a> {
    pub cb_size: u32,
    pub f_mask: u32,
    pub f_style: u32,
    pub clr_fore: u32,
    pub clr_back: u32,
    pub lp_text: Cow<'a, [u16]>,
    pub cch: u32,
    pub i_image: i32,
    pub hwnd_child: Option<Hwnd>,
    pub cx_min_child: u32,
    pub cy_min_child: u32,
    pub cx: u32,
    pub hbm_back: Option<Hbitmap>,
    pub w_id: u32,
    pub cy_child: u32,
    pub cy_max_child: u32,
    pub cy_integral: u32,
    pub cx_ideal: u32,
    pub l_param: Lparam,
    pub cx_header: u32,
    pub rc_chevron_location: Rect,
    pub u_chevron_state: u32,
}
impl<'a> Rebarbandinfow<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::REBARBANDINFOW {
        let Self { cb_size, f_mask, f_style, clr_fore, clr_back, lp_text, cch, i_image, hwnd_child, cx_min_child, cy_min_child, cx, hbm_back, w_id, cy_child, cy_max_child, cy_integral, cx_ideal, l_param, cx_header, rc_chevron_location, u_chevron_state } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::REBARBANDINFOW>() as _;
        let fMask = *f_mask;
        let fStyle = *f_style;
        let clrFore = *clr_fore;
        let clrBack = *clr_back;
        assert_eq!(lp_text.last().copied(), Some(0));
        let lpText = lp_text.as_ptr() as _;
        let cch = *cch;
        let iImage = *i_image;
        let hwndChild = hwnd_child.map_or(0, Hwnd::into_raw);
        let cxMinChild = *cx_min_child;
        let cyMinChild = *cy_min_child;
        let cx = *cx;
        let hbmBack = hbm_back.map_or(0, Hbitmap::into_raw);
        let wID = *w_id;
        let cyChild = *cy_child;
        let cyMaxChild = *cy_max_child;
        let cyIntegral = *cy_integral;
        let cxIdeal = *cx_ideal;
        let lParam = l_param.into_inner();
        let cxHeader = *cx_header;
        let rcChevronLocation = rc_chevron_location.to_win32();
        let uChevronState = *u_chevron_state;
        windows_sys::Win32::UI::Controls::REBARBANDINFOW { cbSize, fMask, fStyle, clrFore, clrBack, lpText, cch, iImage, hwndChild, cxMinChild, cyMinChild, cx, hbmBack, wID, cyChild, cyMaxChild, cyIntegral, cxIdeal, lParam, cxHeader, rcChevronLocation, uChevronState }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::REBARBANDINFOW) -> Self {
        let windows_sys::Win32::UI::Controls::REBARBANDINFOW { cbSize, fMask, fStyle, clrFore, clrBack, lpText, cch, iImage, hwndChild, cxMinChild, cyMinChild, cx, hbmBack, wID, cyChild, cyMaxChild, cyIntegral, cxIdeal, lParam, cxHeader, rcChevronLocation, uChevronState } = win32;
        let cb_size = cbSize;
        let f_mask = fMask;
        let f_style = fStyle;
        let clr_fore = clrFore;
        let clr_back = clrBack;
        let slen = unsafe { wide_strlen(lpText as *const u16) };
        let lpText = unsafe { slice::from_raw_parts(lpText, slen + 1) };
        let lp_text = Cow::Owned(lpText.to_vec());
        let cch = cch;
        let i_image = iImage;
        let hwnd_child = unsafe { Hwnd::new_optional(hwndChild) };
        let cx_min_child = cxMinChild;
        let cy_min_child = cyMinChild;
        let cx = cx;
        let hbm_back = unsafe { Hbitmap::new_optional(hbmBack) };
        let w_id = wID;
        let cy_child = cyChild;
        let cy_max_child = cyMaxChild;
        let cy_integral = cyIntegral;
        let cx_ideal = cxIdeal;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        let cx_header = cxHeader;
        let rc_chevron_location = unsafe { Rect::from_win32(rcChevronLocation) };
        let u_chevron_state = uChevronState;
        Self { cb_size, f_mask, f_style, clr_fore, clr_back, lp_text, cch, i_image, hwnd_child, cx_min_child, cy_min_child, cx, hbm_back, w_id, cy_child, cy_max_child, cy_integral, cx_ideal, l_param, cx_header, rc_chevron_location, u_chevron_state }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Rebarinfo {
    pub cb_size: u32,
    pub f_mask: u32,
    pub himl: Option<Himagelist>,
}
impl Rebarinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::REBARINFO {
        let Self { cb_size, f_mask, himl } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::REBARINFO>() as _;
        let fMask = *f_mask;
        let himl = himl.map_or(0, Himagelist::into_raw);
        windows_sys::Win32::UI::Controls::REBARINFO { cbSize, fMask, himl }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::REBARINFO) -> Self {
        let windows_sys::Win32::UI::Controls::REBARINFO { cbSize, fMask, himl } = win32;
        let cb_size = cbSize;
        let f_mask = fMask;
        let himl = unsafe { Himagelist::new_optional(himl) };
        Self { cb_size, f_mask, himl }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Rect {
    pub left: i32,
    pub top: i32,
    pub right: i32,
    pub bottom: i32,
}
impl Rect {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::RECT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::RECT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Rectl {
    pub left: i32,
    pub top: i32,
    pub right: i32,
    pub bottom: i32,
}
impl Rectl {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::RECTL {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::RECTL) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Rgbquad {
    pub rgb_blue: u8,
    pub rgb_green: u8,
    pub rgb_red: u8,
    pub rgb_reserved: u8,
}
impl Rgbquad {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::RGBQUAD {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::RGBQUAD) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Rgbtriple {
    pub rgbt_blue: u8,
    pub rgbt_green: u8,
    pub rgbt_red: u8,
}
impl Rgbtriple {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::RGBTRIPLE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::RGBTRIPLE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Rgndata {
    pub rdh: Rgndataheader,
    pub buffer: [CHAR; 1],
}
impl Rgndata {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::RGNDATA {
        let Self { rdh, buffer } = self;
        let rdh = rdh.to_win32();
        let Buffer = [*&buffer[0]];
        windows_sys::Win32::Graphics::Gdi::RGNDATA { rdh, Buffer }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::RGNDATA) -> Self {
        let windows_sys::Win32::Graphics::Gdi::RGNDATA { rdh, Buffer } = win32;
        let rdh = unsafe { Rgndataheader::from_win32(rdh) };
        let buffer = [Buffer[0]];
        Self { rdh, buffer }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Rgndataheader {
    pub dw_size: u32,
    pub i_type: u32,
    pub n_count: u32,
    pub n_rgn_size: u32,
    pub rc_bound: Rect,
}
impl Rgndataheader {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::RGNDATAHEADER {
        let Self { dw_size, i_type, n_count, n_rgn_size, rc_bound } = self;
        let dwSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::RGNDATAHEADER>() as _;
        let iType = *i_type;
        let nCount = *n_count;
        let nRgnSize = *n_rgn_size;
        let rcBound = rc_bound.to_win32();
        windows_sys::Win32::Graphics::Gdi::RGNDATAHEADER { dwSize, iType, nCount, nRgnSize, rcBound }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::RGNDATAHEADER) -> Self {
        let windows_sys::Win32::Graphics::Gdi::RGNDATAHEADER { dwSize, iType, nCount, nRgnSize, rcBound } = win32;
        let dw_size = dwSize;
        let i_type = iType;
        let n_count = nCount;
        let n_rgn_size = nRgnSize;
        let rc_bound = unsafe { Rect::from_win32(rcBound) };
        Self { dw_size, i_type, n_count, n_rgn_size, rc_bound }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Scrollbarinfo {
    pub cb_size: u32,
    pub rc_scroll_bar: Rect,
    pub dxy_line_button: i32,
    pub xy_thumb_top: i32,
    pub xy_thumb_bottom: i32,
    pub reserved: i32,
    pub rgstate: [u32; 6],
}
impl Scrollbarinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::SCROLLBARINFO {
        let Self { cb_size, rc_scroll_bar, dxy_line_button, xy_thumb_top, xy_thumb_bottom, reserved, rgstate } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::SCROLLBARINFO>() as _;
        let rcScrollBar = rc_scroll_bar.to_win32();
        let dxyLineButton = *dxy_line_button;
        let xyThumbTop = *xy_thumb_top;
        let xyThumbBottom = *xy_thumb_bottom;
        let reserved = *reserved;
        let rgstate = [*&rgstate[0],*&rgstate[1],*&rgstate[2],*&rgstate[3],*&rgstate[4],*&rgstate[5]];
        windows_sys::Win32::UI::WindowsAndMessaging::SCROLLBARINFO { cbSize, rcScrollBar, dxyLineButton, xyThumbTop, xyThumbBottom, reserved, rgstate }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::SCROLLBARINFO) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::SCROLLBARINFO { cbSize, rcScrollBar, dxyLineButton, xyThumbTop, xyThumbBottom, reserved, rgstate } = win32;
        let cb_size = cbSize;
        let rc_scroll_bar = unsafe { Rect::from_win32(rcScrollBar) };
        let dxy_line_button = dxyLineButton;
        let xy_thumb_top = xyThumbTop;
        let xy_thumb_bottom = xyThumbBottom;
        let reserved = reserved;
        let rgstate = [rgstate[0],rgstate[1],rgstate[2],rgstate[3],rgstate[4],rgstate[5]];
        Self { cb_size, rc_scroll_bar, dxy_line_button, xy_thumb_top, xy_thumb_bottom, reserved, rgstate }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Scrollinfo {
    pub cb_size: u32,
    pub f_mask: u32,
    pub n_min: i32,
    pub n_max: i32,
    pub n_page: u32,
    pub n_pos: i32,
    pub n_track_pos: i32,
}
impl Scrollinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::SCROLLINFO {
        let Self { cb_size, f_mask, n_min, n_max, n_page, n_pos, n_track_pos } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::SCROLLINFO>() as _;
        let fMask = *f_mask;
        let nMin = *n_min;
        let nMax = *n_max;
        let nPage = *n_page;
        let nPos = *n_pos;
        let nTrackPos = *n_track_pos;
        windows_sys::Win32::UI::WindowsAndMessaging::SCROLLINFO { cbSize, fMask, nMin, nMax, nPage, nPos, nTrackPos }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::SCROLLINFO) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::SCROLLINFO { cbSize, fMask, nMin, nMax, nPage, nPos, nTrackPos } = win32;
        let cb_size = cbSize;
        let f_mask = fMask;
        let n_min = nMin;
        let n_max = nMax;
        let n_page = nPage;
        let n_pos = nPos;
        let n_track_pos = nTrackPos;
        Self { cb_size, f_mask, n_min, n_max, n_page, n_pos, n_track_pos }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct SfvmHelptopicData {
    pub wsz_help_file: [u8; 260],
    pub wsz_help_topic: [u8; 260],
}
impl SfvmHelptopicData {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::SFVM_HELPTOPIC_DATA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::SFVM_HELPTOPIC_DATA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone)]
#[repr(C)]
pub struct SfvmProppageData {
    pub dw_reserved: u32,
    pub pfn: Option<unsafe extern "system" fn(HPROPSHEETPAGE, LPARAM) -> BOOL>,
    pub l_param: Lparam,
}
impl SfvmProppageData {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::SFVM_PROPPAGE_DATA {
        let Self { dw_reserved, pfn, l_param } = self;
        let dwReserved = *dw_reserved;
        let pfn = *pfn;
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::Shell::SFVM_PROPPAGE_DATA { dwReserved, pfn, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::SFVM_PROPPAGE_DATA) -> Self {
        let windows_sys::Win32::UI::Shell::SFVM_PROPPAGE_DATA { dwReserved, pfn, lParam } = win32;
        let dw_reserved = dwReserved;
        let pfn = pfn;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { dw_reserved, pfn, l_param }
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ShandlePtr {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl ShandlePtr {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for ShandlePtr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for ShandlePtr {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Size {
    pub cx: i32,
    pub cy: i32,
}
impl Size {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::SIZE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::SIZE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Slowappinfo<'a> {
    pub ull_size: u64,
    pub ft_last_used: Filetime,
    pub i_times_used: i32,
    pub psz_image: Cow<'a, [u16]>,
}
impl<'a> Slowappinfo<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::SLOWAPPINFO {
        let Self { ull_size, ft_last_used, i_times_used, psz_image } = self;
        let ullSize = mem::size_of::<windows_sys::Win32::UI::Shell::SLOWAPPINFO>() as _;
        let ftLastUsed = ft_last_used.to_win32();
        let iTimesUsed = *i_times_used;
        assert_eq!(psz_image.last().copied(), Some(0));
        let pszImage = psz_image.as_ptr() as _;
        windows_sys::Win32::UI::Shell::SLOWAPPINFO { ullSize, ftLastUsed, iTimesUsed, pszImage }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::SLOWAPPINFO) -> Self {
        let windows_sys::Win32::UI::Shell::SLOWAPPINFO { ullSize, ftLastUsed, iTimesUsed, pszImage } = win32;
        let ull_size = ullSize;
        let ft_last_used = unsafe { Filetime::from_win32(ftLastUsed) };
        let i_times_used = iTimesUsed;
        let slen = unsafe { wide_strlen(pszImage as *const u16) };
        let pszImage = unsafe { slice::from_raw_parts(pszImage, slen + 1) };
        let psz_image = Cow::Owned(pszImage.to_vec());
        Self { ull_size, ft_last_used, i_times_used, psz_image }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Sminfo {
    pub dw_mask: u32,
    pub dw_type: u32,
    pub dw_flags: u32,
    pub i_icon: i32,
}
impl Sminfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::SMINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::SMINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Stylestruct {
    pub style_old: u32,
    pub style_new: u32,
}
impl Stylestruct {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::STYLESTRUCT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::STYLESTRUCT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Systemtime {
    pub w_year: u16,
    pub w_month: u16,
    pub w_day_of_week: u16,
    pub w_day: u16,
    pub w_hour: u16,
    pub w_minute: u16,
    pub w_second: u16,
    pub w_milliseconds: u16,
}
impl Systemtime {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::SYSTEMTIME {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::SYSTEMTIME) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ShFindChangeNotificationHandle {
    handle: NonZeroIsize, 
    _thread_unsafe: PhantomData<*mut ()>,
}

impl ShFindChangeNotificationHandle {
    pub const unsafe fn new(handle: isize) -> Self {
        Self {
            handle: NonZeroIsize::new_unchecked(handle),
            _thread_unsafe: PhantomData,
        }
    }

    pub const unsafe fn new_optional(handle: isize) -> Option<Self> {
        match NonZeroIsize::new(handle) {
            Some(handle) => Some(Self {
                handle,
                _thread_unsafe: PhantomData,
            }),
            None => None,
        }
    }

    pub fn into_raw(self) -> isize {
        self.handle.get()
    }
}

impl fmt::Debug for ShFindChangeNotificationHandle {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::UpperHex::fmt(&self.handle, f)
    }
}

#[cfg(feature = "breadthread")]
unsafe impl breadthread::Compatible for ShFindChangeNotificationHandle {
    fn representative(&self) -> usize {
        self.into_raw() as usize
    }
}
                    
#[derive(Debug, PartialEq, Default, Copy, Clone)]
#[repr(C)]
pub struct TaCubicBezier {
    pub header: TaTimingfunction,
    pub r_x0: f32,
    pub r_y0: f32,
    pub r_x1: f32,
    pub r_y1: f32,
}
impl TaCubicBezier {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TA_CUBIC_BEZIER {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TA_CUBIC_BEZIER) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct TaTimingfunction {
    pub e_timing_function_type: i32,
}
impl TaTimingfunction {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TA_TIMINGFUNCTION {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TA_TIMINGFUNCTION) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct TaTransform {
    pub e_transform_type: i32,
    pub dw_timing_function_id: u32,
    pub dw_start_time: u32,
    pub dw_duration_time: u32,
    pub e_flags: i32,
}
impl TaTransform {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TA_TRANSFORM {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TA_TRANSFORM) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone)]
#[repr(C)]
pub struct TaTransform2d {
    pub header: TaTransform,
    pub r_x: f32,
    pub r_y: f32,
    pub r_initial_x: f32,
    pub r_initial_y: f32,
    pub r_origin_x: f32,
    pub r_origin_y: f32,
}
impl TaTransform2d {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TA_TRANSFORM_2D {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TA_TRANSFORM_2D) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone)]
#[repr(C)]
pub struct TaTransformClip {
    pub header: TaTransform,
    pub r_left: f32,
    pub r_top: f32,
    pub r_right: f32,
    pub r_bottom: f32,
    pub r_initial_left: f32,
    pub r_initial_top: f32,
    pub r_initial_right: f32,
    pub r_initial_bottom: f32,
}
impl TaTransformClip {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TA_TRANSFORM_CLIP {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TA_TRANSFORM_CLIP) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone)]
#[repr(C)]
pub struct TaTransformOpacity {
    pub header: TaTransform,
    pub r_opacity: f32,
    pub r_initial_opacity: f32,
}
impl TaTransformOpacity {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TA_TRANSFORM_OPACITY {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TA_TRANSFORM_OPACITY) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tbaddbitmap {
    pub h_inst: Option<Hinstance>,
    pub n_id: usize,
}
impl Tbaddbitmap {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TBADDBITMAP {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TBADDBITMAP) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tbbutton {
    pub i_bitmap: i32,
    pub id_command: i32,
    pub fs_state: u8,
    pub fs_style: u8,
    pub b_reserved: [u8; 2],
    pub dw_data: usize,
    pub i_string: isize,
}
impl Tbbutton {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TBBUTTON {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TBBUTTON) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tbbuttoninfoa<'a> {
    pub cb_size: u32,
    pub dw_mask: u32,
    pub id_command: i32,
    pub i_image: i32,
    pub fs_state: u8,
    pub fs_style: u8,
    pub cx: u16,
    pub l_param: usize,
    pub psz_text: Cow<'a, CStr>,
    pub cch_text: i32,
}
impl<'a> Tbbuttoninfoa<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TBBUTTONINFOA {
        let Self { cb_size, dw_mask, id_command, i_image, fs_state, fs_style, cx, l_param, psz_text, cch_text } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::TBBUTTONINFOA>() as _;
        let dwMask = *dw_mask;
        let idCommand = *id_command;
        let iImage = *i_image;
        let fsState = *fs_state;
        let fsStyle = *fs_style;
        let cx = *cx;
        let lParam = *l_param;
        let pszText = psz_text.as_ptr() as _;
        let cchText = *cch_text;
        windows_sys::Win32::UI::Controls::TBBUTTONINFOA { cbSize, dwMask, idCommand, iImage, fsState, fsStyle, cx, lParam, pszText, cchText }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TBBUTTONINFOA) -> Self {
        let windows_sys::Win32::UI::Controls::TBBUTTONINFOA { cbSize, dwMask, idCommand, iImage, fsState, fsStyle, cx, lParam, pszText, cchText } = win32;
        let cb_size = cbSize;
        let dw_mask = dwMask;
        let id_command = idCommand;
        let i_image = iImage;
        let fs_state = fsState;
        let fs_style = fsStyle;
        let cx = cx;
        let l_param = lParam;
        let pszText = unsafe { CStr::from_ptr(pszText as *const _) };
        let pszText = pszText.to_bytes_with_nul().to_vec();
        let psz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(pszText) });
        let cch_text = cchText;
        Self { cb_size, dw_mask, id_command, i_image, fs_state, fs_style, cx, l_param, psz_text, cch_text }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tbbuttoninfow<'a> {
    pub cb_size: u32,
    pub dw_mask: u32,
    pub id_command: i32,
    pub i_image: i32,
    pub fs_state: u8,
    pub fs_style: u8,
    pub cx: u16,
    pub l_param: usize,
    pub psz_text: Cow<'a, [u16]>,
    pub cch_text: i32,
}
impl<'a> Tbbuttoninfow<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TBBUTTONINFOW {
        let Self { cb_size, dw_mask, id_command, i_image, fs_state, fs_style, cx, l_param, psz_text, cch_text } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::TBBUTTONINFOW>() as _;
        let dwMask = *dw_mask;
        let idCommand = *id_command;
        let iImage = *i_image;
        let fsState = *fs_state;
        let fsStyle = *fs_style;
        let cx = *cx;
        let lParam = *l_param;
        assert_eq!(psz_text.last().copied(), Some(0));
        let pszText = psz_text.as_ptr() as _;
        let cchText = *cch_text;
        windows_sys::Win32::UI::Controls::TBBUTTONINFOW { cbSize, dwMask, idCommand, iImage, fsState, fsStyle, cx, lParam, pszText, cchText }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TBBUTTONINFOW) -> Self {
        let windows_sys::Win32::UI::Controls::TBBUTTONINFOW { cbSize, dwMask, idCommand, iImage, fsState, fsStyle, cx, lParam, pszText, cchText } = win32;
        let cb_size = cbSize;
        let dw_mask = dwMask;
        let id_command = idCommand;
        let i_image = iImage;
        let fs_state = fsState;
        let fs_style = fsStyle;
        let cx = cx;
        let l_param = lParam;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = Cow::Owned(pszText.to_vec());
        let cch_text = cchText;
        Self { cb_size, dw_mask, id_command, i_image, fs_state, fs_style, cx, l_param, psz_text, cch_text }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tbinfo {
    pub cbuttons: u32,
    pub u_flags: u32,
}
impl Tbinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::TBINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::TBINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tbinsertmark {
    pub i_button: i32,
    pub dw_flags: u32,
}
impl Tbinsertmark {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TBINSERTMARK {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TBINSERTMARK) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tbmetrics {
    pub cb_size: u32,
    pub dw_mask: u32,
    pub cx_pad: i32,
    pub cy_pad: i32,
    pub cx_bar_pad: i32,
    pub cy_bar_pad: i32,
    pub cx_button_spacing: i32,
    pub cy_button_spacing: i32,
}
impl Tbmetrics {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TBMETRICS {
        let Self { cb_size, dw_mask, cx_pad, cy_pad, cx_bar_pad, cy_bar_pad, cx_button_spacing, cy_button_spacing } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::TBMETRICS>() as _;
        let dwMask = *dw_mask;
        let cxPad = *cx_pad;
        let cyPad = *cy_pad;
        let cxBarPad = *cx_bar_pad;
        let cyBarPad = *cy_bar_pad;
        let cxButtonSpacing = *cx_button_spacing;
        let cyButtonSpacing = *cy_button_spacing;
        windows_sys::Win32::UI::Controls::TBMETRICS { cbSize, dwMask, cxPad, cyPad, cxBarPad, cyBarPad, cxButtonSpacing, cyButtonSpacing }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TBMETRICS) -> Self {
        let windows_sys::Win32::UI::Controls::TBMETRICS { cbSize, dwMask, cxPad, cyPad, cxBarPad, cyBarPad, cxButtonSpacing, cyButtonSpacing } = win32;
        let cb_size = cbSize;
        let dw_mask = dwMask;
        let cx_pad = cxPad;
        let cy_pad = cyPad;
        let cx_bar_pad = cxBarPad;
        let cy_bar_pad = cyBarPad;
        let cx_button_spacing = cxButtonSpacing;
        let cy_button_spacing = cyButtonSpacing;
        Self { cb_size, dw_mask, cx_pad, cy_pad, cx_bar_pad, cy_bar_pad, cx_button_spacing, cy_button_spacing }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tbreplacebitmap {
    pub h_inst_old: Option<Hinstance>,
    pub n_id_old: usize,
    pub h_inst_new: Option<Hinstance>,
    pub n_id_new: usize,
    pub n_buttons: i32,
}
impl Tbreplacebitmap {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TBREPLACEBITMAP {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TBREPLACEBITMAP) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tbsaveparamsa<'a> {
    pub hkr: Option<Hkey>,
    pub psz_sub_key: Cow<'a, CStr>,
    pub psz_value_name: Cow<'a, CStr>,
}
impl<'a> Tbsaveparamsa<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TBSAVEPARAMSA {
        let Self { hkr, psz_sub_key, psz_value_name } = self;
        let hkr = hkr.map_or(0, Hkey::into_raw);
        let pszSubKey = psz_sub_key.as_ptr() as _;
        let pszValueName = psz_value_name.as_ptr() as _;
        windows_sys::Win32::UI::Controls::TBSAVEPARAMSA { hkr, pszSubKey, pszValueName }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TBSAVEPARAMSA) -> Self {
        let windows_sys::Win32::UI::Controls::TBSAVEPARAMSA { hkr, pszSubKey, pszValueName } = win32;
        let hkr = unsafe { Hkey::new_optional(hkr) };
        let pszSubKey = unsafe { CStr::from_ptr(pszSubKey as *const _) };
        let pszSubKey = pszSubKey.to_bytes_with_nul().to_vec();
        let psz_sub_key = Cow::Owned(unsafe { CString::from_vec_unchecked(pszSubKey) });
        let pszValueName = unsafe { CStr::from_ptr(pszValueName as *const _) };
        let pszValueName = pszValueName.to_bytes_with_nul().to_vec();
        let psz_value_name = Cow::Owned(unsafe { CString::from_vec_unchecked(pszValueName) });
        Self { hkr, psz_sub_key, psz_value_name }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tbsaveparamsw<'a> {
    pub hkr: Option<Hkey>,
    pub psz_sub_key: Cow<'a, [u16]>,
    pub psz_value_name: Cow<'a, [u16]>,
}
impl<'a> Tbsaveparamsw<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TBSAVEPARAMSW {
        let Self { hkr, psz_sub_key, psz_value_name } = self;
        let hkr = hkr.map_or(0, Hkey::into_raw);
        assert_eq!(psz_sub_key.last().copied(), Some(0));
        let pszSubKey = psz_sub_key.as_ptr() as _;
        assert_eq!(psz_value_name.last().copied(), Some(0));
        let pszValueName = psz_value_name.as_ptr() as _;
        windows_sys::Win32::UI::Controls::TBSAVEPARAMSW { hkr, pszSubKey, pszValueName }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TBSAVEPARAMSW) -> Self {
        let windows_sys::Win32::UI::Controls::TBSAVEPARAMSW { hkr, pszSubKey, pszValueName } = win32;
        let hkr = unsafe { Hkey::new_optional(hkr) };
        let slen = unsafe { wide_strlen(pszSubKey as *const u16) };
        let pszSubKey = unsafe { slice::from_raw_parts(pszSubKey, slen + 1) };
        let psz_sub_key = Cow::Owned(pszSubKey.to_vec());
        let slen = unsafe { wide_strlen(pszValueName as *const u16) };
        let pszValueName = unsafe { slice::from_raw_parts(pszValueName, slen + 1) };
        let psz_value_name = Cow::Owned(pszValueName.to_vec());
        Self { hkr, psz_sub_key, psz_value_name }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tchittestinfo {
    pub pt: Point,
    pub flags: u32,
}
impl Tchittestinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TCHITTESTINFO {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TCHITTESTINFO) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tcitema<'a> {
    pub mask: u32,
    pub dw_state: u32,
    pub dw_state_mask: u32,
    pub psz_text: Cow<'a, CStr>,
    pub cch_text_max: i32,
    pub i_image: i32,
    pub l_param: Lparam,
}
impl<'a> Tcitema<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TCITEMA {
        let Self { mask, dw_state, dw_state_mask, psz_text, cch_text_max, i_image, l_param } = self;
        let mask = *mask;
        let dwState = *dw_state;
        let dwStateMask = *dw_state_mask;
        let pszText = psz_text.as_ptr() as _;
        let cchTextMax = *cch_text_max;
        let iImage = *i_image;
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::Controls::TCITEMA { mask, dwState, dwStateMask, pszText, cchTextMax, iImage, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TCITEMA) -> Self {
        let windows_sys::Win32::UI::Controls::TCITEMA { mask, dwState, dwStateMask, pszText, cchTextMax, iImage, lParam } = win32;
        let mask = mask;
        let dw_state = dwState;
        let dw_state_mask = dwStateMask;
        let pszText = unsafe { CStr::from_ptr(pszText as *const _) };
        let pszText = pszText.to_bytes_with_nul().to_vec();
        let psz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(pszText) });
        let cch_text_max = cchTextMax;
        let i_image = iImage;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { mask, dw_state, dw_state_mask, psz_text, cch_text_max, i_image, l_param }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tcitemheadera<'a> {
    pub mask: u32,
    pub lp_reserved1: u32,
    pub lp_reserved2: u32,
    pub psz_text: Cow<'a, CStr>,
    pub cch_text_max: i32,
    pub i_image: i32,
}
impl<'a> Tcitemheadera<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TCITEMHEADERA {
        let Self { mask, lp_reserved1, lp_reserved2, psz_text, cch_text_max, i_image } = self;
        let mask = *mask;
        let lpReserved1 = *lp_reserved1;
        let lpReserved2 = *lp_reserved2;
        let pszText = psz_text.as_ptr() as _;
        let cchTextMax = *cch_text_max;
        let iImage = *i_image;
        windows_sys::Win32::UI::Controls::TCITEMHEADERA { mask, lpReserved1, lpReserved2, pszText, cchTextMax, iImage }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TCITEMHEADERA) -> Self {
        let windows_sys::Win32::UI::Controls::TCITEMHEADERA { mask, lpReserved1, lpReserved2, pszText, cchTextMax, iImage } = win32;
        let mask = mask;
        let lp_reserved1 = lpReserved1;
        let lp_reserved2 = lpReserved2;
        let pszText = unsafe { CStr::from_ptr(pszText as *const _) };
        let pszText = pszText.to_bytes_with_nul().to_vec();
        let psz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(pszText) });
        let cch_text_max = cchTextMax;
        let i_image = iImage;
        Self { mask, lp_reserved1, lp_reserved2, psz_text, cch_text_max, i_image }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tcitemheaderw<'a> {
    pub mask: u32,
    pub lp_reserved1: u32,
    pub lp_reserved2: u32,
    pub psz_text: Cow<'a, [u16]>,
    pub cch_text_max: i32,
    pub i_image: i32,
}
impl<'a> Tcitemheaderw<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TCITEMHEADERW {
        let Self { mask, lp_reserved1, lp_reserved2, psz_text, cch_text_max, i_image } = self;
        let mask = *mask;
        let lpReserved1 = *lp_reserved1;
        let lpReserved2 = *lp_reserved2;
        assert_eq!(psz_text.last().copied(), Some(0));
        let pszText = psz_text.as_ptr() as _;
        let cchTextMax = *cch_text_max;
        let iImage = *i_image;
        windows_sys::Win32::UI::Controls::TCITEMHEADERW { mask, lpReserved1, lpReserved2, pszText, cchTextMax, iImage }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TCITEMHEADERW) -> Self {
        let windows_sys::Win32::UI::Controls::TCITEMHEADERW { mask, lpReserved1, lpReserved2, pszText, cchTextMax, iImage } = win32;
        let mask = mask;
        let lp_reserved1 = lpReserved1;
        let lp_reserved2 = lpReserved2;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = Cow::Owned(pszText.to_vec());
        let cch_text_max = cchTextMax;
        let i_image = iImage;
        Self { mask, lp_reserved1, lp_reserved2, psz_text, cch_text_max, i_image }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tcitemw<'a> {
    pub mask: u32,
    pub dw_state: u32,
    pub dw_state_mask: u32,
    pub psz_text: Cow<'a, [u16]>,
    pub cch_text_max: i32,
    pub i_image: i32,
    pub l_param: Lparam,
}
impl<'a> Tcitemw<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TCITEMW {
        let Self { mask, dw_state, dw_state_mask, psz_text, cch_text_max, i_image, l_param } = self;
        let mask = *mask;
        let dwState = *dw_state;
        let dwStateMask = *dw_state_mask;
        assert_eq!(psz_text.last().copied(), Some(0));
        let pszText = psz_text.as_ptr() as _;
        let cchTextMax = *cch_text_max;
        let iImage = *i_image;
        let lParam = l_param.into_inner();
        windows_sys::Win32::UI::Controls::TCITEMW { mask, dwState, dwStateMask, pszText, cchTextMax, iImage, lParam }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TCITEMW) -> Self {
        let windows_sys::Win32::UI::Controls::TCITEMW { mask, dwState, dwStateMask, pszText, cchTextMax, iImage, lParam } = win32;
        let mask = mask;
        let dw_state = dwState;
        let dw_state_mask = dwStateMask;
        let slen = unsafe { wide_strlen(pszText as *const u16) };
        let pszText = unsafe { slice::from_raw_parts(pszText, slen + 1) };
        let psz_text = Cow::Owned(pszText.to_vec());
        let cch_text_max = cchTextMax;
        let i_image = iImage;
        let l_param = unsafe { Lparam::from_inner(lParam) };
        Self { mask, dw_state, dw_state_mask, psz_text, cch_text_max, i_image, l_param }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Textmetrica {
    pub tm_height: i32,
    pub tm_ascent: i32,
    pub tm_descent: i32,
    pub tm_internal_leading: i32,
    pub tm_external_leading: i32,
    pub tm_ave_char_width: i32,
    pub tm_max_char_width: i32,
    pub tm_weight: i32,
    pub tm_overhang: i32,
    pub tm_digitized_aspect_x: i32,
    pub tm_digitized_aspect_y: i32,
    pub tm_first_char: u8,
    pub tm_last_char: u8,
    pub tm_default_char: u8,
    pub tm_break_char: u8,
    pub tm_italic: u8,
    pub tm_underlined: u8,
    pub tm_struck_out: u8,
    pub tm_pitch_and_family: u8,
    pub tm_char_set: u8,
}
impl Textmetrica {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::TEXTMETRICA {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::TEXTMETRICA) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Textmetricw {
    pub tm_height: i32,
    pub tm_ascent: i32,
    pub tm_descent: i32,
    pub tm_internal_leading: i32,
    pub tm_external_leading: i32,
    pub tm_ave_char_width: i32,
    pub tm_max_char_width: i32,
    pub tm_weight: i32,
    pub tm_overhang: i32,
    pub tm_digitized_aspect_x: i32,
    pub tm_digitized_aspect_y: i32,
    pub tm_first_char: u8,
    pub tm_last_char: u8,
    pub tm_default_char: u8,
    pub tm_break_char: u8,
    pub tm_italic: u8,
    pub tm_underlined: u8,
    pub tm_struck_out: u8,
    pub tm_pitch_and_family: u8,
    pub tm_char_set: u8,
}
impl Textmetricw {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::TEXTMETRICW {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::TEXTMETRICW) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Thumbbutton {
    pub dw_mask: i32,
    pub i_id: u32,
    pub i_bitmap: u32,
    pub h_icon: Option<Hicon>,
    pub sz_tip: [u8; 260],
    pub dw_flags: i32,
}
impl Thumbbutton {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::THUMBBUTTON {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::THUMBBUTTON) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Titlebarinfo {
    pub cb_size: u32,
    pub rc_title_bar: Rect,
    pub rgstate: [u32; 6],
}
impl Titlebarinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::TITLEBARINFO {
        let Self { cb_size, rc_title_bar, rgstate } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::TITLEBARINFO>() as _;
        let rcTitleBar = rc_title_bar.to_win32();
        let rgstate = [*&rgstate[0],*&rgstate[1],*&rgstate[2],*&rgstate[3],*&rgstate[4],*&rgstate[5]];
        windows_sys::Win32::UI::WindowsAndMessaging::TITLEBARINFO { cbSize, rcTitleBar, rgstate }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::TITLEBARINFO) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::TITLEBARINFO { cbSize, rcTitleBar, rgstate } = win32;
        let cb_size = cbSize;
        let rc_title_bar = unsafe { Rect::from_win32(rcTitleBar) };
        let rgstate = [rgstate[0],rgstate[1],rgstate[2],rgstate[3],rgstate[4],rgstate[5]];
        Self { cb_size, rc_title_bar, rgstate }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Titlebarinfoex {
    pub cb_size: u32,
    pub rc_title_bar: Rect,
    pub rgstate: [u32; 6],
    pub rgrect: [Rect; 6],
}
impl Titlebarinfoex {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::TITLEBARINFOEX {
        let Self { cb_size, rc_title_bar, rgstate, rgrect } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::TITLEBARINFOEX>() as _;
        let rcTitleBar = rc_title_bar.to_win32();
        let rgstate = [*&rgstate[0],*&rgstate[1],*&rgstate[2],*&rgstate[3],*&rgstate[4],*&rgstate[5]];
        let rgrect = [rgrect[0].to_win32(),rgrect[1].to_win32(),rgrect[2].to_win32(),rgrect[3].to_win32(),rgrect[4].to_win32(),rgrect[5].to_win32()];
        windows_sys::Win32::UI::WindowsAndMessaging::TITLEBARINFOEX { cbSize, rcTitleBar, rgstate, rgrect }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::TITLEBARINFOEX) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::TITLEBARINFOEX { cbSize, rcTitleBar, rgstate, rgrect } = win32;
        let cb_size = cbSize;
        let rc_title_bar = unsafe { Rect::from_win32(rcTitleBar) };
        let rgstate = [rgstate[0],rgstate[1],rgstate[2],rgstate[3],rgstate[4],rgstate[5]];
        let rgrect = [unsafe { Rect::from_win32(rgrect[0]) },unsafe { Rect::from_win32(rgrect[1]) },unsafe { Rect::from_win32(rgrect[2]) },unsafe { Rect::from_win32(rgrect[3]) },unsafe { Rect::from_win32(rgrect[4]) },unsafe { Rect::from_win32(rgrect[5]) }];
        Self { cb_size, rc_title_bar, rgstate, rgrect }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct TouchHitTestingInput {
    pub pointer_id: u32,
    pub point: Point,
    pub bounding_box: Rect,
    pub non_occluded_bounding_box: Rect,
    pub orientation: u32,
}
impl TouchHitTestingInput {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TOUCH_HIT_TESTING_INPUT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TOUCH_HIT_TESTING_INPUT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct TouchHitTestingProximityEvaluation {
    pub score: u16,
    pub adjusted_point: Point,
}
impl TouchHitTestingProximityEvaluation {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TOUCH_HIT_TESTING_PROXIMITY_EVALUATION {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TOUCH_HIT_TESTING_PROXIMITY_EVALUATION) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Tpmparams {
    pub cb_size: u32,
    pub rc_exclude: Rect,
}
impl Tpmparams {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::TPMPARAMS {
        let Self { cb_size, rc_exclude } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::TPMPARAMS>() as _;
        let rcExclude = rc_exclude.to_win32();
        windows_sys::Win32::UI::WindowsAndMessaging::TPMPARAMS { cbSize, rcExclude }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::TPMPARAMS) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::TPMPARAMS { cbSize, rcExclude } = win32;
        let cb_size = cbSize;
        let rc_exclude = unsafe { Rect::from_win32(rcExclude) };
        Self { cb_size, rc_exclude }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Trivertex {
    pub x: i32,
    pub y: i32,
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub alpha: u16,
}
impl Trivertex {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::TRIVERTEX {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::TRIVERTEX) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Ttembedinfo<'a> {
    pub us_struct_size: u16,
    pub us_root_str_size: u16,
    pub pus_root_str: &'a mut u16,
}
impl<'a> Ttembedinfo<'a> {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::TTEMBEDINFO {
        let Self { us_struct_size, us_root_str_size, pus_root_str } = self;
        let usStructSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::TTEMBEDINFO>() as _;
        let usRootStrSize = *us_root_str_size;
        let pusRootStr = unsafe { &mut *(pus_root_str as *mut _ as *mut _) };
        windows_sys::Win32::Graphics::Gdi::TTEMBEDINFO { usStructSize, usRootStrSize, pusRootStr }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::TTEMBEDINFO) -> Self {
        let windows_sys::Win32::Graphics::Gdi::TTEMBEDINFO { usStructSize, usRootStrSize, pusRootStr } = win32;
        let us_struct_size = usStructSize;
        let us_root_str_size = usRootStrSize;
        let pus_root_str = unsafe { &mut *(pusRootStr as *mut _ as *mut _) };
        Self { us_struct_size, us_root_str_size, pus_root_str }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Ttgettitle<'a> {
    pub dw_size: u32,
    pub u_title_bitmap: u32,
    pub cch: u32,
    pub psz_title: Cow<'a, [u16]>,
}
impl<'a> Ttgettitle<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TTGETTITLE {
        let Self { dw_size, u_title_bitmap, cch, psz_title } = self;
        let dwSize = mem::size_of::<windows_sys::Win32::UI::Controls::TTGETTITLE>() as _;
        let uTitleBitmap = *u_title_bitmap;
        let cch = *cch;
        assert_eq!(psz_title.last().copied(), Some(0));
        let pszTitle = psz_title.as_ptr() as _;
        windows_sys::Win32::UI::Controls::TTGETTITLE { dwSize, uTitleBitmap, cch, pszTitle }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TTGETTITLE) -> Self {
        let windows_sys::Win32::UI::Controls::TTGETTITLE { dwSize, uTitleBitmap, cch, pszTitle } = win32;
        let dw_size = dwSize;
        let u_title_bitmap = uTitleBitmap;
        let cch = cch;
        let slen = unsafe { wide_strlen(pszTitle as *const u16) };
        let pszTitle = unsafe { slice::from_raw_parts(pszTitle, slen + 1) };
        let psz_title = Cow::Owned(pszTitle.to_vec());
        Self { dw_size, u_title_bitmap, cch, psz_title }
    }
}
//  Not generated due to containing a void type
//  #[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Tthittestinfoa<'a> {
//      pub hwnd: Option<Hwnd>,
//      pub pt: Point,
//      pub ti: Tttoolinfoa<'a>,
//  }
//  impl<'a> Tthittestinfoa<'a> {
//      fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TTHITTESTINFOA {
//          let Self { hwnd, pt, ti } = self;
//          let hwnd = hwnd.map_or(0, Hwnd::into_raw);
//          let pt = pt.to_win32();
//          let ti = ti.to_win32();
//          windows_sys::Win32::UI::Controls::TTHITTESTINFOA { hwnd, pt, ti }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TTHITTESTINFOA) -> Self {
//          let windows_sys::Win32::UI::Controls::TTHITTESTINFOA { hwnd, pt, ti } = win32;
//          let hwnd = unsafe { Hwnd::new_optional(hwnd) };
//          let pt = unsafe { Point::from_win32(pt) };
//          let ti = unsafe { Tttoolinfoa::from_win32(ti) };
//          Self { hwnd, pt, ti }
//      }
//  }
//  Not generated due to containing a void type
//  #[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Tthittestinfow<'a> {
//      pub hwnd: Option<Hwnd>,
//      pub pt: Point,
//      pub ti: Tttoolinfow<'a>,
//  }
//  impl<'a> Tthittestinfow<'a> {
//      fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TTHITTESTINFOW {
//          let Self { hwnd, pt, ti } = self;
//          let hwnd = hwnd.map_or(0, Hwnd::into_raw);
//          let pt = pt.to_win32();
//          let ti = ti.to_win32();
//          windows_sys::Win32::UI::Controls::TTHITTESTINFOW { hwnd, pt, ti }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TTHITTESTINFOW) -> Self {
//          let windows_sys::Win32::UI::Controls::TTHITTESTINFOW { hwnd, pt, ti } = win32;
//          let hwnd = unsafe { Hwnd::new_optional(hwnd) };
//          let pt = unsafe { Point::from_win32(pt) };
//          let ti = unsafe { Tttoolinfow::from_win32(ti) };
//          Self { hwnd, pt, ti }
//      }
//  }
#[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Ttloadinfo<'a> {
    pub us_struct_size: u16,
    pub us_ref_str_size: u16,
    pub pus_ref_str: &'a mut u16,
}
impl<'a> Ttloadinfo<'a> {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::TTLOADINFO {
        let Self { us_struct_size, us_ref_str_size, pus_ref_str } = self;
        let usStructSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::TTLOADINFO>() as _;
        let usRefStrSize = *us_ref_str_size;
        let pusRefStr = unsafe { &mut *(pus_ref_str as *mut _ as *mut _) };
        windows_sys::Win32::Graphics::Gdi::TTLOADINFO { usStructSize, usRefStrSize, pusRefStr }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::TTLOADINFO) -> Self {
        let windows_sys::Win32::Graphics::Gdi::TTLOADINFO { usStructSize, usRefStrSize, pusRefStr } = win32;
        let us_struct_size = usStructSize;
        let us_ref_str_size = usRefStrSize;
        let pus_ref_str = unsafe { &mut *(pusRefStr as *mut _ as *mut _) };
        Self { us_struct_size, us_ref_str_size, pus_ref_str }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Ttpolycurve {
    pub w_type: u16,
    pub cpfx: u16,
    pub apfx: [Pointfx; 1],
}
impl Ttpolycurve {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::TTPOLYCURVE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::TTPOLYCURVE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Ttpolygonheader {
    pub cb: u32,
    pub dw_type: u32,
    pub pfx_start: Pointfx,
}
impl Ttpolygonheader {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::TTPOLYGONHEADER {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::TTPOLYGONHEADER) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
//  Not generated due to containing a void type
//  #[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Tttoolinfoa<'a> {
//      pub cb_size: u32,
//      pub u_flags: u32,
//      pub hwnd: Option<Hwnd>,
//      pub u_id: usize,
//      pub rect: Rect,
//      pub hinst: Option<Hinstance>,
//      pub lpsz_text: Cow<'a, CStr>,
//      pub l_param: Lparam,
//      pub lp_reserved: &'a mut todo_void,
//  }
//  impl<'a> Tttoolinfoa<'a> {
//      fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TTTOOLINFOA {
//          let Self { cb_size, u_flags, hwnd, u_id, rect, hinst, lpsz_text, l_param, lp_reserved } = self;
//          let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::TTTOOLINFOA>() as _;
//          let uFlags = *u_flags;
//          let hwnd = hwnd.map_or(0, Hwnd::into_raw);
//          let uId = *u_id;
//          let rect = rect.to_win32();
//          let hinst = hinst.map_or(0, Hinstance::into_raw);
//          let lpszText = lpsz_text.as_ptr() as _;
//          let lParam = l_param.into_inner();
//          let lpReserved = unsafe { &mut *(lp_reserved as *mut _ as *mut _) };
//          windows_sys::Win32::UI::Controls::TTTOOLINFOA { cbSize, uFlags, hwnd, uId, rect, hinst, lpszText, lParam, lpReserved }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TTTOOLINFOA) -> Self {
//          let windows_sys::Win32::UI::Controls::TTTOOLINFOA { cbSize, uFlags, hwnd, uId, rect, hinst, lpszText, lParam, lpReserved } = win32;
//          let cb_size = cbSize;
//          let u_flags = uFlags;
//          let hwnd = unsafe { Hwnd::new_optional(hwnd) };
//          let u_id = uId;
//          let rect = unsafe { Rect::from_win32(rect) };
//          let hinst = unsafe { Hinstance::new_optional(hinst) };
//          let lpszText = unsafe { CStr::from_ptr(lpszText as *const _) };
//          let lpszText = lpszText.to_bytes_with_nul().to_vec();
//          let lpsz_text = Cow::Owned(unsafe { CString::from_vec_unchecked(lpszText) });
//          let l_param = unsafe { Lparam::from_inner(lParam) };
//          let lp_reserved = unsafe { &mut *(lpReserved as *mut _ as *mut _) };
//          Self { cb_size, u_flags, hwnd, u_id, rect, hinst, lpsz_text, l_param, lp_reserved }
//      }
//  }
//  Not generated due to containing a void type
//  #[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct Tttoolinfow<'a> {
//      pub cb_size: u32,
//      pub u_flags: u32,
//      pub hwnd: Option<Hwnd>,
//      pub u_id: usize,
//      pub rect: Rect,
//      pub hinst: Option<Hinstance>,
//      pub lpsz_text: Cow<'a, [u16]>,
//      pub l_param: Lparam,
//      pub lp_reserved: &'a mut todo_void,
//  }
//  impl<'a> Tttoolinfow<'a> {
//      fn to_win32(&self) -> windows_sys::Win32::UI::Controls::TTTOOLINFOW {
//          let Self { cb_size, u_flags, hwnd, u_id, rect, hinst, lpsz_text, l_param, lp_reserved } = self;
//          let cbSize = mem::size_of::<windows_sys::Win32::UI::Controls::TTTOOLINFOW>() as _;
//          let uFlags = *u_flags;
//          let hwnd = hwnd.map_or(0, Hwnd::into_raw);
//          let uId = *u_id;
//          let rect = rect.to_win32();
//          let hinst = hinst.map_or(0, Hinstance::into_raw);
//          assert_eq!(lpsz_text.last().copied(), Some(0));
//          let lpszText = lpsz_text.as_ptr() as _;
//          let lParam = l_param.into_inner();
//          let lpReserved = unsafe { &mut *(lp_reserved as *mut _ as *mut _) };
//          windows_sys::Win32::UI::Controls::TTTOOLINFOW { cbSize, uFlags, hwnd, uId, rect, hinst, lpszText, lParam, lpReserved }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::TTTOOLINFOW) -> Self {
//          let windows_sys::Win32::UI::Controls::TTTOOLINFOW { cbSize, uFlags, hwnd, uId, rect, hinst, lpszText, lParam, lpReserved } = win32;
//          let cb_size = cbSize;
//          let u_flags = uFlags;
//          let hwnd = unsafe { Hwnd::new_optional(hwnd) };
//          let u_id = uId;
//          let rect = unsafe { Rect::from_win32(rect) };
//          let hinst = unsafe { Hinstance::new_optional(hinst) };
//          let slen = unsafe { wide_strlen(lpszText as *const u16) };
//          let lpszText = unsafe { slice::from_raw_parts(lpszText, slen + 1) };
//          let lpsz_text = Cow::Owned(lpszText.to_vec());
//          let l_param = unsafe { Lparam::from_inner(lParam) };
//          let lp_reserved = unsafe { &mut *(lpReserved as *mut _ as *mut _) };
//          Self { cb_size, u_flags, hwnd, u_id, rect, hinst, lpsz_text, l_param, lp_reserved }
//      }
//  }
#[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Ttvalidationtestsparams<'a> {
    pub ul_struct_size: u32,
    pub l_test_from_size: i32,
    pub l_test_to_size: i32,
    pub ul_char_set: u32,
    pub us_reserved1: u16,
    pub us_char_code_count: u16,
    pub pus_char_code_set: &'a mut u16,
}
impl<'a> Ttvalidationtestsparams<'a> {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::TTVALIDATIONTESTSPARAMS {
        let Self { ul_struct_size, l_test_from_size, l_test_to_size, ul_char_set, us_reserved1, us_char_code_count, pus_char_code_set } = self;
        let ulStructSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::TTVALIDATIONTESTSPARAMS>() as _;
        let lTestFromSize = *l_test_from_size;
        let lTestToSize = *l_test_to_size;
        let ulCharSet = *ul_char_set;
        let usReserved1 = *us_reserved1;
        let usCharCodeCount = *us_char_code_count;
        let pusCharCodeSet = unsafe { &mut *(pus_char_code_set as *mut _ as *mut _) };
        windows_sys::Win32::Graphics::Gdi::TTVALIDATIONTESTSPARAMS { ulStructSize, lTestFromSize, lTestToSize, ulCharSet, usReserved1, usCharCodeCount, pusCharCodeSet }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::TTVALIDATIONTESTSPARAMS) -> Self {
        let windows_sys::Win32::Graphics::Gdi::TTVALIDATIONTESTSPARAMS { ulStructSize, lTestFromSize, lTestToSize, ulCharSet, usReserved1, usCharCodeCount, pusCharCodeSet } = win32;
        let ul_struct_size = ulStructSize;
        let l_test_from_size = lTestFromSize;
        let l_test_to_size = lTestToSize;
        let ul_char_set = ulCharSet;
        let us_reserved1 = usReserved1;
        let us_char_code_count = usCharCodeCount;
        let pus_char_code_set = unsafe { &mut *(pusCharCodeSet as *mut _ as *mut _) };
        Self { ul_struct_size, l_test_from_size, l_test_to_size, ul_char_set, us_reserved1, us_char_code_count, pus_char_code_set }
    }
}
#[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Ttvalidationtestsparamsex<'a> {
    pub ul_struct_size: u32,
    pub l_test_from_size: i32,
    pub l_test_to_size: i32,
    pub ul_char_set: u32,
    pub us_reserved1: u16,
    pub us_char_code_count: u16,
    pub pul_char_code_set: &'a mut u32,
}
impl<'a> Ttvalidationtestsparamsex<'a> {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::TTVALIDATIONTESTSPARAMSEX {
        let Self { ul_struct_size, l_test_from_size, l_test_to_size, ul_char_set, us_reserved1, us_char_code_count, pul_char_code_set } = self;
        let ulStructSize = mem::size_of::<windows_sys::Win32::Graphics::Gdi::TTVALIDATIONTESTSPARAMSEX>() as _;
        let lTestFromSize = *l_test_from_size;
        let lTestToSize = *l_test_to_size;
        let ulCharSet = *ul_char_set;
        let usReserved1 = *us_reserved1;
        let usCharCodeCount = *us_char_code_count;
        let pulCharCodeSet = unsafe { &mut *(pul_char_code_set as *mut _ as *mut _) };
        windows_sys::Win32::Graphics::Gdi::TTVALIDATIONTESTSPARAMSEX { ulStructSize, lTestFromSize, lTestToSize, ulCharSet, usReserved1, usCharCodeCount, pulCharCodeSet }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::TTVALIDATIONTESTSPARAMSEX) -> Self {
        let windows_sys::Win32::Graphics::Gdi::TTVALIDATIONTESTSPARAMSEX { ulStructSize, lTestFromSize, lTestToSize, ulCharSet, usReserved1, usCharCodeCount, pulCharCodeSet } = win32;
        let ul_struct_size = ulStructSize;
        let l_test_from_size = lTestFromSize;
        let l_test_to_size = lTestToSize;
        let ul_char_set = ulCharSet;
        let us_reserved1 = usReserved1;
        let us_char_code_count = usCharCodeCount;
        let pul_char_code_set = unsafe { &mut *(pulCharCodeSet as *mut _ as *mut _) };
        Self { ul_struct_size, l_test_from_size, l_test_to_size, ul_char_set, us_reserved1, us_char_code_count, pul_char_code_set }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct TouchPredictionParameters {
    pub cb_size: u32,
    pub dw_latency: u32,
    pub dw_sample_time: u32,
    pub b_use_hw_time_stamp: u32,
}
impl TouchPredictionParameters {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::TouchPredictionParameters {
        let Self { cb_size, dw_latency, dw_sample_time, b_use_hw_time_stamp } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::TouchPredictionParameters>() as _;
        let dwLatency = *dw_latency;
        let dwSampleTime = *dw_sample_time;
        let bUseHWTimeStamp = *b_use_hw_time_stamp;
        windows_sys::Win32::UI::WindowsAndMessaging::TouchPredictionParameters { cbSize, dwLatency, dwSampleTime, bUseHWTimeStamp }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::TouchPredictionParameters) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::TouchPredictionParameters { cbSize, dwLatency, dwSampleTime, bUseHWTimeStamp } = win32;
        let cb_size = cbSize;
        let dw_latency = dwLatency;
        let dw_sample_time = dwSampleTime;
        let b_use_hw_time_stamp = bUseHWTimeStamp;
        Self { cb_size, dw_latency, dw_sample_time, b_use_hw_time_stamp }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Udaccel {
    pub n_sec: u32,
    pub n_inc: u32,
}
impl Udaccel {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::UDACCEL {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::UDACCEL) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct UnicodeString<'a> {
    pub length: u16,
    pub maximum_length: u16,
    pub buffer: Cow<'a, [u16]>,
}
impl<'a> UnicodeString<'a> {
    fn to_win32(&self) -> windows_sys::Win32::Foundation::UNICODE_STRING {
        let Self { length, maximum_length, buffer } = self;
        let Length = *length;
        let MaximumLength = *maximum_length;
        assert_eq!(buffer.last().copied(), Some(0));
        let Buffer = buffer.as_ptr() as _;
        windows_sys::Win32::Foundation::UNICODE_STRING { Length, MaximumLength, Buffer }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Foundation::UNICODE_STRING) -> Self {
        let windows_sys::Win32::Foundation::UNICODE_STRING { Length, MaximumLength, Buffer } = win32;
        let length = Length;
        let maximum_length = MaximumLength;
        let slen = unsafe { wide_strlen(Buffer as *const u16) };
        let Buffer = unsafe { slice::from_raw_parts(Buffer, slen + 1) };
        let buffer = Cow::Owned(Buffer.to_vec());
        Self { length, maximum_length, buffer }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Updatelayeredwindowinfo<'a> {
    pub cb_size: u32,
    pub hdc_dst: Option<Hdc>,
    pub ppt_dst: Cow<'a, Point>,
    pub psize: Cow<'a, Size>,
    pub hdc_src: Option<Hdc>,
    pub ppt_src: Cow<'a, Point>,
    pub cr_key: u32,
    pub pblend: Cow<'a, Blendfunction>,
    pub dw_flags: u32,
    pub prc_dirty: Cow<'a, Rect>,
}
impl<'a> Updatelayeredwindowinfo<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::UPDATELAYEREDWINDOWINFO {
        let Self { cb_size, hdc_dst, ppt_dst, psize, hdc_src, ppt_src, cr_key, pblend, dw_flags, prc_dirty } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::UPDATELAYEREDWINDOWINFO>() as _;
        let hdcDst = hdc_dst.map_or(0, Hdc::into_raw);
        let pptDst = unsafe { &*(&**ppt_dst as *const _ as *const _) };
        let psize = unsafe { &*(&**psize as *const _ as *const _) };
        let hdcSrc = hdc_src.map_or(0, Hdc::into_raw);
        let pptSrc = unsafe { &*(&**ppt_src as *const _ as *const _) };
        let crKey = *cr_key;
        let pblend = unsafe { &*(&**pblend as *const _ as *const _) };
        let dwFlags = *dw_flags;
        let prcDirty = unsafe { &*(&**prc_dirty as *const _ as *const _) };
        windows_sys::Win32::UI::WindowsAndMessaging::UPDATELAYEREDWINDOWINFO { cbSize, hdcDst, pptDst, psize, hdcSrc, pptSrc, crKey, pblend, dwFlags, prcDirty }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::UPDATELAYEREDWINDOWINFO) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::UPDATELAYEREDWINDOWINFO { cbSize, hdcDst, pptDst, psize, hdcSrc, pptSrc, crKey, pblend, dwFlags, prcDirty } = win32;
        let cb_size = cbSize;
        let hdc_dst = unsafe { Hdc::new_optional(hdcDst) };
        let ppt_dst = Cow::Borrowed(unsafe { &*(pptDst as *const _ as *const _) });
        let psize = Cow::Borrowed(unsafe { &*(psize as *const _ as *const _) });
        let hdc_src = unsafe { Hdc::new_optional(hdcSrc) };
        let ppt_src = Cow::Borrowed(unsafe { &*(pptSrc as *const _ as *const _) });
        let cr_key = crKey;
        let pblend = Cow::Borrowed(unsafe { &*(pblend as *const _ as *const _) });
        let dw_flags = dwFlags;
        let prc_dirty = Cow::Borrowed(unsafe { &*(prcDirty as *const _ as *const _) });
        Self { cb_size, hdc_dst, ppt_dst, psize, hdc_src, ppt_src, cr_key, pblend, dw_flags, prc_dirty }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct UsageProperties {
    pub level: u16,
    pub page: u16,
    pub usage: u16,
    pub logical_minimum: i32,
    pub logical_maximum: i32,
    pub unit: u16,
    pub exponent: u16,
    pub count: u8,
    pub physical_minimum: i32,
    pub physical_maximum: i32,
}
impl UsageProperties {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::USAGE_PROPERTIES {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::USAGE_PROPERTIES) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Valenta<'a> {
    pub ve_valuename: Cow<'a, CStr>,
    pub ve_valuelen: u32,
    pub ve_valueptr: usize,
    pub ve_type: u32,
}
impl<'a> Valenta<'a> {
    fn to_win32(&self) -> windows_sys::Win32::System::Registry::VALENTA {
        let Self { ve_valuename, ve_valuelen, ve_valueptr, ve_type } = self;
        let ve_valuename = ve_valuename.as_ptr() as _;
        let ve_valuelen = *ve_valuelen;
        let ve_valueptr = *ve_valueptr;
        let ve_type = *ve_type;
        windows_sys::Win32::System::Registry::VALENTA { ve_valuename, ve_valuelen, ve_valueptr, ve_type }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::System::Registry::VALENTA) -> Self {
        let windows_sys::Win32::System::Registry::VALENTA { ve_valuename, ve_valuelen, ve_valueptr, ve_type } = win32;
        let ve_valuename = unsafe { CStr::from_ptr(ve_valuename as *const _) };
        let ve_valuename = ve_valuename.to_bytes_with_nul().to_vec();
        let ve_valuename = Cow::Owned(unsafe { CString::from_vec_unchecked(ve_valuename) });
        let ve_valuelen = ve_valuelen;
        let ve_valueptr = ve_valueptr;
        let ve_type = ve_type;
        Self { ve_valuename, ve_valuelen, ve_valueptr, ve_type }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Valentw<'a> {
    pub ve_valuename: Cow<'a, [u16]>,
    pub ve_valuelen: u32,
    pub ve_valueptr: usize,
    pub ve_type: u32,
}
impl<'a> Valentw<'a> {
    fn to_win32(&self) -> windows_sys::Win32::System::Registry::VALENTW {
        let Self { ve_valuename, ve_valuelen, ve_valueptr, ve_type } = self;
        assert_eq!(ve_valuename.last().copied(), Some(0));
        let ve_valuename = ve_valuename.as_ptr() as _;
        let ve_valuelen = *ve_valuelen;
        let ve_valueptr = *ve_valueptr;
        let ve_type = *ve_type;
        windows_sys::Win32::System::Registry::VALENTW { ve_valuename, ve_valuelen, ve_valueptr, ve_type }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::System::Registry::VALENTW) -> Self {
        let windows_sys::Win32::System::Registry::VALENTW { ve_valuename, ve_valuelen, ve_valueptr, ve_type } = win32;
        let slen = unsafe { wide_strlen(ve_valuename as *const u16) };
        let ve_valuename = unsafe { slice::from_raw_parts(ve_valuename, slen + 1) };
        let ve_valuename = Cow::Owned(ve_valuename.to_vec());
        let ve_valuelen = ve_valuelen;
        let ve_valueptr = ve_valueptr;
        let ve_type = ve_type;
        Self { ve_valuename, ve_valuelen, ve_valueptr, ve_type }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Wcrange {
    pub wc_low: u8,
    pub c_glyphs: u16,
}
impl Wcrange {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::WCRANGE {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::WCRANGE) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Wglswap {
    pub hdc: Option<Hdc>,
    pub ui_flags: u32,
}
impl Wglswap {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::WGLSWAP {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::WGLSWAP) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Windowinfo {
    pub cb_size: u32,
    pub rc_window: Rect,
    pub rc_client: Rect,
    pub dw_style: u32,
    pub dw_ex_style: u32,
    pub dw_window_status: u32,
    pub cx_window_borders: u32,
    pub cy_window_borders: u32,
    pub atom_window_type: u16,
    pub w_creator_version: u16,
}
impl Windowinfo {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::WINDOWINFO {
        let Self { cb_size, rc_window, rc_client, dw_style, dw_ex_style, dw_window_status, cx_window_borders, cy_window_borders, atom_window_type, w_creator_version } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::WINDOWINFO>() as _;
        let rcWindow = rc_window.to_win32();
        let rcClient = rc_client.to_win32();
        let dwStyle = *dw_style;
        let dwExStyle = *dw_ex_style;
        let dwWindowStatus = *dw_window_status;
        let cxWindowBorders = *cx_window_borders;
        let cyWindowBorders = *cy_window_borders;
        let atomWindowType = *atom_window_type;
        let wCreatorVersion = *w_creator_version;
        windows_sys::Win32::UI::WindowsAndMessaging::WINDOWINFO { cbSize, rcWindow, rcClient, dwStyle, dwExStyle, dwWindowStatus, cxWindowBorders, cyWindowBorders, atomWindowType, wCreatorVersion }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::WINDOWINFO) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::WINDOWINFO { cbSize, rcWindow, rcClient, dwStyle, dwExStyle, dwWindowStatus, cxWindowBorders, cyWindowBorders, atomWindowType, wCreatorVersion } = win32;
        let cb_size = cbSize;
        let rc_window = unsafe { Rect::from_win32(rcWindow) };
        let rc_client = unsafe { Rect::from_win32(rcClient) };
        let dw_style = dwStyle;
        let dw_ex_style = dwExStyle;
        let dw_window_status = dwWindowStatus;
        let cx_window_borders = cxWindowBorders;
        let cy_window_borders = cyWindowBorders;
        let atom_window_type = atomWindowType;
        let w_creator_version = wCreatorVersion;
        Self { cb_size, rc_window, rc_client, dw_style, dw_ex_style, dw_window_status, cx_window_borders, cy_window_borders, atom_window_type, w_creator_version }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Windowplacement {
    pub length: u32,
    pub flags: u32,
    pub show_cmd: u32,
    pub pt_min_position: Point,
    pub pt_max_position: Point,
    pub rc_normal_position: Rect,
}
impl Windowplacement {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::WINDOWPLACEMENT {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::WINDOWPLACEMENT) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct Windowpos {
    pub hwnd: Option<Hwnd>,
    pub hwnd_insert_after: Option<Hwnd>,
    pub x: i32,
    pub y: i32,
    pub cx: i32,
    pub cy: i32,
    pub flags: u32,
}
impl Windowpos {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::WINDOWPOS {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::WINDOWPOS) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Clone)]
#[repr(C)]
pub struct Wndclassa<'a> {
    pub style: u32,
    pub lpfn_wnd_proc: Option<unsafe extern "system" fn(HWND, u32, WPARAM, LPARAM) -> LRESULT>,
    pub cb_cls_extra: i32,
    pub cb_wnd_extra: i32,
    pub h_instance: Option<Hinstance>,
    pub h_icon: Option<Hicon>,
    pub h_cursor: Option<Hcursor>,
    pub hbr_background: Option<Hbrush>,
    pub lpsz_menu_name: Cow<'a, CStr>,
    pub lpsz_class_name: Cow<'a, CStr>,
}
impl<'a> Wndclassa<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSA {
        let Self { style, lpfn_wnd_proc, cb_cls_extra, cb_wnd_extra, h_instance, h_icon, h_cursor, hbr_background, lpsz_menu_name, lpsz_class_name } = self;
        let style = *style;
        let lpfnWndProc = *lpfn_wnd_proc;
        let cbClsExtra = *cb_cls_extra;
        let cbWndExtra = *cb_wnd_extra;
        let hInstance = h_instance.map_or(0, Hinstance::into_raw);
        let hIcon = h_icon.map_or(0, Hicon::into_raw);
        let hCursor = h_cursor.map_or(0, Hcursor::into_raw);
        let hbrBackground = hbr_background.map_or(0, Hbrush::into_raw);
        let lpszMenuName = lpsz_menu_name.as_ptr() as _;
        let lpszClassName = lpsz_class_name.as_ptr() as _;
        windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSA { style, lpfnWndProc, cbClsExtra, cbWndExtra, hInstance, hIcon, hCursor, hbrBackground, lpszMenuName, lpszClassName }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSA) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSA { style, lpfnWndProc, cbClsExtra, cbWndExtra, hInstance, hIcon, hCursor, hbrBackground, lpszMenuName, lpszClassName } = win32;
        let style = style;
        let lpfn_wnd_proc = lpfnWndProc;
        let cb_cls_extra = cbClsExtra;
        let cb_wnd_extra = cbWndExtra;
        let h_instance = unsafe { Hinstance::new_optional(hInstance) };
        let h_icon = unsafe { Hicon::new_optional(hIcon) };
        let h_cursor = unsafe { Hcursor::new_optional(hCursor) };
        let hbr_background = unsafe { Hbrush::new_optional(hbrBackground) };
        let lpszMenuName = unsafe { CStr::from_ptr(lpszMenuName as *const _) };
        let lpszMenuName = lpszMenuName.to_bytes_with_nul().to_vec();
        let lpsz_menu_name = Cow::Owned(unsafe { CString::from_vec_unchecked(lpszMenuName) });
        let lpszClassName = unsafe { CStr::from_ptr(lpszClassName as *const _) };
        let lpszClassName = lpszClassName.to_bytes_with_nul().to_vec();
        let lpsz_class_name = Cow::Owned(unsafe { CString::from_vec_unchecked(lpszClassName) });
        Self { style, lpfn_wnd_proc, cb_cls_extra, cb_wnd_extra, h_instance, h_icon, h_cursor, hbr_background, lpsz_menu_name, lpsz_class_name }
    }
}
#[derive(Debug, PartialEq, Default, Clone)]
#[repr(C)]
pub struct Wndclassexa<'a> {
    pub cb_size: u32,
    pub style: u32,
    pub lpfn_wnd_proc: Option<unsafe extern "system" fn(HWND, u32, WPARAM, LPARAM) -> LRESULT>,
    pub cb_cls_extra: i32,
    pub cb_wnd_extra: i32,
    pub h_instance: Option<Hinstance>,
    pub h_icon: Option<Hicon>,
    pub h_cursor: Option<Hcursor>,
    pub hbr_background: Option<Hbrush>,
    pub lpsz_menu_name: Cow<'a, CStr>,
    pub lpsz_class_name: Cow<'a, CStr>,
    pub h_icon_sm: Option<Hicon>,
}
impl<'a> Wndclassexa<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSEXA {
        let Self { cb_size, style, lpfn_wnd_proc, cb_cls_extra, cb_wnd_extra, h_instance, h_icon, h_cursor, hbr_background, lpsz_menu_name, lpsz_class_name, h_icon_sm } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSEXA>() as _;
        let style = *style;
        let lpfnWndProc = *lpfn_wnd_proc;
        let cbClsExtra = *cb_cls_extra;
        let cbWndExtra = *cb_wnd_extra;
        let hInstance = h_instance.map_or(0, Hinstance::into_raw);
        let hIcon = h_icon.map_or(0, Hicon::into_raw);
        let hCursor = h_cursor.map_or(0, Hcursor::into_raw);
        let hbrBackground = hbr_background.map_or(0, Hbrush::into_raw);
        let lpszMenuName = lpsz_menu_name.as_ptr() as _;
        let lpszClassName = lpsz_class_name.as_ptr() as _;
        let hIconSm = h_icon_sm.map_or(0, Hicon::into_raw);
        windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSEXA { cbSize, style, lpfnWndProc, cbClsExtra, cbWndExtra, hInstance, hIcon, hCursor, hbrBackground, lpszMenuName, lpszClassName, hIconSm }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSEXA) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSEXA { cbSize, style, lpfnWndProc, cbClsExtra, cbWndExtra, hInstance, hIcon, hCursor, hbrBackground, lpszMenuName, lpszClassName, hIconSm } = win32;
        let cb_size = cbSize;
        let style = style;
        let lpfn_wnd_proc = lpfnWndProc;
        let cb_cls_extra = cbClsExtra;
        let cb_wnd_extra = cbWndExtra;
        let h_instance = unsafe { Hinstance::new_optional(hInstance) };
        let h_icon = unsafe { Hicon::new_optional(hIcon) };
        let h_cursor = unsafe { Hcursor::new_optional(hCursor) };
        let hbr_background = unsafe { Hbrush::new_optional(hbrBackground) };
        let lpszMenuName = unsafe { CStr::from_ptr(lpszMenuName as *const _) };
        let lpszMenuName = lpszMenuName.to_bytes_with_nul().to_vec();
        let lpsz_menu_name = Cow::Owned(unsafe { CString::from_vec_unchecked(lpszMenuName) });
        let lpszClassName = unsafe { CStr::from_ptr(lpszClassName as *const _) };
        let lpszClassName = lpszClassName.to_bytes_with_nul().to_vec();
        let lpsz_class_name = Cow::Owned(unsafe { CString::from_vec_unchecked(lpszClassName) });
        let h_icon_sm = unsafe { Hicon::new_optional(hIconSm) };
        Self { cb_size, style, lpfn_wnd_proc, cb_cls_extra, cb_wnd_extra, h_instance, h_icon, h_cursor, hbr_background, lpsz_menu_name, lpsz_class_name, h_icon_sm }
    }
}
#[derive(Debug, PartialEq, Default, Clone)]
#[repr(C)]
pub struct Wndclassexw<'a> {
    pub cb_size: u32,
    pub style: u32,
    pub lpfn_wnd_proc: Option<unsafe extern "system" fn(HWND, u32, WPARAM, LPARAM) -> LRESULT>,
    pub cb_cls_extra: i32,
    pub cb_wnd_extra: i32,
    pub h_instance: Option<Hinstance>,
    pub h_icon: Option<Hicon>,
    pub h_cursor: Option<Hcursor>,
    pub hbr_background: Option<Hbrush>,
    pub lpsz_menu_name: Cow<'a, [u16]>,
    pub lpsz_class_name: Cow<'a, [u16]>,
    pub h_icon_sm: Option<Hicon>,
}
impl<'a> Wndclassexw<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSEXW {
        let Self { cb_size, style, lpfn_wnd_proc, cb_cls_extra, cb_wnd_extra, h_instance, h_icon, h_cursor, hbr_background, lpsz_menu_name, lpsz_class_name, h_icon_sm } = self;
        let cbSize = mem::size_of::<windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSEXW>() as _;
        let style = *style;
        let lpfnWndProc = *lpfn_wnd_proc;
        let cbClsExtra = *cb_cls_extra;
        let cbWndExtra = *cb_wnd_extra;
        let hInstance = h_instance.map_or(0, Hinstance::into_raw);
        let hIcon = h_icon.map_or(0, Hicon::into_raw);
        let hCursor = h_cursor.map_or(0, Hcursor::into_raw);
        let hbrBackground = hbr_background.map_or(0, Hbrush::into_raw);
        assert_eq!(lpsz_menu_name.last().copied(), Some(0));
        let lpszMenuName = lpsz_menu_name.as_ptr() as _;
        assert_eq!(lpsz_class_name.last().copied(), Some(0));
        let lpszClassName = lpsz_class_name.as_ptr() as _;
        let hIconSm = h_icon_sm.map_or(0, Hicon::into_raw);
        windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSEXW { cbSize, style, lpfnWndProc, cbClsExtra, cbWndExtra, hInstance, hIcon, hCursor, hbrBackground, lpszMenuName, lpszClassName, hIconSm }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSEXW) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSEXW { cbSize, style, lpfnWndProc, cbClsExtra, cbWndExtra, hInstance, hIcon, hCursor, hbrBackground, lpszMenuName, lpszClassName, hIconSm } = win32;
        let cb_size = cbSize;
        let style = style;
        let lpfn_wnd_proc = lpfnWndProc;
        let cb_cls_extra = cbClsExtra;
        let cb_wnd_extra = cbWndExtra;
        let h_instance = unsafe { Hinstance::new_optional(hInstance) };
        let h_icon = unsafe { Hicon::new_optional(hIcon) };
        let h_cursor = unsafe { Hcursor::new_optional(hCursor) };
        let hbr_background = unsafe { Hbrush::new_optional(hbrBackground) };
        let slen = unsafe { wide_strlen(lpszMenuName as *const u16) };
        let lpszMenuName = unsafe { slice::from_raw_parts(lpszMenuName, slen + 1) };
        let lpsz_menu_name = Cow::Owned(lpszMenuName.to_vec());
        let slen = unsafe { wide_strlen(lpszClassName as *const u16) };
        let lpszClassName = unsafe { slice::from_raw_parts(lpszClassName, slen + 1) };
        let lpsz_class_name = Cow::Owned(lpszClassName.to_vec());
        let h_icon_sm = unsafe { Hicon::new_optional(hIconSm) };
        Self { cb_size, style, lpfn_wnd_proc, cb_cls_extra, cb_wnd_extra, h_instance, h_icon, h_cursor, hbr_background, lpsz_menu_name, lpsz_class_name, h_icon_sm }
    }
}
#[derive(Debug, PartialEq, Default, Clone)]
#[repr(C)]
pub struct Wndclassw<'a> {
    pub style: u32,
    pub lpfn_wnd_proc: Option<unsafe extern "system" fn(HWND, u32, WPARAM, LPARAM) -> LRESULT>,
    pub cb_cls_extra: i32,
    pub cb_wnd_extra: i32,
    pub h_instance: Option<Hinstance>,
    pub h_icon: Option<Hicon>,
    pub h_cursor: Option<Hcursor>,
    pub hbr_background: Option<Hbrush>,
    pub lpsz_menu_name: Cow<'a, [u16]>,
    pub lpsz_class_name: Cow<'a, [u16]>,
}
impl<'a> Wndclassw<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSW {
        let Self { style, lpfn_wnd_proc, cb_cls_extra, cb_wnd_extra, h_instance, h_icon, h_cursor, hbr_background, lpsz_menu_name, lpsz_class_name } = self;
        let style = *style;
        let lpfnWndProc = *lpfn_wnd_proc;
        let cbClsExtra = *cb_cls_extra;
        let cbWndExtra = *cb_wnd_extra;
        let hInstance = h_instance.map_or(0, Hinstance::into_raw);
        let hIcon = h_icon.map_or(0, Hicon::into_raw);
        let hCursor = h_cursor.map_or(0, Hcursor::into_raw);
        let hbrBackground = hbr_background.map_or(0, Hbrush::into_raw);
        assert_eq!(lpsz_menu_name.last().copied(), Some(0));
        let lpszMenuName = lpsz_menu_name.as_ptr() as _;
        assert_eq!(lpsz_class_name.last().copied(), Some(0));
        let lpszClassName = lpsz_class_name.as_ptr() as _;
        windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSW { style, lpfnWndProc, cbClsExtra, cbWndExtra, hInstance, hIcon, hCursor, hbrBackground, lpszMenuName, lpszClassName }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSW) -> Self {
        let windows_sys::Win32::UI::WindowsAndMessaging::WNDCLASSW { style, lpfnWndProc, cbClsExtra, cbWndExtra, hInstance, hIcon, hCursor, hbrBackground, lpszMenuName, lpszClassName } = win32;
        let style = style;
        let lpfn_wnd_proc = lpfnWndProc;
        let cb_cls_extra = cbClsExtra;
        let cb_wnd_extra = cbWndExtra;
        let h_instance = unsafe { Hinstance::new_optional(hInstance) };
        let h_icon = unsafe { Hicon::new_optional(hIcon) };
        let h_cursor = unsafe { Hcursor::new_optional(hCursor) };
        let hbr_background = unsafe { Hbrush::new_optional(hbrBackground) };
        let slen = unsafe { wide_strlen(lpszMenuName as *const u16) };
        let lpszMenuName = unsafe { slice::from_raw_parts(lpszMenuName, slen + 1) };
        let lpsz_menu_name = Cow::Owned(lpszMenuName.to_vec());
        let slen = unsafe { wide_strlen(lpszClassName as *const u16) };
        let lpszClassName = unsafe { slice::from_raw_parts(lpszClassName, slen + 1) };
        let lpsz_class_name = Cow::Owned(lpszClassName.to_vec());
        Self { style, lpfn_wnd_proc, cb_cls_extra, cb_wnd_extra, h_instance, h_icon, h_cursor, hbr_background, lpsz_menu_name, lpsz_class_name }
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct WtaOptions {
    pub dw_flags: u32,
    pub dw_mask: u32,
}
impl WtaOptions {
    fn to_win32(&self) -> windows_sys::Win32::UI::Controls::WTA_OPTIONS {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Controls::WTA_OPTIONS) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct WtsThumbnailid {
    pub rgb_key: [u8; 16],
}
impl WtsThumbnailid {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::WTS_THUMBNAILID {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::WTS_THUMBNAILID) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
#[derive(Debug, PartialEq, Default, Copy, Clone)]
#[repr(C)]
pub struct Xform {
    pub e_m11: f32,
    pub e_m12: f32,
    pub e_m21: f32,
    pub e_m22: f32,
    pub e_dx: f32,
    pub e_dy: f32,
}
impl Xform {
    fn to_win32(&self) -> windows_sys::Win32::Graphics::Gdi::XFORM {
        // SAFETY: this is a thin struct
        unsafe { mem::transmute_copy(self) }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::Graphics::Gdi::XFORM) -> Self {
        // SAFETY: this is a thin struct
        mem::transmute(win32)
    }
}
//  Not generated due to containing a void type
//  #[derive(Debug, PartialEq, Default)]
//  #[repr(C)]
//  pub struct ProviderInfo<'a> {
//      pub pi_r0_1val: Option<unsafe extern "system" fn(*mut c_void, *mut windows_sys::Win32::System::Registry::val_context, u32, *mut c_void, *mut u32, u32) -> u32>,
//      pub pi_r0_allvals: Option<unsafe extern "system" fn(*mut c_void, *mut windows_sys::Win32::System::Registry::val_context, u32, *mut c_void, *mut u32, u32) -> u32>,
//      pub pi_r3_1val: Option<unsafe extern "system" fn(*mut c_void, *mut windows_sys::Win32::System::Registry::val_context, u32, *mut c_void, *mut u32, u32) -> u32>,
//      pub pi_r3_allvals: Option<unsafe extern "system" fn(*mut c_void, *mut windows_sys::Win32::System::Registry::val_context, u32, *mut c_void, *mut u32, u32) -> u32>,
//      pub pi_flags: u32,
//      pub pi_key_context: &'a mut todo_void,
//  }
//  impl<'a> ProviderInfo<'a> {
//      fn to_win32(&self) -> windows_sys::Win32::System::Registry::provider_info {
//          let Self { pi_r0_1val, pi_r0_allvals, pi_r3_1val, pi_r3_allvals, pi_flags, pi_key_context } = self;
//          let pi_R0_1val = *pi_r0_1val;
//          let pi_R0_allvals = *pi_r0_allvals;
//          let pi_R3_1val = *pi_r3_1val;
//          let pi_R3_allvals = *pi_r3_allvals;
//          let pi_flags = *pi_flags;
//          let pi_key_context = unsafe { &mut *(pi_key_context as *mut _ as *mut _) };
//          windows_sys::Win32::System::Registry::provider_info { pi_R0_1val, pi_R0_allvals, pi_R3_1val, pi_R3_allvals, pi_flags, pi_key_context }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::System::Registry::provider_info) -> Self {
//          let windows_sys::Win32::System::Registry::provider_info { pi_R0_1val, pi_R0_allvals, pi_R3_1val, pi_R3_allvals, pi_flags, pi_key_context } = win32;
//          let pi_r0_1val = pi_R0_1val;
//          let pi_r0_allvals = pi_R0_allvals;
//          let pi_r3_1val = pi_R3_1val;
//          let pi_r3_allvals = pi_R3_allvals;
//          let pi_flags = pi_flags;
//          let pi_key_context = unsafe { &mut *(pi_key_context as *mut _ as *mut _) };
//          Self { pi_r0_1val, pi_r0_allvals, pi_r3_1val, pi_r3_allvals, pi_flags, pi_key_context }
//      }
//  }
//  Not generated due to containing a void type
//  #[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct PvalueA<'a> {
//      pub pv_valuename: Cow<'a, CStr>,
//      pub pv_valuelen: i32,
//      pub pv_value_context: &'a mut todo_void,
//      pub pv_type: u32,
//  }
//  impl<'a> PvalueA<'a> {
//      fn to_win32(&self) -> windows_sys::Win32::System::Registry::pvalueA {
//          let Self { pv_valuename, pv_valuelen, pv_value_context, pv_type } = self;
//          let pv_valuename = pv_valuename.as_ptr() as _;
//          let pv_valuelen = *pv_valuelen;
//          let pv_value_context = unsafe { &mut *(pv_value_context as *mut _ as *mut _) };
//          let pv_type = *pv_type;
//          windows_sys::Win32::System::Registry::pvalueA { pv_valuename, pv_valuelen, pv_value_context, pv_type }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::System::Registry::pvalueA) -> Self {
//          let windows_sys::Win32::System::Registry::pvalueA { pv_valuename, pv_valuelen, pv_value_context, pv_type } = win32;
//          let pv_valuename = unsafe { CStr::from_ptr(pv_valuename as *const _) };
//          let pv_valuename = pv_valuename.to_bytes_with_nul().to_vec();
//          let pv_valuename = Cow::Owned(unsafe { CString::from_vec_unchecked(pv_valuename) });
//          let pv_valuelen = pv_valuelen;
//          let pv_value_context = unsafe { &mut *(pv_value_context as *mut _ as *mut _) };
//          let pv_type = pv_type;
//          Self { pv_valuename, pv_valuelen, pv_value_context, pv_type }
//      }
//  }
//  Not generated due to containing a void type
//  #[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct PvalueW<'a> {
//      pub pv_valuename: Cow<'a, [u16]>,
//      pub pv_valuelen: i32,
//      pub pv_value_context: &'a mut todo_void,
//      pub pv_type: u32,
//  }
//  impl<'a> PvalueW<'a> {
//      fn to_win32(&self) -> windows_sys::Win32::System::Registry::pvalueW {
//          let Self { pv_valuename, pv_valuelen, pv_value_context, pv_type } = self;
//          assert_eq!(pv_valuename.last().copied(), Some(0));
//          let pv_valuename = pv_valuename.as_ptr() as _;
//          let pv_valuelen = *pv_valuelen;
//          let pv_value_context = unsafe { &mut *(pv_value_context as *mut _ as *mut _) };
//          let pv_type = *pv_type;
//          windows_sys::Win32::System::Registry::pvalueW { pv_valuename, pv_valuelen, pv_value_context, pv_type }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::System::Registry::pvalueW) -> Self {
//          let windows_sys::Win32::System::Registry::pvalueW { pv_valuename, pv_valuelen, pv_value_context, pv_type } = win32;
//          let slen = unsafe { wide_strlen(pv_valuename as *const u16) };
//          let pv_valuename = unsafe { slice::from_raw_parts(pv_valuename, slen + 1) };
//          let pv_valuename = Cow::Owned(pv_valuename.to_vec());
//          let pv_valuelen = pv_valuelen;
//          let pv_value_context = unsafe { &mut *(pv_value_context as *mut _ as *mut _) };
//          let pv_type = pv_type;
//          Self { pv_valuename, pv_valuelen, pv_value_context, pv_type }
//      }
//  }
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct UrlinvokecommandinfoA<'a> {
    pub dwcb_size: u32,
    pub dw_flags: u32,
    pub hwnd_parent: Option<Hwnd>,
    pub pcsz_verb: Cow<'a, CStr>,
}
impl<'a> UrlinvokecommandinfoA<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::urlinvokecommandinfoA {
        let Self { dwcb_size, dw_flags, hwnd_parent, pcsz_verb } = self;
        let dwcbSize = mem::size_of::<windows_sys::Win32::UI::Shell::urlinvokecommandinfoA>() as _;
        let dwFlags = *dw_flags;
        let hwndParent = hwnd_parent.map_or(0, Hwnd::into_raw);
        let pcszVerb = pcsz_verb.as_ptr() as _;
        windows_sys::Win32::UI::Shell::urlinvokecommandinfoA { dwcbSize, dwFlags, hwndParent, pcszVerb }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::urlinvokecommandinfoA) -> Self {
        let windows_sys::Win32::UI::Shell::urlinvokecommandinfoA { dwcbSize, dwFlags, hwndParent, pcszVerb } = win32;
        let dwcb_size = dwcbSize;
        let dw_flags = dwFlags;
        let hwnd_parent = unsafe { Hwnd::new_optional(hwndParent) };
        let pcszVerb = unsafe { CStr::from_ptr(pcszVerb as *const _) };
        let pcszVerb = pcszVerb.to_bytes_with_nul().to_vec();
        let pcsz_verb = Cow::Owned(unsafe { CString::from_vec_unchecked(pcszVerb) });
        Self { dwcb_size, dw_flags, hwnd_parent, pcsz_verb }
    }
}
#[derive(Debug, PartialEq, Default, Clone, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct UrlinvokecommandinfoW<'a> {
    pub dwcb_size: u32,
    pub dw_flags: u32,
    pub hwnd_parent: Option<Hwnd>,
    pub pcsz_verb: Cow<'a, [u16]>,
}
impl<'a> UrlinvokecommandinfoW<'a> {
    fn to_win32(&self) -> windows_sys::Win32::UI::Shell::urlinvokecommandinfoW {
        let Self { dwcb_size, dw_flags, hwnd_parent, pcsz_verb } = self;
        let dwcbSize = mem::size_of::<windows_sys::Win32::UI::Shell::urlinvokecommandinfoW>() as _;
        let dwFlags = *dw_flags;
        let hwndParent = hwnd_parent.map_or(0, Hwnd::into_raw);
        assert_eq!(pcsz_verb.last().copied(), Some(0));
        let pcszVerb = pcsz_verb.as_ptr() as _;
        windows_sys::Win32::UI::Shell::urlinvokecommandinfoW { dwcbSize, dwFlags, hwndParent, pcszVerb }
    }
    unsafe fn from_win32(win32: windows_sys::Win32::UI::Shell::urlinvokecommandinfoW) -> Self {
        let windows_sys::Win32::UI::Shell::urlinvokecommandinfoW { dwcbSize, dwFlags, hwndParent, pcszVerb } = win32;
        let dwcb_size = dwcbSize;
        let dw_flags = dwFlags;
        let hwnd_parent = unsafe { Hwnd::new_optional(hwndParent) };
        let slen = unsafe { wide_strlen(pcszVerb as *const u16) };
        let pcszVerb = unsafe { slice::from_raw_parts(pcszVerb, slen + 1) };
        let pcsz_verb = Cow::Owned(pcszVerb.to_vec());
        Self { dwcb_size, dw_flags, hwnd_parent, pcsz_verb }
    }
}
//  Not generated due to containing a void type
//  #[derive(Debug, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
//  #[repr(C)]
//  pub struct ValContext<'a> {
//      pub valuelen: i32,
//      pub value_context: &'a mut todo_void,
//      pub val_buff_ptr: &'a mut todo_void,
//  }
//  impl<'a> ValContext<'a> {
//      fn to_win32(&self) -> windows_sys::Win32::System::Registry::val_context {
//          let Self { valuelen, value_context, val_buff_ptr } = self;
//          let valuelen = *valuelen;
//          let value_context = unsafe { &mut *(value_context as *mut _ as *mut _) };
//          let val_buff_ptr = unsafe { &mut *(val_buff_ptr as *mut _ as *mut _) };
//          windows_sys::Win32::System::Registry::val_context { valuelen, value_context, val_buff_ptr }
//      }
//      unsafe fn from_win32(win32: windows_sys::Win32::System::Registry::val_context) -> Self {
//          let windows_sys::Win32::System::Registry::val_context { valuelen, value_context, val_buff_ptr } = win32;
//          let valuelen = valuelen;
//          let value_context = unsafe { &mut *(value_context as *mut _ as *mut _) };
//          let val_buff_ptr = unsafe { &mut *(val_buff_ptr as *mut _ as *mut _) };
//          Self { valuelen, value_context, val_buff_ptr }
//      }
//  }
#[inline]
pub fn close_handle(h_object: Handle) -> Result<BOOL> {
    let hObject_win32 = h_object.into_raw();
    let return_value = unsafe { windows_sys::Win32::Foundation::CloseHandle(hObject_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn compare_object_handles(h_first_object_handle: Handle, h_second_object_handle: Handle) -> Result<BOOL> {
    let hFirstObjectHandle_win32 = h_first_object_handle.into_raw();
    let hSecondObjectHandle_win32 = h_second_object_handle.into_raw();
    let return_value = unsafe { windows_sys::Win32::Foundation::CompareObjectHandles(hFirstObjectHandle_win32, hSecondObjectHandle_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn duplicate_handle(h_source_process_handle: Handle, h_source_handle: Handle, h_target_process_handle: Handle, dw_desired_access: u32, b_inherit_handle: BOOL, dw_options: u32) -> Result<(BOOL, Handle)> {
    let mut lp_target_handle = mem::MaybeUninit::zeroed();
    let lpTargetHandle_win32 = lp_target_handle.as_mut_ptr();
    let hSourceProcessHandle_win32 = h_source_process_handle.into_raw();
    let hSourceHandle_win32 = h_source_handle.into_raw();
    let hTargetProcessHandle_win32 = h_target_process_handle.into_raw();
    let dwDesiredAccess_win32 = dw_desired_access;
    let bInheritHandle_win32 = b_inherit_handle;
    let dwOptions_win32 = dw_options;
    let return_value = unsafe { windows_sys::Win32::Foundation::DuplicateHandle(hSourceProcessHandle_win32, hSourceHandle_win32, hTargetProcessHandle_win32, lpTargetHandle_win32, dwDesiredAccess_win32, bInheritHandle_win32, dwOptions_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_target_handle = unsafe { Handle::new(unsafe { lp_target_handle.assume_init() }) };
    Ok((real_return_value,lp_target_handle))
}
#[inline]
pub fn get_handle_information(h_object: Handle, ) -> Result<(BOOL, u32)> {
    let mut lpdw_flags = mem::MaybeUninit::zeroed();
    let lpdwFlags_win32 = lpdw_flags.as_mut_ptr();
    let hObject_win32 = h_object.into_raw();
    let return_value = unsafe { windows_sys::Win32::Foundation::GetHandleInformation(hObject_win32, lpdwFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpdw_flags = unsafe { lpdw_flags.assume_init() };
    Ok((real_return_value,lpdw_flags))
}
#[inline]
pub fn get_last_error() -> u32 {
    let return_value = unsafe { windows_sys::Win32::Foundation::GetLastError() };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn rtl_nt_status_to_dos_error(status: NTSTATUS) -> u32 {
    let Status_win32 = status;
    let return_value = unsafe { windows_sys::Win32::Foundation::RtlNtStatusToDosError(Status_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn set_handle_information(h_object: Handle, dw_mask: u32, dw_flags: u32) -> Result<BOOL> {
    let hObject_win32 = h_object.into_raw();
    let dwMask_win32 = dw_mask;
    let dwFlags_win32 = dw_flags;
    let return_value = unsafe { windows_sys::Win32::Foundation::SetHandleInformation(hObject_win32, dwMask_win32, dwFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_last_error(dw_err_code: u32) -> () {
    let dwErrCode_win32 = dw_err_code;
    let return_value = unsafe { windows_sys::Win32::Foundation::SetLastError(dwErrCode_win32) };
    let _ = return_value;
}
#[inline]
pub fn set_last_error_ex(dw_err_code: u32, dw_type: u32) -> () {
    let dwErrCode_win32 = dw_err_code;
    let dwType_win32 = dw_type;
    let return_value = unsafe { windows_sys::Win32::Foundation::SetLastErrorEx(dwErrCode_win32, dwType_win32) };
    let _ = return_value;
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn get_registry_value_with_fallback_w(hkey_primary: Option<Hkey>, pwsz_primary_sub_key: Option<&OsStr>, hkey_fallback: Option<Hkey>, pwsz_fallback_sub_key: Option<&OsStr>, pwsz_value: &OsStr, dw_flags: u32, pv_data: Option<todo_void>, cb_data_in: u32, ) -> (u32, u32, todo_void_ret, u32) {
//      let mut pdw_type = mem::MaybeUninit::zeroed();
//      let pdwType_win32 = pdw_type.as_mut_ptr();
//      let mut pcb_data_out = mem::MaybeUninit::zeroed();
//      let pcbDataOut_win32 = pcb_data_out.as_mut_ptr();
//      let hkeyPrimary_win32 = hkey_primary.map_or(0, Hkey::into_raw);
//      let temp0 = pwsz_primary_sub_key.map(|val| {
//          let mut temp0: Vec<u16> = val.encode_wide().collect();
//          temp0.push(0);
//          temp0
//      });
//      let pwszPrimarySubKey_win32 = temp0.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let hkeyFallback_win32 = hkey_fallback.map_or(0, Hkey::into_raw);
//      let temp1 = pwsz_fallback_sub_key.map(|val| {
//          let mut temp1: Vec<u16> = val.encode_wide().collect();
//          temp1.push(0);
//          temp1
//      });
//      let pwszFallbackSubKey_win32 = temp1.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let mut temp2: Vec<u16> = pwsz_value.encode_wide().collect();
//      temp2.push(0);
//      let pwszValue_win32 = temp2.as_ptr() as _;
//      let dwFlags_win32 = dw_flags;
//      let mut pvData_win32 = todo_void;
//      let cbDataIn_win32 = cb_data_in;
//      let return_value = unsafe { windows_sys::Win32::System::Registry::GetRegistryValueWithFallbackW(hkeyPrimary_win32, pwszPrimarySubKey_win32, hkeyFallback_win32, pwszFallbackSubKey_win32, pwszValue_win32, dwFlags_win32, pdwType_win32, &mut pvData_win32, cbDataIn_win32, pcbDataOut_win32) };
//      let real_return_value = return_value;
//      let pcb_data_out = unsafe { pcb_data_out.assume_init() };
//      let pv_data = todo_void;
//      let pdw_type = unsafe { pdw_type.assume_init() };
//      (real_return_value,pdw_type, pv_data, pcb_data_out)
//  }
#[inline]
pub fn abort_path(hdc: Hdc) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::AbortPath(hdc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn add_font_mem_resource_ex(p_file_view: &todo_void, pv_resrved: todo_void, p_num_fonts: &[u32]) -> Result<(Handle, todo_void_ret)> {
//      // SAFETY: type is a thin type
//      let pFileView_win32 = unsafe { &*(p_file_view as *const _ as *const _) };
//      let mut pvResrved_win32 = todo_void;
//      let pNumFonts_win32 = p_num_fonts.as_ptr() as _;
//      let cjSize_win32 = p_num_fonts.len() as _;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::AddFontMemResourceEx(pFileView_win32, cjSize_win32, &mut pvResrved_win32, pNumFonts_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = unsafe { Handle::new(return_value) };
//      let pv_resrved = todo_void;
//      Ok((real_return_value,pv_resrved))
//  }
#[inline]
pub fn add_font_resource_a(param0: &CStr) -> Result<i32> {
    let param0_win32 = param0.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::AddFontResourceA(param0_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn add_font_resource_ex_a(name: &CStr, fl: u32, res: todo_void) -> Result<(i32, todo_void_ret)> {
//      let name_win32 = name.as_ptr() as _;
//      let fl_win32 = fl;
//      let mut res_win32 = todo_void;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::AddFontResourceExA(name_win32, fl_win32, &mut res_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      let res = todo_void;
//      Ok((real_return_value,res))
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn add_font_resource_ex_w(name: &OsStr, fl: u32, res: todo_void) -> Result<(i32, todo_void_ret)> {
//      let mut temp3: Vec<u16> = name.encode_wide().collect();
//      temp3.push(0);
//      let name_win32 = temp3.as_ptr() as _;
//      let fl_win32 = fl;
//      let mut res_win32 = todo_void;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::AddFontResourceExW(name_win32, fl_win32, &mut res_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      let res = todo_void;
//      Ok((real_return_value,res))
//  }
#[inline]
pub fn add_font_resource_w(param0: &OsStr) -> Result<i32> {
    let mut temp4: Vec<u16> = param0.encode_wide().collect();
    temp4.push(0);
    let param0_win32 = temp4.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::AddFontResourceW(param0_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn alpha_blend(hdc_dest: Hdc, xorigin_dest: i32, yorigin_dest: i32, w_dest: i32, h_dest: i32, hdc_src: Hdc, xorigin_src: i32, yorigin_src: i32, w_src: i32, h_src: i32, ftn: Blendfunction) -> Result<BOOL> {
    let hdcDest_win32 = hdc_dest.into_raw();
    let xoriginDest_win32 = xorigin_dest;
    let yoriginDest_win32 = yorigin_dest;
    let wDest_win32 = w_dest;
    let hDest_win32 = h_dest;
    let hdcSrc_win32 = hdc_src.into_raw();
    let xoriginSrc_win32 = xorigin_src;
    let yoriginSrc_win32 = yorigin_src;
    let wSrc_win32 = w_src;
    let hSrc_win32 = h_src;
    let ftn_win32 = ftn.to_win32();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::AlphaBlend(hdcDest_win32, xoriginDest_win32, yoriginDest_win32, wDest_win32, hDest_win32, hdcSrc_win32, xoriginSrc_win32, yoriginSrc_win32, wSrc_win32, hSrc_win32, ftn_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn angle_arc(hdc: Hdc, x: i32, y: i32, r: u32, start_angle: f32, sweep_angle: f32) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let r_win32 = r;
    let StartAngle_win32 = start_angle;
    let SweepAngle_win32 = sweep_angle;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::AngleArc(hdc_win32, x_win32, y_win32, r_win32, StartAngle_win32, SweepAngle_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn animate_palette(h_pal: Hpalette, i_start_index: u32, ppe: &[Paletteentry]) -> Result<BOOL> {
    let hPal_win32 = h_pal.into_raw();
    let iStartIndex_win32 = i_start_index;
    let ppe_win32 = ppe.as_ptr() as _;
    let cEntries_win32 = ppe.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::AnimatePalette(hPal_win32, iStartIndex_win32, cEntries_win32, ppe_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn arc(hdc: Hdc, x1: i32, y1: i32, x2: i32, y2: i32, x3: i32, y3: i32, x4: i32, y4: i32) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let x1_win32 = x1;
    let y1_win32 = y1;
    let x2_win32 = x2;
    let y2_win32 = y2;
    let x3_win32 = x3;
    let y3_win32 = y3;
    let x4_win32 = x4;
    let y4_win32 = y4;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::Arc(hdc_win32, x1_win32, y1_win32, x2_win32, y2_win32, x3_win32, y3_win32, x4_win32, y4_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn arc_to(hdc: Hdc, left: i32, top: i32, right: i32, bottom: i32, xr1: i32, yr1: i32, xr2: i32, yr2: i32) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let left_win32 = left;
    let top_win32 = top;
    let right_win32 = right;
    let bottom_win32 = bottom;
    let xr1_win32 = xr1;
    let yr1_win32 = yr1;
    let xr2_win32 = xr2;
    let yr2_win32 = yr2;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ArcTo(hdc_win32, left_win32, top_win32, right_win32, bottom_win32, xr1_win32, yr1_win32, xr2_win32, yr2_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn begin_paint(h_wnd: Hwnd, ) -> Result<(Hdc, Paintstruct)> {
    let mut lp_paint = mem::MaybeUninit::zeroed();
    let lpPaint_win32 = lp_paint.as_mut_ptr();
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::BeginPaint(hWnd_win32, lpPaint_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hdc::new(return_value) };
    let lp_paint = unsafe { Paintstruct::from_win32(unsafe { lp_paint.assume_init() }) };
    Ok((real_return_value,lp_paint))
}
#[inline]
pub fn begin_path(hdc: Hdc) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::BeginPath(hdc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn bit_blt(hdc: Hdc, x: i32, y: i32, cx: i32, cy: i32, hdc_src: Option<Hdc>, x1: i32, y1: i32, rop: u32) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let cx_win32 = cx;
    let cy_win32 = cy;
    let hdcSrc_win32 = hdc_src.map_or(0, Hdc::into_raw);
    let x1_win32 = x1;
    let y1_win32 = y1;
    let rop_win32 = rop;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::BitBlt(hdc_win32, x_win32, y_win32, cx_win32, cy_win32, hdcSrc_win32, x1_win32, y1_win32, rop_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn cancel_dc(hdc: Hdc) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CancelDC(hdc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn change_display_settings_a(lp_dev_mode: Option<&Devmodea>, dw_flags: u32) -> i32 {
    let temp5 = lp_dev_mode.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
    let lpDevMode_win32 = &temp5;
    let dwFlags_win32 = dw_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ChangeDisplaySettingsA(lpDevMode_win32, dwFlags_win32) };
    let real_return_value = return_value;
    real_return_value
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn change_display_settings_ex_a(lpsz_device_name: Option<&CStr>, lp_dev_mode: Option<&Devmodea>, hwnd: Hwnd, dwflags: u32, l_param: Option<&todo_void>) -> i32 {
//      let lpszDeviceName_win32 = lpsz_device_name.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let temp6 = lp_dev_mode.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
//      let lpDevMode_win32 = &temp6;
//      let hwnd_win32 = hwnd.into_raw();
//      let dwflags_win32 = dwflags;
//      // SAFETY: type is a thin type
//      let lParam_win32 = l_param.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ChangeDisplaySettingsExA(lpszDeviceName_win32, lpDevMode_win32, hwnd_win32, dwflags_win32, lParam_win32) };
//      let real_return_value = return_value;
//      real_return_value
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn change_display_settings_ex_w(lpsz_device_name: Option<&OsStr>, lp_dev_mode: Option<&Devmodew>, hwnd: Hwnd, dwflags: u32, l_param: Option<&todo_void>) -> i32 {
//      let temp7 = lpsz_device_name.map(|val| {
//          let mut temp7: Vec<u16> = val.encode_wide().collect();
//          temp7.push(0);
//          temp7
//      });
//      let lpszDeviceName_win32 = temp7.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let temp8 = lp_dev_mode.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
//      let lpDevMode_win32 = &temp8;
//      let hwnd_win32 = hwnd.into_raw();
//      let dwflags_win32 = dwflags;
//      // SAFETY: type is a thin type
//      let lParam_win32 = l_param.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ChangeDisplaySettingsExW(lpszDeviceName_win32, lpDevMode_win32, hwnd_win32, dwflags_win32, lParam_win32) };
//      let real_return_value = return_value;
//      real_return_value
//  }
#[inline]
pub fn change_display_settings_w(lp_dev_mode: Option<&Devmodew>, dw_flags: u32) -> i32 {
    let temp9 = lp_dev_mode.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
    let lpDevMode_win32 = &temp9;
    let dwFlags_win32 = dw_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ChangeDisplaySettingsW(lpDevMode_win32, dwFlags_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn chord(hdc: Hdc, x1: i32, y1: i32, x2: i32, y2: i32, x3: i32, y3: i32, x4: i32, y4: i32) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let x1_win32 = x1;
    let y1_win32 = y1;
    let x2_win32 = x2;
    let y2_win32 = y2;
    let x3_win32 = x3;
    let y3_win32 = y3;
    let x4_win32 = x4;
    let y4_win32 = y4;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::Chord(hdc_win32, x1_win32, y1_win32, x2_win32, y2_win32, x3_win32, y3_win32, x4_win32, y4_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn client_to_screen(h_wnd: Hwnd, lp_point: Point) -> Result<(BOOL, Point)> {
    let hWnd_win32 = h_wnd.into_raw();
    let mut lpPoint_win32 = lp_point.to_win32();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ClientToScreen(hWnd_win32, &mut lpPoint_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_point = unsafe { Point::from_win32(lpPoint_win32) };
    Ok((real_return_value,lp_point))
}
#[inline]
pub fn close_enh_meta_file(hdc: Hdc) -> Result<Henhmetafile> {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CloseEnhMetaFile(hdc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Henhmetafile::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn close_figure(hdc: Hdc) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CloseFigure(hdc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn close_meta_file(hdc: Hdc) -> Result<Hmetafile> {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CloseMetaFile(hdc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hmetafile::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn combine_rgn(hrgn_dst: Option<Hrgn>, hrgn_src1: Option<Hrgn>, hrgn_src2: Option<Hrgn>, i_mode: i32) -> Result<i32> {
    let hrgnDst_win32 = hrgn_dst.map_or(0, Hrgn::into_raw);
    let hrgnSrc1_win32 = hrgn_src1.map_or(0, Hrgn::into_raw);
    let hrgnSrc2_win32 = hrgn_src2.map_or(0, Hrgn::into_raw);
    let iMode_win32 = i_mode;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CombineRgn(hrgnDst_win32, hrgnSrc1_win32, hrgnSrc2_win32, iMode_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn combine_transform(lpxf1: &Xform, lpxf2: &Xform) -> Result<(BOOL, Xform)> {
    let mut lpxf_out = mem::MaybeUninit::zeroed();
    let lpxfOut_win32 = lpxf_out.as_mut_ptr();
    // SAFETY: type is a thin type
    let lpxf1_win32 = unsafe { &*(lpxf1 as *const _ as *const _) };
    // SAFETY: type is a thin type
    let lpxf2_win32 = unsafe { &*(lpxf2 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CombineTransform(lpxfOut_win32, lpxf1_win32, lpxf2_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpxf_out = unsafe { Xform::from_win32(unsafe { lpxf_out.assume_init() }) };
    Ok((real_return_value,lpxf_out))
}
#[inline]
pub fn copy_enh_meta_file_a(h_enh: Henhmetafile, lp_file_name: Option<&CStr>) -> Result<Henhmetafile> {
    let hEnh_win32 = h_enh.into_raw();
    let lpFileName_win32 = lp_file_name.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CopyEnhMetaFileA(hEnh_win32, lpFileName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Henhmetafile::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn copy_enh_meta_file_w(h_enh: Henhmetafile, lp_file_name: Option<&OsStr>) -> Result<Henhmetafile> {
    let hEnh_win32 = h_enh.into_raw();
    let temp10 = lp_file_name.map(|val| {
        let mut temp10: Vec<u16> = val.encode_wide().collect();
        temp10.push(0);
        temp10
    });
    let lpFileName_win32 = temp10.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CopyEnhMetaFileW(hEnh_win32, lpFileName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Henhmetafile::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn copy_meta_file_a(param0: Hmetafile, param1: Option<&CStr>) -> Result<Hmetafile> {
    let param0_win32 = param0.into_raw();
    let param1_win32 = param1.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CopyMetaFileA(param0_win32, param1_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hmetafile::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn copy_meta_file_w(param0: Hmetafile, param1: Option<&OsStr>) -> Result<Hmetafile> {
    let param0_win32 = param0.into_raw();
    let temp11 = param1.map(|val| {
        let mut temp11: Vec<u16> = val.encode_wide().collect();
        temp11.push(0);
        temp11
    });
    let param1_win32 = temp11.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CopyMetaFileW(param0_win32, param1_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hmetafile::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn copy_rect(lprc_src: &Rect) -> Result<(BOOL, Rect)> {
    let mut lprc_dst = mem::MaybeUninit::zeroed();
    let lprcDst_win32 = lprc_dst.as_mut_ptr();
    // SAFETY: type is a thin type
    let lprcSrc_win32 = unsafe { &*(lprc_src as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CopyRect(lprcDst_win32, lprcSrc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lprc_dst = unsafe { Rect::from_win32(unsafe { lprc_dst.assume_init() }) };
    Ok((real_return_value,lprc_dst))
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn create_bitmap(n_width: i32, n_height: i32, n_planes: u32, lp_bits: Option<&[todo_void]>) -> Result<Hbitmap> {
//      let nWidth_win32 = n_width;
//      let nHeight_win32 = n_height;
//      let nPlanes_win32 = n_planes;
//      let lpBits_win32 = lp_bits.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let nBitCount_win32 = lp_bits.len() as _;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateBitmap(nWidth_win32, nHeight_win32, nPlanes_win32, nBitCount_win32, lpBits_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = unsafe { Hbitmap::new(return_value) };
//      Ok(real_return_value)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn create_bitmap_indirect(pbm: &Bitmap<'_>) -> Result<Hbitmap> {
//      let temp12 = pbm.to_win32();
//      let pbm_win32 = &temp12;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateBitmapIndirect(pbm_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = unsafe { Hbitmap::new(return_value) };
//      Ok(real_return_value)
//  }
#[inline]
pub fn create_brush_indirect(plbrush: &Logbrush) -> Result<Hbrush> {
    // SAFETY: type is a thin type
    let plbrush_win32 = unsafe { &*(plbrush as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateBrushIndirect(plbrush_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hbrush::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_compatible_bitmap(hdc: Hdc, cx: i32, cy: i32) -> Result<Hbitmap> {
    let hdc_win32 = hdc.into_raw();
    let cx_win32 = cx;
    let cy_win32 = cy;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateCompatibleBitmap(hdc_win32, cx_win32, cy_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hbitmap::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_compatible_dc(hdc: Option<Hdc>) -> Result<CreatedHdc> {
    let hdc_win32 = hdc.map_or(0, Hdc::into_raw);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateCompatibleDC(hdc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { CreatedHdc::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_dca(pwsz_driver: Option<&CStr>, pwsz_device: Option<&CStr>, psz_port: Option<&CStr>, pdm: Option<&Devmodea>) -> Result<CreatedHdc> {
    let pwszDriver_win32 = pwsz_driver.map_or(ptr::null(), |v| v.as_ptr() as _);
    let pwszDevice_win32 = pwsz_device.map_or(ptr::null(), |v| v.as_ptr() as _);
    let pszPort_win32 = psz_port.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp13 = pdm.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
    let pdm_win32 = &temp13;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateDCA(pwszDriver_win32, pwszDevice_win32, pszPort_win32, pdm_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { CreatedHdc::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_dcw(pwsz_driver: Option<&OsStr>, pwsz_device: Option<&OsStr>, psz_port: Option<&OsStr>, pdm: Option<&Devmodew>) -> Result<CreatedHdc> {
    let temp14 = pwsz_driver.map(|val| {
        let mut temp14: Vec<u16> = val.encode_wide().collect();
        temp14.push(0);
        temp14
    });
    let pwszDriver_win32 = temp14.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp15 = pwsz_device.map(|val| {
        let mut temp15: Vec<u16> = val.encode_wide().collect();
        temp15.push(0);
        temp15
    });
    let pwszDevice_win32 = temp15.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp16 = psz_port.map(|val| {
        let mut temp16: Vec<u16> = val.encode_wide().collect();
        temp16.push(0);
        temp16
    });
    let pszPort_win32 = temp16.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp17 = pdm.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
    let pdm_win32 = &temp17;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateDCW(pwszDriver_win32, pwszDevice_win32, pszPort_win32, pdm_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { CreatedHdc::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_dib_pattern_brush(h: isize, i_usage: u32) -> Result<Hbrush> {
    let h_win32 = h;
    let iUsage_win32 = i_usage;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateDIBPatternBrush(h_win32, iUsage_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hbrush::new(return_value) };
    Ok(real_return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn create_dib_pattern_brush_pt(lp_packed_dib: &todo_void, i_usage: u32) -> Result<Hbrush> {
//      // SAFETY: type is a thin type
//      let lpPackedDIB_win32 = unsafe { &*(lp_packed_dib as *const _ as *const _) };
//      let iUsage_win32 = i_usage;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateDIBPatternBrushPt(lpPackedDIB_win32, iUsage_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = unsafe { Hbrush::new(return_value) };
//      Ok(real_return_value)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn create_dib_section(hdc: Option<Hdc>, pbmi: &Bitmapinfo, usage: u32, h_section: Option<Handle>, offset: u32) -> Result<(Hbitmap, &mut todo_void_ret)> {
//      let mut ppv_bits = mem::MaybeUninit::zeroed();
//      let ppvBits_win32 = ppv_bits.as_mut_ptr();
//      let hdc_win32 = hdc.map_or(0, Hdc::into_raw);
//      let temp18 = pbmi.to_win32();
//      let pbmi_win32 = &temp18;
//      let usage_win32 = usage;
//      let hSection_win32 = h_section.map_or(0, Handle::into_raw);
//      let offset_win32 = offset;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateDIBSection(hdc_win32, pbmi_win32, usage_win32, ppvBits_win32, hSection_win32, offset_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = unsafe { Hbitmap::new(return_value) };
//      let ppv_bits = unsafe { &mut *(unsafe { ppv_bits.assume_init() } as *mut _) };
//      Ok((real_return_value,ppv_bits))
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn create_di_bitmap(hdc: Hdc, pbmih: Option<&Bitmapinfoheader>, fl_init: u32, pj_bits: Option<&todo_void>, pbmi: Option<&Bitmapinfo>, i_usage: u32) -> Result<Hbitmap> {
//      let hdc_win32 = hdc.into_raw();
//      let temp19 = pbmih.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
//      let pbmih_win32 = &temp19;
//      let flInit_win32 = fl_init;
//      // SAFETY: type is a thin type
//      let pjBits_win32 = pj_bits.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      let temp20 = pbmi.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
//      let pbmi_win32 = &temp20;
//      let iUsage_win32 = i_usage;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateDIBitmap(hdc_win32, pbmih_win32, flInit_win32, pjBits_win32, pbmi_win32, iUsage_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = unsafe { Hbitmap::new(return_value) };
//      Ok(real_return_value)
//  }
#[inline]
pub fn create_discardable_bitmap(hdc: Hdc, cx: i32, cy: i32) -> Result<Hbitmap> {
    let hdc_win32 = hdc.into_raw();
    let cx_win32 = cx;
    let cy_win32 = cy;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateDiscardableBitmap(hdc_win32, cx_win32, cy_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hbitmap::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_elliptic_rgn(x1: i32, y1: i32, x2: i32, y2: i32) -> Result<Hrgn> {
    let x1_win32 = x1;
    let y1_win32 = y1;
    let x2_win32 = x2;
    let y2_win32 = y2;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateEllipticRgn(x1_win32, y1_win32, x2_win32, y2_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hrgn::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_elliptic_rgn_indirect(lprect: &Rect) -> Result<Hrgn> {
    // SAFETY: type is a thin type
    let lprect_win32 = unsafe { &*(lprect as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateEllipticRgnIndirect(lprect_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hrgn::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_enh_meta_file_a(hdc: Option<Hdc>, lp_filename: Option<&CStr>, lprc: Option<&Rect>, lp_desc: Option<&CStr>) -> Result<HdcMetdataEnhFileHandle> {
    let hdc_win32 = hdc.map_or(0, Hdc::into_raw);
    let lpFilename_win32 = lp_filename.map_or(ptr::null(), |v| v.as_ptr() as _);
    // SAFETY: type is a thin type
    let lprc_win32 = lprc.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let lpDesc_win32 = lp_desc.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateEnhMetaFileA(hdc_win32, lpFilename_win32, lprc_win32, lpDesc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { HdcMetdataEnhFileHandle::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_enh_meta_file_w(hdc: Option<Hdc>, lp_filename: Option<&OsStr>, lprc: Option<&Rect>, lp_desc: Option<&OsStr>) -> Result<HdcMetdataEnhFileHandle> {
    let hdc_win32 = hdc.map_or(0, Hdc::into_raw);
    let temp21 = lp_filename.map(|val| {
        let mut temp21: Vec<u16> = val.encode_wide().collect();
        temp21.push(0);
        temp21
    });
    let lpFilename_win32 = temp21.map_or(ptr::null(), |v| v.as_ptr() as _);
    // SAFETY: type is a thin type
    let lprc_win32 = lprc.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let temp22 = lp_desc.map(|val| {
        let mut temp22: Vec<u16> = val.encode_wide().collect();
        temp22.push(0);
        temp22
    });
    let lpDesc_win32 = temp22.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateEnhMetaFileW(hdc_win32, lpFilename_win32, lprc_win32, lpDesc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { HdcMetdataEnhFileHandle::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_font_a(c_height: i32, c_width: i32, c_escapement: i32, c_orientation: i32, c_weight: i32, b_italic: u32, b_underline: u32, b_strike_out: u32, i_char_set: u32, i_out_precision: u32, i_clip_precision: u32, i_quality: u32, i_pitch_and_family: u32, psz_face_name: Option<&CStr>) -> Result<Hfont> {
    let cHeight_win32 = c_height;
    let cWidth_win32 = c_width;
    let cEscapement_win32 = c_escapement;
    let cOrientation_win32 = c_orientation;
    let cWeight_win32 = c_weight;
    let bItalic_win32 = b_italic;
    let bUnderline_win32 = b_underline;
    let bStrikeOut_win32 = b_strike_out;
    let iCharSet_win32 = i_char_set;
    let iOutPrecision_win32 = i_out_precision;
    let iClipPrecision_win32 = i_clip_precision;
    let iQuality_win32 = i_quality;
    let iPitchAndFamily_win32 = i_pitch_and_family;
    let pszFaceName_win32 = psz_face_name.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateFontA(cHeight_win32, cWidth_win32, cEscapement_win32, cOrientation_win32, cWeight_win32, bItalic_win32, bUnderline_win32, bStrikeOut_win32, iCharSet_win32, iOutPrecision_win32, iClipPrecision_win32, iQuality_win32, iPitchAndFamily_win32, pszFaceName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hfont::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_font_indirect_a(lplf: &Logfonta) -> Result<Hfont> {
    // SAFETY: type is a thin type
    let lplf_win32 = unsafe { &*(lplf as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateFontIndirectA(lplf_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hfont::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_font_indirect_ex_a(param0: &Enumlogfontexdva) -> Result<Hfont> {
    // SAFETY: type is a thin type
    let param0_win32 = unsafe { &*(param0 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateFontIndirectExA(param0_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hfont::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_font_indirect_ex_w(param0: &Enumlogfontexdvw) -> Result<Hfont> {
    // SAFETY: type is a thin type
    let param0_win32 = unsafe { &*(param0 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateFontIndirectExW(param0_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hfont::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_font_indirect_w(lplf: &Logfontw) -> Result<Hfont> {
    // SAFETY: type is a thin type
    let lplf_win32 = unsafe { &*(lplf as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateFontIndirectW(lplf_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hfont::new(return_value) };
    Ok(real_return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn create_font_package(puch_src_buffer: &u8, ppuch_font_package_buffer: &mut u8, pul_font_package_buffer_size: u32, pul_bytes_written: u32, us_flag: u16, us_ttc_index: u16, us_subset_format: u16, us_subset_language: u16, us_subset_platform: u32, us_subset_encoding: u32, pus_subset_keep_list: &[u16], us_subset_list_count: u16, lpfn_allocate: Option<unsafe extern "system" fn(usize) -> *mut c_void>, lpfn_re_allocate: Option<unsafe extern "system" fn(*mut c_void, usize) -> *mut c_void>, lpfn_free: Option<unsafe extern "system" fn(*mut c_void)>, lpv_reserved: todo_void) -> (u32, &mut u8, u32, u32, todo_void_ret) {
//      // SAFETY: type is a thin type
//      let puchSrcBuffer_win32 = unsafe { &*(puch_src_buffer as *const _ as *const _) };
//      let mut temp23 = ppuch_font_package_buffer;
//      let mut ppuchFontPackageBuffer_win32 = &mut temp23;
//      let mut pulFontPackageBufferSize_win32 = pul_font_package_buffer_size;
//      let mut pulBytesWritten_win32 = pul_bytes_written;
//      let usFlag_win32 = us_flag;
//      let usTTCIndex_win32 = us_ttc_index;
//      let usSubsetFormat_win32 = us_subset_format;
//      let usSubsetLanguage_win32 = us_subset_language;
//      let usSubsetPlatform_win32 = us_subset_platform;
//      let usSubsetEncoding_win32 = us_subset_encoding;
//      let pusSubsetKeepList_win32 = pus_subset_keep_list.as_ptr() as _;
//      let ulSrcBufferSize_win32 = pus_subset_keep_list.len() as _;
//      let usSubsetListCount_win32 = us_subset_list_count;
//      let lpfnAllocate_win32 = lpfn_allocate;
//      let lpfnReAllocate_win32 = lpfn_re_allocate;
//      let lpfnFree_win32 = lpfn_free;
//      let mut lpvReserved_win32 = todo_void;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateFontPackage(puchSrcBuffer_win32, ulSrcBufferSize_win32, &mut ppuchFontPackageBuffer_win32, &mut pulFontPackageBufferSize_win32, &mut pulBytesWritten_win32, usFlag_win32, usTTCIndex_win32, usSubsetFormat_win32, usSubsetLanguage_win32, usSubsetPlatform_win32, usSubsetEncoding_win32, pusSubsetKeepList_win32, usSubsetListCount_win32, lpfnAllocate_win32, lpfnReAllocate_win32, lpfnFree_win32, &mut lpvReserved_win32) };
//      let real_return_value = return_value;
//      let lpv_reserved = todo_void;
//      let pul_bytes_written = pulBytesWritten_win32;
//      let pul_font_package_buffer_size = pulFontPackageBufferSize_win32;
//      let ppuch_font_package_buffer = unsafe { &mut *(ppuchFontPackageBuffer_win32 as *mut _) };
//      (real_return_value,ppuch_font_package_buffer, pul_font_package_buffer_size, pul_bytes_written, lpv_reserved)
//  }
#[inline]
pub fn create_font_w(c_height: i32, c_width: i32, c_escapement: i32, c_orientation: i32, c_weight: i32, b_italic: u32, b_underline: u32, b_strike_out: u32, i_char_set: u32, i_out_precision: u32, i_clip_precision: u32, i_quality: u32, i_pitch_and_family: u32, psz_face_name: Option<&OsStr>) -> Result<Hfont> {
    let cHeight_win32 = c_height;
    let cWidth_win32 = c_width;
    let cEscapement_win32 = c_escapement;
    let cOrientation_win32 = c_orientation;
    let cWeight_win32 = c_weight;
    let bItalic_win32 = b_italic;
    let bUnderline_win32 = b_underline;
    let bStrikeOut_win32 = b_strike_out;
    let iCharSet_win32 = i_char_set;
    let iOutPrecision_win32 = i_out_precision;
    let iClipPrecision_win32 = i_clip_precision;
    let iQuality_win32 = i_quality;
    let iPitchAndFamily_win32 = i_pitch_and_family;
    let temp24 = psz_face_name.map(|val| {
        let mut temp24: Vec<u16> = val.encode_wide().collect();
        temp24.push(0);
        temp24
    });
    let pszFaceName_win32 = temp24.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateFontW(cHeight_win32, cWidth_win32, cEscapement_win32, cOrientation_win32, cWeight_win32, bItalic_win32, bUnderline_win32, bStrikeOut_win32, iCharSet_win32, iOutPrecision_win32, iClipPrecision_win32, iQuality_win32, iPitchAndFamily_win32, pszFaceName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hfont::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_halftone_palette(hdc: Option<Hdc>) -> Result<Hpalette> {
    let hdc_win32 = hdc.map_or(0, Hdc::into_raw);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateHalftonePalette(hdc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hpalette::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_hatch_brush(i_hatch: u32, color: u32) -> Result<Hbrush> {
    let iHatch_win32 = i_hatch;
    let color_win32 = color;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateHatchBrush(iHatch_win32, color_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hbrush::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_ica(psz_driver: Option<&CStr>, psz_device: Option<&CStr>, psz_port: Option<&CStr>, pdm: Option<&Devmodea>) -> Result<CreatedHdc> {
    let pszDriver_win32 = psz_driver.map_or(ptr::null(), |v| v.as_ptr() as _);
    let pszDevice_win32 = psz_device.map_or(ptr::null(), |v| v.as_ptr() as _);
    let pszPort_win32 = psz_port.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp25 = pdm.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
    let pdm_win32 = &temp25;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateICA(pszDriver_win32, pszDevice_win32, pszPort_win32, pdm_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { CreatedHdc::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_icw(psz_driver: Option<&OsStr>, psz_device: Option<&OsStr>, psz_port: Option<&OsStr>, pdm: Option<&Devmodew>) -> Result<CreatedHdc> {
    let temp26 = psz_driver.map(|val| {
        let mut temp26: Vec<u16> = val.encode_wide().collect();
        temp26.push(0);
        temp26
    });
    let pszDriver_win32 = temp26.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp27 = psz_device.map(|val| {
        let mut temp27: Vec<u16> = val.encode_wide().collect();
        temp27.push(0);
        temp27
    });
    let pszDevice_win32 = temp27.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp28 = psz_port.map(|val| {
        let mut temp28: Vec<u16> = val.encode_wide().collect();
        temp28.push(0);
        temp28
    });
    let pszPort_win32 = temp28.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp29 = pdm.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
    let pdm_win32 = &temp29;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateICW(pszDriver_win32, pszDevice_win32, pszPort_win32, pdm_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { CreatedHdc::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_meta_file_a(psz_file: Option<&CStr>) -> Result<HdcMetdataFileHandle> {
    let pszFile_win32 = psz_file.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateMetaFileA(pszFile_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { HdcMetdataFileHandle::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_meta_file_w(psz_file: Option<&OsStr>) -> Result<HdcMetdataFileHandle> {
    let temp30 = psz_file.map(|val| {
        let mut temp30: Vec<u16> = val.encode_wide().collect();
        temp30.push(0);
        temp30
    });
    let pszFile_win32 = temp30.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateMetaFileW(pszFile_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { HdcMetdataFileHandle::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_palette(plpal: &Logpalette) -> Result<Hpalette> {
    // SAFETY: type is a thin type
    let plpal_win32 = unsafe { &*(plpal as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreatePalette(plpal_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hpalette::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_pattern_brush(hbm: Hbitmap) -> Result<Hbrush> {
    let hbm_win32 = hbm.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreatePatternBrush(hbm_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hbrush::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_pen(i_style: u32, c_width: i32, color: u32) -> Result<Hpen> {
    let iStyle_win32 = i_style;
    let cWidth_win32 = c_width;
    let color_win32 = color;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreatePen(iStyle_win32, cWidth_win32, color_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hpen::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_pen_indirect(plpen: &Logpen) -> Result<Hpen> {
    // SAFETY: type is a thin type
    let plpen_win32 = unsafe { &*(plpen as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreatePenIndirect(plpen_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hpen::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_poly_polygon_rgn(pptl: &Point, pc: &[i32], i_mode: u32) -> Result<Hrgn> {
    // SAFETY: type is a thin type
    let pptl_win32 = unsafe { &*(pptl as *const _ as *const _) };
    let pc_win32 = pc.as_ptr() as _;
    let cPoly_win32 = pc.len() as _;
    let iMode_win32 = i_mode;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreatePolyPolygonRgn(pptl_win32, pc_win32, cPoly_win32, iMode_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hrgn::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_polygon_rgn(pptl: &[Point], i_mode: u32) -> Result<Hrgn> {
    let pptl_win32 = pptl.as_ptr() as _;
    let cPoint_win32 = pptl.len() as _;
    let iMode_win32 = i_mode;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreatePolygonRgn(pptl_win32, cPoint_win32, iMode_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hrgn::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_rect_rgn(x1: i32, y1: i32, x2: i32, y2: i32) -> Result<Hrgn> {
    let x1_win32 = x1;
    let y1_win32 = y1;
    let x2_win32 = x2;
    let y2_win32 = y2;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateRectRgn(x1_win32, y1_win32, x2_win32, y2_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hrgn::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_rect_rgn_indirect(lprect: &Rect) -> Result<Hrgn> {
    // SAFETY: type is a thin type
    let lprect_win32 = unsafe { &*(lprect as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateRectRgnIndirect(lprect_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hrgn::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_round_rect_rgn(x1: i32, y1: i32, x2: i32, y2: i32, w: i32, h: i32) -> Result<Hrgn> {
    let x1_win32 = x1;
    let y1_win32 = y1;
    let x2_win32 = x2;
    let y2_win32 = y2;
    let w_win32 = w;
    let h_win32 = h;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateRoundRectRgn(x1_win32, y1_win32, x2_win32, y2_win32, w_win32, h_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hrgn::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_scalable_font_resource_a(fdw_hidden: u32, lpsz_font: &CStr, lpsz_file: &CStr, lpsz_path: Option<&CStr>) -> Result<BOOL> {
    let fdwHidden_win32 = fdw_hidden;
    let lpszFont_win32 = lpsz_font.as_ptr() as _;
    let lpszFile_win32 = lpsz_file.as_ptr() as _;
    let lpszPath_win32 = lpsz_path.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateScalableFontResourceA(fdwHidden_win32, lpszFont_win32, lpszFile_win32, lpszPath_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn create_scalable_font_resource_w(fdw_hidden: u32, lpsz_font: &OsStr, lpsz_file: &OsStr, lpsz_path: Option<&OsStr>) -> Result<BOOL> {
    let fdwHidden_win32 = fdw_hidden;
    let mut temp31: Vec<u16> = lpsz_font.encode_wide().collect();
    temp31.push(0);
    let lpszFont_win32 = temp31.as_ptr() as _;
    let mut temp32: Vec<u16> = lpsz_file.encode_wide().collect();
    temp32.push(0);
    let lpszFile_win32 = temp32.as_ptr() as _;
    let temp33 = lpsz_path.map(|val| {
        let mut temp33: Vec<u16> = val.encode_wide().collect();
        temp33.push(0);
        temp33
    });
    let lpszPath_win32 = temp33.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateScalableFontResourceW(fdwHidden_win32, lpszFont_win32, lpszFile_win32, lpszPath_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn create_solid_brush(color: u32) -> Result<Hbrush> {
    let color_win32 = color;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::CreateSolidBrush(color_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hbrush::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn d_pto_lp(hdc: Hdc, lppt: Point, c: i32) -> Result<(BOOL, Point)> {
    let hdc_win32 = hdc.into_raw();
    let mut lppt_win32 = lppt.to_win32();
    let c_win32 = c;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DPtoLP(hdc_win32, &mut lppt_win32, c_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lppt = unsafe { Point::from_win32(lppt_win32) };
    Ok((real_return_value,lppt))
}
#[inline]
pub fn delete_dc(hdc: CreatedHdc) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DeleteDC(hdc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn delete_enh_meta_file(hmf: Option<Henhmetafile>) -> Result<BOOL> {
    let hmf_win32 = hmf.map_or(0, Henhmetafile::into_raw);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DeleteEnhMetaFile(hmf_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn delete_meta_file(hmf: Hmetafile) -> Result<BOOL> {
    let hmf_win32 = hmf.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DeleteMetaFile(hmf_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn delete_object(ho: Hgdiobj) -> Result<BOOL> {
    let ho_win32 = ho.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DeleteObject(ho_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn draw_animated_rects(hwnd: Option<Hwnd>, id_ani: i32, lprc_from: &Rect, lprc_to: &Rect) -> Result<BOOL> {
    let hwnd_win32 = hwnd.map_or(0, Hwnd::into_raw);
    let idAni_win32 = id_ani;
    // SAFETY: type is a thin type
    let lprcFrom_win32 = unsafe { &*(lprc_from as *const _ as *const _) };
    // SAFETY: type is a thin type
    let lprcTo_win32 = unsafe { &*(lprc_to as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DrawAnimatedRects(hwnd_win32, idAni_win32, lprcFrom_win32, lprcTo_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn draw_caption(hwnd: Hwnd, hdc: Hdc, lprect: &Rect, flags: u32) -> Result<BOOL> {
    let hwnd_win32 = hwnd.into_raw();
    let hdc_win32 = hdc.into_raw();
    // SAFETY: type is a thin type
    let lprect_win32 = unsafe { &*(lprect as *const _ as *const _) };
    let flags_win32 = flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DrawCaption(hwnd_win32, hdc_win32, lprect_win32, flags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn draw_edge(hdc: Hdc, qrc: Rect, edge: u32, grf_flags: u32) -> Result<(BOOL, Rect)> {
    let hdc_win32 = hdc.into_raw();
    let mut qrc_win32 = qrc.to_win32();
    let edge_win32 = edge;
    let grfFlags_win32 = grf_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DrawEdge(hdc_win32, &mut qrc_win32, edge_win32, grfFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let qrc = unsafe { Rect::from_win32(qrc_win32) };
    Ok((real_return_value,qrc))
}
#[inline]
pub fn draw_escape(hdc: Hdc, i_escape: i32, cj_in: i32, lp_in: Option<&CStr>) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let iEscape_win32 = i_escape;
    let cjIn_win32 = cj_in;
    let lpIn_win32 = lp_in.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DrawEscape(hdc_win32, iEscape_win32, cjIn_win32, lpIn_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn draw_focus_rect(h_dc: Hdc, lprc: &Rect) -> Result<BOOL> {
    let hDC_win32 = h_dc.into_raw();
    // SAFETY: type is a thin type
    let lprc_win32 = unsafe { &*(lprc as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DrawFocusRect(hDC_win32, lprc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn draw_frame_control(param0: Hdc, param1: Rect, param2: u32, param3: u32) -> Result<(BOOL, Rect)> {
    let param0_win32 = param0.into_raw();
    let mut param1_win32 = param1.to_win32();
    let param2_win32 = param2;
    let param3_win32 = param3;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DrawFrameControl(param0_win32, &mut param1_win32, param2_win32, param3_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let param1 = unsafe { Rect::from_win32(param1_win32) };
    Ok((real_return_value,param1))
}
#[inline]
pub fn draw_state_a<Drawstateproc: FnMut(Hdc, Lparam, i32, i32) -> BOOL>(hdc: Hdc, hbr_fore: Option<Hbrush>, qfn_call_back: Option<Drawstateproc>, l_data: Lparam, x: i32, y: i32, cx: i32, cy: i32, u_flags: u32) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let hbrFore_win32 = hbr_fore.map_or(0, Hbrush::into_raw);
    unsafe extern "system" fn drawstateproc_impl<Drawstateproc>(param0: HDC, param1: LPARAM, param2: WPARAM, param3: i32, param4: i32) -> BOOL {
        abort_on_panic(move || {
            let input0 = unsafe { Hdc::new(param0) };
            let input1 = unsafe { Lparam::from_inner(param1) };
            let input3 = param3;
            let input4 = param4;
            let closure = unsafe {
                &mut *(param2 as usize as *mut Drawstateproc)
            };
            let return_value = (closure)(input0, input1, input3, input4);
            let real_return_value = return_value;
            real_return_value
        })
    }
    let qfnCallBack_win32 = Some(drawstateproc_impl::<Drawstateproc>);
    let mut qfn_call_back = qfn_call_back;
    let wData_win32 = unsafe { Wparam::from_ptr((&mut qfn_call_back) as *mut _ as *mut _) };
    let lData_win32 = l_data.into_inner();
    let x_win32 = x;
    let y_win32 = y;
    let cx_win32 = cx;
    let cy_win32 = cy;
    let uFlags_win32 = u_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DrawStateA(hdc_win32, hbrFore_win32, qfnCallBack_win32, lData_win32, wData_win32, x_win32, y_win32, cx_win32, cy_win32, uFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn draw_state_w<Drawstateproc: FnMut(Hdc, Lparam, i32, i32) -> BOOL>(hdc: Hdc, hbr_fore: Option<Hbrush>, qfn_call_back: Option<Drawstateproc>, l_data: Lparam, x: i32, y: i32, cx: i32, cy: i32, u_flags: u32) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let hbrFore_win32 = hbr_fore.map_or(0, Hbrush::into_raw);
    unsafe extern "system" fn drawstateproc_impl<Drawstateproc>(param0: HDC, param1: LPARAM, param2: WPARAM, param3: i32, param4: i32) -> BOOL {
        abort_on_panic(move || {
            let input0 = unsafe { Hdc::new(param0) };
            let input1 = unsafe { Lparam::from_inner(param1) };
            let input3 = param3;
            let input4 = param4;
            let closure = unsafe {
                &mut *(param2 as usize as *mut Drawstateproc)
            };
            let return_value = (closure)(input0, input1, input3, input4);
            let real_return_value = return_value;
            real_return_value
        })
    }
    let qfnCallBack_win32 = Some(drawstateproc_impl::<Drawstateproc>);
    let mut qfn_call_back = qfn_call_back;
    let wData_win32 = unsafe { Wparam::from_ptr((&mut qfn_call_back) as *mut _ as *mut _) };
    let lData_win32 = l_data.into_inner();
    let x_win32 = x;
    let y_win32 = y;
    let cx_win32 = cx;
    let cy_win32 = cy;
    let uFlags_win32 = u_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DrawStateW(hdc_win32, hbrFore_win32, qfnCallBack_win32, lData_win32, wData_win32, x_win32, y_win32, cx_win32, cy_win32, uFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn draw_text_a(hdc: Hdc, lpch_text: &CStr, cch_text: i32, lprc: Rect, format: u32) -> Result<(i32, Rect)> {
    let hdc_win32 = hdc.into_raw();
    let lpchText_win32 = lpch_text.as_ptr() as _;
    let cchText_win32 = cch_text;
    let mut lprc_win32 = lprc.to_win32();
    let format_win32 = format;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DrawTextA(hdc_win32, lpchText_win32, cchText_win32, &mut lprc_win32, format_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lprc = unsafe { Rect::from_win32(lprc_win32) };
    Ok((real_return_value,lprc))
}
#[inline]
pub fn draw_text_ex_a(hdc: Hdc, lpch_text: &CStr, cch_text: i32, lprc: Rect, format: u32, lpdtp: Option<&Drawtextparams>) -> Result<(i32, CString, Rect)> {
    let hdc_win32 = hdc.into_raw();
    let mut lpchText_win32 = lpch_text.as_ptr() as _;
    let cchText_win32 = cch_text;
    let mut lprc_win32 = lprc.to_win32();
    let format_win32 = format;
    let temp34 = lpdtp.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
    let lpdtp_win32 = &temp34;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DrawTextExA(hdc_win32, &mut lpchText_win32, cchText_win32, &mut lprc_win32, format_win32, lpdtp_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lprc = unsafe { Rect::from_win32(lprc_win32) };
    lpchText_win32.truncate(return_value as usize);
    let lpch_text = unsafe { CString::from_vec_unchecked(lpchText_win32) };
    Ok((real_return_value,lpch_text, lprc))
}
#[inline]
pub fn draw_text_ex_w(hdc: Hdc, lpch_text: &OsStr, cch_text: i32, lprc: Rect, format: u32, lpdtp: Option<&Drawtextparams>) -> Result<(i32, OsString, Rect)> {
    let hdc_win32 = hdc.into_raw();
    let mut temp35: Vec<u16> = lpch_text.encode_wide().collect();
    temp35.push(0);
    let mut lpchText_win32 = temp35.as_ptr() as _;
    let cchText_win32 = cch_text;
    let mut lprc_win32 = lprc.to_win32();
    let format_win32 = format;
    let temp36 = lpdtp.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
    let lpdtp_win32 = &temp36;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DrawTextExW(hdc_win32, &mut lpchText_win32, cchText_win32, &mut lprc_win32, format_win32, lpdtp_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lprc = unsafe { Rect::from_win32(lprc_win32) };
    lpchText_win32.truncate(return_value as usize);
    let lpch_text = OsString::from_wide(&lpchText_win32);
    Ok((real_return_value,lpch_text, lprc))
}
#[inline]
pub fn draw_text_w(hdc: Hdc, lpch_text: &OsStr, cch_text: i32, lprc: Rect, format: u32) -> Result<(i32, Rect)> {
    let hdc_win32 = hdc.into_raw();
    let mut temp37: Vec<u16> = lpch_text.encode_wide().collect();
    temp37.push(0);
    let lpchText_win32 = temp37.as_ptr() as _;
    let cchText_win32 = cch_text;
    let mut lprc_win32 = lprc.to_win32();
    let format_win32 = format;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::DrawTextW(hdc_win32, lpchText_win32, cchText_win32, &mut lprc_win32, format_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lprc = unsafe { Rect::from_win32(lprc_win32) };
    Ok((real_return_value,lprc))
}
#[inline]
pub fn ellipse(hdc: Hdc, left: i32, top: i32, right: i32, bottom: i32) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let left_win32 = left;
    let top_win32 = top;
    let right_win32 = right;
    let bottom_win32 = bottom;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::Ellipse(hdc_win32, left_win32, top_win32, right_win32, bottom_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn end_paint(h_wnd: Hwnd, lp_paint: &Paintstruct) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    // SAFETY: type is a thin type
    let lpPaint_win32 = unsafe { &*(lp_paint as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EndPaint(hWnd_win32, lpPaint_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn end_path(hdc: Hdc) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EndPath(hdc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_display_devices_a(lp_device: Option<&CStr>, i_dev_num: u32, lp_display_device: DisplayDevicea, dw_flags: u32) -> Result<(BOOL, DisplayDevicea)> {
    let lpDevice_win32 = lp_device.map_or(ptr::null(), |v| v.as_ptr() as _);
    let iDevNum_win32 = i_dev_num;
    let mut lpDisplayDevice_win32 = lp_display_device.to_win32();
    let dwFlags_win32 = dw_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumDisplayDevicesA(lpDevice_win32, iDevNum_win32, &mut lpDisplayDevice_win32, dwFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_display_device = unsafe { DisplayDevicea::from_win32(lpDisplayDevice_win32) };
    Ok((real_return_value,lp_display_device))
}
#[inline]
pub fn enum_display_devices_w(lp_device: Option<&OsStr>, i_dev_num: u32, lp_display_device: DisplayDevicew, dw_flags: u32) -> Result<(BOOL, DisplayDevicew)> {
    let temp38 = lp_device.map(|val| {
        let mut temp38: Vec<u16> = val.encode_wide().collect();
        temp38.push(0);
        temp38
    });
    let lpDevice_win32 = temp38.map_or(ptr::null(), |v| v.as_ptr() as _);
    let iDevNum_win32 = i_dev_num;
    let mut lpDisplayDevice_win32 = lp_display_device.to_win32();
    let dwFlags_win32 = dw_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumDisplayDevicesW(lpDevice_win32, iDevNum_win32, &mut lpDisplayDevice_win32, dwFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_display_device = unsafe { DisplayDevicew::from_win32(lpDisplayDevice_win32) };
    Ok((real_return_value,lp_display_device))
}
#[inline]
pub fn enum_display_monitors<Monitorenumproc: FnMut(Hmonitor, Hdc, &mut Rect, ) -> BOOL>(hdc: Option<Hdc>, lprc_clip: Option<&Rect>, lpfn_enum: Monitorenumproc, ) -> Result<BOOL> {
    let hdc_win32 = hdc.map_or(0, Hdc::into_raw);
    // SAFETY: type is a thin type
    let lprcClip_win32 = lprc_clip.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    unsafe extern "system" fn monitorenumproc_impl<Monitorenumproc>(param0: HMONITOR, param1: HDC, param2: *mut windows_sys::Win32::Foundation::RECT, param3: LPARAM) -> BOOL {
        abort_on_panic(move || {
            let input0 = unsafe { Hmonitor::new(param0) };
            let input1 = unsafe { Hdc::new(param1) };
            let input2 = unsafe { &mut *(param2 as *mut _) };
            let closure = unsafe {
                &mut *(param3 as usize as *mut Monitorenumproc)
            };
            let return_value = (closure)(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpfnEnum_win32 = Some(monitorenumproc_impl::<Monitorenumproc>);
    let mut lpfn_enum = lpfn_enum;
    let dwData_win32 = unsafe { Lparam::from_ptr((&mut lpfn_enum) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumDisplayMonitors(hdc_win32, lprcClip_win32, lpfnEnum_win32, dwData_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_display_settings_a(lpsz_device_name: Option<&CStr>, i_mode_num: u32, lp_dev_mode: Devmodea) -> Result<(BOOL, Devmodea)> {
    let lpszDeviceName_win32 = lpsz_device_name.map_or(ptr::null(), |v| v.as_ptr() as _);
    let iModeNum_win32 = i_mode_num;
    let mut lpDevMode_win32 = lp_dev_mode.to_win32();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumDisplaySettingsA(lpszDeviceName_win32, iModeNum_win32, &mut lpDevMode_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_dev_mode = unsafe { Devmodea::from_win32(lpDevMode_win32) };
    Ok((real_return_value,lp_dev_mode))
}
#[inline]
pub fn enum_display_settings_ex_a(lpsz_device_name: Option<&CStr>, i_mode_num: u32, lp_dev_mode: Devmodea, dw_flags: u32) -> Result<(BOOL, Devmodea)> {
    let lpszDeviceName_win32 = lpsz_device_name.map_or(ptr::null(), |v| v.as_ptr() as _);
    let iModeNum_win32 = i_mode_num;
    let mut lpDevMode_win32 = lp_dev_mode.to_win32();
    let dwFlags_win32 = dw_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumDisplaySettingsExA(lpszDeviceName_win32, iModeNum_win32, &mut lpDevMode_win32, dwFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_dev_mode = unsafe { Devmodea::from_win32(lpDevMode_win32) };
    Ok((real_return_value,lp_dev_mode))
}
#[inline]
pub fn enum_display_settings_ex_w(lpsz_device_name: Option<&OsStr>, i_mode_num: u32, lp_dev_mode: Devmodew, dw_flags: u32) -> Result<(BOOL, Devmodew)> {
    let temp39 = lpsz_device_name.map(|val| {
        let mut temp39: Vec<u16> = val.encode_wide().collect();
        temp39.push(0);
        temp39
    });
    let lpszDeviceName_win32 = temp39.map_or(ptr::null(), |v| v.as_ptr() as _);
    let iModeNum_win32 = i_mode_num;
    let mut lpDevMode_win32 = lp_dev_mode.to_win32();
    let dwFlags_win32 = dw_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumDisplaySettingsExW(lpszDeviceName_win32, iModeNum_win32, &mut lpDevMode_win32, dwFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_dev_mode = unsafe { Devmodew::from_win32(lpDevMode_win32) };
    Ok((real_return_value,lp_dev_mode))
}
#[inline]
pub fn enum_display_settings_w(lpsz_device_name: Option<&OsStr>, i_mode_num: u32, lp_dev_mode: Devmodew) -> Result<(BOOL, Devmodew)> {
    let temp40 = lpsz_device_name.map(|val| {
        let mut temp40: Vec<u16> = val.encode_wide().collect();
        temp40.push(0);
        temp40
    });
    let lpszDeviceName_win32 = temp40.map_or(ptr::null(), |v| v.as_ptr() as _);
    let iModeNum_win32 = i_mode_num;
    let mut lpDevMode_win32 = lp_dev_mode.to_win32();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumDisplaySettingsW(lpszDeviceName_win32, iModeNum_win32, &mut lpDevMode_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_dev_mode = unsafe { Devmodew::from_win32(lpDevMode_win32) };
    Ok((real_return_value,lp_dev_mode))
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn enum_enh_meta_file(hdc: Option<Hdc>, hmf: Henhmetafile, proc: Option<unsafe extern "system" fn(HDC, *const windows_sys::Win32::Graphics::Gdi::HANDLETABLE, *const windows_sys::Win32::Graphics::Gdi::ENHMETARECORD, i32, LPARAM) -> i32>, param3: Option<&todo_void>, lp_rect: Option<&Rect>) -> Result<BOOL> {
//      let hdc_win32 = hdc.map_or(0, Hdc::into_raw);
//      let hmf_win32 = hmf.into_raw();
//      let proc_win32 = proc;
//      // SAFETY: type is a thin type
//      let param3_win32 = param3.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      // SAFETY: type is a thin type
//      let lpRect_win32 = lp_rect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumEnhMetaFile(hdc_win32, hmf_win32, proc_win32, param3_win32, lpRect_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      Ok(real_return_value)
//  }
#[inline]
pub fn enum_font_families_a<Fontenumproca: FnMut(&Logfonta, &Textmetrica, u32, ) -> i32>(hdc: Hdc, lp_logfont: Option<&CStr>, lp_proc: Fontenumproca, ) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let lpLogfont_win32 = lp_logfont.map_or(ptr::null(), |v| v.as_ptr() as _);
    unsafe extern "system" fn fontenumproca_impl<Fontenumproca>(param0: *const windows_sys::Win32::Graphics::Gdi::LOGFONTA, param1: *const windows_sys::Win32::Graphics::Gdi::TEXTMETRICA, param2: u32, param3: LPARAM) -> i32 {
        abort_on_panic(move || {
            let input0 = unsafe { &*(param0 as *const _) };
            let input1 = unsafe { &*(param1 as *const _) };
            let input2 = param2;
            let closure = unsafe {
                &mut *(param3 as usize as *mut Fontenumproca)
            };
            let return_value = (closure)(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpProc_win32 = Some(fontenumproca_impl::<Fontenumproca>);
    let mut lp_proc = lp_proc;
    let lParam_win32 = unsafe { Lparam::from_ptr((&mut lp_proc) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumFontFamiliesA(hdc_win32, lpLogfont_win32, lpProc_win32, lParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_font_families_ex_a<Fontenumproca: FnMut(&Logfonta, &Textmetrica, u32, ) -> i32>(hdc: Hdc, lp_logfont: &Logfonta, lp_proc: Fontenumproca, dw_flags: u32) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    // SAFETY: type is a thin type
    let lpLogfont_win32 = unsafe { &*(lp_logfont as *const _ as *const _) };
    unsafe extern "system" fn fontenumproca_impl<Fontenumproca>(param0: *const windows_sys::Win32::Graphics::Gdi::LOGFONTA, param1: *const windows_sys::Win32::Graphics::Gdi::TEXTMETRICA, param2: u32, param3: LPARAM) -> i32 {
        abort_on_panic(move || {
            let input0 = unsafe { &*(param0 as *const _) };
            let input1 = unsafe { &*(param1 as *const _) };
            let input2 = param2;
            let closure = unsafe {
                &mut *(param3 as usize as *mut Fontenumproca)
            };
            let return_value = (closure)(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpProc_win32 = Some(fontenumproca_impl::<Fontenumproca>);
    let mut lp_proc = lp_proc;
    let lParam_win32 = unsafe { Lparam::from_ptr((&mut lp_proc) as *mut _ as *mut _) };
    let dwFlags_win32 = dw_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumFontFamiliesExA(hdc_win32, lpLogfont_win32, lpProc_win32, lParam_win32, dwFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_font_families_ex_w<Fontenumprocw: FnMut(&Logfontw, &Textmetricw, u32, ) -> i32>(hdc: Hdc, lp_logfont: &Logfontw, lp_proc: Fontenumprocw, dw_flags: u32) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    // SAFETY: type is a thin type
    let lpLogfont_win32 = unsafe { &*(lp_logfont as *const _ as *const _) };
    unsafe extern "system" fn fontenumprocw_impl<Fontenumprocw>(param0: *const windows_sys::Win32::Graphics::Gdi::LOGFONTW, param1: *const windows_sys::Win32::Graphics::Gdi::TEXTMETRICW, param2: u32, param3: LPARAM) -> i32 {
        abort_on_panic(move || {
            let input0 = unsafe { &*(param0 as *const _) };
            let input1 = unsafe { &*(param1 as *const _) };
            let input2 = param2;
            let closure = unsafe {
                &mut *(param3 as usize as *mut Fontenumprocw)
            };
            let return_value = (closure)(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpProc_win32 = Some(fontenumprocw_impl::<Fontenumprocw>);
    let mut lp_proc = lp_proc;
    let lParam_win32 = unsafe { Lparam::from_ptr((&mut lp_proc) as *mut _ as *mut _) };
    let dwFlags_win32 = dw_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumFontFamiliesExW(hdc_win32, lpLogfont_win32, lpProc_win32, lParam_win32, dwFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_font_families_w<Fontenumprocw: FnMut(&Logfontw, &Textmetricw, u32, ) -> i32>(hdc: Hdc, lp_logfont: Option<&OsStr>, lp_proc: Fontenumprocw, ) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let temp41 = lp_logfont.map(|val| {
        let mut temp41: Vec<u16> = val.encode_wide().collect();
        temp41.push(0);
        temp41
    });
    let lpLogfont_win32 = temp41.map_or(ptr::null(), |v| v.as_ptr() as _);
    unsafe extern "system" fn fontenumprocw_impl<Fontenumprocw>(param0: *const windows_sys::Win32::Graphics::Gdi::LOGFONTW, param1: *const windows_sys::Win32::Graphics::Gdi::TEXTMETRICW, param2: u32, param3: LPARAM) -> i32 {
        abort_on_panic(move || {
            let input0 = unsafe { &*(param0 as *const _) };
            let input1 = unsafe { &*(param1 as *const _) };
            let input2 = param2;
            let closure = unsafe {
                &mut *(param3 as usize as *mut Fontenumprocw)
            };
            let return_value = (closure)(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpProc_win32 = Some(fontenumprocw_impl::<Fontenumprocw>);
    let mut lp_proc = lp_proc;
    let lParam_win32 = unsafe { Lparam::from_ptr((&mut lp_proc) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumFontFamiliesW(hdc_win32, lpLogfont_win32, lpProc_win32, lParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_fonts_a<Fontenumproca: FnMut(&Logfonta, &Textmetrica, u32, ) -> i32>(hdc: Hdc, lp_logfont: Option<&CStr>, lp_proc: Fontenumproca, ) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let lpLogfont_win32 = lp_logfont.map_or(ptr::null(), |v| v.as_ptr() as _);
    unsafe extern "system" fn fontenumproca_impl<Fontenumproca>(param0: *const windows_sys::Win32::Graphics::Gdi::LOGFONTA, param1: *const windows_sys::Win32::Graphics::Gdi::TEXTMETRICA, param2: u32, param3: LPARAM) -> i32 {
        abort_on_panic(move || {
            let input0 = unsafe { &*(param0 as *const _) };
            let input1 = unsafe { &*(param1 as *const _) };
            let input2 = param2;
            let closure = unsafe {
                &mut *(param3 as usize as *mut Fontenumproca)
            };
            let return_value = (closure)(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpProc_win32 = Some(fontenumproca_impl::<Fontenumproca>);
    let mut lp_proc = lp_proc;
    let lParam_win32 = unsafe { Lparam::from_ptr((&mut lp_proc) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumFontsA(hdc_win32, lpLogfont_win32, lpProc_win32, lParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_fonts_w<Fontenumprocw: FnMut(&Logfontw, &Textmetricw, u32, ) -> i32>(hdc: Hdc, lp_logfont: Option<&OsStr>, lp_proc: Fontenumprocw, ) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let temp42 = lp_logfont.map(|val| {
        let mut temp42: Vec<u16> = val.encode_wide().collect();
        temp42.push(0);
        temp42
    });
    let lpLogfont_win32 = temp42.map_or(ptr::null(), |v| v.as_ptr() as _);
    unsafe extern "system" fn fontenumprocw_impl<Fontenumprocw>(param0: *const windows_sys::Win32::Graphics::Gdi::LOGFONTW, param1: *const windows_sys::Win32::Graphics::Gdi::TEXTMETRICW, param2: u32, param3: LPARAM) -> i32 {
        abort_on_panic(move || {
            let input0 = unsafe { &*(param0 as *const _) };
            let input1 = unsafe { &*(param1 as *const _) };
            let input2 = param2;
            let closure = unsafe {
                &mut *(param3 as usize as *mut Fontenumprocw)
            };
            let return_value = (closure)(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpProc_win32 = Some(fontenumprocw_impl::<Fontenumprocw>);
    let mut lp_proc = lp_proc;
    let lParam_win32 = unsafe { Lparam::from_ptr((&mut lp_proc) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumFontsW(hdc_win32, lpLogfont_win32, lpProc_win32, lParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn enum_objects<Gobjenumproc: FnMut(&mut todo_void, ) -> i32>(hdc: Hdc, n_type: i32, lp_func: Gobjenumproc, ) -> Result<i32> {
//      let hdc_win32 = hdc.into_raw();
//      let nType_win32 = n_type;
//      unsafe extern "system" fn gobjenumproc_impl<Gobjenumproc>(param0: *mut c_void, param1: LPARAM) -> i32 {
//          abort_on_panic(move || {
//              let input0 = unsafe { &mut *(param0 as *mut _) };
//              let closure = unsafe {
//                  &mut *(param1 as usize as *mut Gobjenumproc)
//              };
//              let return_value = (closure)(input0, );
//              let real_return_value = return_value;
//              real_return_value
//          })
//      }
//      let lpFunc_win32 = Some(gobjenumproc_impl::<Gobjenumproc>);
//      let mut lp_func = lp_func;
//      let lParam_win32 = unsafe { Lparam::from_ptr((&mut lp_func) as *mut _ as *mut _) };
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EnumObjects(hdc_win32, nType_win32, lpFunc_win32, lParam_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      Ok(real_return_value)
//  }
#[inline]
pub fn equal_rect(lprc1: &Rect, lprc2: &Rect) -> BOOL {
    // SAFETY: type is a thin type
    let lprc1_win32 = unsafe { &*(lprc1 as *const _ as *const _) };
    // SAFETY: type is a thin type
    let lprc2_win32 = unsafe { &*(lprc2 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EqualRect(lprc1_win32, lprc2_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn equal_rgn(hrgn1: Hrgn, hrgn2: Hrgn) -> BOOL {
    let hrgn1_win32 = hrgn1.into_raw();
    let hrgn2_win32 = hrgn2.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::EqualRgn(hrgn1_win32, hrgn2_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn exclude_clip_rect(hdc: Hdc, left: i32, top: i32, right: i32, bottom: i32) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let left_win32 = left;
    let top_win32 = top;
    let right_win32 = right;
    let bottom_win32 = bottom;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ExcludeClipRect(hdc_win32, left_win32, top_win32, right_win32, bottom_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn exclude_update_rgn(h_dc: Hdc, h_wnd: Hwnd) -> Result<i32> {
    let hDC_win32 = h_dc.into_raw();
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ExcludeUpdateRgn(hDC_win32, hWnd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn ext_create_pen(i_pen_style: u32, c_width: u32, plbrush: &Logbrush, pstyle: Option<&[u32]>) -> Result<Hpen> {
    let iPenStyle_win32 = i_pen_style;
    let cWidth_win32 = c_width;
    // SAFETY: type is a thin type
    let plbrush_win32 = unsafe { &*(plbrush as *const _ as *const _) };
    let pstyle_win32 = pstyle.map_or(ptr::null(), |v| v.as_ptr() as _);
    let cStyle_win32 = pstyle.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ExtCreatePen(iPenStyle_win32, cWidth_win32, plbrush_win32, cStyle_win32, pstyle_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hpen::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn ext_create_region(lpx: Option<&Xform>, lp_data: &[Rgndata]) -> Result<Hrgn> {
    // SAFETY: type is a thin type
    let lpx_win32 = lpx.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let lpData_win32 = lp_data.as_ptr() as _;
    let nCount_win32 = lp_data.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ExtCreateRegion(lpx_win32, nCount_win32, lpData_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hrgn::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn ext_flood_fill(hdc: Hdc, x: i32, y: i32, color: u32, r#type: u32) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let color_win32 = color;
    let r#type_win32 = r#type;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ExtFloodFill(hdc_win32, x_win32, y_win32, color_win32, r#type_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn ext_select_clip_rgn(hdc: Hdc, hrgn: Option<Hrgn>, mode: i32) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let hrgn_win32 = hrgn.map_or(0, Hrgn::into_raw);
    let mode_win32 = mode;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ExtSelectClipRgn(hdc_win32, hrgn_win32, mode_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn ext_text_out_a(hdc: Hdc, x: i32, y: i32, options: u32, lprect: Option<&Rect>, lp_string: Option<&CStr>, lp_dx: Option<&[i32]>) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let options_win32 = options;
    // SAFETY: type is a thin type
    let lprect_win32 = lprect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let lpString_win32 = lp_string.map_or(ptr::null(), |v| v.as_ptr() as _);
    let lpDx_win32 = lp_dx.map_or(ptr::null(), |v| v.as_ptr() as _);
    let c_win32 = lp_dx.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ExtTextOutA(hdc_win32, x_win32, y_win32, options_win32, lprect_win32, lpString_win32, c_win32, lpDx_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn ext_text_out_w(hdc: Hdc, x: i32, y: i32, options: u32, lprect: Option<&Rect>, lp_string: Option<&OsStr>, lp_dx: Option<&[i32]>) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let options_win32 = options;
    // SAFETY: type is a thin type
    let lprect_win32 = lprect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let temp43 = lp_string.map(|val| {
        let mut temp43: Vec<u16> = val.encode_wide().collect();
        temp43.push(0);
        temp43
    });
    let lpString_win32 = temp43.map_or(ptr::null(), |v| v.as_ptr() as _);
    let lpDx_win32 = lp_dx.map_or(ptr::null(), |v| v.as_ptr() as _);
    let c_win32 = lp_dx.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ExtTextOutW(hdc_win32, x_win32, y_win32, options_win32, lprect_win32, lpString_win32, c_win32, lpDx_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn fill_path(hdc: Hdc) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::FillPath(hdc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn fill_rect(h_dc: Hdc, lprc: &Rect, hbr: Hbrush) -> Result<i32> {
    let hDC_win32 = h_dc.into_raw();
    // SAFETY: type is a thin type
    let lprc_win32 = unsafe { &*(lprc as *const _ as *const _) };
    let hbr_win32 = hbr.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::FillRect(hDC_win32, lprc_win32, hbr_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn fill_rgn(hdc: Hdc, hrgn: Hrgn, hbr: Hbrush) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let hrgn_win32 = hrgn.into_raw();
    let hbr_win32 = hbr.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::FillRgn(hdc_win32, hrgn_win32, hbr_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn fix_brush_org_ex(hdc: Hdc, x: i32, y: i32, ptl: Option<&Point>) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    // SAFETY: type is a thin type
    let ptl_win32 = ptl.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::FixBrushOrgEx(hdc_win32, x_win32, y_win32, ptl_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn flatten_path(hdc: Hdc) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::FlattenPath(hdc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn flood_fill(hdc: Hdc, x: i32, y: i32, color: u32) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let color_win32 = color;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::FloodFill(hdc_win32, x_win32, y_win32, color_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn frame_rect(h_dc: Hdc, lprc: &Rect, hbr: Hbrush) -> Result<i32> {
    let hDC_win32 = h_dc.into_raw();
    // SAFETY: type is a thin type
    let lprc_win32 = unsafe { &*(lprc as *const _ as *const _) };
    let hbr_win32 = hbr.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::FrameRect(hDC_win32, lprc_win32, hbr_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn frame_rgn(hdc: Hdc, hrgn: Hrgn, hbr: Hbrush, w: i32, h: i32) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let hrgn_win32 = hrgn.into_raw();
    let hbr_win32 = hbr.into_raw();
    let w_win32 = w;
    let h_win32 = h;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::FrameRgn(hdc_win32, hrgn_win32, hbr_win32, w_win32, h_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn gdi_alpha_blend(hdc_dest: Hdc, xorigin_dest: i32, yorigin_dest: i32, w_dest: i32, h_dest: i32, hdc_src: Hdc, xorigin_src: i32, yorigin_src: i32, w_src: i32, h_src: i32, ftn: Blendfunction) -> Result<BOOL> {
    let hdcDest_win32 = hdc_dest.into_raw();
    let xoriginDest_win32 = xorigin_dest;
    let yoriginDest_win32 = yorigin_dest;
    let wDest_win32 = w_dest;
    let hDest_win32 = h_dest;
    let hdcSrc_win32 = hdc_src.into_raw();
    let xoriginSrc_win32 = xorigin_src;
    let yoriginSrc_win32 = yorigin_src;
    let wSrc_win32 = w_src;
    let hSrc_win32 = h_src;
    let ftn_win32 = ftn.to_win32();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GdiAlphaBlend(hdcDest_win32, xoriginDest_win32, yoriginDest_win32, wDest_win32, hDest_win32, hdcSrc_win32, xoriginSrc_win32, yoriginSrc_win32, wSrc_win32, hSrc_win32, ftn_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn gdi_comment(hdc: Hdc, lp_data: &[u8]) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let lpData_win32 = lp_data.as_ptr() as _;
    let nSize_win32 = lp_data.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GdiComment(hdc_win32, nSize_win32, lpData_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn gdi_flush() -> Result<BOOL> {
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GdiFlush() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn gdi_get_batch_limit() -> u32 {
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GdiGetBatchLimit() };
    let real_return_value = return_value;
    real_return_value
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn gdi_gradient_fill(hdc: Hdc, p_vertex: &[Trivertex], p_mesh: &[todo_void], ul_mode: u32) -> Result<BOOL> {
//      let hdc_win32 = hdc.into_raw();
//      let pVertex_win32 = p_vertex.as_ptr() as _;
//      let nVertex_win32 = p_vertex.len() as _;
//      let pMesh_win32 = p_mesh.as_ptr() as _;
//      let nCount_win32 = p_mesh.len() as _;
//      let ulMode_win32 = ul_mode;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GdiGradientFill(hdc_win32, pVertex_win32, nVertex_win32, pMesh_win32, nCount_win32, ulMode_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      Ok(real_return_value)
//  }
#[inline]
pub fn gdi_set_batch_limit(dw: u32) -> u32 {
    let dw_win32 = dw;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GdiSetBatchLimit(dw_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn gdi_transparent_blt(hdc_dest: Hdc, xorigin_dest: i32, yorigin_dest: i32, w_dest: i32, h_dest: i32, hdc_src: Hdc, xorigin_src: i32, yorigin_src: i32, w_src: i32, h_src: i32, cr_transparent: u32) -> Result<BOOL> {
    let hdcDest_win32 = hdc_dest.into_raw();
    let xoriginDest_win32 = xorigin_dest;
    let yoriginDest_win32 = yorigin_dest;
    let wDest_win32 = w_dest;
    let hDest_win32 = h_dest;
    let hdcSrc_win32 = hdc_src.into_raw();
    let xoriginSrc_win32 = xorigin_src;
    let yoriginSrc_win32 = yorigin_src;
    let wSrc_win32 = w_src;
    let hSrc_win32 = h_src;
    let crTransparent_win32 = cr_transparent;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GdiTransparentBlt(hdcDest_win32, xoriginDest_win32, yoriginDest_win32, wDest_win32, hDest_win32, hdcSrc_win32, xoriginSrc_win32, yoriginSrc_win32, wSrc_win32, hSrc_win32, crTransparent_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_arc_direction(hdc: Hdc) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetArcDirection(hdc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_aspect_ratio_filter_ex(hdc: Hdc, ) -> Result<(BOOL, Size)> {
    let mut lpsize = mem::MaybeUninit::zeroed();
    let lpsize_win32 = lpsize.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetAspectRatioFilterEx(hdc_win32, lpsize_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpsize = unsafe { Size::from_win32(unsafe { lpsize.assume_init() }) };
    Ok((real_return_value,lpsize))
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn get_bitmap_bits(hbit: Hbitmap, cb: i32, ) -> Result<(i32, todo_void_ret)> {
//      let mut lpv_bits = mem::MaybeUninit::zeroed();
//      let lpvBits_win32 = lpv_bits.as_mut_ptr();
//      let hbit_win32 = hbit.into_raw();
//      let cb_win32 = cb;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetBitmapBits(hbit_win32, cb_win32, lpvBits_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      let lpv_bits = todo_void;
//      Ok((real_return_value,lpv_bits))
//  }
#[inline]
pub fn get_bitmap_dimension_ex(hbit: Hbitmap, ) -> Result<(BOOL, Size)> {
    let mut lpsize = mem::MaybeUninit::zeroed();
    let lpsize_win32 = lpsize.as_mut_ptr();
    let hbit_win32 = hbit.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetBitmapDimensionEx(hbit_win32, lpsize_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpsize = unsafe { Size::from_win32(unsafe { lpsize.assume_init() }) };
    Ok((real_return_value,lpsize))
}
#[inline]
pub fn get_bk_color(hdc: Hdc) -> u32 {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetBkColor(hdc_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_bk_mode(hdc: Hdc) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetBkMode(hdc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_bounds_rect(hdc: Hdc, flags: u32) -> (u32, Rect) {
    let mut lprect = mem::MaybeUninit::zeroed();
    let lprect_win32 = lprect.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let flags_win32 = flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetBoundsRect(hdc_win32, lprect_win32, flags_win32) };
    let real_return_value = return_value;
    let lprect = unsafe { Rect::from_win32(unsafe { lprect.assume_init() }) };
    (real_return_value,lprect)
}
#[inline]
pub fn get_brush_org_ex(hdc: Hdc, ) -> Result<(BOOL, Point)> {
    let mut lppt = mem::MaybeUninit::zeroed();
    let lppt_win32 = lppt.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetBrushOrgEx(hdc_win32, lppt_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lppt = unsafe { Point::from_win32(unsafe { lppt.assume_init() }) };
    Ok((real_return_value,lppt))
}
#[inline]
pub fn get_clip_box(hdc: Hdc, ) -> Result<(i32, Rect)> {
    let mut lprect = mem::MaybeUninit::zeroed();
    let lprect_win32 = lprect.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetClipBox(hdc_win32, lprect_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lprect = unsafe { Rect::from_win32(unsafe { lprect.assume_init() }) };
    Ok((real_return_value,lprect))
}
#[inline]
pub fn get_clip_rgn(hdc: Hdc, hrgn: Hrgn) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let hrgn_win32 = hrgn.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetClipRgn(hdc_win32, hrgn_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_color_adjustment(hdc: Hdc, ) -> Result<(BOOL, Coloradjustment)> {
    let mut lpca = mem::MaybeUninit::zeroed();
    let lpca_win32 = lpca.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetColorAdjustment(hdc_win32, lpca_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpca = unsafe { Coloradjustment::from_win32(unsafe { lpca.assume_init() }) };
    Ok((real_return_value,lpca))
}
#[inline]
pub fn get_current_object(hdc: Hdc, r#type: i32) -> Result<Hgdiobj> {
    let hdc_win32 = hdc.into_raw();
    let r#type_win32 = r#type;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetCurrentObject(hdc_win32, r#type_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hgdiobj::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_current_position_ex(hdc: Hdc, ) -> Result<(BOOL, Point)> {
    let mut lppt = mem::MaybeUninit::zeroed();
    let lppt_win32 = lppt.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetCurrentPositionEx(hdc_win32, lppt_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lppt = unsafe { Point::from_win32(unsafe { lppt.assume_init() }) };
    Ok((real_return_value,lppt))
}
#[inline]
pub fn get_dc(h_wnd: Option<Hwnd>) -> Result<Hdc> {
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetDC(hWnd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hdc::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_dc_brush_color(hdc: Hdc) -> u32 {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetDCBrushColor(hdc_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_dc_ex(h_wnd: Option<Hwnd>, hrgn_clip: Option<Hrgn>, flags: u32) -> Result<Hdc> {
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let hrgnClip_win32 = hrgn_clip.map_or(0, Hrgn::into_raw);
    let flags_win32 = flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetDCEx(hWnd_win32, hrgnClip_win32, flags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hdc::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_dc_org_ex(hdc: Hdc, ) -> Result<(BOOL, Point)> {
    let mut lppt = mem::MaybeUninit::zeroed();
    let lppt_win32 = lppt.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetDCOrgEx(hdc_win32, lppt_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lppt = unsafe { Point::from_win32(unsafe { lppt.assume_init() }) };
    Ok((real_return_value,lppt))
}
#[inline]
pub fn get_dc_pen_color(hdc: Hdc) -> u32 {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetDCPenColor(hdc_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_dib_color_table(hdc: Hdc, i_start: u32, c_entries: u32, ) -> (u32, Rgbquad) {
    let mut prgbq = mem::MaybeUninit::zeroed();
    let prgbq_win32 = prgbq.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let iStart_win32 = i_start;
    let cEntries_win32 = c_entries;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetDIBColorTable(hdc_win32, iStart_win32, cEntries_win32, prgbq_win32) };
    let real_return_value = return_value;
    let prgbq = unsafe { Rgbquad::from_win32(unsafe { prgbq.assume_init() }) };
    (real_return_value,prgbq)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn get_di_bits(hdc: Hdc, hbm: Hbitmap, start: u32, c_lines: u32, lpbmi: Bitmapinfo, usage: u32) -> Result<(i32, todo_void_ret, Bitmapinfo)> {
//      let mut lpv_bits = mem::MaybeUninit::zeroed();
//      let lpvBits_win32 = lpv_bits.as_mut_ptr();
//      let hdc_win32 = hdc.into_raw();
//      let hbm_win32 = hbm.into_raw();
//      let start_win32 = start;
//      let cLines_win32 = c_lines;
//      let mut lpbmi_win32 = lpbmi.to_win32();
//      let usage_win32 = usage;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetDIBits(hdc_win32, hbm_win32, start_win32, cLines_win32, lpvBits_win32, &mut lpbmi_win32, usage_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      let lpbmi = unsafe { Bitmapinfo::from_win32(lpbmi_win32) };
//      let lpv_bits = todo_void;
//      Ok((real_return_value,lpv_bits, lpbmi))
//  }
#[inline]
pub fn get_device_caps(hdc: Option<Hdc>, index: u32) -> Result<i32> {
    let hdc_win32 = hdc.map_or(0, Hdc::into_raw);
    let index_win32 = index;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetDeviceCaps(hdc_win32, index_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_enh_meta_file_a(lp_name: &CStr) -> Result<Henhmetafile> {
    let lpName_win32 = lp_name.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetEnhMetaFileA(lpName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Henhmetafile::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_enh_meta_file_bits(h_emf: Henhmetafile, n_size: u32, ) -> (u32, u8) {
    let mut lp_data = mem::MaybeUninit::zeroed();
    let lpData_win32 = lp_data.as_mut_ptr();
    let hEMF_win32 = h_emf.into_raw();
    let nSize_win32 = n_size;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetEnhMetaFileBits(hEMF_win32, nSize_win32, lpData_win32) };
    let real_return_value = return_value;
    let lp_data = unsafe { lp_data.assume_init() };
    (real_return_value,lp_data)
}
#[inline]
pub fn get_enh_meta_file_description_a(hemf: Henhmetafile, cch_buffer: u32, ) -> (u32, CString) {
    let mut lp_description = Vec::<u8>::with_capacity(cch_buffer as usize + 1);
    let lpDescription_win32 = lp_description.as_mut_ptr();
    let hemf_win32 = hemf.into_raw();
    let cchBuffer_win32 = cch_buffer;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetEnhMetaFileDescriptionA(hemf_win32, cchBuffer_win32, lpDescription_win32) };
    let real_return_value = return_value;
    lp_description.truncate(return_value as usize);
    let lp_description = unsafe { CString::from_vec_unchecked(lp_description) };
    (real_return_value,lp_description)
}
#[inline]
pub fn get_enh_meta_file_description_w(hemf: Henhmetafile, cch_buffer: u32, ) -> (u32, OsString) {
    let mut lp_description = Vec::<u16>::with_capacity(cch_buffer as usize + 1);
    let lpDescription_win32 = lp_description.as_mut_ptr();
    let hemf_win32 = hemf.into_raw();
    let cchBuffer_win32 = cch_buffer;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetEnhMetaFileDescriptionW(hemf_win32, cchBuffer_win32, lpDescription_win32) };
    let real_return_value = return_value;
    lp_description.truncate(return_value as usize);
    let lp_description = OsString::from_wide(&lp_description);
    (real_return_value,lp_description)
}
#[inline]
pub fn get_enh_meta_file_header(hemf: Henhmetafile, n_size: u32, ) -> (u32, Enhmetaheader) {
    let mut lp_enh_meta_header = mem::MaybeUninit::zeroed();
    let lpEnhMetaHeader_win32 = lp_enh_meta_header.as_mut_ptr();
    let hemf_win32 = hemf.into_raw();
    let nSize_win32 = n_size;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetEnhMetaFileHeader(hemf_win32, nSize_win32, lpEnhMetaHeader_win32) };
    let real_return_value = return_value;
    let lp_enh_meta_header = unsafe { Enhmetaheader::from_win32(unsafe { lp_enh_meta_header.assume_init() }) };
    (real_return_value,lp_enh_meta_header)
}
#[inline]
pub fn get_enh_meta_file_palette_entries(hemf: Henhmetafile, n_num_entries: u32, ) -> (u32, Paletteentry) {
    let mut lp_palette_entries = mem::MaybeUninit::zeroed();
    let lpPaletteEntries_win32 = lp_palette_entries.as_mut_ptr();
    let hemf_win32 = hemf.into_raw();
    let nNumEntries_win32 = n_num_entries;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetEnhMetaFilePaletteEntries(hemf_win32, nNumEntries_win32, lpPaletteEntries_win32) };
    let real_return_value = return_value;
    let lp_palette_entries = unsafe { Paletteentry::from_win32(unsafe { lp_palette_entries.assume_init() }) };
    (real_return_value,lp_palette_entries)
}
#[inline]
pub fn get_enh_meta_file_w(lp_name: &OsStr) -> Result<Henhmetafile> {
    let mut temp44: Vec<u16> = lp_name.encode_wide().collect();
    temp44.push(0);
    let lpName_win32 = temp44.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetEnhMetaFileW(lpName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Henhmetafile::new(return_value) };
    Ok(real_return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn get_font_data(hdc: Hdc, dw_table: u32, dw_offset: u32, cj_buffer: u32) -> (u32, todo_void_ret) {
//      let mut pv_buffer = mem::MaybeUninit::zeroed();
//      let pvBuffer_win32 = pv_buffer.as_mut_ptr();
//      let hdc_win32 = hdc.into_raw();
//      let dwTable_win32 = dw_table;
//      let dwOffset_win32 = dw_offset;
//      let cjBuffer_win32 = cj_buffer;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetFontData(hdc_win32, dwTable_win32, dwOffset_win32, pvBuffer_win32, cjBuffer_win32) };
//      let real_return_value = return_value;
//      let pv_buffer = todo_void;
//      (real_return_value,pv_buffer)
//  }
#[inline]
pub fn get_font_language_info(hdc: Hdc) -> u32 {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetFontLanguageInfo(hdc_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_font_unicode_ranges(hdc: Hdc, ) -> (u32, Glyphset) {
    let mut lpgs = mem::MaybeUninit::zeroed();
    let lpgs_win32 = lpgs.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetFontUnicodeRanges(hdc_win32, lpgs_win32) };
    let real_return_value = return_value;
    let lpgs = unsafe { Glyphset::from_win32(unsafe { lpgs.assume_init() }) };
    (real_return_value,lpgs)
}
#[inline]
pub fn get_glyph_indices_a(hdc: Hdc, lpstr: &CStr, c: i32, fl: u32) -> (u32, u16) {
    let mut pgi = mem::MaybeUninit::zeroed();
    let pgi_win32 = pgi.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let lpstr_win32 = lpstr.as_ptr() as _;
    let c_win32 = c;
    let fl_win32 = fl;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetGlyphIndicesA(hdc_win32, lpstr_win32, c_win32, pgi_win32, fl_win32) };
    let real_return_value = return_value;
    let pgi = unsafe { pgi.assume_init() };
    (real_return_value,pgi)
}
#[inline]
pub fn get_glyph_indices_w(hdc: Hdc, lpstr: &OsStr, c: i32, fl: u32) -> (u32, u16) {
    let mut pgi = mem::MaybeUninit::zeroed();
    let pgi_win32 = pgi.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let mut temp45: Vec<u16> = lpstr.encode_wide().collect();
    temp45.push(0);
    let lpstr_win32 = temp45.as_ptr() as _;
    let c_win32 = c;
    let fl_win32 = fl;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetGlyphIndicesW(hdc_win32, lpstr_win32, c_win32, pgi_win32, fl_win32) };
    let real_return_value = return_value;
    let pgi = unsafe { pgi.assume_init() };
    (real_return_value,pgi)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn get_glyph_outline_a(hdc: Hdc, u_char: u32, fu_format: u32, lpmat2: &[Mat2]) -> (u32, Glyphmetrics, todo_void_ret) {
//      let mut lpgm = mem::MaybeUninit::zeroed();
//      let lpgm_win32 = lpgm.as_mut_ptr();
//      let mut pv_buffer = mem::MaybeUninit::zeroed();
//      let pvBuffer_win32 = pv_buffer.as_mut_ptr();
//      let hdc_win32 = hdc.into_raw();
//      let uChar_win32 = u_char;
//      let fuFormat_win32 = fu_format;
//      let lpmat2_win32 = lpmat2.as_ptr() as _;
//      let cjBuffer_win32 = lpmat2.len() as _;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetGlyphOutlineA(hdc_win32, uChar_win32, fuFormat_win32, lpgm_win32, cjBuffer_win32, pvBuffer_win32, lpmat2_win32) };
//      let real_return_value = return_value;
//      let pv_buffer = todo_void;
//      let lpgm = unsafe { Glyphmetrics::from_win32(unsafe { lpgm.assume_init() }) };
//      (real_return_value,lpgm, pv_buffer)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn get_glyph_outline_w(hdc: Hdc, u_char: u32, fu_format: u32, lpmat2: &[Mat2]) -> (u32, Glyphmetrics, todo_void_ret) {
//      let mut lpgm = mem::MaybeUninit::zeroed();
//      let lpgm_win32 = lpgm.as_mut_ptr();
//      let mut pv_buffer = mem::MaybeUninit::zeroed();
//      let pvBuffer_win32 = pv_buffer.as_mut_ptr();
//      let hdc_win32 = hdc.into_raw();
//      let uChar_win32 = u_char;
//      let fuFormat_win32 = fu_format;
//      let lpmat2_win32 = lpmat2.as_ptr() as _;
//      let cjBuffer_win32 = lpmat2.len() as _;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetGlyphOutlineW(hdc_win32, uChar_win32, fuFormat_win32, lpgm_win32, cjBuffer_win32, pvBuffer_win32, lpmat2_win32) };
//      let real_return_value = return_value;
//      let pv_buffer = todo_void;
//      let lpgm = unsafe { Glyphmetrics::from_win32(unsafe { lpgm.assume_init() }) };
//      (real_return_value,lpgm, pv_buffer)
//  }
#[inline]
pub fn get_graphics_mode(hdc: Hdc) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetGraphicsMode(hdc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_kerning_pairs_a(hdc: Hdc, n_pairs: u32, ) -> (u32, Kerningpair) {
    let mut lp_kern_pair = mem::MaybeUninit::zeroed();
    let lpKernPair_win32 = lp_kern_pair.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let nPairs_win32 = n_pairs;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetKerningPairsA(hdc_win32, nPairs_win32, lpKernPair_win32) };
    let real_return_value = return_value;
    let lp_kern_pair = unsafe { Kerningpair::from_win32(unsafe { lp_kern_pair.assume_init() }) };
    (real_return_value,lp_kern_pair)
}
#[inline]
pub fn get_kerning_pairs_w(hdc: Hdc, n_pairs: u32, ) -> (u32, Kerningpair) {
    let mut lp_kern_pair = mem::MaybeUninit::zeroed();
    let lpKernPair_win32 = lp_kern_pair.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let nPairs_win32 = n_pairs;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetKerningPairsW(hdc_win32, nPairs_win32, lpKernPair_win32) };
    let real_return_value = return_value;
    let lp_kern_pair = unsafe { Kerningpair::from_win32(unsafe { lp_kern_pair.assume_init() }) };
    (real_return_value,lp_kern_pair)
}
#[inline]
pub fn get_layout(hdc: Hdc) -> u32 {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetLayout(hdc_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_map_mode(hdc: Hdc) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetMapMode(hdc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_meta_file_a(lp_name: &CStr) -> Result<Hmetafile> {
    let lpName_win32 = lp_name.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetMetaFileA(lpName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hmetafile::new(return_value) };
    Ok(real_return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn get_meta_file_bits_ex(h_mf: Hmetafile, cb_buffer: u32, ) -> (u32, todo_void_ret) {
//      let mut lp_data = mem::MaybeUninit::zeroed();
//      let lpData_win32 = lp_data.as_mut_ptr();
//      let hMF_win32 = h_mf.into_raw();
//      let cbBuffer_win32 = cb_buffer;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetMetaFileBitsEx(hMF_win32, cbBuffer_win32, lpData_win32) };
//      let real_return_value = return_value;
//      let lp_data = todo_void;
//      (real_return_value,lp_data)
//  }
#[inline]
pub fn get_meta_file_w(lp_name: &OsStr) -> Result<Hmetafile> {
    let mut temp46: Vec<u16> = lp_name.encode_wide().collect();
    temp46.push(0);
    let lpName_win32 = temp46.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetMetaFileW(lpName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hmetafile::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_meta_rgn(hdc: Hdc, hrgn: Hrgn) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let hrgn_win32 = hrgn.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetMetaRgn(hdc_win32, hrgn_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_miter_limit(hdc: Hdc, ) -> Result<(BOOL, f32)> {
    let mut plimit = mem::MaybeUninit::zeroed();
    let plimit_win32 = plimit.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetMiterLimit(hdc_win32, plimit_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let plimit = unsafe { plimit.assume_init() };
    Ok((real_return_value,plimit))
}
#[inline]
pub fn get_monitor_info_a(h_monitor: Hmonitor, lpmi: Monitorinfo) -> Result<(BOOL, Monitorinfo)> {
    let hMonitor_win32 = h_monitor.into_raw();
    let mut lpmi_win32 = lpmi.to_win32();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetMonitorInfoA(hMonitor_win32, &mut lpmi_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpmi = unsafe { Monitorinfo::from_win32(lpmi_win32) };
    Ok((real_return_value,lpmi))
}
#[inline]
pub fn get_monitor_info_w(h_monitor: Hmonitor, lpmi: Monitorinfo) -> Result<(BOOL, Monitorinfo)> {
    let hMonitor_win32 = h_monitor.into_raw();
    let mut lpmi_win32 = lpmi.to_win32();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetMonitorInfoW(hMonitor_win32, &mut lpmi_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpmi = unsafe { Monitorinfo::from_win32(lpmi_win32) };
    Ok((real_return_value,lpmi))
}
#[inline]
pub fn get_nearest_color(hdc: Hdc, color: u32) -> u32 {
    let hdc_win32 = hdc.into_raw();
    let color_win32 = color;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetNearestColor(hdc_win32, color_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_nearest_palette_index(h: Hpalette, color: u32) -> u32 {
    let h_win32 = h.into_raw();
    let color_win32 = color;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetNearestPaletteIndex(h_win32, color_win32) };
    let real_return_value = return_value;
    real_return_value
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn get_object_a(h: Hgdiobj, c: i32, ) -> Result<(i32, todo_void_ret)> {
//      let mut pv = mem::MaybeUninit::zeroed();
//      let pv_win32 = pv.as_mut_ptr();
//      let h_win32 = h.into_raw();
//      let c_win32 = c;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetObjectA(h_win32, c_win32, pv_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      let pv = todo_void;
//      Ok((real_return_value,pv))
//  }
#[inline]
pub fn get_object_type(h: Hgdiobj) -> u32 {
    let h_win32 = h.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetObjectType(h_win32) };
    let real_return_value = return_value;
    real_return_value
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn get_object_w(h: Hgdiobj, c: i32, ) -> Result<(i32, todo_void_ret)> {
//      let mut pv = mem::MaybeUninit::zeroed();
//      let pv_win32 = pv.as_mut_ptr();
//      let h_win32 = h.into_raw();
//      let c_win32 = c;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetObjectW(h_win32, c_win32, pv_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      let pv = todo_void;
//      Ok((real_return_value,pv))
//  }
#[inline]
pub fn get_palette_entries(hpal: Hpalette, i_start: u32, c_entries: u32, ) -> (u32, Paletteentry) {
    let mut p_pal_entries = mem::MaybeUninit::zeroed();
    let pPalEntries_win32 = p_pal_entries.as_mut_ptr();
    let hpal_win32 = hpal.into_raw();
    let iStart_win32 = i_start;
    let cEntries_win32 = c_entries;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetPaletteEntries(hpal_win32, iStart_win32, cEntries_win32, pPalEntries_win32) };
    let real_return_value = return_value;
    let p_pal_entries = unsafe { Paletteentry::from_win32(unsafe { p_pal_entries.assume_init() }) };
    (real_return_value,p_pal_entries)
}
#[inline]
pub fn get_path(hdc: Hdc, cpt: i32) -> Result<(i32, Point, u8)> {
    let mut apt = mem::MaybeUninit::zeroed();
    let apt_win32 = apt.as_mut_ptr();
    let mut aj = mem::MaybeUninit::zeroed();
    let aj_win32 = aj.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let cpt_win32 = cpt;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetPath(hdc_win32, apt_win32, aj_win32, cpt_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let aj = unsafe { aj.assume_init() };
    let apt = unsafe { Point::from_win32(unsafe { apt.assume_init() }) };
    Ok((real_return_value,apt, aj))
}
#[inline]
pub fn get_pixel(hdc: Hdc, x: i32, y: i32) -> u32 {
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetPixel(hdc_win32, x_win32, y_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_poly_fill_mode(hdc: Hdc) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetPolyFillMode(hdc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_rop2(hdc: Hdc) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetROP2(hdc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_random_rgn(hdc: Hdc, hrgn: Hrgn, i: i32) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let hrgn_win32 = hrgn.into_raw();
    let i_win32 = i;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetRandomRgn(hdc_win32, hrgn_win32, i_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_rasterizer_caps(cj_bytes: u32) -> Result<(BOOL, RasterizerStatus)> {
    let mut lpraststat = mem::MaybeUninit::zeroed();
    let lpraststat_win32 = lpraststat.as_mut_ptr();
    let cjBytes_win32 = cj_bytes;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetRasterizerCaps(lpraststat_win32, cjBytes_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpraststat = unsafe { RasterizerStatus::from_win32(unsafe { lpraststat.assume_init() }) };
    Ok((real_return_value,lpraststat))
}
#[inline]
pub fn get_region_data(hrgn: Hrgn, n_count: u32, ) -> (u32, Rgndata) {
    let mut lp_rgn_data = mem::MaybeUninit::zeroed();
    let lpRgnData_win32 = lp_rgn_data.as_mut_ptr();
    let hrgn_win32 = hrgn.into_raw();
    let nCount_win32 = n_count;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetRegionData(hrgn_win32, nCount_win32, lpRgnData_win32) };
    let real_return_value = return_value;
    let lp_rgn_data = unsafe { Rgndata::from_win32(unsafe { lp_rgn_data.assume_init() }) };
    (real_return_value,lp_rgn_data)
}
#[inline]
pub fn get_rgn_box(hrgn: Hrgn, ) -> Result<(i32, Rect)> {
    let mut lprc = mem::MaybeUninit::zeroed();
    let lprc_win32 = lprc.as_mut_ptr();
    let hrgn_win32 = hrgn.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetRgnBox(hrgn_win32, lprc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lprc = unsafe { Rect::from_win32(unsafe { lprc.assume_init() }) };
    Ok((real_return_value,lprc))
}
#[inline]
pub fn get_stock_object(i: u32) -> Result<Hgdiobj> {
    let i_win32 = i;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetStockObject(i_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hgdiobj::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_stretch_blt_mode(hdc: Hdc) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetStretchBltMode(hdc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_sys_color_brush(n_index: i32) -> Result<Hbrush> {
    let nIndex_win32 = n_index;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetSysColorBrush(nIndex_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hbrush::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_system_palette_entries(hdc: Hdc, i_start: u32, c_entries: u32, ) -> (u32, Paletteentry) {
    let mut p_pal_entries = mem::MaybeUninit::zeroed();
    let pPalEntries_win32 = p_pal_entries.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let iStart_win32 = i_start;
    let cEntries_win32 = c_entries;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetSystemPaletteEntries(hdc_win32, iStart_win32, cEntries_win32, pPalEntries_win32) };
    let real_return_value = return_value;
    let p_pal_entries = unsafe { Paletteentry::from_win32(unsafe { p_pal_entries.assume_init() }) };
    (real_return_value,p_pal_entries)
}
#[inline]
pub fn get_system_palette_use(hdc: Hdc) -> u32 {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetSystemPaletteUse(hdc_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_tabbed_text_extent_a(hdc: Hdc, lp_string: &CStr, ch_count: i32, lpn_tab_stop_positions: Option<&[i32]>) -> u32 {
    let hdc_win32 = hdc.into_raw();
    let lpString_win32 = lp_string.as_ptr() as _;
    let chCount_win32 = ch_count;
    let lpnTabStopPositions_win32 = lpn_tab_stop_positions.map_or(ptr::null(), |v| v.as_ptr() as _);
    let nTabPositions_win32 = lpn_tab_stop_positions.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTabbedTextExtentA(hdc_win32, lpString_win32, chCount_win32, nTabPositions_win32, lpnTabStopPositions_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_tabbed_text_extent_w(hdc: Hdc, lp_string: &OsStr, ch_count: i32, lpn_tab_stop_positions: Option<&[i32]>) -> u32 {
    let hdc_win32 = hdc.into_raw();
    let mut temp47: Vec<u16> = lp_string.encode_wide().collect();
    temp47.push(0);
    let lpString_win32 = temp47.as_ptr() as _;
    let chCount_win32 = ch_count;
    let lpnTabStopPositions_win32 = lpn_tab_stop_positions.map_or(ptr::null(), |v| v.as_ptr() as _);
    let nTabPositions_win32 = lpn_tab_stop_positions.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTabbedTextExtentW(hdc_win32, lpString_win32, chCount_win32, nTabPositions_win32, lpnTabStopPositions_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_text_align(hdc: Hdc) -> u32 {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextAlign(hdc_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_text_color(hdc: Hdc) -> u32 {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextColor(hdc_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_text_extent_ex_point_a(hdc: Hdc, lpsz_string: &CStr, cch_string: i32, n_max_extent: i32, ) -> Result<(BOOL, i32, i32, Size)> {
    let mut lpn_fit = mem::MaybeUninit::zeroed();
    let lpnFit_win32 = lpn_fit.as_mut_ptr();
    let mut lpn_dx = mem::MaybeUninit::zeroed();
    let lpnDx_win32 = lpn_dx.as_mut_ptr();
    let mut lp_size = mem::MaybeUninit::zeroed();
    let lpSize_win32 = lp_size.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let lpszString_win32 = lpsz_string.as_ptr() as _;
    let cchString_win32 = cch_string;
    let nMaxExtent_win32 = n_max_extent;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextExtentExPointA(hdc_win32, lpszString_win32, cchString_win32, nMaxExtent_win32, lpnFit_win32, lpnDx_win32, lpSize_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_size = unsafe { Size::from_win32(unsafe { lp_size.assume_init() }) };
    let lpn_dx = unsafe { lpn_dx.assume_init() };
    let lpn_fit = unsafe { lpn_fit.assume_init() };
    Ok((real_return_value,lpn_fit, lpn_dx, lp_size))
}
#[inline]
pub fn get_text_extent_ex_point_i(hdc: Hdc, lpwsz_string: &[u16], cwch_string: i32, ) -> Result<(BOOL, i32, i32, Size)> {
    let mut lpn_fit = mem::MaybeUninit::zeroed();
    let lpnFit_win32 = lpn_fit.as_mut_ptr();
    let mut lpn_dx = mem::MaybeUninit::zeroed();
    let lpnDx_win32 = lpn_dx.as_mut_ptr();
    let mut lp_size = mem::MaybeUninit::zeroed();
    let lpSize_win32 = lp_size.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let lpwszString_win32 = lpwsz_string.as_ptr() as _;
    let nMaxExtent_win32 = lpwsz_string.len() as _;
    let cwchString_win32 = cwch_string;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextExtentExPointI(hdc_win32, lpwszString_win32, cwchString_win32, nMaxExtent_win32, lpnFit_win32, lpnDx_win32, lpSize_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_size = unsafe { Size::from_win32(unsafe { lp_size.assume_init() }) };
    let lpn_dx = unsafe { lpn_dx.assume_init() };
    let lpn_fit = unsafe { lpn_fit.assume_init() };
    Ok((real_return_value,lpn_fit, lpn_dx, lp_size))
}
#[inline]
pub fn get_text_extent_ex_point_w(hdc: Hdc, lpsz_string: &OsStr, cch_string: i32, n_max_extent: i32, ) -> Result<(BOOL, i32, i32, Size)> {
    let mut lpn_fit = mem::MaybeUninit::zeroed();
    let lpnFit_win32 = lpn_fit.as_mut_ptr();
    let mut lpn_dx = mem::MaybeUninit::zeroed();
    let lpnDx_win32 = lpn_dx.as_mut_ptr();
    let mut lp_size = mem::MaybeUninit::zeroed();
    let lpSize_win32 = lp_size.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let mut temp48: Vec<u16> = lpsz_string.encode_wide().collect();
    temp48.push(0);
    let lpszString_win32 = temp48.as_ptr() as _;
    let cchString_win32 = cch_string;
    let nMaxExtent_win32 = n_max_extent;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextExtentExPointW(hdc_win32, lpszString_win32, cchString_win32, nMaxExtent_win32, lpnFit_win32, lpnDx_win32, lpSize_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_size = unsafe { Size::from_win32(unsafe { lp_size.assume_init() }) };
    let lpn_dx = unsafe { lpn_dx.assume_init() };
    let lpn_fit = unsafe { lpn_fit.assume_init() };
    Ok((real_return_value,lpn_fit, lpn_dx, lp_size))
}
#[inline]
pub fn get_text_extent_point32_a(hdc: Hdc, lp_string: &CStr, c: i32, ) -> Result<(BOOL, Size)> {
    let mut psizl = mem::MaybeUninit::zeroed();
    let psizl_win32 = psizl.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let lpString_win32 = lp_string.as_ptr() as _;
    let c_win32 = c;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextExtentPoint32A(hdc_win32, lpString_win32, c_win32, psizl_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let psizl = unsafe { Size::from_win32(unsafe { psizl.assume_init() }) };
    Ok((real_return_value,psizl))
}
#[inline]
pub fn get_text_extent_point32_w(hdc: Hdc, lp_string: &OsStr, c: i32, ) -> Result<(BOOL, Size)> {
    let mut psizl = mem::MaybeUninit::zeroed();
    let psizl_win32 = psizl.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let mut temp49: Vec<u16> = lp_string.encode_wide().collect();
    temp49.push(0);
    let lpString_win32 = temp49.as_ptr() as _;
    let c_win32 = c;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextExtentPoint32W(hdc_win32, lpString_win32, c_win32, psizl_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let psizl = unsafe { Size::from_win32(unsafe { psizl.assume_init() }) };
    Ok((real_return_value,psizl))
}
#[inline]
pub fn get_text_extent_point_a(hdc: Hdc, lp_string: &CStr, c: i32, ) -> Result<(BOOL, Size)> {
    let mut lpsz = mem::MaybeUninit::zeroed();
    let lpsz_win32 = lpsz.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let lpString_win32 = lp_string.as_ptr() as _;
    let c_win32 = c;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextExtentPointA(hdc_win32, lpString_win32, c_win32, lpsz_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpsz = unsafe { Size::from_win32(unsafe { lpsz.assume_init() }) };
    Ok((real_return_value,lpsz))
}
#[inline]
pub fn get_text_extent_point_i(hdc: Hdc, pgi_in: &[u16], ) -> Result<(BOOL, Size)> {
    let mut psize = mem::MaybeUninit::zeroed();
    let psize_win32 = psize.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let pgiIn_win32 = pgi_in.as_ptr() as _;
    let cgi_win32 = pgi_in.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextExtentPointI(hdc_win32, pgiIn_win32, cgi_win32, psize_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let psize = unsafe { Size::from_win32(unsafe { psize.assume_init() }) };
    Ok((real_return_value,psize))
}
#[inline]
pub fn get_text_extent_point_w(hdc: Hdc, lp_string: &OsStr, c: i32, ) -> Result<(BOOL, Size)> {
    let mut lpsz = mem::MaybeUninit::zeroed();
    let lpsz_win32 = lpsz.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let mut temp50: Vec<u16> = lp_string.encode_wide().collect();
    temp50.push(0);
    let lpString_win32 = temp50.as_ptr() as _;
    let c_win32 = c;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextExtentPointW(hdc_win32, lpString_win32, c_win32, lpsz_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpsz = unsafe { Size::from_win32(unsafe { lpsz.assume_init() }) };
    Ok((real_return_value,lpsz))
}
#[inline]
pub fn get_text_face_a(hdc: Hdc, c: i32, ) -> Result<(i32, CString)> {
    let mut lp_name = Vec::<u8>::with_capacity(c as usize + 1);
    let lpName_win32 = lp_name.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let c_win32 = c;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextFaceA(hdc_win32, c_win32, lpName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    lp_name.truncate(return_value as usize);
    let lp_name = unsafe { CString::from_vec_unchecked(lp_name) };
    Ok((real_return_value,lp_name))
}
#[inline]
pub fn get_text_face_w(hdc: Hdc, c: i32, ) -> Result<(i32, OsString)> {
    let mut lp_name = Vec::<u16>::with_capacity(c as usize + 1);
    let lpName_win32 = lp_name.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let c_win32 = c;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextFaceW(hdc_win32, c_win32, lpName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    lp_name.truncate(return_value as usize);
    let lp_name = OsString::from_wide(&lp_name);
    Ok((real_return_value,lp_name))
}
#[inline]
pub fn get_text_metrics_a(hdc: Hdc, ) -> Result<(BOOL, Textmetrica)> {
    let mut lptm = mem::MaybeUninit::zeroed();
    let lptm_win32 = lptm.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextMetricsA(hdc_win32, lptm_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lptm = unsafe { Textmetrica::from_win32(unsafe { lptm.assume_init() }) };
    Ok((real_return_value,lptm))
}
#[inline]
pub fn get_text_metrics_w(hdc: Hdc, ) -> Result<(BOOL, Textmetricw)> {
    let mut lptm = mem::MaybeUninit::zeroed();
    let lptm_win32 = lptm.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetTextMetricsW(hdc_win32, lptm_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lptm = unsafe { Textmetricw::from_win32(unsafe { lptm.assume_init() }) };
    Ok((real_return_value,lptm))
}
#[inline]
pub fn get_update_rect(h_wnd: Hwnd, b_erase: BOOL) -> Result<(BOOL, Rect)> {
    let mut lp_rect = mem::MaybeUninit::zeroed();
    let lpRect_win32 = lp_rect.as_mut_ptr();
    let hWnd_win32 = h_wnd.into_raw();
    let bErase_win32 = b_erase;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetUpdateRect(hWnd_win32, lpRect_win32, bErase_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_rect = unsafe { Rect::from_win32(unsafe { lp_rect.assume_init() }) };
    Ok((real_return_value,lp_rect))
}
#[inline]
pub fn get_update_rgn(h_wnd: Hwnd, h_rgn: Hrgn, b_erase: BOOL) -> Result<i32> {
    let hWnd_win32 = h_wnd.into_raw();
    let hRgn_win32 = h_rgn.into_raw();
    let bErase_win32 = b_erase;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetUpdateRgn(hWnd_win32, hRgn_win32, bErase_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_viewport_ext_ex(hdc: Hdc, ) -> Result<(BOOL, Size)> {
    let mut lpsize = mem::MaybeUninit::zeroed();
    let lpsize_win32 = lpsize.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetViewportExtEx(hdc_win32, lpsize_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpsize = unsafe { Size::from_win32(unsafe { lpsize.assume_init() }) };
    Ok((real_return_value,lpsize))
}
#[inline]
pub fn get_viewport_org_ex(hdc: Hdc, ) -> Result<(BOOL, Point)> {
    let mut lppoint = mem::MaybeUninit::zeroed();
    let lppoint_win32 = lppoint.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetViewportOrgEx(hdc_win32, lppoint_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lppoint = unsafe { Point::from_win32(unsafe { lppoint.assume_init() }) };
    Ok((real_return_value,lppoint))
}
#[inline]
pub fn get_win_meta_file_bits(hemf: Henhmetafile, cb_data16: u32, i_map_mode: i32, hdc_ref: Hdc) -> (u32, u8) {
    let mut p_data16 = mem::MaybeUninit::zeroed();
    let pData16_win32 = p_data16.as_mut_ptr();
    let hemf_win32 = hemf.into_raw();
    let cbData16_win32 = cb_data16;
    let iMapMode_win32 = i_map_mode;
    let hdcRef_win32 = hdc_ref.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetWinMetaFileBits(hemf_win32, cbData16_win32, pData16_win32, iMapMode_win32, hdcRef_win32) };
    let real_return_value = return_value;
    let p_data16 = unsafe { p_data16.assume_init() };
    (real_return_value,p_data16)
}
#[inline]
pub fn get_window_dc(h_wnd: Option<Hwnd>) -> Result<Hdc> {
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetWindowDC(hWnd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hdc::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_window_ext_ex(hdc: Hdc, ) -> Result<(BOOL, Size)> {
    let mut lpsize = mem::MaybeUninit::zeroed();
    let lpsize_win32 = lpsize.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetWindowExtEx(hdc_win32, lpsize_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpsize = unsafe { Size::from_win32(unsafe { lpsize.assume_init() }) };
    Ok((real_return_value,lpsize))
}
#[inline]
pub fn get_window_org_ex(hdc: Hdc, ) -> Result<(BOOL, Point)> {
    let mut lppoint = mem::MaybeUninit::zeroed();
    let lppoint_win32 = lppoint.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetWindowOrgEx(hdc_win32, lppoint_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lppoint = unsafe { Point::from_win32(unsafe { lppoint.assume_init() }) };
    Ok((real_return_value,lppoint))
}
#[inline]
pub fn get_window_rgn(h_wnd: Hwnd, h_rgn: Hrgn) -> Result<i32> {
    let hWnd_win32 = h_wnd.into_raw();
    let hRgn_win32 = h_rgn.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetWindowRgn(hWnd_win32, hRgn_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_window_rgn_box(h_wnd: Hwnd, ) -> Result<(i32, Rect)> {
    let mut lprc = mem::MaybeUninit::zeroed();
    let lprc_win32 = lprc.as_mut_ptr();
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetWindowRgnBox(hWnd_win32, lprc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lprc = unsafe { Rect::from_win32(unsafe { lprc.assume_init() }) };
    Ok((real_return_value,lprc))
}
#[inline]
pub fn get_world_transform(hdc: Hdc, ) -> Result<(BOOL, Xform)> {
    let mut lpxf = mem::MaybeUninit::zeroed();
    let lpxf_win32 = lpxf.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GetWorldTransform(hdc_win32, lpxf_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpxf = unsafe { Xform::from_win32(unsafe { lpxf.assume_init() }) };
    Ok((real_return_value,lpxf))
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn gradient_fill(hdc: Hdc, p_vertex: &[Trivertex], p_mesh: &[todo_void], ul_mode: u32) -> Result<BOOL> {
//      let hdc_win32 = hdc.into_raw();
//      let pVertex_win32 = p_vertex.as_ptr() as _;
//      let nVertex_win32 = p_vertex.len() as _;
//      let pMesh_win32 = p_mesh.as_ptr() as _;
//      let nMesh_win32 = p_mesh.len() as _;
//      let ulMode_win32 = ul_mode;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GradientFill(hdc_win32, pVertex_win32, nVertex_win32, pMesh_win32, nMesh_win32, ulMode_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      Ok(real_return_value)
//  }
#[inline]
pub fn gray_string_a<Graystringproc: FnMut(Hdc, i32) -> BOOL>(h_dc: Hdc, h_brush: Option<Hbrush>, lp_output_func: Option<Graystringproc>, n_count: i32, x: i32, y: i32, n_width: i32, n_height: i32) -> Result<BOOL> {
    let hDC_win32 = h_dc.into_raw();
    let hBrush_win32 = h_brush.map_or(0, Hbrush::into_raw);
    unsafe extern "system" fn graystringproc_impl<Graystringproc>(param0: HDC, param1: LPARAM, param2: i32) -> BOOL {
        abort_on_panic(move || {
            let input0 = unsafe { Hdc::new(param0) };
            let input2 = param2;
            let closure = unsafe {
                &mut *(param1 as usize as *mut Graystringproc)
            };
            let return_value = (closure)(input0, input2);
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpOutputFunc_win32 = Some(graystringproc_impl::<Graystringproc>);
    let mut lp_output_func = lp_output_func;
    let lpData_win32 = unsafe { Lparam::from_ptr((&mut lp_output_func) as *mut _ as *mut _) };
    let nCount_win32 = n_count;
    let X_win32 = x;
    let Y_win32 = y;
    let nWidth_win32 = n_width;
    let nHeight_win32 = n_height;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GrayStringA(hDC_win32, hBrush_win32, lpOutputFunc_win32, lpData_win32, nCount_win32, X_win32, Y_win32, nWidth_win32, nHeight_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn gray_string_w<Graystringproc: FnMut(Hdc, i32) -> BOOL>(h_dc: Hdc, h_brush: Option<Hbrush>, lp_output_func: Option<Graystringproc>, n_count: i32, x: i32, y: i32, n_width: i32, n_height: i32) -> Result<BOOL> {
    let hDC_win32 = h_dc.into_raw();
    let hBrush_win32 = h_brush.map_or(0, Hbrush::into_raw);
    unsafe extern "system" fn graystringproc_impl<Graystringproc>(param0: HDC, param1: LPARAM, param2: i32) -> BOOL {
        abort_on_panic(move || {
            let input0 = unsafe { Hdc::new(param0) };
            let input2 = param2;
            let closure = unsafe {
                &mut *(param1 as usize as *mut Graystringproc)
            };
            let return_value = (closure)(input0, input2);
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpOutputFunc_win32 = Some(graystringproc_impl::<Graystringproc>);
    let mut lp_output_func = lp_output_func;
    let lpData_win32 = unsafe { Lparam::from_ptr((&mut lp_output_func) as *mut _ as *mut _) };
    let nCount_win32 = n_count;
    let X_win32 = x;
    let Y_win32 = y;
    let nWidth_win32 = n_width;
    let nHeight_win32 = n_height;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::GrayStringW(hDC_win32, hBrush_win32, lpOutputFunc_win32, lpData_win32, nCount_win32, X_win32, Y_win32, nWidth_win32, nHeight_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn inflate_rect(lprc: Rect, dx: i32, dy: i32) -> Result<(BOOL, Rect)> {
    let mut lprc_win32 = lprc.to_win32();
    let dx_win32 = dx;
    let dy_win32 = dy;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::InflateRect(&mut lprc_win32, dx_win32, dy_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lprc = unsafe { Rect::from_win32(lprc_win32) };
    Ok((real_return_value,lprc))
}
#[inline]
pub fn intersect_clip_rect(hdc: Hdc, left: i32, top: i32, right: i32, bottom: i32) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let left_win32 = left;
    let top_win32 = top;
    let right_win32 = right;
    let bottom_win32 = bottom;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::IntersectClipRect(hdc_win32, left_win32, top_win32, right_win32, bottom_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn intersect_rect(lprc_src1: &Rect, lprc_src2: &Rect) -> Result<(BOOL, Rect)> {
    let mut lprc_dst = mem::MaybeUninit::zeroed();
    let lprcDst_win32 = lprc_dst.as_mut_ptr();
    // SAFETY: type is a thin type
    let lprcSrc1_win32 = unsafe { &*(lprc_src1 as *const _ as *const _) };
    // SAFETY: type is a thin type
    let lprcSrc2_win32 = unsafe { &*(lprc_src2 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::IntersectRect(lprcDst_win32, lprcSrc1_win32, lprcSrc2_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lprc_dst = unsafe { Rect::from_win32(unsafe { lprc_dst.assume_init() }) };
    Ok((real_return_value,lprc_dst))
}
#[inline]
pub fn invalidate_rect(h_wnd: Option<Hwnd>, lp_rect: Option<&Rect>, b_erase: BOOL) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    // SAFETY: type is a thin type
    let lpRect_win32 = lp_rect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let bErase_win32 = b_erase;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::InvalidateRect(hWnd_win32, lpRect_win32, bErase_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn invalidate_rgn(h_wnd: Hwnd, h_rgn: Option<Hrgn>, b_erase: BOOL) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let hRgn_win32 = h_rgn.map_or(0, Hrgn::into_raw);
    let bErase_win32 = b_erase;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::InvalidateRgn(hWnd_win32, hRgn_win32, bErase_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn invert_rect(h_dc: Hdc, lprc: &Rect) -> Result<BOOL> {
    let hDC_win32 = h_dc.into_raw();
    // SAFETY: type is a thin type
    let lprc_win32 = unsafe { &*(lprc as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::InvertRect(hDC_win32, lprc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn invert_rgn(hdc: Hdc, hrgn: Hrgn) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let hrgn_win32 = hrgn.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::InvertRgn(hdc_win32, hrgn_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn is_rect_empty(lprc: &Rect) -> BOOL {
    // SAFETY: type is a thin type
    let lprc_win32 = unsafe { &*(lprc as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::IsRectEmpty(lprc_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn l_pto_dp(hdc: Hdc, lppt: Point, c: i32) -> Result<(BOOL, Point)> {
    let hdc_win32 = hdc.into_raw();
    let mut lppt_win32 = lppt.to_win32();
    let c_win32 = c;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::LPtoDP(hdc_win32, &mut lppt_win32, c_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lppt = unsafe { Point::from_win32(lppt_win32) };
    Ok((real_return_value,lppt))
}
#[inline]
pub fn line_dda<Lineddaproc: FnMut(i32, i32, )>(x_start: i32, y_start: i32, x_end: i32, y_end: i32, lp_proc: Lineddaproc, ) -> Result<BOOL> {
    let xStart_win32 = x_start;
    let yStart_win32 = y_start;
    let xEnd_win32 = x_end;
    let yEnd_win32 = y_end;
    unsafe extern "system" fn lineddaproc_impl<Lineddaproc>(param0: i32, param1: i32, param2: LPARAM) -> () {
        abort_on_panic(move || {
            let input0 = param0;
            let input1 = param1;
            let closure = unsafe {
                &mut *(param2 as usize as *mut Lineddaproc)
            };
            let return_value = (closure)(input0, input1, );
        })
    }
    let lpProc_win32 = Some(lineddaproc_impl::<Lineddaproc>);
    let mut lp_proc = lp_proc;
    let data_win32 = unsafe { Lparam::from_ptr((&mut lp_proc) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::LineDDA(xStart_win32, yStart_win32, xEnd_win32, yEnd_win32, lpProc_win32, data_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn line_to(hdc: Hdc, x: i32, y: i32) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::LineTo(hdc_win32, x_win32, y_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn load_bitmap_a(h_instance: Option<Hinstance>, lp_bitmap_name: &CStr) -> Result<Hbitmap> {
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    let lpBitmapName_win32 = lp_bitmap_name.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::LoadBitmapA(hInstance_win32, lpBitmapName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hbitmap::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn load_bitmap_w(h_instance: Option<Hinstance>, lp_bitmap_name: &OsStr) -> Result<Hbitmap> {
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    let mut temp51: Vec<u16> = lp_bitmap_name.encode_wide().collect();
    temp51.push(0);
    let lpBitmapName_win32 = temp51.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::LoadBitmapW(hInstance_win32, lpBitmapName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hbitmap::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn lock_window_update(h_wnd_lock: Option<Hwnd>) -> Result<BOOL> {
    let hWndLock_win32 = h_wnd_lock.map_or(0, Hwnd::into_raw);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::LockWindowUpdate(hWndLock_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn map_window_points(h_wnd_from: Option<Hwnd>, h_wnd_to: Option<Hwnd>, lp_points: Point, c_points: u32) -> Result<(i32, Point)> {
    let hWndFrom_win32 = h_wnd_from.map_or(0, Hwnd::into_raw);
    let hWndTo_win32 = h_wnd_to.map_or(0, Hwnd::into_raw);
    let mut lpPoints_win32 = lp_points.to_win32();
    let cPoints_win32 = c_points;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::MapWindowPoints(hWndFrom_win32, hWndTo_win32, &mut lpPoints_win32, cPoints_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_points = unsafe { Point::from_win32(lpPoints_win32) };
    Ok((real_return_value,lp_points))
}
#[inline]
pub fn mask_blt(hdc_dest: Hdc, x_dest: i32, y_dest: i32, width: i32, height: i32, hdc_src: Hdc, x_src: i32, y_src: i32, hbm_mask: Hbitmap, x_mask: i32, y_mask: i32, rop: u32) -> Result<BOOL> {
    let hdcDest_win32 = hdc_dest.into_raw();
    let xDest_win32 = x_dest;
    let yDest_win32 = y_dest;
    let width_win32 = width;
    let height_win32 = height;
    let hdcSrc_win32 = hdc_src.into_raw();
    let xSrc_win32 = x_src;
    let ySrc_win32 = y_src;
    let hbmMask_win32 = hbm_mask.into_raw();
    let xMask_win32 = x_mask;
    let yMask_win32 = y_mask;
    let rop_win32 = rop;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::MaskBlt(hdcDest_win32, xDest_win32, yDest_win32, width_win32, height_win32, hdcSrc_win32, xSrc_win32, ySrc_win32, hbmMask_win32, xMask_win32, yMask_win32, rop_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn merge_font_package(puch_merge_font_buffer: &[u8], puch_font_package_buffer: &[u8], ppuch_dest_buffer: &mut u8, pul_dest_buffer_size: u32, pul_bytes_written: u32, us_mode: u16, lpfn_allocate: Option<unsafe extern "system" fn(usize) -> *mut c_void>, lpfn_re_allocate: Option<unsafe extern "system" fn(*mut c_void, usize) -> *mut c_void>, lpfn_free: Option<unsafe extern "system" fn(*mut c_void)>, lpv_reserved: todo_void) -> (u32, &mut u8, u32, u32, todo_void_ret) {
//      let puchMergeFontBuffer_win32 = puch_merge_font_buffer.as_ptr() as _;
//      let ulMergeFontBufferSize_win32 = puch_merge_font_buffer.len() as _;
//      let puchFontPackageBuffer_win32 = puch_font_package_buffer.as_ptr() as _;
//      let ulFontPackageBufferSize_win32 = puch_font_package_buffer.len() as _;
//      let mut temp52 = ppuch_dest_buffer;
//      let mut ppuchDestBuffer_win32 = &mut temp52;
//      let mut pulDestBufferSize_win32 = pul_dest_buffer_size;
//      let mut pulBytesWritten_win32 = pul_bytes_written;
//      let usMode_win32 = us_mode;
//      let lpfnAllocate_win32 = lpfn_allocate;
//      let lpfnReAllocate_win32 = lpfn_re_allocate;
//      let lpfnFree_win32 = lpfn_free;
//      let mut lpvReserved_win32 = todo_void;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::MergeFontPackage(puchMergeFontBuffer_win32, ulMergeFontBufferSize_win32, puchFontPackageBuffer_win32, ulFontPackageBufferSize_win32, &mut ppuchDestBuffer_win32, &mut pulDestBufferSize_win32, &mut pulBytesWritten_win32, usMode_win32, lpfnAllocate_win32, lpfnReAllocate_win32, lpfnFree_win32, &mut lpvReserved_win32) };
//      let real_return_value = return_value;
//      let lpv_reserved = todo_void;
//      let pul_bytes_written = pulBytesWritten_win32;
//      let pul_dest_buffer_size = pulDestBufferSize_win32;
//      let ppuch_dest_buffer = unsafe { &mut *(ppuchDestBuffer_win32 as *mut _) };
//      (real_return_value,ppuch_dest_buffer, pul_dest_buffer_size, pul_bytes_written, lpv_reserved)
//  }
#[inline]
pub fn modify_world_transform(hdc: Hdc, lpxf: Option<&Xform>, mode: u32) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    // SAFETY: type is a thin type
    let lpxf_win32 = lpxf.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let mode_win32 = mode;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ModifyWorldTransform(hdc_win32, lpxf_win32, mode_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn monitor_from_point(pt: Point, dw_flags: u32) -> Result<Hmonitor> {
    let pt_win32 = pt.to_win32();
    let dwFlags_win32 = dw_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::MonitorFromPoint(pt_win32, dwFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hmonitor::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn monitor_from_rect(lprc: &Rect, dw_flags: u32) -> Result<Hmonitor> {
    // SAFETY: type is a thin type
    let lprc_win32 = unsafe { &*(lprc as *const _ as *const _) };
    let dwFlags_win32 = dw_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::MonitorFromRect(lprc_win32, dwFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hmonitor::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn monitor_from_window(hwnd: Hwnd, dw_flags: u32) -> Result<Hmonitor> {
    let hwnd_win32 = hwnd.into_raw();
    let dwFlags_win32 = dw_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::MonitorFromWindow(hwnd_win32, dwFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hmonitor::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn move_to_ex(hdc: Hdc, x: i32, y: i32, ) -> Result<(BOOL, Point)> {
    let mut lppt = mem::MaybeUninit::zeroed();
    let lppt_win32 = lppt.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::MoveToEx(hdc_win32, x_win32, y_win32, lppt_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lppt = unsafe { Point::from_win32(unsafe { lppt.assume_init() }) };
    Ok((real_return_value,lppt))
}
#[inline]
pub fn offset_clip_rgn(hdc: Hdc, x: i32, y: i32) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::OffsetClipRgn(hdc_win32, x_win32, y_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn offset_rect(lprc: Rect, dx: i32, dy: i32) -> Result<(BOOL, Rect)> {
    let mut lprc_win32 = lprc.to_win32();
    let dx_win32 = dx;
    let dy_win32 = dy;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::OffsetRect(&mut lprc_win32, dx_win32, dy_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lprc = unsafe { Rect::from_win32(lprc_win32) };
    Ok((real_return_value,lprc))
}
#[inline]
pub fn offset_rgn(hrgn: Hrgn, x: i32, y: i32) -> Result<i32> {
    let hrgn_win32 = hrgn.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::OffsetRgn(hrgn_win32, x_win32, y_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn offset_viewport_org_ex(hdc: Hdc, x: i32, y: i32, ) -> Result<(BOOL, Point)> {
    let mut lppt = mem::MaybeUninit::zeroed();
    let lppt_win32 = lppt.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::OffsetViewportOrgEx(hdc_win32, x_win32, y_win32, lppt_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lppt = unsafe { Point::from_win32(unsafe { lppt.assume_init() }) };
    Ok((real_return_value,lppt))
}
#[inline]
pub fn offset_window_org_ex(hdc: Hdc, x: i32, y: i32, ) -> Result<(BOOL, Point)> {
    let mut lppt = mem::MaybeUninit::zeroed();
    let lppt_win32 = lppt.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::OffsetWindowOrgEx(hdc_win32, x_win32, y_win32, lppt_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lppt = unsafe { Point::from_win32(unsafe { lppt.assume_init() }) };
    Ok((real_return_value,lppt))
}
#[inline]
pub fn paint_desktop(hdc: Hdc) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PaintDesktop(hdc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn paint_rgn(hdc: Hdc, hrgn: Hrgn) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let hrgn_win32 = hrgn.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PaintRgn(hdc_win32, hrgn_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn pat_blt(hdc: Hdc, x: i32, y: i32, w: i32, h: i32, rop: u32) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let w_win32 = w;
    let h_win32 = h;
    let rop_win32 = rop;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PatBlt(hdc_win32, x_win32, y_win32, w_win32, h_win32, rop_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn pie(hdc: Hdc, left: i32, top: i32, right: i32, bottom: i32, xr1: i32, yr1: i32, xr2: i32, yr2: i32) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let left_win32 = left;
    let top_win32 = top;
    let right_win32 = right;
    let bottom_win32 = bottom;
    let xr1_win32 = xr1;
    let yr1_win32 = yr1;
    let xr2_win32 = xr2;
    let yr2_win32 = yr2;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::Pie(hdc_win32, left_win32, top_win32, right_win32, bottom_win32, xr1_win32, yr1_win32, xr2_win32, yr2_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn play_enh_meta_file(hdc: Hdc, hmf: Henhmetafile, lprect: &Rect) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let hmf_win32 = hmf.into_raw();
    // SAFETY: type is a thin type
    let lprect_win32 = unsafe { &*(lprect as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PlayEnhMetaFile(hdc_win32, hmf_win32, lprect_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn play_enh_meta_file_record(hdc: Hdc, pht: &Handletable, pmr: &[Enhmetarecord], ) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    // SAFETY: type is a thin type
    let pht_win32 = unsafe { &*(pht as *const _ as *const _) };
    let pmr_win32 = pmr.as_ptr() as _;
    let cht_win32 = pmr.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PlayEnhMetaFileRecord(hdc_win32, pht_win32, pmr_win32, cht_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn play_meta_file(hdc: Hdc, hmf: Hmetafile) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let hmf_win32 = hmf.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PlayMetaFile(hdc_win32, hmf_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn play_meta_file_record(hdc: Hdc, lp_handle_table: &Handletable, lp_mr: &[Metarecord], ) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    // SAFETY: type is a thin type
    let lpHandleTable_win32 = unsafe { &*(lp_handle_table as *const _ as *const _) };
    let lpMR_win32 = lp_mr.as_ptr() as _;
    let noObjs_win32 = lp_mr.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PlayMetaFileRecord(hdc_win32, lpHandleTable_win32, lpMR_win32, noObjs_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn plg_blt(hdc_dest: Hdc, lp_point: &Point, hdc_src: Hdc, x_src: i32, y_src: i32, width: i32, height: i32, hbm_mask: Option<Hbitmap>, x_mask: i32, y_mask: i32) -> Result<BOOL> {
    let hdcDest_win32 = hdc_dest.into_raw();
    // SAFETY: type is a thin type
    let lpPoint_win32 = unsafe { &*(lp_point as *const _ as *const _) };
    let hdcSrc_win32 = hdc_src.into_raw();
    let xSrc_win32 = x_src;
    let ySrc_win32 = y_src;
    let width_win32 = width;
    let height_win32 = height;
    let hbmMask_win32 = hbm_mask.map_or(0, Hbitmap::into_raw);
    let xMask_win32 = x_mask;
    let yMask_win32 = y_mask;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PlgBlt(hdcDest_win32, lpPoint_win32, hdcSrc_win32, xSrc_win32, ySrc_win32, width_win32, height_win32, hbmMask_win32, xMask_win32, yMask_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn poly_bezier(hdc: Hdc, apt: &[Point], ) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let apt_win32 = apt.as_ptr() as _;
    let cpt_win32 = apt.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PolyBezier(hdc_win32, apt_win32, cpt_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn poly_bezier_to(hdc: Hdc, apt: &[Point], ) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let apt_win32 = apt.as_ptr() as _;
    let cpt_win32 = apt.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PolyBezierTo(hdc_win32, apt_win32, cpt_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn poly_draw(hdc: Hdc, apt: &Point, aj: &[u8], ) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    // SAFETY: type is a thin type
    let apt_win32 = unsafe { &*(apt as *const _ as *const _) };
    let aj_win32 = aj.as_ptr() as _;
    let cpt_win32 = aj.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PolyDraw(hdc_win32, apt_win32, aj_win32, cpt_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn poly_polygon(hdc: Hdc, apt: &Point, asz: &[i32], ) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    // SAFETY: type is a thin type
    let apt_win32 = unsafe { &*(apt as *const _ as *const _) };
    let asz_win32 = asz.as_ptr() as _;
    let csz_win32 = asz.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PolyPolygon(hdc_win32, apt_win32, asz_win32, csz_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn poly_polyline(hdc: Hdc, apt: &Point, asz: &[u32], ) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    // SAFETY: type is a thin type
    let apt_win32 = unsafe { &*(apt as *const _ as *const _) };
    let asz_win32 = asz.as_ptr() as _;
    let csz_win32 = asz.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PolyPolyline(hdc_win32, apt_win32, asz_win32, csz_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn poly_text_out_a(hdc: Hdc, ppt: &[Polytexta<'_>], ) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let ppt_win32 = ppt.as_ptr() as _;
    let nstrings_win32 = ppt.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PolyTextOutA(hdc_win32, ppt_win32, nstrings_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn poly_text_out_w(hdc: Hdc, ppt: &[Polytextw<'_>], ) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let ppt_win32 = ppt.as_ptr() as _;
    let nstrings_win32 = ppt.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PolyTextOutW(hdc_win32, ppt_win32, nstrings_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn polygon(hdc: Hdc, apt: &[Point], ) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let apt_win32 = apt.as_ptr() as _;
    let cpt_win32 = apt.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::Polygon(hdc_win32, apt_win32, cpt_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn polyline(hdc: Hdc, apt: &[Point], ) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let apt_win32 = apt.as_ptr() as _;
    let cpt_win32 = apt.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::Polyline(hdc_win32, apt_win32, cpt_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn polyline_to(hdc: Hdc, apt: &[Point], ) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let apt_win32 = apt.as_ptr() as _;
    let cpt_win32 = apt.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PolylineTo(hdc_win32, apt_win32, cpt_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn pt_in_rect(lprc: &Rect, pt: Point) -> BOOL {
    // SAFETY: type is a thin type
    let lprc_win32 = unsafe { &*(lprc as *const _ as *const _) };
    let pt_win32 = pt.to_win32();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PtInRect(lprc_win32, pt_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn pt_in_region(hrgn: Hrgn, x: i32, y: i32) -> BOOL {
    let hrgn_win32 = hrgn.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PtInRegion(hrgn_win32, x_win32, y_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn pt_visible(hdc: Hdc, x: i32, y: i32) -> BOOL {
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::PtVisible(hdc_win32, x_win32, y_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn realize_palette(hdc: Hdc) -> u32 {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::RealizePalette(hdc_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn rect_in_region(hrgn: Hrgn, lprect: &Rect) -> BOOL {
    let hrgn_win32 = hrgn.into_raw();
    // SAFETY: type is a thin type
    let lprect_win32 = unsafe { &*(lprect as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::RectInRegion(hrgn_win32, lprect_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn rect_visible(hdc: Hdc, lprect: &Rect) -> BOOL {
    let hdc_win32 = hdc.into_raw();
    // SAFETY: type is a thin type
    let lprect_win32 = unsafe { &*(lprect as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::RectVisible(hdc_win32, lprect_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn rectangle(hdc: Hdc, left: i32, top: i32, right: i32, bottom: i32) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let left_win32 = left;
    let top_win32 = top;
    let right_win32 = right;
    let bottom_win32 = bottom;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::Rectangle(hdc_win32, left_win32, top_win32, right_win32, bottom_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn redraw_window(h_wnd: Option<Hwnd>, lprc_update: Option<&Rect>, hrgn_update: Option<Hrgn>, flags: u32) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    // SAFETY: type is a thin type
    let lprcUpdate_win32 = lprc_update.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let hrgnUpdate_win32 = hrgn_update.map_or(0, Hrgn::into_raw);
    let flags_win32 = flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::RedrawWindow(hWnd_win32, lprcUpdate_win32, hrgnUpdate_win32, flags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn release_dc(h_wnd: Option<Hwnd>, h_dc: Hdc) -> Result<i32> {
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let hDC_win32 = h_dc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ReleaseDC(hWnd_win32, hDC_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn remove_font_mem_resource_ex(h: Handle) -> Result<BOOL> {
    let h_win32 = h.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::RemoveFontMemResourceEx(h_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn remove_font_resource_a(lp_file_name: &CStr) -> Result<BOOL> {
    let lpFileName_win32 = lp_file_name.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::RemoveFontResourceA(lpFileName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn remove_font_resource_ex_a(name: &CStr, fl: u32, pdv: todo_void) -> Result<(BOOL, todo_void_ret)> {
//      let name_win32 = name.as_ptr() as _;
//      let fl_win32 = fl;
//      let mut pdv_win32 = todo_void;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::RemoveFontResourceExA(name_win32, fl_win32, &mut pdv_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      let pdv = todo_void;
//      Ok((real_return_value,pdv))
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn remove_font_resource_ex_w(name: &OsStr, fl: u32, pdv: todo_void) -> Result<(BOOL, todo_void_ret)> {
//      let mut temp53: Vec<u16> = name.encode_wide().collect();
//      temp53.push(0);
//      let name_win32 = temp53.as_ptr() as _;
//      let fl_win32 = fl;
//      let mut pdv_win32 = todo_void;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::RemoveFontResourceExW(name_win32, fl_win32, &mut pdv_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      let pdv = todo_void;
//      Ok((real_return_value,pdv))
//  }
#[inline]
pub fn remove_font_resource_w(lp_file_name: &OsStr) -> Result<BOOL> {
    let mut temp54: Vec<u16> = lp_file_name.encode_wide().collect();
    temp54.push(0);
    let lpFileName_win32 = temp54.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::RemoveFontResourceW(lpFileName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn reset_dca(hdc: Hdc, lpdm: &Devmodea) -> Result<Hdc> {
    let hdc_win32 = hdc.into_raw();
    let temp55 = lpdm.to_win32();
    let lpdm_win32 = &temp55;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ResetDCA(hdc_win32, lpdm_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hdc::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn reset_dcw(hdc: Hdc, lpdm: &Devmodew) -> Result<Hdc> {
    let hdc_win32 = hdc.into_raw();
    let temp56 = lpdm.to_win32();
    let lpdm_win32 = &temp56;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ResetDCW(hdc_win32, lpdm_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hdc::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn resize_palette(hpal: Hpalette, n: u32) -> Result<BOOL> {
    let hpal_win32 = hpal.into_raw();
    let n_win32 = n;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ResizePalette(hpal_win32, n_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn restore_dc(hdc: Hdc, n_saved_dc: i32) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let nSavedDC_win32 = n_saved_dc;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::RestoreDC(hdc_win32, nSavedDC_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn round_rect(hdc: Hdc, left: i32, top: i32, right: i32, bottom: i32, width: i32, height: i32) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let left_win32 = left;
    let top_win32 = top;
    let right_win32 = right;
    let bottom_win32 = bottom;
    let width_win32 = width;
    let height_win32 = height;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::RoundRect(hdc_win32, left_win32, top_win32, right_win32, bottom_win32, width_win32, height_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn save_dc(hdc: Hdc) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SaveDC(hdc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn scale_viewport_ext_ex(hdc: Hdc, xn: i32, dx: i32, yn: i32, yd: i32, ) -> Result<(BOOL, Size)> {
    let mut lpsz = mem::MaybeUninit::zeroed();
    let lpsz_win32 = lpsz.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let xn_win32 = xn;
    let dx_win32 = dx;
    let yn_win32 = yn;
    let yd_win32 = yd;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ScaleViewportExtEx(hdc_win32, xn_win32, dx_win32, yn_win32, yd_win32, lpsz_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpsz = unsafe { Size::from_win32(unsafe { lpsz.assume_init() }) };
    Ok((real_return_value,lpsz))
}
#[inline]
pub fn scale_window_ext_ex(hdc: Hdc, xn: i32, xd: i32, yn: i32, yd: i32, ) -> Result<(BOOL, Size)> {
    let mut lpsz = mem::MaybeUninit::zeroed();
    let lpsz_win32 = lpsz.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let xn_win32 = xn;
    let xd_win32 = xd;
    let yn_win32 = yn;
    let yd_win32 = yd;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ScaleWindowExtEx(hdc_win32, xn_win32, xd_win32, yn_win32, yd_win32, lpsz_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpsz = unsafe { Size::from_win32(unsafe { lpsz.assume_init() }) };
    Ok((real_return_value,lpsz))
}
#[inline]
pub fn screen_to_client(h_wnd: Hwnd, lp_point: Point) -> Result<(BOOL, Point)> {
    let hWnd_win32 = h_wnd.into_raw();
    let mut lpPoint_win32 = lp_point.to_win32();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ScreenToClient(hWnd_win32, &mut lpPoint_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_point = unsafe { Point::from_win32(lpPoint_win32) };
    Ok((real_return_value,lp_point))
}
#[inline]
pub fn select_clip_path(hdc: Hdc, mode: i32) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let mode_win32 = mode;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SelectClipPath(hdc_win32, mode_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn select_clip_rgn(hdc: Hdc, hrgn: Option<Hrgn>) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let hrgn_win32 = hrgn.map_or(0, Hrgn::into_raw);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SelectClipRgn(hdc_win32, hrgn_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn select_object(hdc: Hdc, h: Hgdiobj) -> Result<Hgdiobj> {
    let hdc_win32 = hdc.into_raw();
    let h_win32 = h.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SelectObject(hdc_win32, h_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hgdiobj::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn select_palette(hdc: Hdc, h_pal: Hpalette, b_force_bkgd: BOOL) -> Result<Hpalette> {
    let hdc_win32 = hdc.into_raw();
    let hPal_win32 = h_pal.into_raw();
    let bForceBkgd_win32 = b_force_bkgd;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SelectPalette(hdc_win32, hPal_win32, bForceBkgd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hpalette::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn set_arc_direction(hdc: Hdc, dir: u32) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let dir_win32 = dir;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetArcDirection(hdc_win32, dir_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn set_bitmap_bits(hbm: Hbitmap, pv_bits: &[todo_void]) -> Result<i32> {
//      let hbm_win32 = hbm.into_raw();
//      let pvBits_win32 = pv_bits.as_ptr() as _;
//      let cb_win32 = pv_bits.len() as _;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetBitmapBits(hbm_win32, cb_win32, pvBits_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      Ok(real_return_value)
//  }
#[inline]
pub fn set_bitmap_dimension_ex(hbm: Hbitmap, w: i32, h: i32, ) -> Result<(BOOL, Size)> {
    let mut lpsz = mem::MaybeUninit::zeroed();
    let lpsz_win32 = lpsz.as_mut_ptr();
    let hbm_win32 = hbm.into_raw();
    let w_win32 = w;
    let h_win32 = h;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetBitmapDimensionEx(hbm_win32, w_win32, h_win32, lpsz_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpsz = unsafe { Size::from_win32(unsafe { lpsz.assume_init() }) };
    Ok((real_return_value,lpsz))
}
#[inline]
pub fn set_bk_color(hdc: Hdc, color: u32) -> u32 {
    let hdc_win32 = hdc.into_raw();
    let color_win32 = color;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetBkColor(hdc_win32, color_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn set_bk_mode(hdc: Hdc, mode: u32) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let mode_win32 = mode;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetBkMode(hdc_win32, mode_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_bounds_rect(hdc: Hdc, lprect: Option<&Rect>, flags: u32) -> u32 {
    let hdc_win32 = hdc.into_raw();
    // SAFETY: type is a thin type
    let lprect_win32 = lprect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let flags_win32 = flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetBoundsRect(hdc_win32, lprect_win32, flags_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn set_brush_org_ex(hdc: Hdc, x: i32, y: i32, ) -> Result<(BOOL, Point)> {
    let mut lppt = mem::MaybeUninit::zeroed();
    let lppt_win32 = lppt.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetBrushOrgEx(hdc_win32, x_win32, y_win32, lppt_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lppt = unsafe { Point::from_win32(unsafe { lppt.assume_init() }) };
    Ok((real_return_value,lppt))
}
#[inline]
pub fn set_color_adjustment(hdc: Hdc, lpca: &Coloradjustment) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let temp57 = lpca.to_win32();
    let lpca_win32 = &temp57;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetColorAdjustment(hdc_win32, lpca_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_dc_brush_color(hdc: Hdc, color: u32) -> u32 {
    let hdc_win32 = hdc.into_raw();
    let color_win32 = color;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetDCBrushColor(hdc_win32, color_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn set_dc_pen_color(hdc: Hdc, color: u32) -> u32 {
    let hdc_win32 = hdc.into_raw();
    let color_win32 = color;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetDCPenColor(hdc_win32, color_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn set_dib_color_table(hdc: Hdc, i_start: u32, prgbq: &[Rgbquad]) -> u32 {
    let hdc_win32 = hdc.into_raw();
    let iStart_win32 = i_start;
    let prgbq_win32 = prgbq.as_ptr() as _;
    let cEntries_win32 = prgbq.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetDIBColorTable(hdc_win32, iStart_win32, cEntries_win32, prgbq_win32) };
    let real_return_value = return_value;
    real_return_value
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn set_di_bits(hdc: Option<Hdc>, hbm: Hbitmap, start: u32, lp_bits: &todo_void, lpbmi: &[Bitmapinfo], color_use: u32) -> Result<i32> {
//      let hdc_win32 = hdc.map_or(0, Hdc::into_raw);
//      let hbm_win32 = hbm.into_raw();
//      let start_win32 = start;
//      // SAFETY: type is a thin type
//      let lpBits_win32 = unsafe { &*(lp_bits as *const _ as *const _) };
//      let lpbmi_win32 = lpbmi.as_ptr() as _;
//      let cLines_win32 = lpbmi.len() as _;
//      let ColorUse_win32 = color_use;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetDIBits(hdc_win32, hbm_win32, start_win32, cLines_win32, lpBits_win32, lpbmi_win32, ColorUse_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      Ok(real_return_value)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn set_di_bits_to_device(hdc: Hdc, x_dest: i32, y_dest: i32, w: u32, h: u32, x_src: i32, y_src: i32, start_scan: u32, lpv_bits: &todo_void, lpbmi: &[Bitmapinfo], color_use: u32) -> Result<i32> {
//      let hdc_win32 = hdc.into_raw();
//      let xDest_win32 = x_dest;
//      let yDest_win32 = y_dest;
//      let w_win32 = w;
//      let h_win32 = h;
//      let xSrc_win32 = x_src;
//      let ySrc_win32 = y_src;
//      let StartScan_win32 = start_scan;
//      // SAFETY: type is a thin type
//      let lpvBits_win32 = unsafe { &*(lpv_bits as *const _ as *const _) };
//      let lpbmi_win32 = lpbmi.as_ptr() as _;
//      let cLines_win32 = lpbmi.len() as _;
//      let ColorUse_win32 = color_use;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetDIBitsToDevice(hdc_win32, xDest_win32, yDest_win32, w_win32, h_win32, xSrc_win32, ySrc_win32, StartScan_win32, cLines_win32, lpvBits_win32, lpbmi_win32, ColorUse_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      Ok(real_return_value)
//  }
#[inline]
pub fn set_enh_meta_file_bits(pb: &[u8]) -> Result<Henhmetafile> {
    let pb_win32 = pb.as_ptr() as _;
    let nSize_win32 = pb.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetEnhMetaFileBits(nSize_win32, pb_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Henhmetafile::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn set_graphics_mode(hdc: Hdc, i_mode: u32) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let iMode_win32 = i_mode;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetGraphicsMode(hdc_win32, iMode_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_layout(hdc: Hdc, l: u32) -> u32 {
    let hdc_win32 = hdc.into_raw();
    let l_win32 = l;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetLayout(hdc_win32, l_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn set_map_mode(hdc: Hdc, i_mode: u32) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let iMode_win32 = i_mode;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetMapMode(hdc_win32, iMode_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_mapper_flags(hdc: Hdc, flags: u32) -> u32 {
    let hdc_win32 = hdc.into_raw();
    let flags_win32 = flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetMapperFlags(hdc_win32, flags_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn set_meta_file_bits_ex(lp_data: &[u8]) -> Result<Hmetafile> {
    let lpData_win32 = lp_data.as_ptr() as _;
    let cbBuffer_win32 = lp_data.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetMetaFileBitsEx(cbBuffer_win32, lpData_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hmetafile::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn set_meta_rgn(hdc: Hdc) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetMetaRgn(hdc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_miter_limit(hdc: Hdc, limit: f32, ) -> Result<(BOOL, f32)> {
    let mut old = mem::MaybeUninit::zeroed();
    let old_win32 = old.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let limit_win32 = limit;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetMiterLimit(hdc_win32, limit_win32, old_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let old = unsafe { old.assume_init() };
    Ok((real_return_value,old))
}
#[inline]
pub fn set_palette_entries(hpal: Hpalette, i_start: u32, p_pal_entries: &[Paletteentry]) -> u32 {
    let hpal_win32 = hpal.into_raw();
    let iStart_win32 = i_start;
    let pPalEntries_win32 = p_pal_entries.as_ptr() as _;
    let cEntries_win32 = p_pal_entries.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetPaletteEntries(hpal_win32, iStart_win32, cEntries_win32, pPalEntries_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn set_pixel(hdc: Hdc, x: i32, y: i32, color: u32) -> u32 {
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let color_win32 = color;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetPixel(hdc_win32, x_win32, y_win32, color_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn set_pixel_v(hdc: Hdc, x: i32, y: i32, color: u32) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let color_win32 = color;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetPixelV(hdc_win32, x_win32, y_win32, color_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_poly_fill_mode(hdc: Hdc, mode: u32) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let mode_win32 = mode;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetPolyFillMode(hdc_win32, mode_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_rop2(hdc: Hdc, rop2: i32) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let rop2_win32 = rop2;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetROP2(hdc_win32, rop2_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_rect(x_left: i32, y_top: i32, x_right: i32, y_bottom: i32) -> Result<(BOOL, Rect)> {
    let mut lprc = mem::MaybeUninit::zeroed();
    let lprc_win32 = lprc.as_mut_ptr();
    let xLeft_win32 = x_left;
    let yTop_win32 = y_top;
    let xRight_win32 = x_right;
    let yBottom_win32 = y_bottom;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetRect(lprc_win32, xLeft_win32, yTop_win32, xRight_win32, yBottom_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lprc = unsafe { Rect::from_win32(unsafe { lprc.assume_init() }) };
    Ok((real_return_value,lprc))
}
#[inline]
pub fn set_rect_empty() -> Result<(BOOL, Rect)> {
    let mut lprc = mem::MaybeUninit::zeroed();
    let lprc_win32 = lprc.as_mut_ptr();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetRectEmpty(lprc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lprc = unsafe { Rect::from_win32(unsafe { lprc.assume_init() }) };
    Ok((real_return_value,lprc))
}
#[inline]
pub fn set_rect_rgn(hrgn: Hrgn, left: i32, top: i32, right: i32, bottom: i32) -> Result<BOOL> {
    let hrgn_win32 = hrgn.into_raw();
    let left_win32 = left;
    let top_win32 = top;
    let right_win32 = right;
    let bottom_win32 = bottom;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetRectRgn(hrgn_win32, left_win32, top_win32, right_win32, bottom_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_stretch_blt_mode(hdc: Hdc, mode: u32) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let mode_win32 = mode;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetStretchBltMode(hdc_win32, mode_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_system_palette_use(hdc: Hdc, r#use: u32) -> u32 {
    let hdc_win32 = hdc.into_raw();
    let r#use_win32 = r#use;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetSystemPaletteUse(hdc_win32, r#use_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn set_text_align(hdc: Hdc, align: u32) -> u32 {
    let hdc_win32 = hdc.into_raw();
    let align_win32 = align;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetTextAlign(hdc_win32, align_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn set_text_color(hdc: Hdc, color: u32) -> u32 {
    let hdc_win32 = hdc.into_raw();
    let color_win32 = color;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetTextColor(hdc_win32, color_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn set_text_justification(hdc: Hdc, extra: i32, count: i32) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let extra_win32 = extra;
    let count_win32 = count;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetTextJustification(hdc_win32, extra_win32, count_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_viewport_ext_ex(hdc: Hdc, x: i32, y: i32, ) -> Result<(BOOL, Size)> {
    let mut lpsz = mem::MaybeUninit::zeroed();
    let lpsz_win32 = lpsz.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetViewportExtEx(hdc_win32, x_win32, y_win32, lpsz_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpsz = unsafe { Size::from_win32(unsafe { lpsz.assume_init() }) };
    Ok((real_return_value,lpsz))
}
#[inline]
pub fn set_viewport_org_ex(hdc: Hdc, x: i32, y: i32, ) -> Result<(BOOL, Point)> {
    let mut lppt = mem::MaybeUninit::zeroed();
    let lppt_win32 = lppt.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetViewportOrgEx(hdc_win32, x_win32, y_win32, lppt_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lppt = unsafe { Point::from_win32(unsafe { lppt.assume_init() }) };
    Ok((real_return_value,lppt))
}
#[inline]
pub fn set_window_ext_ex(hdc: Hdc, x: i32, y: i32, ) -> Result<(BOOL, Size)> {
    let mut lpsz = mem::MaybeUninit::zeroed();
    let lpsz_win32 = lpsz.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetWindowExtEx(hdc_win32, x_win32, y_win32, lpsz_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpsz = unsafe { Size::from_win32(unsafe { lpsz.assume_init() }) };
    Ok((real_return_value,lpsz))
}
#[inline]
pub fn set_window_org_ex(hdc: Hdc, x: i32, y: i32, ) -> Result<(BOOL, Point)> {
    let mut lppt = mem::MaybeUninit::zeroed();
    let lppt_win32 = lppt.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetWindowOrgEx(hdc_win32, x_win32, y_win32, lppt_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lppt = unsafe { Point::from_win32(unsafe { lppt.assume_init() }) };
    Ok((real_return_value,lppt))
}
#[inline]
pub fn set_window_rgn(h_wnd: Hwnd, h_rgn: Option<Hrgn>, b_redraw: BOOL) -> Result<i32> {
    let hWnd_win32 = h_wnd.into_raw();
    let hRgn_win32 = h_rgn.map_or(0, Hrgn::into_raw);
    let bRedraw_win32 = b_redraw;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetWindowRgn(hWnd_win32, hRgn_win32, bRedraw_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_world_transform(hdc: Hdc, lpxf: &Xform) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    // SAFETY: type is a thin type
    let lpxf_win32 = unsafe { &*(lpxf as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SetWorldTransform(hdc_win32, lpxf_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn subtract_rect(lprc_src1: &Rect, lprc_src2: &Rect) -> Result<(BOOL, Rect)> {
    let mut lprc_dst = mem::MaybeUninit::zeroed();
    let lprcDst_win32 = lprc_dst.as_mut_ptr();
    // SAFETY: type is a thin type
    let lprcSrc1_win32 = unsafe { &*(lprc_src1 as *const _ as *const _) };
    // SAFETY: type is a thin type
    let lprcSrc2_win32 = unsafe { &*(lprc_src2 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::SubtractRect(lprcDst_win32, lprcSrc1_win32, lprcSrc2_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lprc_dst = unsafe { Rect::from_win32(unsafe { lprc_dst.assume_init() }) };
    Ok((real_return_value,lprc_dst))
}
#[inline]
pub fn tt_delete_embedded_font(h_font_reference: Handle, ul_flags: u32, ) -> Result<(i32, u32)> {
    let mut pul_status = mem::MaybeUninit::zeroed();
    let pulStatus_win32 = pul_status.as_mut_ptr();
    let hFontReference_win32 = h_font_reference.into_raw();
    let ulFlags_win32 = ul_flags;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTDeleteEmbeddedFont(hFontReference_win32, ulFlags_win32, pulStatus_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pul_status = unsafe { pul_status.assume_init() };
    Ok((real_return_value,pul_status))
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn tt_embed_font<Writeembedproc: FnMut(&mut todo_void, u32) -> u32>(h_dc: Hdc, ul_flags: u32, ul_char_set: u32, lpfn_write_to_stream: Writeembedproc, pus_char_code_set: &u16, us_char_code_count: u16, us_language: u16, p_tt_embed_info: Option<&Ttembedinfo<'_>>) -> Result<(i32, u32, u32)> {
//      let mut pul_priv_status = mem::MaybeUninit::zeroed();
//      let pulPrivStatus_win32 = pul_priv_status.as_mut_ptr();
//      let mut pul_status = mem::MaybeUninit::zeroed();
//      let pulStatus_win32 = pul_status.as_mut_ptr();
//      let hDC_win32 = h_dc.into_raw();
//      let ulFlags_win32 = ul_flags;
//      let ulCharSet_win32 = ul_char_set;
//      unsafe extern "system" fn writeembedproc_impl<Writeembedproc>(param0: *mut c_void, param1: *const c_void, param2: u32) -> u32 {
//          abort_on_panic(move || {
//              let input0 = unsafe { &mut *(param0 as *mut _) };
//              let input2 = param2;
//              let closure = unsafe {
//                  &mut *(param1 as usize as *mut Writeembedproc)
//              };
//              let return_value = (closure)(input0, input2);
//              let real_return_value = return_value;
//              real_return_value
//          })
//      }
//      let lpfnWriteToStream_win32 = Some(writeembedproc_impl::<Writeembedproc>);
//      let mut lpfn_write_to_stream = lpfn_write_to_stream;
//      let lpvWriteStream_win32 = (&mut lpfn_write_to_stream) as *mut _ as *mut _;
//      // SAFETY: type is a thin type
//      let pusCharCodeSet_win32 = unsafe { &*(pus_char_code_set as *const _ as *const _) };
//      let usCharCodeCount_win32 = us_char_code_count;
//      let usLanguage_win32 = us_language;
//      let temp58 = p_tt_embed_info.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
//      let pTTEmbedInfo_win32 = &temp58;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTEmbedFont(hDC_win32, ulFlags_win32, ulCharSet_win32, pulPrivStatus_win32, pulStatus_win32, lpfnWriteToStream_win32, lpvWriteStream_win32, pusCharCodeSet_win32, usCharCodeCount_win32, usLanguage_win32, pTTEmbedInfo_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      let pul_status = unsafe { pul_status.assume_init() };
//      let pul_priv_status = unsafe { pul_priv_status.assume_init() };
//      Ok((real_return_value,pul_priv_status, pul_status))
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn tt_embed_font_ex<Writeembedproc: FnMut(&mut todo_void, u32) -> u32>(h_dc: Hdc, ul_flags: u32, ul_char_set: u32, lpfn_write_to_stream: Writeembedproc, pul_char_code_set: &u32, us_char_code_count: u16, us_language: u16, p_tt_embed_info: Option<&Ttembedinfo<'_>>) -> Result<(i32, u32, u32)> {
//      let mut pul_priv_status = mem::MaybeUninit::zeroed();
//      let pulPrivStatus_win32 = pul_priv_status.as_mut_ptr();
//      let mut pul_status = mem::MaybeUninit::zeroed();
//      let pulStatus_win32 = pul_status.as_mut_ptr();
//      let hDC_win32 = h_dc.into_raw();
//      let ulFlags_win32 = ul_flags;
//      let ulCharSet_win32 = ul_char_set;
//      unsafe extern "system" fn writeembedproc_impl<Writeembedproc>(param0: *mut c_void, param1: *const c_void, param2: u32) -> u32 {
//          abort_on_panic(move || {
//              let input0 = unsafe { &mut *(param0 as *mut _) };
//              let input2 = param2;
//              let closure = unsafe {
//                  &mut *(param1 as usize as *mut Writeembedproc)
//              };
//              let return_value = (closure)(input0, input2);
//              let real_return_value = return_value;
//              real_return_value
//          })
//      }
//      let lpfnWriteToStream_win32 = Some(writeembedproc_impl::<Writeembedproc>);
//      let mut lpfn_write_to_stream = lpfn_write_to_stream;
//      let lpvWriteStream_win32 = (&mut lpfn_write_to_stream) as *mut _ as *mut _;
//      // SAFETY: type is a thin type
//      let pulCharCodeSet_win32 = unsafe { &*(pul_char_code_set as *const _ as *const _) };
//      let usCharCodeCount_win32 = us_char_code_count;
//      let usLanguage_win32 = us_language;
//      let temp59 = p_tt_embed_info.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
//      let pTTEmbedInfo_win32 = &temp59;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTEmbedFontEx(hDC_win32, ulFlags_win32, ulCharSet_win32, pulPrivStatus_win32, pulStatus_win32, lpfnWriteToStream_win32, lpvWriteStream_win32, pulCharCodeSet_win32, usCharCodeCount_win32, usLanguage_win32, pTTEmbedInfo_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      let pul_status = unsafe { pul_status.assume_init() };
//      let pul_priv_status = unsafe { pul_priv_status.assume_init() };
//      Ok((real_return_value,pul_priv_status, pul_status))
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn tt_embed_font_from_file_a<Writeembedproc: FnMut(&mut todo_void, u32) -> u32>(h_dc: Hdc, sz_font_file_name: &CStr, us_ttc_index: u16, ul_flags: u32, ul_char_set: u32, lpfn_write_to_stream: Writeembedproc, pus_char_code_set: &u16, us_char_code_count: u16, us_language: u16, p_tt_embed_info: Option<&Ttembedinfo<'_>>) -> Result<(i32, u32, u32)> {
//      let mut pul_priv_status = mem::MaybeUninit::zeroed();
//      let pulPrivStatus_win32 = pul_priv_status.as_mut_ptr();
//      let mut pul_status = mem::MaybeUninit::zeroed();
//      let pulStatus_win32 = pul_status.as_mut_ptr();
//      let hDC_win32 = h_dc.into_raw();
//      let szFontFileName_win32 = sz_font_file_name.as_ptr() as _;
//      let usTTCIndex_win32 = us_ttc_index;
//      let ulFlags_win32 = ul_flags;
//      let ulCharSet_win32 = ul_char_set;
//      unsafe extern "system" fn writeembedproc_impl<Writeembedproc>(param0: *mut c_void, param1: *const c_void, param2: u32) -> u32 {
//          abort_on_panic(move || {
//              let input0 = unsafe { &mut *(param0 as *mut _) };
//              let input2 = param2;
//              let closure = unsafe {
//                  &mut *(param1 as usize as *mut Writeembedproc)
//              };
//              let return_value = (closure)(input0, input2);
//              let real_return_value = return_value;
//              real_return_value
//          })
//      }
//      let lpfnWriteToStream_win32 = Some(writeembedproc_impl::<Writeembedproc>);
//      let mut lpfn_write_to_stream = lpfn_write_to_stream;
//      let lpvWriteStream_win32 = (&mut lpfn_write_to_stream) as *mut _ as *mut _;
//      // SAFETY: type is a thin type
//      let pusCharCodeSet_win32 = unsafe { &*(pus_char_code_set as *const _ as *const _) };
//      let usCharCodeCount_win32 = us_char_code_count;
//      let usLanguage_win32 = us_language;
//      let temp60 = p_tt_embed_info.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
//      let pTTEmbedInfo_win32 = &temp60;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTEmbedFontFromFileA(hDC_win32, szFontFileName_win32, usTTCIndex_win32, ulFlags_win32, ulCharSet_win32, pulPrivStatus_win32, pulStatus_win32, lpfnWriteToStream_win32, lpvWriteStream_win32, pusCharCodeSet_win32, usCharCodeCount_win32, usLanguage_win32, pTTEmbedInfo_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      let pul_status = unsafe { pul_status.assume_init() };
//      let pul_priv_status = unsafe { pul_priv_status.assume_init() };
//      Ok((real_return_value,pul_priv_status, pul_status))
//  }
#[inline]
pub fn tt_enable_embedding_for_facename(lpsz_facename: &CStr, b_enable: BOOL) -> Result<i32> {
    let lpszFacename_win32 = lpsz_facename.as_ptr() as _;
    let bEnable_win32 = b_enable;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTEnableEmbeddingForFacename(lpszFacename_win32, bEnable_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn tt_get_embedded_font_info(ul_flags: u32, ul_privs: u32, lpfn_read_from_stream: Option<unsafe extern "system" fn(*mut c_void, *mut c_void, u32) -> u32>, lpv_read_stream: &todo_void, p_tt_load_info: Option<&Ttloadinfo<'_>>) -> Result<(i32, u32, u32)> {
//      let mut pul_priv_status = mem::MaybeUninit::zeroed();
//      let pulPrivStatus_win32 = pul_priv_status.as_mut_ptr();
//      let mut pul_status = mem::MaybeUninit::zeroed();
//      let pulStatus_win32 = pul_status.as_mut_ptr();
//      let ulFlags_win32 = ul_flags;
//      let ulPrivs_win32 = ul_privs;
//      let lpfnReadFromStream_win32 = lpfn_read_from_stream;
//      // SAFETY: type is a thin type
//      let lpvReadStream_win32 = unsafe { &*(lpv_read_stream as *const _ as *const _) };
//      let temp61 = p_tt_load_info.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
//      let pTTLoadInfo_win32 = &temp61;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTGetEmbeddedFontInfo(ulFlags_win32, pulPrivStatus_win32, ulPrivs_win32, pulStatus_win32, lpfnReadFromStream_win32, lpvReadStream_win32, pTTLoadInfo_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      let pul_status = unsafe { pul_status.assume_init() };
//      let pul_priv_status = unsafe { pul_priv_status.assume_init() };
//      Ok((real_return_value,pul_priv_status, pul_status))
//  }
#[inline]
pub fn tt_get_embedding_type(h_dc: Hdc, ) -> Result<(i32, u32)> {
    let mut pul_embed_type = mem::MaybeUninit::zeroed();
    let pulEmbedType_win32 = pul_embed_type.as_mut_ptr();
    let hDC_win32 = h_dc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTGetEmbeddingType(hDC_win32, pulEmbedType_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pul_embed_type = unsafe { pul_embed_type.assume_init() };
    Ok((real_return_value,pul_embed_type))
}
#[inline]
pub fn tt_get_new_font_name(ph_font_reference: &Handle, cch_max_win_name: i32, cch_max_mac_name: i32) -> Result<(i32, OsString, CString)> {
    let mut wz_win_family_name = Vec::<u16>::with_capacity(cch_max_mac_name as usize + 1);
    let wzWinFamilyName_win32 = wz_win_family_name.as_mut_ptr();
    let mut sz_mac_family_name = Vec::<u8>::with_capacity(cch_max_mac_name as usize + 1);
    let szMacFamilyName_win32 = sz_mac_family_name.as_mut_ptr();
    // SAFETY: type is a thin type
    let phFontReference_win32 = unsafe { &*(ph_font_reference as *const _ as *const _) };
    let cchMaxWinName_win32 = cch_max_win_name;
    let cchMaxMacName_win32 = cch_max_mac_name;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTGetNewFontName(phFontReference_win32, wzWinFamilyName_win32, cchMaxWinName_win32, szMacFamilyName_win32, cchMaxMacName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    sz_mac_family_name.truncate(return_value as usize);
    let sz_mac_family_name = unsafe { CString::from_vec_unchecked(sz_mac_family_name) };
    wz_win_family_name.truncate(return_value as usize);
    let wz_win_family_name = OsString::from_wide(&wz_win_family_name);
    Ok((real_return_value,wz_win_family_name, sz_mac_family_name))
}
#[inline]
pub fn tt_is_embedding_enabled(h_dc: Hdc, ) -> Result<(i32, BOOL)> {
    let mut pb_enabled = mem::MaybeUninit::zeroed();
    let pbEnabled_win32 = pb_enabled.as_mut_ptr();
    let hDC_win32 = h_dc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTIsEmbeddingEnabled(hDC_win32, pbEnabled_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pb_enabled = unsafe { pb_enabled.assume_init() };
    Ok((real_return_value,pb_enabled))
}
#[inline]
pub fn tt_is_embedding_enabled_for_facename(lpsz_facename: &CStr, ) -> Result<(i32, BOOL)> {
    let mut pb_enabled = mem::MaybeUninit::zeroed();
    let pbEnabled_win32 = pb_enabled.as_mut_ptr();
    let lpszFacename_win32 = lpsz_facename.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTIsEmbeddingEnabledForFacename(lpszFacename_win32, pbEnabled_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pb_enabled = unsafe { pb_enabled.assume_init() };
    Ok((real_return_value,pb_enabled))
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn tt_load_embedded_font(ul_flags: u32, ul_privs: u32, lpfn_read_from_stream: Option<unsafe extern "system" fn(*mut c_void, *mut c_void, u32) -> u32>, lpv_read_stream: &todo_void, sz_win_family_name: Option<&OsStr>, sz_mac_family_name: Option<&CStr>, p_tt_load_info: Option<&Ttloadinfo<'_>>) -> Result<(i32, Handle, u32, u32)> {
//      let mut ph_font_reference = mem::MaybeUninit::zeroed();
//      let phFontReference_win32 = ph_font_reference.as_mut_ptr();
//      let mut pul_priv_status = mem::MaybeUninit::zeroed();
//      let pulPrivStatus_win32 = pul_priv_status.as_mut_ptr();
//      let mut pul_status = mem::MaybeUninit::zeroed();
//      let pulStatus_win32 = pul_status.as_mut_ptr();
//      let ulFlags_win32 = ul_flags;
//      let ulPrivs_win32 = ul_privs;
//      let lpfnReadFromStream_win32 = lpfn_read_from_stream;
//      // SAFETY: type is a thin type
//      let lpvReadStream_win32 = unsafe { &*(lpv_read_stream as *const _ as *const _) };
//      let temp62 = sz_win_family_name.map(|val| {
//          let mut temp62: Vec<u16> = val.encode_wide().collect();
//          temp62.push(0);
//          temp62
//      });
//      let szWinFamilyName_win32 = temp62.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let szMacFamilyName_win32 = sz_mac_family_name.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let temp63 = p_tt_load_info.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
//      let pTTLoadInfo_win32 = &temp63;
//      let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTLoadEmbeddedFont(phFontReference_win32, ulFlags_win32, pulPrivStatus_win32, ulPrivs_win32, pulStatus_win32, lpfnReadFromStream_win32, lpvReadStream_win32, szWinFamilyName_win32, szMacFamilyName_win32, pTTLoadInfo_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      let pul_status = unsafe { pul_status.assume_init() };
//      let pul_priv_status = unsafe { pul_priv_status.assume_init() };
//      let ph_font_reference = unsafe { Handle::new(unsafe { ph_font_reference.assume_init() }) };
//      Ok((real_return_value,ph_font_reference, pul_priv_status, pul_status))
//  }
#[inline]
pub fn tt_run_validation_tests(h_dc: Hdc, p_test_param: &Ttvalidationtestsparams<'_>) -> Result<i32> {
    let hDC_win32 = h_dc.into_raw();
    let temp64 = p_test_param.to_win32();
    let pTestParam_win32 = &temp64;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTRunValidationTests(hDC_win32, pTestParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn tt_run_validation_tests_ex(h_dc: Hdc, p_test_param: &Ttvalidationtestsparamsex<'_>) -> Result<i32> {
    let hDC_win32 = h_dc.into_raw();
    let temp65 = p_test_param.to_win32();
    let pTestParam_win32 = &temp65;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TTRunValidationTestsEx(hDC_win32, pTestParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn tabbed_text_out_a(hdc: Hdc, x: i32, y: i32, lp_string: &CStr, ch_count: i32, n_tab_positions: i32, lpn_tab_stop_positions: Option<&[i32]>, ) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let lpString_win32 = lp_string.as_ptr() as _;
    let chCount_win32 = ch_count;
    let nTabPositions_win32 = n_tab_positions;
    let lpnTabStopPositions_win32 = lpn_tab_stop_positions.map_or(ptr::null(), |v| v.as_ptr() as _);
    let nTabOrigin_win32 = lpn_tab_stop_positions.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TabbedTextOutA(hdc_win32, x_win32, y_win32, lpString_win32, chCount_win32, nTabPositions_win32, lpnTabStopPositions_win32, nTabOrigin_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn tabbed_text_out_w(hdc: Hdc, x: i32, y: i32, lp_string: &OsStr, ch_count: i32, n_tab_positions: i32, lpn_tab_stop_positions: Option<&[i32]>, ) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let mut temp66: Vec<u16> = lp_string.encode_wide().collect();
    temp66.push(0);
    let lpString_win32 = temp66.as_ptr() as _;
    let chCount_win32 = ch_count;
    let nTabPositions_win32 = n_tab_positions;
    let lpnTabStopPositions_win32 = lpn_tab_stop_positions.map_or(ptr::null(), |v| v.as_ptr() as _);
    let nTabOrigin_win32 = lpn_tab_stop_positions.len() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TabbedTextOutW(hdc_win32, x_win32, y_win32, lpString_win32, chCount_win32, nTabPositions_win32, lpnTabStopPositions_win32, nTabOrigin_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn text_out_a(hdc: Hdc, x: i32, y: i32, lp_string: &CStr, c: i32) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let lpString_win32 = lp_string.as_ptr() as _;
    let c_win32 = c;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TextOutA(hdc_win32, x_win32, y_win32, lpString_win32, c_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn text_out_w(hdc: Hdc, x: i32, y: i32, lp_string: &OsStr, c: i32) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let x_win32 = x;
    let y_win32 = y;
    let mut temp67: Vec<u16> = lp_string.encode_wide().collect();
    temp67.push(0);
    let lpString_win32 = temp67.as_ptr() as _;
    let c_win32 = c;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TextOutW(hdc_win32, x_win32, y_win32, lpString_win32, c_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn transparent_blt(hdc_dest: Hdc, xorigin_dest: i32, yorigin_dest: i32, w_dest: i32, h_dest: i32, hdc_src: Hdc, xorigin_src: i32, yorigin_src: i32, w_src: i32, h_src: i32, cr_transparent: u32) -> Result<BOOL> {
    let hdcDest_win32 = hdc_dest.into_raw();
    let xoriginDest_win32 = xorigin_dest;
    let yoriginDest_win32 = yorigin_dest;
    let wDest_win32 = w_dest;
    let hDest_win32 = h_dest;
    let hdcSrc_win32 = hdc_src.into_raw();
    let xoriginSrc_win32 = xorigin_src;
    let yoriginSrc_win32 = yorigin_src;
    let wSrc_win32 = w_src;
    let hSrc_win32 = h_src;
    let crTransparent_win32 = cr_transparent;
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::TransparentBlt(hdcDest_win32, xoriginDest_win32, yoriginDest_win32, wDest_win32, hDest_win32, hdcSrc_win32, xoriginSrc_win32, yoriginSrc_win32, wSrc_win32, hSrc_win32, crTransparent_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn union_rect(lprc_src1: &Rect, lprc_src2: &Rect) -> Result<(BOOL, Rect)> {
    let mut lprc_dst = mem::MaybeUninit::zeroed();
    let lprcDst_win32 = lprc_dst.as_mut_ptr();
    // SAFETY: type is a thin type
    let lprcSrc1_win32 = unsafe { &*(lprc_src1 as *const _ as *const _) };
    // SAFETY: type is a thin type
    let lprcSrc2_win32 = unsafe { &*(lprc_src2 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::UnionRect(lprcDst_win32, lprcSrc1_win32, lprcSrc2_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lprc_dst = unsafe { Rect::from_win32(unsafe { lprc_dst.assume_init() }) };
    Ok((real_return_value,lprc_dst))
}
#[inline]
pub fn unrealize_object(h: Hgdiobj) -> Result<BOOL> {
    let h_win32 = h.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::UnrealizeObject(h_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn update_colors(hdc: Hdc) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::UpdateColors(hdc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn update_window(h_wnd: Hwnd) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::UpdateWindow(hWnd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn validate_rect(h_wnd: Option<Hwnd>, lp_rect: Option<&Rect>) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    // SAFETY: type is a thin type
    let lpRect_win32 = lp_rect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ValidateRect(hWnd_win32, lpRect_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn validate_rgn(h_wnd: Hwnd, h_rgn: Option<Hrgn>) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let hRgn_win32 = h_rgn.map_or(0, Hrgn::into_raw);
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::ValidateRgn(hWnd_win32, hRgn_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn widen_path(hdc: Hdc) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::WidenPath(hdc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn window_from_dc(h_dc: Hdc) -> Result<Hwnd> {
    let hDC_win32 = h_dc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::WindowFromDC(hDC_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn wgl_swap_multiple_buffers(param0: u32, param1: &Wglswap) -> u32 {
    let param0_win32 = param0;
    // SAFETY: type is a thin type
    let param1_win32 = unsafe { &*(param1 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::Gdi::wglSwapMultipleBuffers(param0_win32, param1_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn enable_mouse_in_pointer(f_enable: BOOL) -> BOOL {
    let fEnable_win32 = f_enable;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::EnableMouseInPointer(fEnable_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_pointer_cursor_id(pointer_id: u32, ) -> Result<(BOOL, u32)> {
    let mut cursor_id = mem::MaybeUninit::zeroed();
    let cursorId_win32 = cursor_id.as_mut_ptr();
    let pointerId_win32 = pointer_id;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerCursorId(pointerId_win32, cursorId_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let cursor_id = unsafe { cursor_id.assume_init() };
    Ok((real_return_value,cursor_id))
}
#[inline]
pub fn get_pointer_device(device: Handle, ) -> Result<(BOOL, PointerDeviceInfo)> {
    let mut pointer_device = mem::MaybeUninit::zeroed();
    let pointerDevice_win32 = pointer_device.as_mut_ptr();
    let device_win32 = device.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerDevice(device_win32, pointerDevice_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pointer_device = unsafe { PointerDeviceInfo::from_win32(unsafe { pointer_device.assume_init() }) };
    Ok((real_return_value,pointer_device))
}
#[inline]
pub fn get_pointer_device_cursors(device: Handle, cursor_count: u32, ) -> Result<(BOOL, u32, PointerDeviceCursorInfo)> {
    let mut device_cursors = mem::MaybeUninit::zeroed();
    let deviceCursors_win32 = device_cursors.as_mut_ptr();
    let device_win32 = device.into_raw();
    let mut cursorCount_win32 = cursor_count;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerDeviceCursors(device_win32, &mut cursorCount_win32, deviceCursors_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let device_cursors = unsafe { PointerDeviceCursorInfo::from_win32(unsafe { device_cursors.assume_init() }) };
    let cursor_count = cursorCount_win32;
    Ok((real_return_value,cursor_count, device_cursors))
}
#[inline]
pub fn get_pointer_device_properties(device: Handle, property_count: u32, ) -> Result<(BOOL, u32, PointerDeviceProperty)> {
    let mut pointer_properties = mem::MaybeUninit::zeroed();
    let pointerProperties_win32 = pointer_properties.as_mut_ptr();
    let device_win32 = device.into_raw();
    let mut propertyCount_win32 = property_count;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerDeviceProperties(device_win32, &mut propertyCount_win32, pointerProperties_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pointer_properties = unsafe { PointerDeviceProperty::from_win32(unsafe { pointer_properties.assume_init() }) };
    let property_count = propertyCount_win32;
    Ok((real_return_value,property_count, pointer_properties))
}
#[inline]
pub fn get_pointer_device_rects(device: Handle, ) -> Result<(BOOL, Rect, Rect)> {
    let mut pointer_device_rect = mem::MaybeUninit::zeroed();
    let pointerDeviceRect_win32 = pointer_device_rect.as_mut_ptr();
    let mut display_rect = mem::MaybeUninit::zeroed();
    let displayRect_win32 = display_rect.as_mut_ptr();
    let device_win32 = device.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerDeviceRects(device_win32, pointerDeviceRect_win32, displayRect_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let display_rect = unsafe { Rect::from_win32(unsafe { display_rect.assume_init() }) };
    let pointer_device_rect = unsafe { Rect::from_win32(unsafe { pointer_device_rect.assume_init() }) };
    Ok((real_return_value,pointer_device_rect, display_rect))
}
#[inline]
pub fn get_pointer_devices(device_count: u32, ) -> Result<(BOOL, u32, PointerDeviceInfo)> {
    let mut pointer_devices = mem::MaybeUninit::zeroed();
    let pointerDevices_win32 = pointer_devices.as_mut_ptr();
    let mut deviceCount_win32 = device_count;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerDevices(&mut deviceCount_win32, pointerDevices_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pointer_devices = unsafe { PointerDeviceInfo::from_win32(unsafe { pointer_devices.assume_init() }) };
    let device_count = deviceCount_win32;
    Ok((real_return_value,device_count, pointer_devices))
}
#[inline]
pub fn get_pointer_frame_info(pointer_id: u32, pointer_count: u32, ) -> Result<(BOOL, u32, PointerInfo)> {
    let mut pointer_info = mem::MaybeUninit::zeroed();
    let pointerInfo_win32 = pointer_info.as_mut_ptr();
    let pointerId_win32 = pointer_id;
    let mut pointerCount_win32 = pointer_count;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerFrameInfo(pointerId_win32, &mut pointerCount_win32, pointerInfo_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pointer_info = unsafe { PointerInfo::from_win32(unsafe { pointer_info.assume_init() }) };
    let pointer_count = pointerCount_win32;
    Ok((real_return_value,pointer_count, pointer_info))
}
#[inline]
pub fn get_pointer_frame_info_history(pointer_id: u32, entries_count: u32, pointer_count: u32, ) -> Result<(BOOL, u32, u32, PointerInfo)> {
    let mut pointer_info = mem::MaybeUninit::zeroed();
    let pointerInfo_win32 = pointer_info.as_mut_ptr();
    let pointerId_win32 = pointer_id;
    let mut entriesCount_win32 = entries_count;
    let mut pointerCount_win32 = pointer_count;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerFrameInfoHistory(pointerId_win32, &mut entriesCount_win32, &mut pointerCount_win32, pointerInfo_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pointer_info = unsafe { PointerInfo::from_win32(unsafe { pointer_info.assume_init() }) };
    let pointer_count = pointerCount_win32;
    let entries_count = entriesCount_win32;
    Ok((real_return_value,entries_count, pointer_count, pointer_info))
}
#[inline]
pub fn get_pointer_frame_pen_info(pointer_id: u32, pointer_count: u32, ) -> Result<(BOOL, u32, PointerPenInfo)> {
    let mut pen_info = mem::MaybeUninit::zeroed();
    let penInfo_win32 = pen_info.as_mut_ptr();
    let pointerId_win32 = pointer_id;
    let mut pointerCount_win32 = pointer_count;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerFramePenInfo(pointerId_win32, &mut pointerCount_win32, penInfo_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pen_info = unsafe { PointerPenInfo::from_win32(unsafe { pen_info.assume_init() }) };
    let pointer_count = pointerCount_win32;
    Ok((real_return_value,pointer_count, pen_info))
}
#[inline]
pub fn get_pointer_frame_pen_info_history(pointer_id: u32, entries_count: u32, pointer_count: u32, ) -> Result<(BOOL, u32, u32, PointerPenInfo)> {
    let mut pen_info = mem::MaybeUninit::zeroed();
    let penInfo_win32 = pen_info.as_mut_ptr();
    let pointerId_win32 = pointer_id;
    let mut entriesCount_win32 = entries_count;
    let mut pointerCount_win32 = pointer_count;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerFramePenInfoHistory(pointerId_win32, &mut entriesCount_win32, &mut pointerCount_win32, penInfo_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pen_info = unsafe { PointerPenInfo::from_win32(unsafe { pen_info.assume_init() }) };
    let pointer_count = pointerCount_win32;
    let entries_count = entriesCount_win32;
    Ok((real_return_value,entries_count, pointer_count, pen_info))
}
#[inline]
pub fn get_pointer_frame_touch_info(pointer_id: u32, pointer_count: u32, ) -> Result<(BOOL, u32, PointerTouchInfo)> {
    let mut touch_info = mem::MaybeUninit::zeroed();
    let touchInfo_win32 = touch_info.as_mut_ptr();
    let pointerId_win32 = pointer_id;
    let mut pointerCount_win32 = pointer_count;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerFrameTouchInfo(pointerId_win32, &mut pointerCount_win32, touchInfo_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let touch_info = unsafe { PointerTouchInfo::from_win32(unsafe { touch_info.assume_init() }) };
    let pointer_count = pointerCount_win32;
    Ok((real_return_value,pointer_count, touch_info))
}
#[inline]
pub fn get_pointer_frame_touch_info_history(pointer_id: u32, entries_count: u32, pointer_count: u32, ) -> Result<(BOOL, u32, u32, PointerTouchInfo)> {
    let mut touch_info = mem::MaybeUninit::zeroed();
    let touchInfo_win32 = touch_info.as_mut_ptr();
    let pointerId_win32 = pointer_id;
    let mut entriesCount_win32 = entries_count;
    let mut pointerCount_win32 = pointer_count;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerFrameTouchInfoHistory(pointerId_win32, &mut entriesCount_win32, &mut pointerCount_win32, touchInfo_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let touch_info = unsafe { PointerTouchInfo::from_win32(unsafe { touch_info.assume_init() }) };
    let pointer_count = pointerCount_win32;
    let entries_count = entriesCount_win32;
    Ok((real_return_value,entries_count, pointer_count, touch_info))
}
#[inline]
pub fn get_pointer_info(pointer_id: u32, ) -> Result<(BOOL, PointerInfo)> {
    let mut pointer_info = mem::MaybeUninit::zeroed();
    let pointerInfo_win32 = pointer_info.as_mut_ptr();
    let pointerId_win32 = pointer_id;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerInfo(pointerId_win32, pointerInfo_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pointer_info = unsafe { PointerInfo::from_win32(unsafe { pointer_info.assume_init() }) };
    Ok((real_return_value,pointer_info))
}
#[inline]
pub fn get_pointer_info_history(pointer_id: u32, entries_count: u32, ) -> Result<(BOOL, u32, PointerInfo)> {
    let mut pointer_info = mem::MaybeUninit::zeroed();
    let pointerInfo_win32 = pointer_info.as_mut_ptr();
    let pointerId_win32 = pointer_id;
    let mut entriesCount_win32 = entries_count;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerInfoHistory(pointerId_win32, &mut entriesCount_win32, pointerInfo_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pointer_info = unsafe { PointerInfo::from_win32(unsafe { pointer_info.assume_init() }) };
    let entries_count = entriesCount_win32;
    Ok((real_return_value,entries_count, pointer_info))
}
#[inline]
pub fn get_pointer_pen_info(pointer_id: u32, ) -> Result<(BOOL, PointerPenInfo)> {
    let mut pen_info = mem::MaybeUninit::zeroed();
    let penInfo_win32 = pen_info.as_mut_ptr();
    let pointerId_win32 = pointer_id;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerPenInfo(pointerId_win32, penInfo_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pen_info = unsafe { PointerPenInfo::from_win32(unsafe { pen_info.assume_init() }) };
    Ok((real_return_value,pen_info))
}
#[inline]
pub fn get_pointer_pen_info_history(pointer_id: u32, entries_count: u32, ) -> Result<(BOOL, u32, PointerPenInfo)> {
    let mut pen_info = mem::MaybeUninit::zeroed();
    let penInfo_win32 = pen_info.as_mut_ptr();
    let pointerId_win32 = pointer_id;
    let mut entriesCount_win32 = entries_count;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerPenInfoHistory(pointerId_win32, &mut entriesCount_win32, penInfo_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pen_info = unsafe { PointerPenInfo::from_win32(unsafe { pen_info.assume_init() }) };
    let entries_count = entriesCount_win32;
    Ok((real_return_value,entries_count, pen_info))
}
#[inline]
pub fn get_pointer_touch_info(pointer_id: u32, ) -> Result<(BOOL, PointerTouchInfo)> {
    let mut touch_info = mem::MaybeUninit::zeroed();
    let touchInfo_win32 = touch_info.as_mut_ptr();
    let pointerId_win32 = pointer_id;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerTouchInfo(pointerId_win32, touchInfo_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let touch_info = unsafe { PointerTouchInfo::from_win32(unsafe { touch_info.assume_init() }) };
    Ok((real_return_value,touch_info))
}
#[inline]
pub fn get_pointer_touch_info_history(pointer_id: u32, entries_count: u32, ) -> Result<(BOOL, u32, PointerTouchInfo)> {
    let mut touch_info = mem::MaybeUninit::zeroed();
    let touchInfo_win32 = touch_info.as_mut_ptr();
    let pointerId_win32 = pointer_id;
    let mut entriesCount_win32 = entries_count;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerTouchInfoHistory(pointerId_win32, &mut entriesCount_win32, touchInfo_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let touch_info = unsafe { PointerTouchInfo::from_win32(unsafe { touch_info.assume_init() }) };
    let entries_count = entriesCount_win32;
    Ok((real_return_value,entries_count, touch_info))
}
#[inline]
pub fn get_pointer_type(pointer_id: u32, ) -> Result<(BOOL, i32)> {
    let mut pointer_type = mem::MaybeUninit::zeroed();
    let pointerType_win32 = pointer_type.as_mut_ptr();
    let pointerId_win32 = pointer_id;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetPointerType(pointerId_win32, pointerType_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pointer_type = unsafe { pointer_type.assume_init() };
    Ok((real_return_value,pointer_type))
}
#[inline]
pub fn get_raw_pointer_device_data(pointer_id: u32, history_count: u32, p_properties: &[PointerDeviceProperty], ) -> Result<(BOOL, i32)> {
    let mut p_values = mem::MaybeUninit::zeroed();
    let pValues_win32 = p_values.as_mut_ptr();
    let pointerId_win32 = pointer_id;
    let historyCount_win32 = history_count;
    let pProperties_win32 = p_properties.as_ptr() as _;
    let propertiesCount_win32 = p_properties.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetRawPointerDeviceData(pointerId_win32, historyCount_win32, propertiesCount_win32, pProperties_win32, pValues_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let p_values = unsafe { p_values.assume_init() };
    Ok((real_return_value,p_values))
}
#[inline]
pub fn get_unpredicted_message_pos() -> u32 {
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::GetUnpredictedMessagePos() };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn initialize_touch_injection(max_count: u32, dw_mode: u32) -> Result<BOOL> {
    let maxCount_win32 = max_count;
    let dwMode_win32 = dw_mode;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::InitializeTouchInjection(maxCount_win32, dwMode_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn inject_synthetic_pointer_input(device: Hsyntheticpointerdevice, pointer_info: &[PointerTypeInfo], ) -> Result<BOOL> {
    let device_win32 = device.into_raw();
    let pointerInfo_win32 = pointer_info.as_ptr() as _;
    let count_win32 = pointer_info.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::InjectSyntheticPointerInput(device_win32, pointerInfo_win32, count_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn inject_touch_input(contacts: &[PointerTouchInfo]) -> Result<BOOL> {
    let contacts_win32 = contacts.as_ptr() as _;
    let count_win32 = contacts.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::InjectTouchInput(count_win32, contacts_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn is_mouse_in_pointer_enabled() -> BOOL {
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::IsMouseInPointerEnabled() };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn skip_pointer_frame_messages(pointer_id: u32) -> Result<BOOL> {
    let pointerId_win32 = pointer_id;
    let return_value = unsafe { windows_sys::Win32::UI::Input::Pointer::SkipPointerFrameMessages(pointerId_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn begin_buffered_animation(hwnd: Hwnd, hdc_target: Hdc, prc_target: &Rect, dw_format: i32, p_paint_params: Option<&BpPaintparams<'_>>, p_animation_params: &BpAnimationparams, ) -> (isize, Hdc, Hdc) {
    let mut phdc_from = mem::MaybeUninit::zeroed();
    let phdcFrom_win32 = phdc_from.as_mut_ptr();
    let mut phdc_to = mem::MaybeUninit::zeroed();
    let phdcTo_win32 = phdc_to.as_mut_ptr();
    let hwnd_win32 = hwnd.into_raw();
    let hdcTarget_win32 = hdc_target.into_raw();
    // SAFETY: type is a thin type
    let prcTarget_win32 = unsafe { &*(prc_target as *const _ as *const _) };
    let dwFormat_win32 = dw_format;
    let temp68 = p_paint_params.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
    let pPaintParams_win32 = &temp68;
    let temp69 = p_animation_params.to_win32();
    let pAnimationParams_win32 = &temp69;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::BeginBufferedAnimation(hwnd_win32, hdcTarget_win32, prcTarget_win32, dwFormat_win32, pPaintParams_win32, pAnimationParams_win32, phdcFrom_win32, phdcTo_win32) };
    let real_return_value = return_value;
    let phdc_to = unsafe { Hdc::new(unsafe { phdc_to.assume_init() }) };
    let phdc_from = unsafe { Hdc::new(unsafe { phdc_from.assume_init() }) };
    (real_return_value,phdc_from, phdc_to)
}
#[inline]
pub fn begin_buffered_paint(hdc_target: Hdc, prc_target: &Rect, dw_format: i32, p_paint_params: Option<&BpPaintparams<'_>>, ) -> (isize, Hdc) {
    let mut phdc = mem::MaybeUninit::zeroed();
    let phdc_win32 = phdc.as_mut_ptr();
    let hdcTarget_win32 = hdc_target.into_raw();
    // SAFETY: type is a thin type
    let prcTarget_win32 = unsafe { &*(prc_target as *const _ as *const _) };
    let dwFormat_win32 = dw_format;
    let temp70 = p_paint_params.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
    let pPaintParams_win32 = &temp70;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::BeginBufferedPaint(hdcTarget_win32, prcTarget_win32, dwFormat_win32, pPaintParams_win32, phdc_win32) };
    let real_return_value = return_value;
    let phdc = unsafe { Hdc::new(unsafe { phdc.assume_init() }) };
    (real_return_value,phdc)
}
#[inline]
pub fn begin_panning_feedback(hwnd: Hwnd) -> Result<BOOL> {
    let hwnd_win32 = hwnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::BeginPanningFeedback(hwnd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn buffered_paint_clear(h_buffered_paint: isize, prc: Option<&Rect>) -> HRESULT {
    let hBufferedPaint_win32 = h_buffered_paint;
    // SAFETY: type is a thin type
    let prc_win32 = prc.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let return_value = unsafe { windows_sys::Win32::UI::Controls::BufferedPaintClear(hBufferedPaint_win32, prc_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn buffered_paint_init() -> HRESULT {
    let return_value = unsafe { windows_sys::Win32::UI::Controls::BufferedPaintInit() };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn buffered_paint_render_animation(hwnd: Hwnd, hdc_target: Hdc) -> Result<BOOL> {
    let hwnd_win32 = hwnd.into_raw();
    let hdcTarget_win32 = hdc_target.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::BufferedPaintRenderAnimation(hwnd_win32, hdcTarget_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn buffered_paint_set_alpha(h_buffered_paint: isize, prc: Option<&Rect>, alpha: u8) -> HRESULT {
    let hBufferedPaint_win32 = h_buffered_paint;
    // SAFETY: type is a thin type
    let prc_win32 = prc.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let alpha_win32 = alpha;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::BufferedPaintSetAlpha(hBufferedPaint_win32, prc_win32, alpha_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn buffered_paint_stop_all_animations(hwnd: Hwnd) -> HRESULT {
    let hwnd_win32 = hwnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::BufferedPaintStopAllAnimations(hwnd_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn buffered_paint_un_init() -> HRESULT {
    let return_value = unsafe { windows_sys::Win32::UI::Controls::BufferedPaintUnInit() };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn check_dlg_button(h_dlg: Hwnd, n_id_button: i32, u_check: u32) -> Result<BOOL> {
    let hDlg_win32 = h_dlg.into_raw();
    let nIDButton_win32 = n_id_button;
    let uCheck_win32 = u_check;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::CheckDlgButton(hDlg_win32, nIDButton_win32, uCheck_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn check_radio_button(h_dlg: Hwnd, n_id_first_button: i32, n_id_last_button: i32, n_id_check_button: i32) -> Result<BOOL> {
    let hDlg_win32 = h_dlg.into_raw();
    let nIDFirstButton_win32 = n_id_first_button;
    let nIDLastButton_win32 = n_id_last_button;
    let nIDCheckButton_win32 = n_id_check_button;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::CheckRadioButton(hDlg_win32, nIDFirstButton_win32, nIDLastButton_win32, nIDCheckButton_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn close_theme_data(h_theme: isize) -> HRESULT {
    let hTheme_win32 = h_theme;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::CloseThemeData(hTheme_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn create_mapped_bitmap(h_instance: Hinstance, id_bitmap: isize, w_flags: u32, lp_color_map: Option<&Colormap>, i_num_maps: i32) -> Result<Hbitmap> {
    let hInstance_win32 = h_instance.into_raw();
    let idBitmap_win32 = id_bitmap;
    let wFlags_win32 = w_flags;
    // SAFETY: type is a thin type
    let lpColorMap_win32 = lp_color_map.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let iNumMaps_win32 = i_num_maps;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::CreateMappedBitmap(hInstance_win32, idBitmap_win32, wFlags_win32, lpColorMap_win32, iNumMaps_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hbitmap::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_status_window_a(style: i32, lpsz_text: &CStr, hwnd_parent: Hwnd, w_id: u32) -> Result<Hwnd> {
    let style_win32 = style;
    let lpszText_win32 = lpsz_text.as_ptr() as _;
    let hwndParent_win32 = hwnd_parent.into_raw();
    let wID_win32 = w_id;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::CreateStatusWindowA(style_win32, lpszText_win32, hwndParent_win32, wID_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_status_window_w(style: i32, lpsz_text: &OsStr, hwnd_parent: Hwnd, w_id: u32) -> Result<Hwnd> {
    let style_win32 = style;
    let mut temp71: Vec<u16> = lpsz_text.encode_wide().collect();
    temp71.push(0);
    let lpszText_win32 = temp71.as_ptr() as _;
    let hwndParent_win32 = hwnd_parent.into_raw();
    let wID_win32 = w_id;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::CreateStatusWindowW(style_win32, lpszText_win32, hwndParent_win32, wID_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_synthetic_pointer_device(pointer_type: i32, max_count: u32, mode: i32) -> Result<Hsyntheticpointerdevice> {
    let pointerType_win32 = pointer_type;
    let maxCount_win32 = max_count;
    let mode_win32 = mode;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::CreateSyntheticPointerDevice(pointerType_win32, maxCount_win32, mode_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hsyntheticpointerdevice::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_toolbar_ex(hwnd: Hwnd, ws: u32, w_id: u32, n_bitmaps: i32, h_bm_inst: Hinstance, w_bmid: usize, lp_buttons: Tbbutton, i_num_buttons: i32, dx_button: i32, dy_button: i32, dx_bitmap: i32, dy_bitmap: i32, u_struct_size: u32) -> Result<(Hwnd, Tbbutton)> {
    let hwnd_win32 = hwnd.into_raw();
    let ws_win32 = ws;
    let wID_win32 = w_id;
    let nBitmaps_win32 = n_bitmaps;
    let hBMInst_win32 = h_bm_inst.into_raw();
    let wBMID_win32 = w_bmid;
    let mut lpButtons_win32 = lp_buttons.to_win32();
    let iNumButtons_win32 = i_num_buttons;
    let dxButton_win32 = dx_button;
    let dyButton_win32 = dy_button;
    let dxBitmap_win32 = dx_bitmap;
    let dyBitmap_win32 = dy_bitmap;
    let uStructSize_win32 = u_struct_size;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::CreateToolbarEx(hwnd_win32, ws_win32, wID_win32, nBitmaps_win32, hBMInst_win32, wBMID_win32, &mut lpButtons_win32, iNumButtons_win32, dxButton_win32, dyButton_win32, dxBitmap_win32, dyBitmap_win32, uStructSize_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    let lp_buttons = unsafe { Tbbutton::from_win32(lpButtons_win32) };
    Ok((real_return_value,lp_buttons))
}
#[inline]
pub fn create_up_down_control(dw_style: u32, x: i32, y: i32, cx: i32, cy: i32, h_parent: Hwnd, n_id: i32, h_inst: Hinstance, h_buddy: Hwnd, n_upper: i32, n_lower: i32, n_pos: i32) -> Result<Hwnd> {
    let dwStyle_win32 = dw_style;
    let x_win32 = x;
    let y_win32 = y;
    let cx_win32 = cx;
    let cy_win32 = cy;
    let hParent_win32 = h_parent.into_raw();
    let nID_win32 = n_id;
    let hInst_win32 = h_inst.into_raw();
    let hBuddy_win32 = h_buddy.into_raw();
    let nUpper_win32 = n_upper;
    let nLower_win32 = n_lower;
    let nPos_win32 = n_pos;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::CreateUpDownControl(dwStyle_win32, x_win32, y_win32, cx_win32, cy_win32, hParent_win32, nID_win32, hInst_win32, hBuddy_win32, nUpper_win32, nLower_win32, nPos_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn dpa_clone(hdpa: Hdpa, hdpa_new: Option<Hdpa>) -> Result<Hdpa> {
    let hdpa_win32 = hdpa.into_raw();
    let hdpaNew_win32 = hdpa_new.map_or(0, Hdpa::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_Clone(hdpa_win32, hdpaNew_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hdpa::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn dpa_create(c_item_grow: i32) -> Result<Hdpa> {
    let cItemGrow_win32 = c_item_grow;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_Create(cItemGrow_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hdpa::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn dpa_create_ex(cp_grow: i32, hheap: Option<Handle>) -> Result<Hdpa> {
    let cpGrow_win32 = cp_grow;
    let hheap_win32 = hheap.map_or(0, Handle::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_CreateEx(cpGrow_win32, hheap_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hdpa::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn dpa_delete_all_ptrs(hdpa: Hdpa) -> Result<BOOL> {
    let hdpa_win32 = hdpa.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_DeleteAllPtrs(hdpa_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dpa_delete_ptr(hdpa: Hdpa, i: i32) -> &mut todo_void_ret {
//      let hdpa_win32 = hdpa.into_raw();
//      let i_win32 = i;
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_DeletePtr(hdpa_win32, i_win32) };
//      let real_return_value = unsafe { &mut *(return_value as *mut _) };
//      real_return_value
//  }
#[inline]
pub fn dpa_destroy(hdpa: Option<Hdpa>) -> Result<BOOL> {
    let hdpa_win32 = hdpa.map_or(0, Hdpa::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_Destroy(hdpa_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dpa_destroy_callback<Pfndaenumcallback: FnMut() -> i32>(hdpa: Option<Hdpa>, pfn_cb: Pfndaenumcallback, ) -> () {
//      let hdpa_win32 = hdpa.map_or(0, Hdpa::into_raw);
//      unsafe extern "system" fn pfndaenumcallback_impl<Pfndaenumcallback>(param0: *const c_void, param1: *const c_void) -> i32 {
//          abort_on_panic(move || {
//              let closure = unsafe {
//                  &mut *(param0 as usize as *mut Pfndaenumcallback)
//              };
//              let return_value = (closure)();
//              let real_return_value = return_value;
//              real_return_value
//          })
//      }
//      let pfnCB_win32 = Some(pfndaenumcallback_impl::<Pfndaenumcallback>);
//      let mut pfn_cb = pfn_cb;
//      let pData_win32 = (&mut pfn_cb) as *mut _ as *mut _;
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_DestroyCallback(hdpa_win32, pfnCB_win32, pData_win32) };
//      let _ = return_value;
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dpa_enum_callback<Pfndaenumcallback: FnMut() -> i32>(hdpa: Option<Hdpa>, pfn_cb: Option<Pfndaenumcallback>, ) -> () {
//      let hdpa_win32 = hdpa.map_or(0, Hdpa::into_raw);
//      unsafe extern "system" fn pfndaenumcallback_impl<Pfndaenumcallback>(param0: *const c_void, param1: *const c_void) -> i32 {
//          abort_on_panic(move || {
//              let closure = unsafe {
//                  &mut *(param0 as usize as *mut Pfndaenumcallback)
//              };
//              let return_value = (closure)();
//              let real_return_value = return_value;
//              real_return_value
//          })
//      }
//      let pfnCB_win32 = Some(pfndaenumcallback_impl::<Pfndaenumcallback>);
//      let mut pfn_cb = pfn_cb;
//      let pData_win32 = (&mut pfn_cb) as *mut _ as *mut _;
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_EnumCallback(hdpa_win32, pfnCB_win32, pData_win32) };
//      let _ = return_value;
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dpa_get_ptr(hdpa: Hdpa, i: isize) -> &mut todo_void_ret {
//      let hdpa_win32 = hdpa.into_raw();
//      let i_win32 = i;
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_GetPtr(hdpa_win32, i_win32) };
//      let real_return_value = unsafe { &mut *(return_value as *mut _) };
//      real_return_value
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dpa_get_ptr_index(hdpa: Hdpa, p: Option<&todo_void>) -> Result<i32> {
//      let hdpa_win32 = hdpa.into_raw();
//      // SAFETY: type is a thin type
//      let p_win32 = p.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_GetPtrIndex(hdpa_win32, p_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      Ok(real_return_value)
//  }
#[inline]
pub fn dpa_get_size(hdpa: Option<Hdpa>) -> u64 {
    let hdpa_win32 = hdpa.map_or(0, Hdpa::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_GetSize(hdpa_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn dpa_grow(pdpa: Hdpa, cp: i32) -> Result<BOOL> {
    let pdpa_win32 = pdpa.into_raw();
    let cp_win32 = cp;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_Grow(pdpa_win32, cp_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dpa_insert_ptr(hdpa: Hdpa, i: i32, p: Option<&todo_void>) -> Result<i32> {
//      let hdpa_win32 = hdpa.into_raw();
//      let i_win32 = i;
//      // SAFETY: type is a thin type
//      let p_win32 = p.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_InsertPtr(hdpa_win32, i_win32, p_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      Ok(real_return_value)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dpa_merge<Pfndpamerge: FnMut(u32, &todo_void, &todo_void, ) -> &mut todo_void_ret>(hdpa_dest: Hdpa, hdpa_src: Hdpa, dw_flags: u32, pfn_compare: Option<unsafe extern "system" fn(*const c_void, *const c_void, LPARAM) -> i32>, pfn_merge: Pfndpamerge, ) -> Result<BOOL> {
//      let hdpaDest_win32 = hdpa_dest.into_raw();
//      let hdpaSrc_win32 = hdpa_src.into_raw();
//      let dwFlags_win32 = dw_flags;
//      let pfnCompare_win32 = pfn_compare;
//      unsafe extern "system" fn pfndpamerge_impl<Pfndpamerge>(param0: u32, param1: *const c_void, param2: *const c_void, param3: LPARAM) -> *mut c_void {
//          abort_on_panic(move || {
//              let input0 = param0;
//              let input1 = unsafe { &*(param1 as *const _) };
//              let input2 = unsafe { &*(param2 as *const _) };
//              let closure = unsafe {
//                  &mut *(param3 as usize as *mut Pfndpamerge)
//              };
//              let return_value = (closure)(input0, input1, input2, );
//              let mut temp72 = todo_void;
//              let real_return_value = &mut temp72;
//              real_return_value
//          })
//      }
//      let pfnMerge_win32 = Some(pfndpamerge_impl::<Pfndpamerge>);
//      let mut pfn_merge = pfn_merge;
//      let lParam_win32 = unsafe { Lparam::from_ptr((&mut pfn_merge) as *mut _ as *mut _) };
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_Merge(hdpaDest_win32, hdpaSrc_win32, dwFlags_win32, pfnCompare_win32, pfnMerge_win32, lParam_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      Ok(real_return_value)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dpa_search<Pfndacompare: FnMut(&todo_void, &todo_void, ) -> i32>(hdpa: Hdpa, p_find: Option<&todo_void>, i_start: i32, pfn_compare: Pfndacompare, options: u32) -> Result<i32> {
//      let hdpa_win32 = hdpa.into_raw();
//      // SAFETY: type is a thin type
//      let pFind_win32 = p_find.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      let iStart_win32 = i_start;
//      unsafe extern "system" fn pfndacompare_impl<Pfndacompare>(param0: *const c_void, param1: *const c_void, param2: LPARAM) -> i32 {
//          abort_on_panic(move || {
//              let input0 = unsafe { &*(param0 as *const _) };
//              let input1 = unsafe { &*(param1 as *const _) };
//              let closure = unsafe {
//                  &mut *(param2 as usize as *mut Pfndacompare)
//              };
//              let return_value = (closure)(input0, input1, );
//              let real_return_value = return_value;
//              real_return_value
//          })
//      }
//      let pfnCompare_win32 = Some(pfndacompare_impl::<Pfndacompare>);
//      let mut pfn_compare = pfn_compare;
//      let lParam_win32 = unsafe { Lparam::from_ptr((&mut pfn_compare) as *mut _ as *mut _) };
//      let options_win32 = options;
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_Search(hdpa_win32, pFind_win32, iStart_win32, pfnCompare_win32, lParam_win32, options_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      Ok(real_return_value)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dpa_set_ptr(hdpa: Hdpa, i: i32, p: Option<&todo_void>) -> Result<BOOL> {
//      let hdpa_win32 = hdpa.into_raw();
//      let i_win32 = i;
//      // SAFETY: type is a thin type
//      let p_win32 = p.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_SetPtr(hdpa_win32, i_win32, p_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      Ok(real_return_value)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dpa_sort<Pfndacompare: FnMut(&todo_void, &todo_void, ) -> i32>(hdpa: Hdpa, pfn_compare: Pfndacompare, ) -> Result<BOOL> {
//      let hdpa_win32 = hdpa.into_raw();
//      unsafe extern "system" fn pfndacompare_impl<Pfndacompare>(param0: *const c_void, param1: *const c_void, param2: LPARAM) -> i32 {
//          abort_on_panic(move || {
//              let input0 = unsafe { &*(param0 as *const _) };
//              let input1 = unsafe { &*(param1 as *const _) };
//              let closure = unsafe {
//                  &mut *(param2 as usize as *mut Pfndacompare)
//              };
//              let return_value = (closure)(input0, input1, );
//              let real_return_value = return_value;
//              real_return_value
//          })
//      }
//      let pfnCompare_win32 = Some(pfndacompare_impl::<Pfndacompare>);
//      let mut pfn_compare = pfn_compare;
//      let lParam_win32 = unsafe { Lparam::from_ptr((&mut pfn_compare) as *mut _ as *mut _) };
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DPA_Sort(hdpa_win32, pfnCompare_win32, lParam_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      Ok(real_return_value)
//  }
#[inline]
pub fn dsa_clone(hdsa: Hdsa) -> Result<Hdsa> {
    let hdsa_win32 = hdsa.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_Clone(hdsa_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hdsa::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn dsa_create(cb_item: i32, c_item_grow: i32) -> Result<Hdsa> {
    let cbItem_win32 = cb_item;
    let cItemGrow_win32 = c_item_grow;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_Create(cbItem_win32, cItemGrow_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hdsa::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn dsa_delete_all_items(hdsa: Hdsa) -> Result<BOOL> {
    let hdsa_win32 = hdsa.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_DeleteAllItems(hdsa_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn dsa_delete_item(hdsa: Hdsa, i: i32) -> Result<BOOL> {
    let hdsa_win32 = hdsa.into_raw();
    let i_win32 = i;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_DeleteItem(hdsa_win32, i_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn dsa_destroy(hdsa: Option<Hdsa>) -> Result<BOOL> {
    let hdsa_win32 = hdsa.map_or(0, Hdsa::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_Destroy(hdsa_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dsa_destroy_callback<Pfndaenumcallback: FnMut() -> i32>(hdsa: Option<Hdsa>, pfn_cb: Pfndaenumcallback, ) -> () {
//      let hdsa_win32 = hdsa.map_or(0, Hdsa::into_raw);
//      unsafe extern "system" fn pfndaenumcallback_impl<Pfndaenumcallback>(param0: *const c_void, param1: *const c_void) -> i32 {
//          abort_on_panic(move || {
//              let closure = unsafe {
//                  &mut *(param0 as usize as *mut Pfndaenumcallback)
//              };
//              let return_value = (closure)();
//              let real_return_value = return_value;
//              real_return_value
//          })
//      }
//      let pfnCB_win32 = Some(pfndaenumcallback_impl::<Pfndaenumcallback>);
//      let mut pfn_cb = pfn_cb;
//      let pData_win32 = (&mut pfn_cb) as *mut _ as *mut _;
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_DestroyCallback(hdsa_win32, pfnCB_win32, pData_win32) };
//      let _ = return_value;
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dsa_enum_callback<Pfndaenumcallback: FnMut() -> i32>(hdsa: Hdsa, pfn_cb: Pfndaenumcallback, ) -> () {
//      let hdsa_win32 = hdsa.into_raw();
//      unsafe extern "system" fn pfndaenumcallback_impl<Pfndaenumcallback>(param0: *const c_void, param1: *const c_void) -> i32 {
//          abort_on_panic(move || {
//              let closure = unsafe {
//                  &mut *(param0 as usize as *mut Pfndaenumcallback)
//              };
//              let return_value = (closure)();
//              let real_return_value = return_value;
//              real_return_value
//          })
//      }
//      let pfnCB_win32 = Some(pfndaenumcallback_impl::<Pfndaenumcallback>);
//      let mut pfn_cb = pfn_cb;
//      let pData_win32 = (&mut pfn_cb) as *mut _ as *mut _;
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_EnumCallback(hdsa_win32, pfnCB_win32, pData_win32) };
//      let _ = return_value;
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dsa_get_item(hdsa: Hdsa, i: i32, ) -> Result<(BOOL, todo_void_ret)> {
//      let mut pitem = mem::MaybeUninit::zeroed();
//      let pitem_win32 = pitem.as_mut_ptr();
//      let hdsa_win32 = hdsa.into_raw();
//      let i_win32 = i;
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_GetItem(hdsa_win32, i_win32, pitem_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      let pitem = todo_void;
//      Ok((real_return_value,pitem))
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dsa_get_item_ptr(hdsa: Hdsa, i: i32) -> &mut todo_void_ret {
//      let hdsa_win32 = hdsa.into_raw();
//      let i_win32 = i;
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_GetItemPtr(hdsa_win32, i_win32) };
//      let real_return_value = unsafe { &mut *(return_value as *mut _) };
//      real_return_value
//  }
#[inline]
pub fn dsa_get_size(hdsa: Option<Hdsa>) -> u64 {
    let hdsa_win32 = hdsa.map_or(0, Hdsa::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_GetSize(hdsa_win32) };
    let real_return_value = return_value;
    real_return_value
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dsa_insert_item(hdsa: Hdsa, i: i32, pitem: &todo_void) -> Result<i32> {
//      let hdsa_win32 = hdsa.into_raw();
//      let i_win32 = i;
//      // SAFETY: type is a thin type
//      let pitem_win32 = unsafe { &*(pitem as *const _ as *const _) };
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_InsertItem(hdsa_win32, i_win32, pitem_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      Ok(real_return_value)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dsa_set_item(hdsa: Hdsa, i: i32, pitem: &todo_void) -> Result<BOOL> {
//      let hdsa_win32 = hdsa.into_raw();
//      let i_win32 = i;
//      // SAFETY: type is a thin type
//      let pitem_win32 = unsafe { &*(pitem as *const _ as *const _) };
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_SetItem(hdsa_win32, i_win32, pitem_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      Ok(real_return_value)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn dsa_sort<Pfndacompare: FnMut(&todo_void, &todo_void, ) -> i32>(pdsa: Hdsa, pfn_compare: Pfndacompare, ) -> Result<BOOL> {
//      let pdsa_win32 = pdsa.into_raw();
//      unsafe extern "system" fn pfndacompare_impl<Pfndacompare>(param0: *const c_void, param1: *const c_void, param2: LPARAM) -> i32 {
//          abort_on_panic(move || {
//              let input0 = unsafe { &*(param0 as *const _) };
//              let input1 = unsafe { &*(param1 as *const _) };
//              let closure = unsafe {
//                  &mut *(param2 as usize as *mut Pfndacompare)
//              };
//              let return_value = (closure)(input0, input1, );
//              let real_return_value = return_value;
//              real_return_value
//          })
//      }
//      let pfnCompare_win32 = Some(pfndacompare_impl::<Pfndacompare>);
//      let mut pfn_compare = pfn_compare;
//      let lParam_win32 = unsafe { Lparam::from_ptr((&mut pfn_compare) as *mut _ as *mut _) };
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::DSA_Sort(pdsa_win32, pfnCompare_win32, lParam_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      Ok(real_return_value)
//  }
#[inline]
pub fn destroy_synthetic_pointer_device(device: Hsyntheticpointerdevice) -> () {
    let device_win32 = device.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DestroySyntheticPointerDevice(device_win32) };
    let _ = return_value;
}
#[inline]
pub fn dlg_dir_list_a(h_dlg: Hwnd, lp_path_spec: &CStr, n_id_list_box: i32, n_id_static_path: i32, u_file_type: u32) -> Result<(i32, CString)> {
    let hDlg_win32 = h_dlg.into_raw();
    let mut lpPathSpec_win32 = lp_path_spec.as_ptr() as _;
    let nIDListBox_win32 = n_id_list_box;
    let nIDStaticPath_win32 = n_id_static_path;
    let uFileType_win32 = u_file_type;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DlgDirListA(hDlg_win32, &mut lpPathSpec_win32, nIDListBox_win32, nIDStaticPath_win32, uFileType_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    lpPathSpec_win32.truncate(return_value as usize);
    let lp_path_spec = unsafe { CString::from_vec_unchecked(lpPathSpec_win32) };
    Ok((real_return_value,lp_path_spec))
}
#[inline]
pub fn dlg_dir_list_combo_box_a(h_dlg: Hwnd, lp_path_spec: &CStr, n_id_combo_box: i32, n_id_static_path: i32, u_filetype: u32) -> Result<(i32, CString)> {
    let hDlg_win32 = h_dlg.into_raw();
    let mut lpPathSpec_win32 = lp_path_spec.as_ptr() as _;
    let nIDComboBox_win32 = n_id_combo_box;
    let nIDStaticPath_win32 = n_id_static_path;
    let uFiletype_win32 = u_filetype;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DlgDirListComboBoxA(hDlg_win32, &mut lpPathSpec_win32, nIDComboBox_win32, nIDStaticPath_win32, uFiletype_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    lpPathSpec_win32.truncate(return_value as usize);
    let lp_path_spec = unsafe { CString::from_vec_unchecked(lpPathSpec_win32) };
    Ok((real_return_value,lp_path_spec))
}
#[inline]
pub fn dlg_dir_list_combo_box_w(h_dlg: Hwnd, lp_path_spec: &OsStr, n_id_combo_box: i32, n_id_static_path: i32, u_filetype: u32) -> Result<(i32, OsString)> {
    let hDlg_win32 = h_dlg.into_raw();
    let mut temp73: Vec<u16> = lp_path_spec.encode_wide().collect();
    temp73.push(0);
    let mut lpPathSpec_win32 = temp73.as_ptr() as _;
    let nIDComboBox_win32 = n_id_combo_box;
    let nIDStaticPath_win32 = n_id_static_path;
    let uFiletype_win32 = u_filetype;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DlgDirListComboBoxW(hDlg_win32, &mut lpPathSpec_win32, nIDComboBox_win32, nIDStaticPath_win32, uFiletype_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    lpPathSpec_win32.truncate(return_value as usize);
    let lp_path_spec = OsString::from_wide(&lpPathSpec_win32);
    Ok((real_return_value,lp_path_spec))
}
#[inline]
pub fn dlg_dir_list_w(h_dlg: Hwnd, lp_path_spec: &OsStr, n_id_list_box: i32, n_id_static_path: i32, u_file_type: u32) -> Result<(i32, OsString)> {
    let hDlg_win32 = h_dlg.into_raw();
    let mut temp74: Vec<u16> = lp_path_spec.encode_wide().collect();
    temp74.push(0);
    let mut lpPathSpec_win32 = temp74.as_ptr() as _;
    let nIDListBox_win32 = n_id_list_box;
    let nIDStaticPath_win32 = n_id_static_path;
    let uFileType_win32 = u_file_type;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DlgDirListW(hDlg_win32, &mut lpPathSpec_win32, nIDListBox_win32, nIDStaticPath_win32, uFileType_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    lpPathSpec_win32.truncate(return_value as usize);
    let lp_path_spec = OsString::from_wide(&lpPathSpec_win32);
    Ok((real_return_value,lp_path_spec))
}
#[inline]
pub fn dlg_dir_select_combo_box_ex_a(hwnd_dlg: Hwnd, cch_out: i32, id_combo_box: i32) -> Result<(BOOL, CString)> {
    let mut lp_string = Vec::<u8>::with_capacity(cch_out as usize + 1);
    let lpString_win32 = lp_string.as_mut_ptr();
    let hwndDlg_win32 = hwnd_dlg.into_raw();
    let cchOut_win32 = cch_out;
    let idComboBox_win32 = id_combo_box;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DlgDirSelectComboBoxExA(hwndDlg_win32, lpString_win32, cchOut_win32, idComboBox_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    lp_string.truncate(return_value as usize);
    let lp_string = unsafe { CString::from_vec_unchecked(lp_string) };
    Ok((real_return_value,lp_string))
}
#[inline]
pub fn dlg_dir_select_combo_box_ex_w(hwnd_dlg: Hwnd, cch_out: i32, id_combo_box: i32) -> Result<(BOOL, OsString)> {
    let mut lp_string = Vec::<u16>::with_capacity(cch_out as usize + 1);
    let lpString_win32 = lp_string.as_mut_ptr();
    let hwndDlg_win32 = hwnd_dlg.into_raw();
    let cchOut_win32 = cch_out;
    let idComboBox_win32 = id_combo_box;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DlgDirSelectComboBoxExW(hwndDlg_win32, lpString_win32, cchOut_win32, idComboBox_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    lp_string.truncate(return_value as usize);
    let lp_string = OsString::from_wide(&lp_string);
    Ok((real_return_value,lp_string))
}
#[inline]
pub fn dlg_dir_select_ex_a(hwnd_dlg: Hwnd, ch_count: i32, id_list_box: i32) -> Result<(BOOL, CString)> {
    let mut lp_string = Vec::<u8>::with_capacity(ch_count as usize + 1);
    let lpString_win32 = lp_string.as_mut_ptr();
    let hwndDlg_win32 = hwnd_dlg.into_raw();
    let chCount_win32 = ch_count;
    let idListBox_win32 = id_list_box;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DlgDirSelectExA(hwndDlg_win32, lpString_win32, chCount_win32, idListBox_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    lp_string.truncate(return_value as usize);
    let lp_string = unsafe { CString::from_vec_unchecked(lp_string) };
    Ok((real_return_value,lp_string))
}
#[inline]
pub fn dlg_dir_select_ex_w(hwnd_dlg: Hwnd, ch_count: i32, id_list_box: i32) -> Result<(BOOL, OsString)> {
    let mut lp_string = Vec::<u16>::with_capacity(ch_count as usize + 1);
    let lpString_win32 = lp_string.as_mut_ptr();
    let hwndDlg_win32 = hwnd_dlg.into_raw();
    let chCount_win32 = ch_count;
    let idListBox_win32 = id_list_box;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DlgDirSelectExW(hwndDlg_win32, lpString_win32, chCount_win32, idListBox_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    lp_string.truncate(return_value as usize);
    let lp_string = OsString::from_wide(&lp_string);
    Ok((real_return_value,lp_string))
}
#[inline]
pub fn draw_insert(hand_parent: Hwnd, h_lb: Hwnd, n_item: i32) -> () {
    let handParent_win32 = hand_parent.into_raw();
    let hLB_win32 = h_lb.into_raw();
    let nItem_win32 = n_item;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DrawInsert(handParent_win32, hLB_win32, nItem_win32) };
    let _ = return_value;
}
#[inline]
pub fn draw_shadow_text(hdc: Hdc, psz_text: &OsStr, cch: u32, prc: &[Rect], dw_flags: u32, cr_text: u32, ix_offset: i32, iy_offset: i32) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let mut temp75: Vec<u16> = psz_text.encode_wide().collect();
    temp75.push(0);
    let pszText_win32 = temp75.as_ptr() as _;
    let cch_win32 = cch;
    let prc_win32 = prc.as_ptr() as _;
    let crShadow_win32 = prc.len() as _;
    let dwFlags_win32 = dw_flags;
    let crText_win32 = cr_text;
    let ixOffset_win32 = ix_offset;
    let iyOffset_win32 = iy_offset;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DrawShadowText(hdc_win32, pszText_win32, cch_win32, prc_win32, dwFlags_win32, crText_win32, crShadow_win32, ixOffset_win32, iyOffset_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn draw_status_text_a(h_dc: Hdc, lprc: Rect, psz_text: &CStr, u_flags: u32) -> Rect {
    let hDC_win32 = h_dc.into_raw();
    let mut lprc_win32 = lprc.to_win32();
    let pszText_win32 = psz_text.as_ptr() as _;
    let uFlags_win32 = u_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DrawStatusTextA(hDC_win32, &mut lprc_win32, pszText_win32, uFlags_win32) };
    let lprc = unsafe { Rect::from_win32(lprc_win32) };
    lprc
}
#[inline]
pub fn draw_status_text_w(h_dc: Hdc, lprc: Rect, psz_text: &OsStr, u_flags: u32) -> Rect {
    let hDC_win32 = h_dc.into_raw();
    let mut lprc_win32 = lprc.to_win32();
    let mut temp76: Vec<u16> = psz_text.encode_wide().collect();
    temp76.push(0);
    let pszText_win32 = temp76.as_ptr() as _;
    let uFlags_win32 = u_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DrawStatusTextW(hDC_win32, &mut lprc_win32, pszText_win32, uFlags_win32) };
    let lprc = unsafe { Rect::from_win32(lprc_win32) };
    lprc
}
#[inline]
pub fn draw_theme_background(h_theme: isize, hdc: Hdc, i_part_id: i32, i_state_id: i32, p_rect: &Rect, p_clip_rect: Option<&Rect>) -> HRESULT {
    let hTheme_win32 = h_theme;
    let hdc_win32 = hdc.into_raw();
    let iPartId_win32 = i_part_id;
    let iStateId_win32 = i_state_id;
    // SAFETY: type is a thin type
    let pRect_win32 = unsafe { &*(p_rect as *const _ as *const _) };
    // SAFETY: type is a thin type
    let pClipRect_win32 = p_clip_rect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DrawThemeBackground(hTheme_win32, hdc_win32, iPartId_win32, iStateId_win32, pRect_win32, pClipRect_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn draw_theme_background_ex(h_theme: isize, hdc: Hdc, i_part_id: i32, i_state_id: i32, p_rect: &Rect, p_options: Option<&Dtbgopts>) -> HRESULT {
    let hTheme_win32 = h_theme;
    let hdc_win32 = hdc.into_raw();
    let iPartId_win32 = i_part_id;
    let iStateId_win32 = i_state_id;
    // SAFETY: type is a thin type
    let pRect_win32 = unsafe { &*(p_rect as *const _ as *const _) };
    let temp77 = p_options.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
    let pOptions_win32 = &temp77;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DrawThemeBackgroundEx(hTheme_win32, hdc_win32, iPartId_win32, iStateId_win32, pRect_win32, pOptions_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn draw_theme_edge(h_theme: isize, hdc: Hdc, i_part_id: i32, i_state_id: i32, p_dest_rect: &Rect, u_edge: u32, u_flags: u32, ) -> (HRESULT, Rect) {
    let mut p_content_rect = mem::MaybeUninit::zeroed();
    let pContentRect_win32 = p_content_rect.as_mut_ptr();
    let hTheme_win32 = h_theme;
    let hdc_win32 = hdc.into_raw();
    let iPartId_win32 = i_part_id;
    let iStateId_win32 = i_state_id;
    // SAFETY: type is a thin type
    let pDestRect_win32 = unsafe { &*(p_dest_rect as *const _ as *const _) };
    let uEdge_win32 = u_edge;
    let uFlags_win32 = u_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DrawThemeEdge(hTheme_win32, hdc_win32, iPartId_win32, iStateId_win32, pDestRect_win32, uEdge_win32, uFlags_win32, pContentRect_win32) };
    let real_return_value = return_value;
    let p_content_rect = unsafe { Rect::from_win32(unsafe { p_content_rect.assume_init() }) };
    (real_return_value,p_content_rect)
}
#[inline]
pub fn draw_theme_icon(h_theme: isize, hdc: Hdc, i_part_id: i32, i_state_id: i32, p_rect: &Rect, himl: Himagelist, i_image_index: i32) -> HRESULT {
    let hTheme_win32 = h_theme;
    let hdc_win32 = hdc.into_raw();
    let iPartId_win32 = i_part_id;
    let iStateId_win32 = i_state_id;
    // SAFETY: type is a thin type
    let pRect_win32 = unsafe { &*(p_rect as *const _ as *const _) };
    let himl_win32 = himl.into_raw();
    let iImageIndex_win32 = i_image_index;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DrawThemeIcon(hTheme_win32, hdc_win32, iPartId_win32, iStateId_win32, pRect_win32, himl_win32, iImageIndex_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn draw_theme_parent_background(hwnd: Hwnd, hdc: Hdc, prc: Option<&Rect>) -> HRESULT {
    let hwnd_win32 = hwnd.into_raw();
    let hdc_win32 = hdc.into_raw();
    // SAFETY: type is a thin type
    let prc_win32 = prc.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DrawThemeParentBackground(hwnd_win32, hdc_win32, prc_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn draw_theme_parent_background_ex(hwnd: Hwnd, hdc: Hdc, dw_flags: u32, prc: Option<&Rect>) -> HRESULT {
    let hwnd_win32 = hwnd.into_raw();
    let hdc_win32 = hdc.into_raw();
    let dwFlags_win32 = dw_flags;
    // SAFETY: type is a thin type
    let prc_win32 = prc.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DrawThemeParentBackgroundEx(hwnd_win32, hdc_win32, dwFlags_win32, prc_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn draw_theme_text(h_theme: isize, hdc: Hdc, i_part_id: i32, i_state_id: i32, psz_text: &OsStr, cch_text: i32, dw_text_flags: u32, dw_text_flags2: u32, p_rect: &Rect) -> HRESULT {
    let hTheme_win32 = h_theme;
    let hdc_win32 = hdc.into_raw();
    let iPartId_win32 = i_part_id;
    let iStateId_win32 = i_state_id;
    let mut temp78: Vec<u16> = psz_text.encode_wide().collect();
    temp78.push(0);
    let pszText_win32 = temp78.as_ptr() as _;
    let cchText_win32 = cch_text;
    let dwTextFlags_win32 = dw_text_flags;
    let dwTextFlags2_win32 = dw_text_flags2;
    // SAFETY: type is a thin type
    let pRect_win32 = unsafe { &*(p_rect as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DrawThemeText(hTheme_win32, hdc_win32, iPartId_win32, iStateId_win32, pszText_win32, cchText_win32, dwTextFlags_win32, dwTextFlags2_win32, pRect_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn draw_theme_text_ex(h_theme: isize, hdc: Hdc, i_part_id: i32, i_state_id: i32, psz_text: &OsStr, cch_text: i32, dw_text_flags: u32, p_rect: Rect, p_options: Option<&Dttopts>) -> (HRESULT, Rect) {
    let hTheme_win32 = h_theme;
    let hdc_win32 = hdc.into_raw();
    let iPartId_win32 = i_part_id;
    let iStateId_win32 = i_state_id;
    let mut temp79: Vec<u16> = psz_text.encode_wide().collect();
    temp79.push(0);
    let pszText_win32 = temp79.as_ptr() as _;
    let cchText_win32 = cch_text;
    let dwTextFlags_win32 = dw_text_flags;
    let mut pRect_win32 = p_rect.to_win32();
    let temp80 = p_options.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
    let pOptions_win32 = &temp80;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::DrawThemeTextEx(hTheme_win32, hdc_win32, iPartId_win32, iStateId_win32, pszText_win32, cchText_win32, dwTextFlags_win32, &mut pRect_win32, pOptions_win32) };
    let real_return_value = return_value;
    let p_rect = unsafe { Rect::from_win32(pRect_win32) };
    (real_return_value,p_rect)
}
#[inline]
pub fn enable_scroll_bar(h_wnd: Hwnd, w_s_bflags: u32, w_arrows: u32) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let wSBflags_win32 = w_s_bflags;
    let wArrows_win32 = w_arrows;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::EnableScrollBar(hWnd_win32, wSBflags_win32, wArrows_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enable_theme_dialog_texture(hwnd: Hwnd, dw_flags: u32) -> HRESULT {
    let hwnd_win32 = hwnd.into_raw();
    let dwFlags_win32 = dw_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::EnableThemeDialogTexture(hwnd_win32, dwFlags_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn enable_theming(f_enable: BOOL) -> HRESULT {
    let fEnable_win32 = f_enable;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::EnableTheming(fEnable_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn end_buffered_animation(hbp_animation: isize, f_update_target: BOOL) -> HRESULT {
    let hbpAnimation_win32 = hbp_animation;
    let fUpdateTarget_win32 = f_update_target;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::EndBufferedAnimation(hbpAnimation_win32, fUpdateTarget_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn end_buffered_paint(h_buffered_paint: isize, f_update_target: BOOL) -> HRESULT {
    let hBufferedPaint_win32 = h_buffered_paint;
    let fUpdateTarget_win32 = f_update_target;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::EndBufferedPaint(hBufferedPaint_win32, fUpdateTarget_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn end_panning_feedback(hwnd: Hwnd, f_animate_back: BOOL) -> Result<BOOL> {
    let hwnd_win32 = hwnd.into_raw();
    let fAnimateBack_win32 = f_animate_back;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::EndPanningFeedback(hwnd_win32, fAnimateBack_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn evaluate_proximity_to_polygon(control_polygon: &Point, p_hit_testing_input: &[TouchHitTestingInput], ) -> Result<(BOOL, TouchHitTestingProximityEvaluation)> {
    let mut p_proximity_eval = mem::MaybeUninit::zeroed();
    let pProximityEval_win32 = p_proximity_eval.as_mut_ptr();
    // SAFETY: type is a thin type
    let controlPolygon_win32 = unsafe { &*(control_polygon as *const _ as *const _) };
    let pHitTestingInput_win32 = p_hit_testing_input.as_ptr() as _;
    let numVertices_win32 = p_hit_testing_input.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::EvaluateProximityToPolygon(numVertices_win32, controlPolygon_win32, pHitTestingInput_win32, pProximityEval_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let p_proximity_eval = unsafe { TouchHitTestingProximityEvaluation::from_win32(unsafe { p_proximity_eval.assume_init() }) };
    Ok((real_return_value,p_proximity_eval))
}
#[inline]
pub fn evaluate_proximity_to_rect(control_bounding_box: &Rect, p_hit_testing_input: &TouchHitTestingInput, ) -> Result<(BOOL, TouchHitTestingProximityEvaluation)> {
    let mut p_proximity_eval = mem::MaybeUninit::zeroed();
    let pProximityEval_win32 = p_proximity_eval.as_mut_ptr();
    // SAFETY: type is a thin type
    let controlBoundingBox_win32 = unsafe { &*(control_bounding_box as *const _ as *const _) };
    // SAFETY: type is a thin type
    let pHitTestingInput_win32 = unsafe { &*(p_hit_testing_input as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Controls::EvaluateProximityToRect(controlBoundingBox_win32, pHitTestingInput_win32, pProximityEval_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let p_proximity_eval = unsafe { TouchHitTestingProximityEvaluation::from_win32(unsafe { p_proximity_eval.assume_init() }) };
    Ok((real_return_value,p_proximity_eval))
}
#[inline]
pub fn flat_sb_enable_scroll_bar(param0: Hwnd, param1: i32, param2: u32) -> Result<BOOL> {
    let param0_win32 = param0.into_raw();
    let param1_win32 = param1;
    let param2_win32 = param2;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::FlatSB_EnableScrollBar(param0_win32, param1_win32, param2_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn flat_sb_get_scroll_info(param0: Hwnd, code: u32, param2: Scrollinfo) -> Result<(BOOL, Scrollinfo)> {
    let param0_win32 = param0.into_raw();
    let code_win32 = code;
    let mut param2_win32 = param2.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::FlatSB_GetScrollInfo(param0_win32, code_win32, &mut param2_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let param2 = unsafe { Scrollinfo::from_win32(param2_win32) };
    Ok((real_return_value,param2))
}
#[inline]
pub fn flat_sb_get_scroll_pos(param0: Hwnd, code: u32) -> Result<i32> {
    let param0_win32 = param0.into_raw();
    let code_win32 = code;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::FlatSB_GetScrollPos(param0_win32, code_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn flat_sb_get_scroll_prop(param0: Hwnd, prop_index: i32, param2: i32) -> Result<(BOOL, i32)> {
    let param0_win32 = param0.into_raw();
    let propIndex_win32 = prop_index;
    let mut param2_win32 = param2;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::FlatSB_GetScrollProp(param0_win32, propIndex_win32, &mut param2_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let param2 = param2_win32;
    Ok((real_return_value,param2))
}
#[inline]
pub fn flat_sb_get_scroll_range(param0: Hwnd, code: u32, param2: i32, param3: i32) -> Result<(BOOL, i32, i32)> {
    let param0_win32 = param0.into_raw();
    let code_win32 = code;
    let mut param2_win32 = param2;
    let mut param3_win32 = param3;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::FlatSB_GetScrollRange(param0_win32, code_win32, &mut param2_win32, &mut param3_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let param3 = param3_win32;
    let param2 = param2_win32;
    Ok((real_return_value,param2, param3))
}
#[inline]
pub fn flat_sb_set_scroll_info(param0: Hwnd, code: u32, psi: Scrollinfo, f_redraw: BOOL) -> Result<(i32, Scrollinfo)> {
    let param0_win32 = param0.into_raw();
    let code_win32 = code;
    let mut psi_win32 = psi.to_win32();
    let fRedraw_win32 = f_redraw;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::FlatSB_SetScrollInfo(param0_win32, code_win32, &mut psi_win32, fRedraw_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let psi = unsafe { Scrollinfo::from_win32(psi_win32) };
    Ok((real_return_value,psi))
}
#[inline]
pub fn flat_sb_set_scroll_pos(param0: Hwnd, code: u32, pos: i32, f_redraw: BOOL) -> Result<i32> {
    let param0_win32 = param0.into_raw();
    let code_win32 = code;
    let pos_win32 = pos;
    let fRedraw_win32 = f_redraw;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::FlatSB_SetScrollPos(param0_win32, code_win32, pos_win32, fRedraw_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn flat_sb_set_scroll_prop(param0: Hwnd, index: i32, new_value: isize, param3: BOOL) -> Result<BOOL> {
    let param0_win32 = param0.into_raw();
    let index_win32 = index;
    let newValue_win32 = new_value;
    let param3_win32 = param3;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::FlatSB_SetScrollProp(param0_win32, index_win32, newValue_win32, param3_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn flat_sb_set_scroll_range(param0: Hwnd, code: u32, min: i32, max: i32, f_redraw: BOOL) -> Result<i32> {
    let param0_win32 = param0.into_raw();
    let code_win32 = code;
    let min_win32 = min;
    let max_win32 = max;
    let fRedraw_win32 = f_redraw;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::FlatSB_SetScrollRange(param0_win32, code_win32, min_win32, max_win32, fRedraw_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn flat_sb_show_scroll_bar(param0: Hwnd, code: u32, param2: BOOL) -> Result<BOOL> {
    let param0_win32 = param0.into_raw();
    let code_win32 = code;
    let param2_win32 = param2;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::FlatSB_ShowScrollBar(param0_win32, code_win32, param2_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_buffered_paint_dc(h_buffered_paint: isize) -> Result<Hdc> {
    let hBufferedPaint_win32 = h_buffered_paint;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::GetBufferedPaintDC(hBufferedPaint_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hdc::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_buffered_paint_target_dc(h_buffered_paint: isize) -> Result<Hdc> {
    let hBufferedPaint_win32 = h_buffered_paint;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::GetBufferedPaintTargetDC(hBufferedPaint_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hdc::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_buffered_paint_target_rect(h_buffered_paint: isize, ) -> (HRESULT, Rect) {
    let mut prc = mem::MaybeUninit::zeroed();
    let prc_win32 = prc.as_mut_ptr();
    let hBufferedPaint_win32 = h_buffered_paint;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::GetBufferedPaintTargetRect(hBufferedPaint_win32, prc_win32) };
    let real_return_value = return_value;
    let prc = unsafe { Rect::from_win32(unsafe { prc.assume_init() }) };
    (real_return_value,prc)
}
#[inline]
pub fn get_combo_box_info(hwnd_combo: Hwnd, pcbi: Comboboxinfo) -> Result<(BOOL, Comboboxinfo)> {
    let hwndCombo_win32 = hwnd_combo.into_raw();
    let mut pcbi_win32 = pcbi.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::GetComboBoxInfo(hwndCombo_win32, &mut pcbi_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pcbi = unsafe { Comboboxinfo::from_win32(pcbi_win32) };
    Ok((real_return_value,pcbi))
}
#[inline]
pub fn get_current_theme_name(cch_max_name_chars: i32, cch_max_color_chars: i32, cch_max_size_chars: i32) -> (HRESULT, OsString, OsString, OsString) {
    let mut psz_theme_file_name = Vec::<u16>::with_capacity(cch_max_size_chars as usize + 1);
    let pszThemeFileName_win32 = psz_theme_file_name.as_mut_ptr();
    let mut psz_color_buff = Vec::<u16>::with_capacity(cch_max_size_chars as usize + 1);
    let pszColorBuff_win32 = psz_color_buff.as_mut_ptr();
    let mut psz_size_buff = Vec::<u16>::with_capacity(cch_max_size_chars as usize + 1);
    let pszSizeBuff_win32 = psz_size_buff.as_mut_ptr();
    let cchMaxNameChars_win32 = cch_max_name_chars;
    let cchMaxColorChars_win32 = cch_max_color_chars;
    let cchMaxSizeChars_win32 = cch_max_size_chars;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::GetCurrentThemeName(pszThemeFileName_win32, cchMaxNameChars_win32, pszColorBuff_win32, cchMaxColorChars_win32, pszSizeBuff_win32, cchMaxSizeChars_win32) };
    let real_return_value = return_value;
    psz_size_buff.truncate(return_value as usize);
    let psz_size_buff = OsString::from_wide(&psz_size_buff);
    psz_color_buff.truncate(return_value as usize);
    let psz_color_buff = OsString::from_wide(&psz_color_buff);
    psz_theme_file_name.truncate(return_value as usize);
    let psz_theme_file_name = OsString::from_wide(&psz_theme_file_name);
    (real_return_value,psz_theme_file_name, psz_color_buff, psz_size_buff)
}
#[inline]
pub fn get_effective_client_rect(h_wnd: Hwnd, lp_info: &i32) -> Rect {
    let mut lprc = mem::MaybeUninit::zeroed();
    let lprc_win32 = lprc.as_mut_ptr();
    let hWnd_win32 = h_wnd.into_raw();
    // SAFETY: type is a thin type
    let lpInfo_win32 = unsafe { &*(lp_info as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Controls::GetEffectiveClientRect(hWnd_win32, lprc_win32, lpInfo_win32) };
    let lprc = unsafe { Rect::from_win32(unsafe { lprc.assume_init() }) };
    lprc
}
#[inline]
pub fn get_list_box_info(hwnd: Hwnd) -> u32 {
    let hwnd_win32 = hwnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::GetListBoxInfo(hwnd_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_mui_language() -> u16 {
    let return_value = unsafe { windows_sys::Win32::UI::Controls::GetMUILanguage() };
    let real_return_value = return_value;
    real_return_value
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn get_window_feedback_setting(hwnd: Hwnd, feedback: i32, dw_flags: u32, p_size: u32, ) -> Result<(BOOL, u32, todo_void_ret)> {
//      let mut config = mem::MaybeUninit::zeroed();
//      let config_win32 = config.as_mut_ptr();
//      let hwnd_win32 = hwnd.into_raw();
//      let feedback_win32 = feedback;
//      let dwFlags_win32 = dw_flags;
//      let mut pSize_win32 = p_size;
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::GetWindowFeedbackSetting(hwnd_win32, feedback_win32, dwFlags_win32, &mut pSize_win32, config_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      let config = todo_void;
//      let p_size = pSize_win32;
//      Ok((real_return_value,p_size, config))
//  }
#[inline]
pub fn get_window_theme(hwnd: Hwnd) -> isize {
    let hwnd_win32 = hwnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::GetWindowTheme(hwnd_win32) };
    let real_return_value = return_value;
    real_return_value
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn himagelist_query_interface(himl: Himagelist, riid: &GUID, ) -> (HRESULT, &mut todo_void_ret) {
//      let mut ppv = mem::MaybeUninit::zeroed();
//      let ppv_win32 = ppv.as_mut_ptr();
//      let himl_win32 = himl.into_raw();
//      // SAFETY: type is a thin type
//      let riid_win32 = unsafe { &*(riid as *const _ as *const _) };
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::HIMAGELIST_QueryInterface(himl_win32, riid_win32, ppv_win32) };
//      let real_return_value = return_value;
//      let ppv = unsafe { &mut *(unsafe { ppv.assume_init() } as *mut _) };
//      (real_return_value,ppv)
//  }
#[inline]
pub fn hit_test_theme_background(h_theme: isize, hdc: Option<Hdc>, i_part_id: i32, i_state_id: i32, dw_options: u32, p_rect: &Rect, hrgn: Option<Hrgn>, pt_test: Point, ) -> (HRESULT, u16) {
    let mut pw_hit_test_code = mem::MaybeUninit::zeroed();
    let pwHitTestCode_win32 = pw_hit_test_code.as_mut_ptr();
    let hTheme_win32 = h_theme;
    let hdc_win32 = hdc.map_or(0, Hdc::into_raw);
    let iPartId_win32 = i_part_id;
    let iStateId_win32 = i_state_id;
    let dwOptions_win32 = dw_options;
    // SAFETY: type is a thin type
    let pRect_win32 = unsafe { &*(p_rect as *const _ as *const _) };
    let hrgn_win32 = hrgn.map_or(0, Hrgn::into_raw);
    let ptTest_win32 = pt_test.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::HitTestThemeBackground(hTheme_win32, hdc_win32, iPartId_win32, iStateId_win32, dwOptions_win32, pRect_win32, hrgn_win32, ptTest_win32, pwHitTestCode_win32) };
    let real_return_value = return_value;
    let pw_hit_test_code = unsafe { pw_hit_test_code.assume_init() };
    (real_return_value,pw_hit_test_code)
}
#[inline]
pub fn init_common_controls() -> () {
    let return_value = unsafe { windows_sys::Win32::UI::Controls::InitCommonControls() };
    let _ = return_value;
}
#[inline]
pub fn init_common_controls_ex(picce: &Initcommoncontrolsex) -> Result<BOOL> {
    let temp81 = picce.to_win32();
    let picce_win32 = &temp81;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::InitCommonControlsEx(picce_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn init_mui_language(ui_lang: u16) -> () {
    let uiLang_win32 = ui_lang;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::InitMUILanguage(uiLang_win32) };
    let _ = return_value;
}
#[inline]
pub fn initialize_flat_sb(param0: Hwnd) -> Result<BOOL> {
    let param0_win32 = param0.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::InitializeFlatSB(param0_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn is_app_themed() -> BOOL {
    let return_value = unsafe { windows_sys::Win32::UI::Controls::IsAppThemed() };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn is_composition_active() -> BOOL {
    let return_value = unsafe { windows_sys::Win32::UI::Controls::IsCompositionActive() };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn is_dlg_button_checked(h_dlg: Hwnd, n_id_button: i32) -> u32 {
    let hDlg_win32 = h_dlg.into_raw();
    let nIDButton_win32 = n_id_button;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::IsDlgButtonChecked(hDlg_win32, nIDButton_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn is_theme_active() -> BOOL {
    let return_value = unsafe { windows_sys::Win32::UI::Controls::IsThemeActive() };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn is_theme_background_partially_transparent(h_theme: isize, i_part_id: i32, i_state_id: i32) -> BOOL {
    let hTheme_win32 = h_theme;
    let iPartId_win32 = i_part_id;
    let iStateId_win32 = i_state_id;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::IsThemeBackgroundPartiallyTransparent(hTheme_win32, iPartId_win32, iStateId_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn is_theme_dialog_texture_enabled(hwnd: Hwnd) -> BOOL {
    let hwnd_win32 = hwnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::IsThemeDialogTextureEnabled(hwnd_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn is_theme_part_defined(h_theme: isize, i_part_id: i32, i_state_id: i32) -> BOOL {
    let hTheme_win32 = h_theme;
    let iPartId_win32 = i_part_id;
    let iStateId_win32 = i_state_id;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::IsThemePartDefined(hTheme_win32, iPartId_win32, iStateId_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn lb_item_from_pt(h_lb: Hwnd, pt: Point, b_auto_scroll: BOOL) -> Result<i32> {
    let hLB_win32 = h_lb.into_raw();
    let pt_win32 = pt.to_win32();
    let bAutoScroll_win32 = b_auto_scroll;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::LBItemFromPt(hLB_win32, pt_win32, bAutoScroll_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn load_icon_metric(hinst: Hinstance, psz_name: &OsStr, lims: i32, ) -> (HRESULT, Hicon) {
    let mut phico = mem::MaybeUninit::zeroed();
    let phico_win32 = phico.as_mut_ptr();
    let hinst_win32 = hinst.into_raw();
    let mut temp82: Vec<u16> = psz_name.encode_wide().collect();
    temp82.push(0);
    let pszName_win32 = temp82.as_ptr() as _;
    let lims_win32 = lims;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::LoadIconMetric(hinst_win32, pszName_win32, lims_win32, phico_win32) };
    let real_return_value = return_value;
    let phico = unsafe { Hicon::new(unsafe { phico.assume_init() }) };
    (real_return_value,phico)
}
#[inline]
pub fn load_icon_with_scale_down(hinst: Hinstance, psz_name: &OsStr, cx: i32, cy: i32, ) -> (HRESULT, Hicon) {
    let mut phico = mem::MaybeUninit::zeroed();
    let phico_win32 = phico.as_mut_ptr();
    let hinst_win32 = hinst.into_raw();
    let mut temp83: Vec<u16> = psz_name.encode_wide().collect();
    temp83.push(0);
    let pszName_win32 = temp83.as_ptr() as _;
    let cx_win32 = cx;
    let cy_win32 = cy;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::LoadIconWithScaleDown(hinst_win32, pszName_win32, cx_win32, cy_win32, phico_win32) };
    let real_return_value = return_value;
    let phico = unsafe { Hicon::new(unsafe { phico.assume_init() }) };
    (real_return_value,phico)
}
#[inline]
pub fn make_drag_list(h_lb: Hwnd) -> Result<BOOL> {
    let hLB_win32 = h_lb.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::MakeDragList(hLB_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn menu_help(u_msg: u32, w_param: Wparam, l_param: Lparam, h_main_menu: Hmenu, h_inst: Hinstance, hwnd_status: Hwnd, lpw_i_ds: &u32) -> () {
    let uMsg_win32 = u_msg;
    let wParam_win32 = w_param.into_inner();
    let lParam_win32 = l_param.into_inner();
    let hMainMenu_win32 = h_main_menu.into_raw();
    let hInst_win32 = h_inst.into_raw();
    let hwndStatus_win32 = hwnd_status.into_raw();
    // SAFETY: type is a thin type
    let lpwIDs_win32 = unsafe { &*(lpw_i_ds as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Controls::MenuHelp(uMsg_win32, wParam_win32, lParam_win32, hMainMenu_win32, hInst_win32, hwndStatus_win32, lpwIDs_win32) };
    let _ = return_value;
}
#[inline]
pub fn open_theme_data(hwnd: Option<Hwnd>, psz_class_list: &OsStr) -> isize {
    let hwnd_win32 = hwnd.map_or(0, Hwnd::into_raw);
    let mut temp84: Vec<u16> = psz_class_list.encode_wide().collect();
    temp84.push(0);
    let pszClassList_win32 = temp84.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::OpenThemeData(hwnd_win32, pszClassList_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn open_theme_data_ex(hwnd: Option<Hwnd>, psz_class_list: &OsStr, dw_flags: u32) -> isize {
    let hwnd_win32 = hwnd.map_or(0, Hwnd::into_raw);
    let mut temp85: Vec<u16> = psz_class_list.encode_wide().collect();
    temp85.push(0);
    let pszClassList_win32 = temp85.as_ptr() as _;
    let dwFlags_win32 = dw_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::OpenThemeDataEx(hwnd_win32, pszClassList_win32, dwFlags_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn pack_touch_hit_testing_proximity_evaluation(p_hit_testing_input: &TouchHitTestingInput, p_proximity_eval: &TouchHitTestingProximityEvaluation) -> Lresult {
    // SAFETY: type is a thin type
    let pHitTestingInput_win32 = unsafe { &*(p_hit_testing_input as *const _ as *const _) };
    // SAFETY: type is a thin type
    let pProximityEval_win32 = unsafe { &*(p_proximity_eval as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Controls::PackTouchHitTestingProximityEvaluation(pHitTestingInput_win32, pProximityEval_win32) };
    let real_return_value = unsafe { Lresult::from_inner(return_value) };
    real_return_value
}
#[inline]
pub fn set_scroll_info(hwnd: Hwnd, n_bar: u32, lpsi: &Scrollinfo, redraw: BOOL) -> Result<i32> {
    let hwnd_win32 = hwnd.into_raw();
    let nBar_win32 = n_bar;
    let temp86 = lpsi.to_win32();
    let lpsi_win32 = &temp86;
    let redraw_win32 = redraw;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::SetScrollInfo(hwnd_win32, nBar_win32, lpsi_win32, redraw_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_scroll_pos(h_wnd: Hwnd, n_bar: u32, n_pos: i32, b_redraw: BOOL) -> Result<i32> {
    let hWnd_win32 = h_wnd.into_raw();
    let nBar_win32 = n_bar;
    let nPos_win32 = n_pos;
    let bRedraw_win32 = b_redraw;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::SetScrollPos(hWnd_win32, nBar_win32, nPos_win32, bRedraw_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_scroll_range(h_wnd: Hwnd, n_bar: u32, n_min_pos: i32, n_max_pos: i32, b_redraw: BOOL) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let nBar_win32 = n_bar;
    let nMinPos_win32 = n_min_pos;
    let nMaxPos_win32 = n_max_pos;
    let bRedraw_win32 = b_redraw;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::SetScrollRange(hWnd_win32, nBar_win32, nMinPos_win32, nMaxPos_win32, bRedraw_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_theme_app_properties(dw_flags: u32) -> () {
    let dwFlags_win32 = dw_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::SetThemeAppProperties(dwFlags_win32) };
    let _ = return_value;
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn set_window_feedback_setting(hwnd: Hwnd, feedback: i32, dw_flags: u32, configuration: Option<&[todo_void]>) -> Result<BOOL> {
//      let hwnd_win32 = hwnd.into_raw();
//      let feedback_win32 = feedback;
//      let dwFlags_win32 = dw_flags;
//      let configuration_win32 = configuration.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let size_win32 = configuration.len() as _;
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::SetWindowFeedbackSetting(hwnd_win32, feedback_win32, dwFlags_win32, size_win32, configuration_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      Ok(real_return_value)
//  }
#[inline]
pub fn set_window_theme(hwnd: Hwnd, psz_sub_app_name: Option<&OsStr>, psz_sub_id_list: Option<&OsStr>) -> HRESULT {
    let hwnd_win32 = hwnd.into_raw();
    let temp87 = psz_sub_app_name.map(|val| {
        let mut temp87: Vec<u16> = val.encode_wide().collect();
        temp87.push(0);
        temp87
    });
    let pszSubAppName_win32 = temp87.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp88 = psz_sub_id_list.map(|val| {
        let mut temp88: Vec<u16> = val.encode_wide().collect();
        temp88.push(0);
        temp88
    });
    let pszSubIdList_win32 = temp88.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::Controls::SetWindowTheme(hwnd_win32, pszSubAppName_win32, pszSubIdList_win32) };
    let real_return_value = return_value;
    real_return_value
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn set_window_theme_attribute(hwnd: Hwnd, e_attribute: i32, pv_attribute: &[todo_void], ) -> HRESULT {
//      let hwnd_win32 = hwnd.into_raw();
//      let eAttribute_win32 = e_attribute;
//      let pvAttribute_win32 = pv_attribute.as_ptr() as _;
//      let cbAttribute_win32 = pv_attribute.len() as _;
//      let return_value = unsafe { windows_sys::Win32::UI::Controls::SetWindowThemeAttribute(hwnd_win32, eAttribute_win32, pvAttribute_win32, cbAttribute_win32) };
//      let real_return_value = return_value;
//      real_return_value
//  }
#[inline]
pub fn show_hide_menu_ctl(h_wnd: Hwnd, u_flags: usize, lp_info: &i32) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let uFlags_win32 = u_flags;
    // SAFETY: type is a thin type
    let lpInfo_win32 = unsafe { &*(lp_info as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Controls::ShowHideMenuCtl(hWnd_win32, uFlags_win32, lpInfo_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn show_scroll_bar(h_wnd: Hwnd, w_bar: u32, b_show: BOOL) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let wBar_win32 = w_bar;
    let bShow_win32 = b_show;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::ShowScrollBar(hWnd_win32, wBar_win32, bShow_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn uninitialize_flat_sb(param0: Hwnd) -> HRESULT {
    let param0_win32 = param0.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Controls::UninitializeFlatSB(param0_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn update_panning_feedback(hwnd: Hwnd, l_total_overpan_offset_x: i32, l_total_overpan_offset_y: i32, f_in_inertia: BOOL) -> Result<BOOL> {
    let hwnd_win32 = hwnd.into_raw();
    let lTotalOverpanOffsetX_win32 = l_total_overpan_offset_x;
    let lTotalOverpanOffsetY_win32 = l_total_overpan_offset_y;
    let fInInertia_win32 = f_in_inertia;
    let return_value = unsafe { windows_sys::Win32::UI::Controls::UpdatePanningFeedback(hwnd_win32, lTotalOverpanOffsetX_win32, lTotalOverpanOffsetY_win32, fInInertia_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn chr_cmp_ia(w1: u16, w2: u16) -> Result<BOOL> {
    let w1_win32 = w1;
    let w2_win32 = w2;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ChrCmpIA(w1_win32, w2_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn chr_cmp_iw(w1: u8, w2: u8) -> Result<BOOL> {
    let w1_win32 = w1;
    let w2_win32 = w2;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ChrCmpIW(w1_win32, w2_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn color_adjust_luma(clr_rgb: u32, n: i32, f_scale: BOOL) -> u32 {
    let clrRGB_win32 = clr_rgb;
    let n_win32 = n;
    let fScale_win32 = f_scale;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ColorAdjustLuma(clrRGB_win32, n_win32, fScale_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn color_hls_to_rgb(w_hue: u16, w_luminance: u16, w_saturation: u16) -> u32 {
    let wHue_win32 = w_hue;
    let wLuminance_win32 = w_luminance;
    let wSaturation_win32 = w_saturation;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ColorHLSToRGB(wHue_win32, wLuminance_win32, wSaturation_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn color_rgb_to_hls(clr_rgb: u32, ) -> (u16, u16, u16) {
    let mut pw_hue = mem::MaybeUninit::zeroed();
    let pwHue_win32 = pw_hue.as_mut_ptr();
    let mut pw_luminance = mem::MaybeUninit::zeroed();
    let pwLuminance_win32 = pw_luminance.as_mut_ptr();
    let mut pw_saturation = mem::MaybeUninit::zeroed();
    let pwSaturation_win32 = pw_saturation.as_mut_ptr();
    let clrRGB_win32 = clr_rgb;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ColorRGBToHLS(clrRGB_win32, pwHue_win32, pwLuminance_win32, pwSaturation_win32) };
    let pw_saturation = unsafe { pw_saturation.assume_init() };
    let pw_luminance = unsafe { pw_luminance.assume_init() };
    let pw_hue = unsafe { pw_hue.assume_init() };
    (pw_hue, pw_luminance, pw_saturation)
}
#[inline]
pub fn dad_auto_scroll(hwnd: Hwnd, pad: AutoScrollData, ppt_now: &Point) -> Result<(BOOL, AutoScrollData)> {
    let hwnd_win32 = hwnd.into_raw();
    let mut pad_win32 = pad.to_win32();
    // SAFETY: type is a thin type
    let pptNow_win32 = unsafe { &*(ppt_now as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DAD_AutoScroll(hwnd_win32, &mut pad_win32, pptNow_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pad = unsafe { AutoScrollData::from_win32(pad_win32) };
    Ok((real_return_value,pad))
}
#[inline]
pub fn dad_drag_enter_ex(hwnd_target: Hwnd, pt_start: Point) -> Result<BOOL> {
    let hwndTarget_win32 = hwnd_target.into_raw();
    let ptStart_win32 = pt_start.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DAD_DragEnterEx(hwndTarget_win32, ptStart_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn dad_drag_leave() -> Result<BOOL> {
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DAD_DragLeave() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn dad_drag_move(pt: Point) -> Result<BOOL> {
    let pt_win32 = pt.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DAD_DragMove(pt_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn dad_set_drag_image(him: Himagelist, ppt_offset: Point) -> Result<(BOOL, Point)> {
    let him_win32 = him.into_raw();
    let mut pptOffset_win32 = ppt_offset.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DAD_SetDragImage(him_win32, &mut pptOffset_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let ppt_offset = unsafe { Point::from_win32(pptOffset_win32) };
    Ok((real_return_value,ppt_offset))
}
#[inline]
pub fn dad_show_drag_image(f_show: BOOL) -> Result<BOOL> {
    let fShow_win32 = f_show;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DAD_ShowDragImage(fShow_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn def_subclass_proc(h_wnd: Hwnd, u_msg: u32, w_param: Wparam, l_param: Lparam) -> Lresult {
    let hWnd_win32 = h_wnd.into_raw();
    let uMsg_win32 = u_msg;
    let wParam_win32 = w_param.into_inner();
    let lParam_win32 = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DefSubclassProc(hWnd_win32, uMsg_win32, wParam_win32, lParam_win32) };
    let real_return_value = unsafe { Lresult::from_inner(return_value) };
    real_return_value
}
#[inline]
pub fn delete_profile_a(lp_sid_string: &CStr, lp_profile_path: Option<&CStr>, lp_computer_name: Option<&CStr>) -> Result<BOOL> {
    let lpSidString_win32 = lp_sid_string.as_ptr() as _;
    let lpProfilePath_win32 = lp_profile_path.map_or(ptr::null(), |v| v.as_ptr() as _);
    let lpComputerName_win32 = lp_computer_name.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DeleteProfileA(lpSidString_win32, lpProfilePath_win32, lpComputerName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn delete_profile_w(lp_sid_string: &OsStr, lp_profile_path: Option<&OsStr>, lp_computer_name: Option<&OsStr>) -> Result<BOOL> {
    let mut temp89: Vec<u16> = lp_sid_string.encode_wide().collect();
    temp89.push(0);
    let lpSidString_win32 = temp89.as_ptr() as _;
    let temp90 = lp_profile_path.map(|val| {
        let mut temp90: Vec<u16> = val.encode_wide().collect();
        temp90.push(0);
        temp90
    });
    let lpProfilePath_win32 = temp90.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp91 = lp_computer_name.map(|val| {
        let mut temp91: Vec<u16> = val.encode_wide().collect();
        temp91.push(0);
        temp91
    });
    let lpComputerName_win32 = temp91.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DeleteProfileW(lpSidString_win32, lpProfilePath_win32, lpComputerName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn drag_accept_files(h_wnd: Hwnd, f_accept: BOOL) -> () {
    let hWnd_win32 = h_wnd.into_raw();
    let fAccept_win32 = f_accept;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DragAcceptFiles(hWnd_win32, fAccept_win32) };
    let _ = return_value;
}
#[inline]
pub fn drag_finish(h_drop: Hdrop) -> () {
    let hDrop_win32 = h_drop.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DragFinish(hDrop_win32) };
    let _ = return_value;
}
#[inline]
pub fn drag_query_file_a(h_drop: Hdrop, i_file: u32, cch: u32) -> (u32, CString) {
    let mut lpsz_file = Vec::<u8>::with_capacity(cch as usize + 1);
    let lpszFile_win32 = lpsz_file.as_mut_ptr();
    let hDrop_win32 = h_drop.into_raw();
    let iFile_win32 = i_file;
    let cch_win32 = cch;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DragQueryFileA(hDrop_win32, iFile_win32, lpszFile_win32, cch_win32) };
    let real_return_value = return_value;
    lpsz_file.truncate(return_value as usize);
    let lpsz_file = unsafe { CString::from_vec_unchecked(lpsz_file) };
    (real_return_value,lpsz_file)
}
#[inline]
pub fn drag_query_file_w(h_drop: Hdrop, i_file: u32, cch: u32) -> (u32, OsString) {
    let mut lpsz_file = Vec::<u16>::with_capacity(cch as usize + 1);
    let lpszFile_win32 = lpsz_file.as_mut_ptr();
    let hDrop_win32 = h_drop.into_raw();
    let iFile_win32 = i_file;
    let cch_win32 = cch;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DragQueryFileW(hDrop_win32, iFile_win32, lpszFile_win32, cch_win32) };
    let real_return_value = return_value;
    lpsz_file.truncate(return_value as usize);
    let lpsz_file = OsString::from_wide(&lpsz_file);
    (real_return_value,lpsz_file)
}
#[inline]
pub fn drag_query_point(h_drop: Hdrop, ) -> Result<(BOOL, Point)> {
    let mut ppt = mem::MaybeUninit::zeroed();
    let ppt_win32 = ppt.as_mut_ptr();
    let hDrop_win32 = h_drop.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DragQueryPoint(hDrop_win32, ppt_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let ppt = unsafe { Point::from_win32(unsafe { ppt.assume_init() }) };
    Ok((real_return_value,ppt))
}
#[inline]
pub fn drive_type(i_drive: i32) -> Result<i32> {
    let iDrive_win32 = i_drive;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DriveType(iDrive_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn duplicate_icon(h_inst: Hinstance, h_icon: Hicon) -> Result<Hicon> {
    let hInst_win32 = h_inst.into_raw();
    let hIcon_win32 = h_icon.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::DuplicateIcon(hInst_win32, hIcon_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hicon::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn extract_icon_a(h_inst: Hinstance, psz_exe_file_name: &CStr, n_icon_index: u32) -> Result<Hicon> {
    let hInst_win32 = h_inst.into_raw();
    let pszExeFileName_win32 = psz_exe_file_name.as_ptr() as _;
    let nIconIndex_win32 = n_icon_index;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ExtractIconA(hInst_win32, pszExeFileName_win32, nIconIndex_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hicon::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn extract_icon_ex_a(lpsz_file: &CStr, n_icon_index: i32, n_icons: u32) -> (u32, Hicon, Hicon) {
    let mut phicon_large = mem::MaybeUninit::zeroed();
    let phiconLarge_win32 = phicon_large.as_mut_ptr();
    let mut phicon_small = mem::MaybeUninit::zeroed();
    let phiconSmall_win32 = phicon_small.as_mut_ptr();
    let lpszFile_win32 = lpsz_file.as_ptr() as _;
    let nIconIndex_win32 = n_icon_index;
    let nIcons_win32 = n_icons;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ExtractIconExA(lpszFile_win32, nIconIndex_win32, phiconLarge_win32, phiconSmall_win32, nIcons_win32) };
    let real_return_value = return_value;
    let phicon_small = unsafe { Hicon::new(unsafe { phicon_small.assume_init() }) };
    let phicon_large = unsafe { Hicon::new(unsafe { phicon_large.assume_init() }) };
    (real_return_value,phicon_large, phicon_small)
}
#[inline]
pub fn extract_icon_ex_w(lpsz_file: &OsStr, n_icon_index: i32, n_icons: u32) -> (u32, Hicon, Hicon) {
    let mut phicon_large = mem::MaybeUninit::zeroed();
    let phiconLarge_win32 = phicon_large.as_mut_ptr();
    let mut phicon_small = mem::MaybeUninit::zeroed();
    let phiconSmall_win32 = phicon_small.as_mut_ptr();
    let mut temp92: Vec<u16> = lpsz_file.encode_wide().collect();
    temp92.push(0);
    let lpszFile_win32 = temp92.as_ptr() as _;
    let nIconIndex_win32 = n_icon_index;
    let nIcons_win32 = n_icons;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ExtractIconExW(lpszFile_win32, nIconIndex_win32, phiconLarge_win32, phiconSmall_win32, nIcons_win32) };
    let real_return_value = return_value;
    let phicon_small = unsafe { Hicon::new(unsafe { phicon_small.assume_init() }) };
    let phicon_large = unsafe { Hicon::new(unsafe { phicon_large.assume_init() }) };
    (real_return_value,phicon_large, phicon_small)
}
#[inline]
pub fn extract_icon_w(h_inst: Hinstance, psz_exe_file_name: &OsStr, n_icon_index: u32) -> Result<Hicon> {
    let hInst_win32 = h_inst.into_raw();
    let mut temp93: Vec<u16> = psz_exe_file_name.encode_wide().collect();
    temp93.push(0);
    let pszExeFileName_win32 = temp93.as_ptr() as _;
    let nIconIndex_win32 = n_icon_index;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ExtractIconW(hInst_win32, pszExeFileName_win32, nIconIndex_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hicon::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_accept_languages_a(pcch_languages: u32) -> (HRESULT, CString, u32) {
    let mut psz_languages = Vec::<u8>::with_capacity(pcch_languages as usize + 1);
    let pszLanguages_win32 = psz_languages.as_mut_ptr();
    let mut pcchLanguages_win32 = pcch_languages;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetAcceptLanguagesA(pszLanguages_win32, &mut pcchLanguages_win32) };
    let real_return_value = return_value;
    let pcch_languages = pcchLanguages_win32;
    psz_languages.truncate(pcch_languages as usize);
    let psz_languages = unsafe { CString::from_vec_unchecked(psz_languages) };
    (real_return_value,psz_languages, pcch_languages)
}
#[inline]
pub fn get_accept_languages_w(pcch_languages: u32) -> (HRESULT, OsString, u32) {
    let mut psz_languages = Vec::<u16>::with_capacity(pcch_languages as usize + 1);
    let pszLanguages_win32 = psz_languages.as_mut_ptr();
    let mut pcchLanguages_win32 = pcch_languages;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetAcceptLanguagesW(pszLanguages_win32, &mut pcchLanguages_win32) };
    let real_return_value = return_value;
    let pcch_languages = pcchLanguages_win32;
    psz_languages.truncate(pcch_languages as usize);
    let psz_languages = OsString::from_wide(&psz_languages);
    (real_return_value,psz_languages, pcch_languages)
}
#[inline]
pub fn get_all_users_profile_directory_a(lpcch_size: u32) -> Result<(BOOL, CString, u32)> {
    let mut lp_profile_dir = Vec::<u8>::with_capacity(lpcch_size as usize + 1);
    let lpProfileDir_win32 = lp_profile_dir.as_mut_ptr();
    let mut lpcchSize_win32 = lpcch_size;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetAllUsersProfileDirectoryA(lpProfileDir_win32, &mut lpcchSize_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpcch_size = lpcchSize_win32;
    lp_profile_dir.truncate(lpcch_size as usize);
    let lp_profile_dir = unsafe { CString::from_vec_unchecked(lp_profile_dir) };
    Ok((real_return_value,lp_profile_dir, lpcch_size))
}
#[inline]
pub fn get_all_users_profile_directory_w(lpcch_size: u32) -> Result<(BOOL, OsString, u32)> {
    let mut lp_profile_dir = Vec::<u16>::with_capacity(lpcch_size as usize + 1);
    let lpProfileDir_win32 = lp_profile_dir.as_mut_ptr();
    let mut lpcchSize_win32 = lpcch_size;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetAllUsersProfileDirectoryW(lpProfileDir_win32, &mut lpcchSize_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpcch_size = lpcchSize_win32;
    lp_profile_dir.truncate(lpcch_size as usize);
    let lp_profile_dir = OsString::from_wide(&lp_profile_dir);
    Ok((real_return_value,lp_profile_dir, lpcch_size))
}
#[inline]
pub fn get_default_user_profile_directory_a(lpcch_size: u32) -> Result<(BOOL, CString, u32)> {
    let mut lp_profile_dir = Vec::<u8>::with_capacity(lpcch_size as usize + 1);
    let lpProfileDir_win32 = lp_profile_dir.as_mut_ptr();
    let mut lpcchSize_win32 = lpcch_size;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetDefaultUserProfileDirectoryA(lpProfileDir_win32, &mut lpcchSize_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpcch_size = lpcchSize_win32;
    lp_profile_dir.truncate(lpcch_size as usize);
    let lp_profile_dir = unsafe { CString::from_vec_unchecked(lp_profile_dir) };
    Ok((real_return_value,lp_profile_dir, lpcch_size))
}
#[inline]
pub fn get_default_user_profile_directory_w(lpcch_size: u32) -> Result<(BOOL, OsString, u32)> {
    let mut lp_profile_dir = Vec::<u16>::with_capacity(lpcch_size as usize + 1);
    let lpProfileDir_win32 = lp_profile_dir.as_mut_ptr();
    let mut lpcchSize_win32 = lpcch_size;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetDefaultUserProfileDirectoryW(lpProfileDir_win32, &mut lpcchSize_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpcch_size = lpcchSize_win32;
    lp_profile_dir.truncate(lpcch_size as usize);
    let lp_profile_dir = OsString::from_wide(&lp_profile_dir);
    Ok((real_return_value,lp_profile_dir, lpcch_size))
}
#[inline]
pub fn get_file_name_from_browse(hwnd: Option<Hwnd>, psz_file_path: &OsStr, cch_file_path: u32, psz_working_dir: Option<&OsStr>, psz_def_ext: &OsStr, psz_filters: Option<&OsStr>, psz_title: Option<&OsStr>) -> Result<(BOOL, OsString)> {
    let hwnd_win32 = hwnd.map_or(0, Hwnd::into_raw);
    let mut temp94: Vec<u16> = psz_file_path.encode_wide().collect();
    temp94.push(0);
    let mut pszFilePath_win32 = temp94.as_ptr() as _;
    let cchFilePath_win32 = cch_file_path;
    let temp95 = psz_working_dir.map(|val| {
        let mut temp95: Vec<u16> = val.encode_wide().collect();
        temp95.push(0);
        temp95
    });
    let pszWorkingDir_win32 = temp95.map_or(ptr::null(), |v| v.as_ptr() as _);
    let mut temp96: Vec<u16> = psz_def_ext.encode_wide().collect();
    temp96.push(0);
    let pszDefExt_win32 = temp96.as_ptr() as _;
    let temp97 = psz_filters.map(|val| {
        let mut temp97: Vec<u16> = val.encode_wide().collect();
        temp97.push(0);
        temp97
    });
    let pszFilters_win32 = temp97.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp98 = psz_title.map(|val| {
        let mut temp98: Vec<u16> = val.encode_wide().collect();
        temp98.push(0);
        temp98
    });
    let pszTitle_win32 = temp98.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetFileNameFromBrowse(hwnd_win32, &mut pszFilePath_win32, cchFilePath_win32, pszWorkingDir_win32, pszDefExt_win32, pszFilters_win32, pszTitle_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    pszFilePath_win32.truncate(return_value as usize);
    let psz_file_path = OsString::from_wide(&pszFilePath_win32);
    Ok((real_return_value,psz_file_path))
}
#[inline]
pub fn get_menu_context_help_id(param0: Hmenu) -> u32 {
    let param0_win32 = param0.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetMenuContextHelpId(param0_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_menu_pos_from_id(hmenu: Hmenu, id: u32) -> Result<i32> {
    let hmenu_win32 = hmenu.into_raw();
    let id_win32 = id;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetMenuPosFromID(hmenu_win32, id_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_profile_type() -> Result<(BOOL, u32)> {
    let mut dw_flags = mem::MaybeUninit::zeroed();
    let dwFlags_win32 = dw_flags.as_mut_ptr();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetProfileType(dwFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let dw_flags = unsafe { dw_flags.assume_init() };
    Ok((real_return_value,dw_flags))
}
#[inline]
pub fn get_profiles_directory_a(lpcch_size: u32) -> Result<(BOOL, CString, u32)> {
    let mut lp_profile_dir = Vec::<u8>::with_capacity(lpcch_size as usize + 1);
    let lpProfileDir_win32 = lp_profile_dir.as_mut_ptr();
    let mut lpcchSize_win32 = lpcch_size;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetProfilesDirectoryA(lpProfileDir_win32, &mut lpcchSize_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpcch_size = lpcchSize_win32;
    lp_profile_dir.truncate(lpcch_size as usize);
    let lp_profile_dir = unsafe { CString::from_vec_unchecked(lp_profile_dir) };
    Ok((real_return_value,lp_profile_dir, lpcch_size))
}
#[inline]
pub fn get_profiles_directory_w(lpcch_size: u32) -> Result<(BOOL, OsString, u32)> {
    let mut lp_profile_dir = Vec::<u16>::with_capacity(lpcch_size as usize + 1);
    let lpProfileDir_win32 = lp_profile_dir.as_mut_ptr();
    let mut lpcchSize_win32 = lpcch_size;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetProfilesDirectoryW(lpProfileDir_win32, &mut lpcchSize_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpcch_size = lpcchSize_win32;
    lp_profile_dir.truncate(lpcch_size as usize);
    let lp_profile_dir = OsString::from_wide(&lp_profile_dir);
    Ok((real_return_value,lp_profile_dir, lpcch_size))
}
#[inline]
pub fn get_user_profile_directory_a(h_token: Handle, lpcch_size: u32) -> Result<(BOOL, CString, u32)> {
    let mut lp_profile_dir = Vec::<u8>::with_capacity(lpcch_size as usize + 1);
    let lpProfileDir_win32 = lp_profile_dir.as_mut_ptr();
    let hToken_win32 = h_token.into_raw();
    let mut lpcchSize_win32 = lpcch_size;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetUserProfileDirectoryA(hToken_win32, lpProfileDir_win32, &mut lpcchSize_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpcch_size = lpcchSize_win32;
    lp_profile_dir.truncate(lpcch_size as usize);
    let lp_profile_dir = unsafe { CString::from_vec_unchecked(lp_profile_dir) };
    Ok((real_return_value,lp_profile_dir, lpcch_size))
}
#[inline]
pub fn get_user_profile_directory_w(h_token: Handle, lpcch_size: u32) -> Result<(BOOL, OsString, u32)> {
    let mut lp_profile_dir = Vec::<u16>::with_capacity(lpcch_size as usize + 1);
    let lpProfileDir_win32 = lp_profile_dir.as_mut_ptr();
    let hToken_win32 = h_token.into_raw();
    let mut lpcchSize_win32 = lpcch_size;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetUserProfileDirectoryW(hToken_win32, lpProfileDir_win32, &mut lpcchSize_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpcch_size = lpcchSize_win32;
    lp_profile_dir.truncate(lpcch_size as usize);
    let lp_profile_dir = OsString::from_wide(&lp_profile_dir);
    Ok((real_return_value,lp_profile_dir, lpcch_size))
}
#[inline]
pub fn get_window_context_help_id(param0: Hwnd) -> u32 {
    let param0_win32 = param0.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetWindowContextHelpId(param0_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_window_subclass<Subclassproc: FnMut(Hwnd, u32, Wparam, Lparam, ) -> Lresult>(h_wnd: Hwnd, pfn_subclass: Subclassproc, ) -> Result<(BOOL, usize)> {
    let mut pdw_ref_data = mem::MaybeUninit::zeroed();
    let pdwRefData_win32 = pdw_ref_data.as_mut_ptr();
    let hWnd_win32 = h_wnd.into_raw();
    unsafe extern "system" fn subclassproc_impl<Subclassproc>(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM, param4: usize, param5: usize) -> LRESULT {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let input3 = unsafe { Lparam::from_inner(param3) };
            let closure = unsafe {
                &mut *(param4 as usize as *mut Subclassproc)
            };
            let return_value = (closure)(input0, input1, input2, input3, );
            let real_return_value = return_value.into_inner();
            real_return_value
        })
    }
    let pfnSubclass_win32 = Some(subclassproc_impl::<Subclassproc>);
    let mut pfn_subclass = pfn_subclass;
    let uIdSubclass_win32 = (&mut pfn_subclass) as *mut _ as *mut _ as usize;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::GetWindowSubclass(hWnd_win32, pfnSubclass_win32, uIdSubclass_win32, pdwRefData_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pdw_ref_data = unsafe { pdw_ref_data.assume_init() };
    Ok((real_return_value,pdw_ref_data))
}
#[inline]
pub fn hmonitor_user_free(param0: &u32, param1: &Hmonitor) -> () {
    // SAFETY: type is a thin type
    let param0_win32 = unsafe { &*(param0 as *const _ as *const _) };
    // SAFETY: type is a thin type
    let param1_win32 = unsafe { &*(param1 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Shell::HMONITOR_UserFree(param0_win32, param1_win32) };
    let _ = return_value;
}
#[inline]
pub fn hmonitor_user_free64(param0: &u32, param1: &Hmonitor) -> () {
    // SAFETY: type is a thin type
    let param0_win32 = unsafe { &*(param0 as *const _ as *const _) };
    // SAFETY: type is a thin type
    let param1_win32 = unsafe { &*(param1 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Shell::HMONITOR_UserFree64(param0_win32, param1_win32) };
    let _ = return_value;
}
#[inline]
pub fn hmonitor_user_size(param0: &u32, param1: u32, param2: &Hmonitor) -> u32 {
    // SAFETY: type is a thin type
    let param0_win32 = unsafe { &*(param0 as *const _ as *const _) };
    let param1_win32 = param1;
    // SAFETY: type is a thin type
    let param2_win32 = unsafe { &*(param2 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Shell::HMONITOR_UserSize(param0_win32, param1_win32, param2_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn hmonitor_user_size64(param0: &u32, param1: u32, param2: &Hmonitor) -> u32 {
    // SAFETY: type is a thin type
    let param0_win32 = unsafe { &*(param0 as *const _ as *const _) };
    let param1_win32 = param1;
    // SAFETY: type is a thin type
    let param2_win32 = unsafe { &*(param2 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Shell::HMONITOR_UserSize64(param0_win32, param1_win32, param2_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn hash_data(pb_data: &[u8], cb_data: u32, ) -> (HRESULT, u8) {
    let mut pb_hash = mem::MaybeUninit::zeroed();
    let pbHash_win32 = pb_hash.as_mut_ptr();
    let pbData_win32 = pb_data.as_ptr() as _;
    let cbHash_win32 = pb_data.len() as _;
    let cbData_win32 = cb_data;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::HashData(pbData_win32, cbData_win32, pbHash_win32, cbHash_win32) };
    let real_return_value = return_value;
    let pb_hash = unsafe { pb_hash.assume_init() };
    (real_return_value,pb_hash)
}
#[inline]
pub fn import_privacy_settings(psz_filename: &OsStr, pf_parse_privacy_preferences: BOOL, pf_parse_per_site_rules: BOOL) -> Result<(BOOL, BOOL, BOOL)> {
    let mut temp99: Vec<u16> = psz_filename.encode_wide().collect();
    temp99.push(0);
    let pszFilename_win32 = temp99.as_ptr() as _;
    let mut pfParsePrivacyPreferences_win32 = pf_parse_privacy_preferences;
    let mut pfParsePerSiteRules_win32 = pf_parse_per_site_rules;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ImportPrivacySettings(pszFilename_win32, &mut pfParsePrivacyPreferences_win32, &mut pfParsePerSiteRules_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pf_parse_per_site_rules = pfParsePerSiteRules_win32;
    let pf_parse_privacy_preferences = pfParsePrivacyPreferences_win32;
    Ok((real_return_value,pf_parse_privacy_preferences, pf_parse_per_site_rules))
}
#[inline]
pub fn init_network_address_control() -> Result<BOOL> {
    let return_value = unsafe { windows_sys::Win32::UI::Shell::InitNetworkAddressControl() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn intl_str_eq_worker_a(f_case_sens: BOOL, lp_string1: &CStr, lp_string2: &CStr, n_char: i32) -> Result<BOOL> {
    let fCaseSens_win32 = f_case_sens;
    let lpString1_win32 = lp_string1.as_ptr() as _;
    let lpString2_win32 = lp_string2.as_ptr() as _;
    let nChar_win32 = n_char;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::IntlStrEqWorkerA(fCaseSens_win32, lpString1_win32, lpString2_win32, nChar_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn intl_str_eq_worker_w(f_case_sens: BOOL, lp_string1: &OsStr, lp_string2: &OsStr, n_char: i32) -> Result<BOOL> {
    let fCaseSens_win32 = f_case_sens;
    let mut temp100: Vec<u16> = lp_string1.encode_wide().collect();
    temp100.push(0);
    let lpString1_win32 = temp100.as_ptr() as _;
    let mut temp101: Vec<u16> = lp_string2.encode_wide().collect();
    temp101.push(0);
    let lpString2_win32 = temp101.as_ptr() as _;
    let nChar_win32 = n_char;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::IntlStrEqWorkerW(fCaseSens_win32, lpString1_win32, lpString2_win32, nChar_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn is_internet_esc_enabled() -> BOOL {
    let return_value = unsafe { windows_sys::Win32::UI::Shell::IsInternetESCEnabled() };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn is_lfn_drive_a(psz_path: Option<&CStr>) -> BOOL {
    let pszPath_win32 = psz_path.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::Shell::IsLFNDriveA(pszPath_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn is_lfn_drive_w(psz_path: Option<&OsStr>) -> BOOL {
    let temp102 = psz_path.map(|val| {
        let mut temp102: Vec<u16> = val.encode_wide().collect();
        temp102.push(0);
        temp102
    });
    let pszPath_win32 = temp102.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::Shell::IsLFNDriveW(pszPath_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn is_net_drive(i_drive: i32) -> Result<i32> {
    let iDrive_win32 = i_drive;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::IsNetDrive(iDrive_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn is_os(dw_os: u32) -> BOOL {
    let dwOS_win32 = dw_os;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::IsOS(dwOS_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn is_user_an_admin() -> BOOL {
    let return_value = unsafe { windows_sys::Win32::UI::Shell::IsUserAnAdmin() };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn load_user_profile_a(h_token: Handle, lp_profile_info: Profileinfoa<'_>) -> Result<(BOOL, Profileinfoa<'static>)> {
    let hToken_win32 = h_token.into_raw();
    let mut lpProfileInfo_win32 = lp_profile_info.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::LoadUserProfileA(hToken_win32, &mut lpProfileInfo_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_profile_info = unsafe { Profileinfoa::from_win32(lpProfileInfo_win32) };
    Ok((real_return_value,lp_profile_info))
}
#[inline]
pub fn load_user_profile_w(h_token: Handle, lp_profile_info: Profileinfow<'_>) -> Result<(BOOL, Profileinfow<'static>)> {
    let hToken_win32 = h_token.into_raw();
    let mut lpProfileInfo_win32 = lp_profile_info.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::LoadUserProfileW(hToken_win32, &mut lpProfileInfo_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_profile_info = unsafe { Profileinfow::from_win32(lpProfileInfo_win32) };
    Ok((real_return_value,lp_profile_info))
}
#[inline]
pub fn parse_urla(pcsz_url: &CStr, ppu: Parsedurla<'_>) -> (HRESULT, Parsedurla<'static>) {
    let pcszURL_win32 = pcsz_url.as_ptr() as _;
    let mut ppu_win32 = ppu.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ParseURLA(pcszURL_win32, &mut ppu_win32) };
    let real_return_value = return_value;
    let ppu = unsafe { Parsedurla::from_win32(ppu_win32) };
    (real_return_value,ppu)
}
#[inline]
pub fn parse_urlw(pcsz_url: &OsStr, ppu: Parsedurlw<'_>) -> (HRESULT, Parsedurlw<'static>) {
    let mut temp103: Vec<u16> = pcsz_url.encode_wide().collect();
    temp103.push(0);
    let pcszURL_win32 = temp103.as_ptr() as _;
    let mut ppu_win32 = ppu.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ParseURLW(pcszURL_win32, &mut ppu_win32) };
    let real_return_value = return_value;
    let ppu = unsafe { Parsedurlw::from_win32(ppu_win32) };
    (real_return_value,ppu)
}
#[inline]
pub fn pick_icon_dlg(hwnd: Option<Hwnd>, psz_icon_path: &OsStr, cch_icon_path: u32, pi_icon_index: Option<i32>) -> Result<(i32, OsString, i32)> {
    let hwnd_win32 = hwnd.map_or(0, Hwnd::into_raw);
    let mut temp104: Vec<u16> = psz_icon_path.encode_wide().collect();
    temp104.push(0);
    let mut pszIconPath_win32 = temp104.as_ptr() as _;
    let cchIconPath_win32 = cch_icon_path;
    let mut piIconIndex_win32 = pi_icon_index;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::PickIconDlg(hwnd_win32, &mut pszIconPath_win32, cchIconPath_win32, &mut piIconIndex_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pi_icon_index = piIconIndex_win32;
    pszIconPath_win32.truncate(return_value as usize);
    let psz_icon_path = OsString::from_wide(&pszIconPath_win32);
    Ok((real_return_value,psz_icon_path, pi_icon_index))
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn qi_search(that: todo_void, pqit: &Qitab<'_>, riid: &GUID, ) -> (HRESULT, todo_void_ret, &mut todo_void_ret) {
//      let mut ppv = mem::MaybeUninit::zeroed();
//      let ppv_win32 = ppv.as_mut_ptr();
//      let mut that_win32 = todo_void;
//      let temp105 = pqit.to_win32();
//      let pqit_win32 = &temp105;
//      // SAFETY: type is a thin type
//      let riid_win32 = unsafe { &*(riid as *const _ as *const _) };
//      let return_value = unsafe { windows_sys::Win32::UI::Shell::QISearch(&mut that_win32, pqit_win32, riid_win32, ppv_win32) };
//      let real_return_value = return_value;
//      let ppv = unsafe { &mut *(unsafe { ppv.assume_init() } as *mut _) };
//      let that = todo_void;
//      (real_return_value,that, ppv)
//  }
#[inline]
pub fn read_cabinet_state(c_length: i32) -> Result<(BOOL, Cabinetstate)> {
    let mut pcs = mem::MaybeUninit::zeroed();
    let pcs_win32 = pcs.as_mut_ptr();
    let cLength_win32 = c_length;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ReadCabinetState(pcs_win32, cLength_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pcs = unsafe { Cabinetstate::from_win32(unsafe { pcs.assume_init() }) };
    Ok((real_return_value,pcs))
}
#[inline]
pub fn real_drive_type(i_drive: i32, f_ok_to_hit_net: BOOL) -> Result<i32> {
    let iDrive_win32 = i_drive;
    let fOKToHitNet_win32 = f_ok_to_hit_net;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::RealDriveType(iDrive_win32, fOKToHitNet_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn remove_window_subclass<Subclassproc: FnMut(Hwnd, u32, Wparam, Lparam, ) -> Lresult>(h_wnd: Hwnd, pfn_subclass: Subclassproc, ) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    unsafe extern "system" fn subclassproc_impl<Subclassproc>(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM, param4: usize, param5: usize) -> LRESULT {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let input3 = unsafe { Lparam::from_inner(param3) };
            let closure = unsafe {
                &mut *(param4 as usize as *mut Subclassproc)
            };
            let return_value = (closure)(input0, input1, input2, input3, );
            let real_return_value = return_value.into_inner();
            real_return_value
        })
    }
    let pfnSubclass_win32 = Some(subclassproc_impl::<Subclassproc>);
    let mut pfn_subclass = pfn_subclass;
    let uIdSubclass_win32 = (&mut pfn_subclass) as *mut _ as *mut _ as usize;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::RemoveWindowSubclass(hWnd_win32, pfnSubclass_win32, uIdSubclass_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn restart_dialog(hwnd: Option<Hwnd>, psz_prompt: Option<&OsStr>, dw_return: u32) -> Result<i32> {
    let hwnd_win32 = hwnd.map_or(0, Hwnd::into_raw);
    let temp106 = psz_prompt.map(|val| {
        let mut temp106: Vec<u16> = val.encode_wide().collect();
        temp106.push(0);
        temp106
    });
    let pszPrompt_win32 = temp106.map_or(ptr::null(), |v| v.as_ptr() as _);
    let dwReturn_win32 = dw_return;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::RestartDialog(hwnd_win32, pszPrompt_win32, dwReturn_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn restart_dialog_ex(hwnd: Option<Hwnd>, psz_prompt: Option<&OsStr>, dw_return: u32, dw_reason_code: u32) -> Result<i32> {
    let hwnd_win32 = hwnd.map_or(0, Hwnd::into_raw);
    let temp107 = psz_prompt.map(|val| {
        let mut temp107: Vec<u16> = val.encode_wide().collect();
        temp107.push(0);
        temp107
    });
    let pszPrompt_win32 = temp107.map_or(ptr::null(), |v| v.as_ptr() as _);
    let dwReturn_win32 = dw_return;
    let dwReasonCode_win32 = dw_reason_code;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::RestartDialogEx(hwnd_win32, pszPrompt_win32, dwReturn_win32, dwReasonCode_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn revoke_scale_change_notifications(display_device: i32, dw_cookie: u32) -> HRESULT {
    let displayDevice_win32 = display_device;
    let dwCookie_win32 = dw_cookie;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::RevokeScaleChangeNotifications(displayDevice_win32, dwCookie_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn sh_add_from_prop_sheet_ext_array<Lpfnsvaddpropsheetpage: FnMut(Hpropsheetpage, ) -> BOOL>(hpsxa: Hpsxa, lpfn_add_page: Lpfnsvaddpropsheetpage, ) -> u32 {
    let hpsxa_win32 = hpsxa.into_raw();
    unsafe extern "system" fn lpfnsvaddpropsheetpage_impl<Lpfnsvaddpropsheetpage>(param0: HPROPSHEETPAGE, param1: LPARAM) -> BOOL {
        abort_on_panic(move || {
            let input0 = unsafe { Hpropsheetpage::new(param0) };
            let closure = unsafe {
                &mut *(param1 as usize as *mut Lpfnsvaddpropsheetpage)
            };
            let return_value = (closure)(input0, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpfnAddPage_win32 = Some(lpfnsvaddpropsheetpage_impl::<Lpfnsvaddpropsheetpage>);
    let mut lpfn_add_page = lpfn_add_page;
    let lParam_win32 = unsafe { Lparam::from_ptr((&mut lpfn_add_page) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHAddFromPropSheetExtArray(hpsxa_win32, lpfnAddPage_win32, lParam_win32) };
    let real_return_value = return_value;
    real_return_value
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn sh_add_to_recent_docs(u_flags: u32, pv: Option<&todo_void>) -> () {
//      let uFlags_win32 = u_flags;
//      // SAFETY: type is a thin type
//      let pv_win32 = pv.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      let return_value = unsafe { windows_sys::Win32::UI::Shell::SHAddToRecentDocs(uFlags_win32, pv_win32) };
//      let _ = return_value;
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn sh_alloc(cb: usize) -> &mut todo_void_ret {
//      let cb_win32 = cb;
//      let return_value = unsafe { windows_sys::Win32::UI::Shell::SHAlloc(cb_win32) };
//      let real_return_value = unsafe { &mut *(return_value as *mut _) };
//      real_return_value
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn sh_alloc_shared(pv_data: Option<&[todo_void]>, dw_process_id: u32) -> Result<Handle> {
//      let pvData_win32 = pv_data.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let dwSize_win32 = pv_data.len() as _;
//      let dwProcessId_win32 = dw_process_id;
//      let return_value = unsafe { windows_sys::Win32::UI::Shell::SHAllocShared(pvData_win32, dwSize_win32, dwProcessId_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = unsafe { Handle::new(return_value) };
//      Ok(real_return_value)
//  }
#[inline]
pub fn sh_app_bar_message(dw_message: u32, p_data: Appbardata) -> (usize, Appbardata) {
    let dwMessage_win32 = dw_message;
    let mut pData_win32 = p_data.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHAppBarMessage(dwMessage_win32, &mut pData_win32) };
    let real_return_value = return_value;
    let p_data = unsafe { Appbardata::from_win32(pData_win32) };
    (real_return_value,p_data)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn sh_assoc_enum_handlers_for_protocol_by_application(protocol: &OsStr, riid: &GUID, ) -> (HRESULT, &mut todo_void_ret) {
//      let mut enum_handlers = mem::MaybeUninit::zeroed();
//      let enumHandlers_win32 = enum_handlers.as_mut_ptr();
//      let mut temp108: Vec<u16> = protocol.encode_wide().collect();
//      temp108.push(0);
//      let protocol_win32 = temp108.as_ptr() as _;
//      // SAFETY: type is a thin type
//      let riid_win32 = unsafe { &*(riid as *const _ as *const _) };
//      let return_value = unsafe { windows_sys::Win32::UI::Shell::SHAssocEnumHandlersForProtocolByApplication(protocol_win32, riid_win32, enumHandlers_win32) };
//      let real_return_value = return_value;
//      let enum_handlers = unsafe { &mut *(unsafe { enum_handlers.assume_init() } as *mut _) };
//      (real_return_value,enum_handlers)
//  }
#[inline]
pub fn sh_auto_complete(hwnd_edit: Hwnd, dw_flags: u32) -> HRESULT {
    let hwndEdit_win32 = hwnd_edit.into_raw();
    let dwFlags_win32 = dw_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHAutoComplete(hwndEdit_win32, dwFlags_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn shclsid_from_string(psz: &OsStr, ) -> (HRESULT, GUID) {
    let mut pclsid = mem::MaybeUninit::zeroed();
    let pclsid_win32 = pclsid.as_mut_ptr();
    let mut temp109: Vec<u16> = psz.encode_wide().collect();
    temp109.push(0);
    let psz_win32 = temp109.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHCLSIDFromString(psz_win32, pclsid_win32) };
    let real_return_value = return_value;
    let pclsid = unsafe { pclsid.assume_init() };
    (real_return_value,pclsid)
}
#[inline]
pub fn sh_empty_recycle_bin_a(hwnd: Option<Hwnd>, psz_root_path: Option<&CStr>, dw_flags: u32) -> HRESULT {
    let hwnd_win32 = hwnd.map_or(0, Hwnd::into_raw);
    let pszRootPath_win32 = psz_root_path.map_or(ptr::null(), |v| v.as_ptr() as _);
    let dwFlags_win32 = dw_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHEmptyRecycleBinA(hwnd_win32, pszRootPath_win32, dwFlags_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn sh_empty_recycle_bin_w(hwnd: Option<Hwnd>, psz_root_path: Option<&OsStr>, dw_flags: u32) -> HRESULT {
    let hwnd_win32 = hwnd.map_or(0, Hwnd::into_raw);
    let temp110 = psz_root_path.map(|val| {
        let mut temp110: Vec<u16> = val.encode_wide().collect();
        temp110.push(0);
        temp110
    });
    let pszRootPath_win32 = temp110.map_or(ptr::null(), |v| v.as_ptr() as _);
    let dwFlags_win32 = dw_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHEmptyRecycleBinW(hwnd_win32, pszRootPath_win32, dwFlags_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn sh_flush_sf_cache() -> () {
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHFlushSFCache() };
    let _ = return_value;
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn sh_free(pv: Option<&todo_void>) -> () {
//      // SAFETY: type is a thin type
//      let pv_win32 = pv.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      let return_value = unsafe { windows_sys::Win32::UI::Shell::SHFree(pv_win32) };
//      let _ = return_value;
//  }
#[inline]
pub fn sh_free_name_mappings(h_name_mappings: Option<Handle>) -> () {
    let hNameMappings_win32 = h_name_mappings.map_or(0, Handle::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHFreeNameMappings(hNameMappings_win32) };
    let _ = return_value;
}
#[inline]
pub fn sh_free_shared(h_data: Handle, dw_process_id: u32) -> Result<BOOL> {
    let hData_win32 = h_data.into_raw();
    let dwProcessId_win32 = dw_process_id;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHFreeShared(hData_win32, dwProcessId_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn sh_global_counter_decrement(id: i32) -> Result<i32> {
    let id_win32 = id;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHGlobalCounterDecrement(id_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn sh_global_counter_get_value(id: i32) -> Result<i32> {
    let id_win32 = id;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHGlobalCounterGetValue(id_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn sh_global_counter_increment(id: i32) -> Result<i32> {
    let id_win32 = id;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHGlobalCounterIncrement(id_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn sh_invoke_printer_command_a(hwnd: Option<Hwnd>, u_action: u32, lp_buf1: &CStr, lp_buf2: Option<&CStr>, f_modal: BOOL) -> Result<BOOL> {
    let hwnd_win32 = hwnd.map_or(0, Hwnd::into_raw);
    let uAction_win32 = u_action;
    let lpBuf1_win32 = lp_buf1.as_ptr() as _;
    let lpBuf2_win32 = lp_buf2.map_or(ptr::null(), |v| v.as_ptr() as _);
    let fModal_win32 = f_modal;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHInvokePrinterCommandA(hwnd_win32, uAction_win32, lpBuf1_win32, lpBuf2_win32, fModal_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn sh_invoke_printer_command_w(hwnd: Option<Hwnd>, u_action: u32, lp_buf1: &OsStr, lp_buf2: Option<&OsStr>, f_modal: BOOL) -> Result<BOOL> {
    let hwnd_win32 = hwnd.map_or(0, Hwnd::into_raw);
    let uAction_win32 = u_action;
    let mut temp111: Vec<u16> = lp_buf1.encode_wide().collect();
    temp111.push(0);
    let lpBuf1_win32 = temp111.as_ptr() as _;
    let temp112 = lp_buf2.map(|val| {
        let mut temp112: Vec<u16> = val.encode_wide().collect();
        temp112.push(0);
        temp112
    });
    let lpBuf2_win32 = temp112.map_or(ptr::null(), |v| v.as_ptr() as _);
    let fModal_win32 = f_modal;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHInvokePrinterCommandW(hwnd_win32, uAction_win32, lpBuf1_win32, lpBuf2_win32, fModal_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn sh_is_file_available_offline(pwsz_path: &OsStr, ) -> (HRESULT, u32) {
    let mut pdw_status = mem::MaybeUninit::zeroed();
    let pdwStatus_win32 = pdw_status.as_mut_ptr();
    let mut temp113: Vec<u16> = pwsz_path.encode_wide().collect();
    temp113.push(0);
    let pwszPath_win32 = temp113.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHIsFileAvailableOffline(pwszPath_win32, pdwStatus_win32) };
    let real_return_value = return_value;
    let pdw_status = unsafe { pdw_status.assume_init() };
    (real_return_value,pdw_status)
}
#[inline]
pub fn sh_is_low_memory_machine(dw_type: u32) -> BOOL {
    let dwType_win32 = dw_type;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHIsLowMemoryMachine(dwType_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn sh_message_box_check_a(hwnd: Option<Hwnd>, psz_text: &CStr, psz_caption: &CStr, u_type: u32, i_default: i32, psz_reg_val: &CStr) -> Result<i32> {
    let hwnd_win32 = hwnd.map_or(0, Hwnd::into_raw);
    let pszText_win32 = psz_text.as_ptr() as _;
    let pszCaption_win32 = psz_caption.as_ptr() as _;
    let uType_win32 = u_type;
    let iDefault_win32 = i_default;
    let pszRegVal_win32 = psz_reg_val.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHMessageBoxCheckA(hwnd_win32, pszText_win32, pszCaption_win32, uType_win32, iDefault_win32, pszRegVal_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn sh_message_box_check_w(hwnd: Option<Hwnd>, psz_text: &OsStr, psz_caption: &OsStr, u_type: u32, i_default: i32, psz_reg_val: &OsStr) -> Result<i32> {
    let hwnd_win32 = hwnd.map_or(0, Hwnd::into_raw);
    let mut temp114: Vec<u16> = psz_text.encode_wide().collect();
    temp114.push(0);
    let pszText_win32 = temp114.as_ptr() as _;
    let mut temp115: Vec<u16> = psz_caption.encode_wide().collect();
    temp115.push(0);
    let pszCaption_win32 = temp115.as_ptr() as _;
    let uType_win32 = u_type;
    let iDefault_win32 = i_default;
    let mut temp116: Vec<u16> = psz_reg_val.encode_wide().collect();
    temp116.push(0);
    let pszRegVal_win32 = temp116.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHMessageBoxCheckW(hwnd_win32, pszText_win32, pszCaption_win32, uType_win32, iDefault_win32, pszRegVal_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn sh_object_properties(hwnd: Option<Hwnd>, shop_object_type: i32, psz_object_name: &OsStr, psz_property_page: Option<&OsStr>) -> Result<BOOL> {
    let hwnd_win32 = hwnd.map_or(0, Hwnd::into_raw);
    let shopObjectType_win32 = shop_object_type;
    let mut temp117: Vec<u16> = psz_object_name.encode_wide().collect();
    temp117.push(0);
    let pszObjectName_win32 = temp117.as_ptr() as _;
    let temp118 = psz_property_page.map(|val| {
        let mut temp118: Vec<u16> = val.encode_wide().collect();
        temp118.push(0);
        temp118
    });
    let pszPropertyPage_win32 = temp118.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHObjectProperties(hwnd_win32, shopObjectType_win32, pszObjectName_win32, pszPropertyPage_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn sh_test_token_membership(h_token: Option<Handle>, ul_rid: u32) -> Result<BOOL> {
    let hToken_win32 = h_token.map_or(0, Handle::into_raw);
    let ulRID_win32 = ul_rid;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SHTestTokenMembership(hToken_win32, ulRID_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_current_process_explicit_app_user_model_id(app_id: &OsStr) -> HRESULT {
    let mut temp119: Vec<u16> = app_id.encode_wide().collect();
    temp119.push(0);
    let AppID_win32 = temp119.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SetCurrentProcessExplicitAppUserModelID(AppID_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn set_menu_context_help_id(param0: Hmenu, param1: u32) -> Result<BOOL> {
    let param0_win32 = param0.into_raw();
    let param1_win32 = param1;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SetMenuContextHelpId(param0_win32, param1_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_window_context_help_id(param0: Hwnd, param1: u32) -> Result<BOOL> {
    let param0_win32 = param0.into_raw();
    let param1_win32 = param1;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SetWindowContextHelpId(param0_win32, param1_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_window_subclass<Subclassproc: FnMut(Hwnd, u32, Wparam, Lparam, ) -> Lresult>(h_wnd: Hwnd, pfn_subclass: Subclassproc, u_id_subclass: usize, ) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    unsafe extern "system" fn subclassproc_impl<Subclassproc>(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM, param4: usize, param5: usize) -> LRESULT {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let input3 = unsafe { Lparam::from_inner(param3) };
            let closure = unsafe {
                &mut *(param4 as usize as *mut Subclassproc)
            };
            let return_value = (closure)(input0, input1, input2, input3, );
            let real_return_value = return_value.into_inner();
            real_return_value
        })
    }
    let pfnSubclass_win32 = Some(subclassproc_impl::<Subclassproc>);
    let mut pfn_subclass = pfn_subclass;
    let dwRefData_win32 = (&mut pfn_subclass) as *mut _ as *mut _ as usize;
    let uIdSubclass_win32 = u_id_subclass;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::SetWindowSubclass(hWnd_win32, pfnSubclass_win32, uIdSubclass_win32, dwRefData_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn shell_about_a(h_wnd: Option<Hwnd>, sz_app: &CStr, sz_other_stuff: Option<&CStr>, h_icon: Option<Hicon>) -> Result<i32> {
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let szApp_win32 = sz_app.as_ptr() as _;
    let szOtherStuff_win32 = sz_other_stuff.map_or(ptr::null(), |v| v.as_ptr() as _);
    let hIcon_win32 = h_icon.map_or(0, Hicon::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ShellAboutA(hWnd_win32, szApp_win32, szOtherStuff_win32, hIcon_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn shell_about_w(h_wnd: Option<Hwnd>, sz_app: &OsStr, sz_other_stuff: Option<&OsStr>, h_icon: Option<Hicon>) -> Result<i32> {
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let mut temp120: Vec<u16> = sz_app.encode_wide().collect();
    temp120.push(0);
    let szApp_win32 = temp120.as_ptr() as _;
    let temp121 = sz_other_stuff.map(|val| {
        let mut temp121: Vec<u16> = val.encode_wide().collect();
        temp121.push(0);
        temp121
    });
    let szOtherStuff_win32 = temp121.map_or(ptr::null(), |v| v.as_ptr() as _);
    let hIcon_win32 = h_icon.map_or(0, Hicon::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ShellAboutW(hWnd_win32, szApp_win32, szOtherStuff_win32, hIcon_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn shell_execute_a(hwnd: Option<Hwnd>, lp_operation: Option<&CStr>, lp_file: &CStr, lp_parameters: Option<&CStr>, lp_directory: Option<&CStr>, n_show_cmd: i32) -> Result<Hinstance> {
    let hwnd_win32 = hwnd.map_or(0, Hwnd::into_raw);
    let lpOperation_win32 = lp_operation.map_or(ptr::null(), |v| v.as_ptr() as _);
    let lpFile_win32 = lp_file.as_ptr() as _;
    let lpParameters_win32 = lp_parameters.map_or(ptr::null(), |v| v.as_ptr() as _);
    let lpDirectory_win32 = lp_directory.map_or(ptr::null(), |v| v.as_ptr() as _);
    let nShowCmd_win32 = n_show_cmd;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ShellExecuteA(hwnd_win32, lpOperation_win32, lpFile_win32, lpParameters_win32, lpDirectory_win32, nShowCmd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hinstance::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn shell_execute_w(hwnd: Option<Hwnd>, lp_operation: Option<&OsStr>, lp_file: &OsStr, lp_parameters: Option<&OsStr>, lp_directory: Option<&OsStr>, n_show_cmd: i32) -> Result<Hinstance> {
    let hwnd_win32 = hwnd.map_or(0, Hwnd::into_raw);
    let temp122 = lp_operation.map(|val| {
        let mut temp122: Vec<u16> = val.encode_wide().collect();
        temp122.push(0);
        temp122
    });
    let lpOperation_win32 = temp122.map_or(ptr::null(), |v| v.as_ptr() as _);
    let mut temp123: Vec<u16> = lp_file.encode_wide().collect();
    temp123.push(0);
    let lpFile_win32 = temp123.as_ptr() as _;
    let temp124 = lp_parameters.map(|val| {
        let mut temp124: Vec<u16> = val.encode_wide().collect();
        temp124.push(0);
        temp124
    });
    let lpParameters_win32 = temp124.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp125 = lp_directory.map(|val| {
        let mut temp125: Vec<u16> = val.encode_wide().collect();
        temp125.push(0);
        temp125
    });
    let lpDirectory_win32 = temp125.map_or(ptr::null(), |v| v.as_ptr() as _);
    let nShowCmd_win32 = n_show_cmd;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ShellExecuteW(hwnd_win32, lpOperation_win32, lpFile_win32, lpParameters_win32, lpDirectory_win32, nShowCmd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hinstance::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn shell_message_box_a(h_app_inst: Option<Hinstance>, h_wnd: Option<Hwnd>, lpc_text: &CStr, lpc_title: Option<&CStr>, fu_style: u32) -> Result<i32> {
    let hAppInst_win32 = h_app_inst.map_or(0, Hinstance::into_raw);
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let lpcText_win32 = lpc_text.as_ptr() as _;
    let lpcTitle_win32 = lpc_title.map_or(ptr::null(), |v| v.as_ptr() as _);
    let fuStyle_win32 = fu_style;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ShellMessageBoxA(hAppInst_win32, hWnd_win32, lpcText_win32, lpcTitle_win32, fuStyle_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn shell_message_box_w(h_app_inst: Option<Hinstance>, h_wnd: Option<Hwnd>, lpc_text: &OsStr, lpc_title: Option<&OsStr>, fu_style: u32) -> Result<i32> {
    let hAppInst_win32 = h_app_inst.map_or(0, Hinstance::into_raw);
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let mut temp126: Vec<u16> = lpc_text.encode_wide().collect();
    temp126.push(0);
    let lpcText_win32 = temp126.as_ptr() as _;
    let temp127 = lpc_title.map(|val| {
        let mut temp127: Vec<u16> = val.encode_wide().collect();
        temp127.push(0);
        temp127
    });
    let lpcTitle_win32 = temp127.map_or(ptr::null(), |v| v.as_ptr() as _);
    let fuStyle_win32 = fu_style;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::ShellMessageBoxW(hAppInst_win32, hWnd_win32, lpcText_win32, lpcTitle_win32, fuStyle_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn shell_get_cached_image_index(pwsz_icon_path: &OsStr, i_icon_index: i32, u_icon_flags: u32) -> Result<i32> {
    let mut temp128: Vec<u16> = pwsz_icon_path.encode_wide().collect();
    temp128.push(0);
    let pwszIconPath_win32 = temp128.as_ptr() as _;
    let iIconIndex_win32 = i_icon_index;
    let uIconFlags_win32 = u_icon_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::Shell_GetCachedImageIndex(pwszIconPath_win32, iIconIndex_win32, uIconFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn shell_get_cached_image_index_a(psz_icon_path: &CStr, i_icon_index: i32, u_icon_flags: u32) -> Result<i32> {
    let pszIconPath_win32 = psz_icon_path.as_ptr() as _;
    let iIconIndex_win32 = i_icon_index;
    let uIconFlags_win32 = u_icon_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::Shell_GetCachedImageIndexA(pszIconPath_win32, iIconIndex_win32, uIconFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn shell_get_cached_image_index_w(psz_icon_path: &OsStr, i_icon_index: i32, u_icon_flags: u32) -> Result<i32> {
    let mut temp129: Vec<u16> = psz_icon_path.encode_wide().collect();
    temp129.push(0);
    let pszIconPath_win32 = temp129.as_ptr() as _;
    let iIconIndex_win32 = i_icon_index;
    let uIconFlags_win32 = u_icon_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::Shell_GetCachedImageIndexW(pszIconPath_win32, iIconIndex_win32, uIconFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn shell_merge_menus(hm_dst: Hmenu, hm_src: Hmenu, u_insert: u32, u_id_adjust: u32, u_id_adjust_max: u32, u_flags: u32) -> u32 {
    let hmDst_win32 = hm_dst.into_raw();
    let hmSrc_win32 = hm_src.into_raw();
    let uInsert_win32 = u_insert;
    let uIDAdjust_win32 = u_id_adjust;
    let uIDAdjustMax_win32 = u_id_adjust_max;
    let uFlags_win32 = u_flags;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::Shell_MergeMenus(hmDst_win32, hmSrc_win32, uInsert_win32, uIDAdjust_win32, uIDAdjustMax_win32, uFlags_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn unload_user_profile(h_token: Handle, h_profile: Handle) -> Result<BOOL> {
    let hToken_win32 = h_token.into_raw();
    let hProfile_win32 = h_profile.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::Shell::UnloadUserProfile(hToken_win32, hProfile_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn unregister_scale_change_event(dw_cookie: usize) -> HRESULT {
    let dwCookie_win32 = dw_cookie;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::UnregisterScaleChangeEvent(dwCookie_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn which_platform() -> u32 {
    let return_value = unsafe { windows_sys::Win32::UI::Shell::WhichPlatform() };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn win32_delete_file(psz_path: &OsStr) -> Result<BOOL> {
    let mut temp130: Vec<u16> = psz_path.encode_wide().collect();
    temp130.push(0);
    let pszPath_win32 = temp130.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::Win32DeleteFile(pszPath_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn win_help_a(h_wnd_main: Option<Hwnd>, lpsz_help: Option<&CStr>, u_command: u32, dw_data: usize) -> Result<BOOL> {
    let hWndMain_win32 = h_wnd_main.map_or(0, Hwnd::into_raw);
    let lpszHelp_win32 = lpsz_help.map_or(ptr::null(), |v| v.as_ptr() as _);
    let uCommand_win32 = u_command;
    let dwData_win32 = dw_data;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::WinHelpA(hWndMain_win32, lpszHelp_win32, uCommand_win32, dwData_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn win_help_w(h_wnd_main: Option<Hwnd>, lpsz_help: Option<&OsStr>, u_command: u32, dw_data: usize) -> Result<BOOL> {
    let hWndMain_win32 = h_wnd_main.map_or(0, Hwnd::into_raw);
    let temp131 = lpsz_help.map(|val| {
        let mut temp131: Vec<u16> = val.encode_wide().collect();
        temp131.push(0);
        temp131
    });
    let lpszHelp_win32 = temp131.map_or(ptr::null(), |v| v.as_ptr() as _);
    let uCommand_win32 = u_command;
    let dwData_win32 = dw_data;
    let return_value = unsafe { windows_sys::Win32::UI::Shell::WinHelpW(hWndMain_win32, lpszHelp_win32, uCommand_win32, dwData_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn write_cabinet_state(pcs: &Cabinetstate) -> Result<BOOL> {
    // SAFETY: type is a thin type
    let pcs_win32 = unsafe { &*(pcs as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::Shell::WriteCabinetState(pcs_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn adjust_window_rect(lp_rect: Rect, dw_style: u32, b_menu: BOOL) -> Result<(BOOL, Rect)> {
    let mut lpRect_win32 = lp_rect.to_win32();
    let dwStyle_win32 = dw_style;
    let bMenu_win32 = b_menu;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::AdjustWindowRect(&mut lpRect_win32, dwStyle_win32, bMenu_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_rect = unsafe { Rect::from_win32(lpRect_win32) };
    Ok((real_return_value,lp_rect))
}
#[inline]
pub fn adjust_window_rect_ex(lp_rect: Rect, dw_style: u32, b_menu: BOOL, dw_ex_style: u32) -> Result<(BOOL, Rect)> {
    let mut lpRect_win32 = lp_rect.to_win32();
    let dwStyle_win32 = dw_style;
    let bMenu_win32 = b_menu;
    let dwExStyle_win32 = dw_ex_style;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::AdjustWindowRectEx(&mut lpRect_win32, dwStyle_win32, bMenu_win32, dwExStyle_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_rect = unsafe { Rect::from_win32(lpRect_win32) };
    Ok((real_return_value,lp_rect))
}
#[inline]
pub fn allow_set_foreground_window(dw_process_id: u32) -> Result<BOOL> {
    let dwProcessId_win32 = dw_process_id;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::AllowSetForegroundWindow(dwProcessId_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn animate_window(h_wnd: Hwnd, dw_time: u32, dw_flags: u32) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let dwTime_win32 = dw_time;
    let dwFlags_win32 = dw_flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::AnimateWindow(hWnd_win32, dwTime_win32, dwFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn any_popup() -> Result<BOOL> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::AnyPopup() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn append_menu_a(h_menu: Hmenu, u_flags: u32, u_id_new_item: usize, lp_new_item: Option<&CStr>) -> Result<BOOL> {
    let hMenu_win32 = h_menu.into_raw();
    let uFlags_win32 = u_flags;
    let uIDNewItem_win32 = u_id_new_item;
    let lpNewItem_win32 = lp_new_item.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::AppendMenuA(hMenu_win32, uFlags_win32, uIDNewItem_win32, lpNewItem_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn append_menu_w(h_menu: Hmenu, u_flags: u32, u_id_new_item: usize, lp_new_item: Option<&OsStr>) -> Result<BOOL> {
    let hMenu_win32 = h_menu.into_raw();
    let uFlags_win32 = u_flags;
    let uIDNewItem_win32 = u_id_new_item;
    let temp132 = lp_new_item.map(|val| {
        let mut temp132: Vec<u16> = val.encode_wide().collect();
        temp132.push(0);
        temp132
    });
    let lpNewItem_win32 = temp132.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::AppendMenuW(hMenu_win32, uFlags_win32, uIDNewItem_win32, lpNewItem_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn arrange_iconic_windows(h_wnd: Hwnd) -> u32 {
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ArrangeIconicWindows(hWnd_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn begin_defer_window_pos(n_num_windows: i32) -> isize {
    let nNumWindows_win32 = n_num_windows;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::BeginDeferWindowPos(nNumWindows_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn bring_window_to_top(h_wnd: Hwnd) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::BringWindowToTop(hWnd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn calculate_popup_window_position(anchor_point: &Point, window_size: &Size, flags: u32, exclude_rect: Option<&Rect>, ) -> Result<(BOOL, Rect)> {
    let mut popup_window_position = mem::MaybeUninit::zeroed();
    let popupWindowPosition_win32 = popup_window_position.as_mut_ptr();
    // SAFETY: type is a thin type
    let anchorPoint_win32 = unsafe { &*(anchor_point as *const _ as *const _) };
    // SAFETY: type is a thin type
    let windowSize_win32 = unsafe { &*(window_size as *const _ as *const _) };
    let flags_win32 = flags;
    // SAFETY: type is a thin type
    let excludeRect_win32 = exclude_rect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CalculatePopupWindowPosition(anchorPoint_win32, windowSize_win32, flags_win32, excludeRect_win32, popupWindowPosition_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let popup_window_position = unsafe { Rect::from_win32(unsafe { popup_window_position.assume_init() }) };
    Ok((real_return_value,popup_window_position))
}
#[inline]
pub fn call_msg_filter_a(lp_msg: &[Msg], ) -> Result<BOOL> {
    let lpMsg_win32 = lp_msg.as_ptr() as _;
    let nCode_win32 = lp_msg.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CallMsgFilterA(lpMsg_win32, nCode_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn call_msg_filter_w(lp_msg: &[Msg], ) -> Result<BOOL> {
    let lpMsg_win32 = lp_msg.as_ptr() as _;
    let nCode_win32 = lp_msg.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CallMsgFilterW(lpMsg_win32, nCode_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn call_next_hook_ex(hhk: Option<Hhook>, n_code: i32, w_param: Wparam, l_param: Lparam) -> Lresult {
    let hhk_win32 = hhk.map_or(0, Hhook::into_raw);
    let nCode_win32 = n_code;
    let wParam_win32 = w_param.into_inner();
    let lParam_win32 = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CallNextHookEx(hhk_win32, nCode_win32, wParam_win32, lParam_win32) };
    let real_return_value = unsafe { Lresult::from_inner(return_value) };
    real_return_value
}
#[inline]
pub fn call_window_proc_a<Wndproc: FnMut(Hwnd, u32, Wparam, ) -> Lresult>(lp_prev_wnd_func: Wndproc, h_wnd: Hwnd, msg: u32, w_param: Wparam, ) -> Lresult {
    unsafe extern "system" fn wndproc_impl<Wndproc>(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM) -> LRESULT {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let closure = unsafe {
                &mut *(param3 as usize as *mut Wndproc)
            };
            let return_value = (closure)(input0, input1, input2, );
            let real_return_value = return_value.into_inner();
            real_return_value
        })
    }
    let lpPrevWndFunc_win32 = Some(wndproc_impl::<Wndproc>);
    let mut lp_prev_wnd_func = lp_prev_wnd_func;
    let lParam_win32 = unsafe { Lparam::from_ptr((&mut lp_prev_wnd_func) as *mut _ as *mut _) };
    let hWnd_win32 = h_wnd.into_raw();
    let Msg_win32 = msg;
    let wParam_win32 = w_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CallWindowProcA(lpPrevWndFunc_win32, hWnd_win32, Msg_win32, wParam_win32, lParam_win32) };
    let real_return_value = unsafe { Lresult::from_inner(return_value) };
    real_return_value
}
#[inline]
pub fn call_window_proc_w<Wndproc: FnMut(Hwnd, u32, Wparam, ) -> Lresult>(lp_prev_wnd_func: Wndproc, h_wnd: Hwnd, msg: u32, w_param: Wparam, ) -> Lresult {
    unsafe extern "system" fn wndproc_impl<Wndproc>(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM) -> LRESULT {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let closure = unsafe {
                &mut *(param3 as usize as *mut Wndproc)
            };
            let return_value = (closure)(input0, input1, input2, );
            let real_return_value = return_value.into_inner();
            real_return_value
        })
    }
    let lpPrevWndFunc_win32 = Some(wndproc_impl::<Wndproc>);
    let mut lp_prev_wnd_func = lp_prev_wnd_func;
    let lParam_win32 = unsafe { Lparam::from_ptr((&mut lp_prev_wnd_func) as *mut _ as *mut _) };
    let hWnd_win32 = h_wnd.into_raw();
    let Msg_win32 = msg;
    let wParam_win32 = w_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CallWindowProcW(lpPrevWndFunc_win32, hWnd_win32, Msg_win32, wParam_win32, lParam_win32) };
    let real_return_value = unsafe { Lresult::from_inner(return_value) };
    real_return_value
}
#[inline]
pub fn cancel_shutdown() -> Result<BOOL> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CancelShutdown() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn cascade_windows(hwnd_parent: Option<Hwnd>, w_how: u32, lp_rect: Option<&Rect>, lp_kids: Option<&[Hwnd]>) -> u16 {
    let hwndParent_win32 = hwnd_parent.map_or(0, Hwnd::into_raw);
    let wHow_win32 = w_how;
    // SAFETY: type is a thin type
    let lpRect_win32 = lp_rect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let lpKids_win32 = lp_kids.map_or(ptr::null(), |v| v.as_ptr() as _);
    let cKids_win32 = lp_kids.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CascadeWindows(hwndParent_win32, wHow_win32, lpRect_win32, cKids_win32, lpKids_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn change_menu_a(h_menu: Hmenu, cmd: u32, lpsz_new_item: Option<&CStr>, cmd_insert: u32, flags: u32) -> Result<BOOL> {
    let hMenu_win32 = h_menu.into_raw();
    let cmd_win32 = cmd;
    let lpszNewItem_win32 = lpsz_new_item.map_or(ptr::null(), |v| v.as_ptr() as _);
    let cmdInsert_win32 = cmd_insert;
    let flags_win32 = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ChangeMenuA(hMenu_win32, cmd_win32, lpszNewItem_win32, cmdInsert_win32, flags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn change_menu_w(h_menu: Hmenu, cmd: u32, lpsz_new_item: Option<&OsStr>, cmd_insert: u32, flags: u32) -> Result<BOOL> {
    let hMenu_win32 = h_menu.into_raw();
    let cmd_win32 = cmd;
    let temp133 = lpsz_new_item.map(|val| {
        let mut temp133: Vec<u16> = val.encode_wide().collect();
        temp133.push(0);
        temp133
    });
    let lpszNewItem_win32 = temp133.map_or(ptr::null(), |v| v.as_ptr() as _);
    let cmdInsert_win32 = cmd_insert;
    let flags_win32 = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ChangeMenuW(hMenu_win32, cmd_win32, lpszNewItem_win32, cmdInsert_win32, flags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn change_window_message_filter(message: u32, dw_flag: u32) -> Result<BOOL> {
    let message_win32 = message;
    let dwFlag_win32 = dw_flag;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ChangeWindowMessageFilter(message_win32, dwFlag_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn change_window_message_filter_ex(hwnd: Hwnd, message: u32, action: u32, p_change_filter_struct: Option<Changefilterstruct>) -> Result<(BOOL, Changefilterstruct)> {
    let hwnd_win32 = hwnd.into_raw();
    let message_win32 = message;
    let action_win32 = action;
    let mut pChangeFilterStruct_win32 = p_change_filter_struct.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ChangeWindowMessageFilterEx(hwnd_win32, message_win32, action_win32, &mut pChangeFilterStruct_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let p_change_filter_struct = unsafe { Changefilterstruct::from_win32(pChangeFilterStruct_win32) };
    Ok((real_return_value,p_change_filter_struct))
}
#[inline]
pub fn check_menu_item(h_menu: Hmenu, u_id_check_item: u32, u_check: u32) -> u32 {
    let hMenu_win32 = h_menu.into_raw();
    let uIDCheckItem_win32 = u_id_check_item;
    let uCheck_win32 = u_check;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CheckMenuItem(hMenu_win32, uIDCheckItem_win32, uCheck_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn check_menu_radio_item(hmenu: Hmenu, first: u32, last: u32, check: u32, flags: u32) -> Result<BOOL> {
    let hmenu_win32 = hmenu.into_raw();
    let first_win32 = first;
    let last_win32 = last;
    let check_win32 = check;
    let flags_win32 = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CheckMenuRadioItem(hmenu_win32, first_win32, last_win32, check_win32, flags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn child_window_from_point(h_wnd_parent: Hwnd, point: Point) -> Result<Hwnd> {
    let hWndParent_win32 = h_wnd_parent.into_raw();
    let Point_win32 = point.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ChildWindowFromPoint(hWndParent_win32, Point_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn child_window_from_point_ex(hwnd: Hwnd, pt: Point, flags: u32) -> Result<Hwnd> {
    let hwnd_win32 = hwnd.into_raw();
    let pt_win32 = pt.to_win32();
    let flags_win32 = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ChildWindowFromPointEx(hwnd_win32, pt_win32, flags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn clip_cursor(lp_rect: Option<&Rect>) -> Result<BOOL> {
    // SAFETY: type is a thin type
    let lpRect_win32 = lp_rect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ClipCursor(lpRect_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn close_window(h_wnd: Hwnd) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CloseWindow(hWnd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn copy_accelerator_table_a(h_accel_src: Haccel, c_accel_entries: i32) -> Result<(i32, Accel)> {
    let mut lp_accel_dst = mem::MaybeUninit::zeroed();
    let lpAccelDst_win32 = lp_accel_dst.as_mut_ptr();
    let hAccelSrc_win32 = h_accel_src.into_raw();
    let cAccelEntries_win32 = c_accel_entries;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CopyAcceleratorTableA(hAccelSrc_win32, lpAccelDst_win32, cAccelEntries_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_accel_dst = unsafe { Accel::from_win32(unsafe { lp_accel_dst.assume_init() }) };
    Ok((real_return_value,lp_accel_dst))
}
#[inline]
pub fn copy_accelerator_table_w(h_accel_src: Haccel, c_accel_entries: i32) -> Result<(i32, Accel)> {
    let mut lp_accel_dst = mem::MaybeUninit::zeroed();
    let lpAccelDst_win32 = lp_accel_dst.as_mut_ptr();
    let hAccelSrc_win32 = h_accel_src.into_raw();
    let cAccelEntries_win32 = c_accel_entries;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CopyAcceleratorTableW(hAccelSrc_win32, lpAccelDst_win32, cAccelEntries_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_accel_dst = unsafe { Accel::from_win32(unsafe { lp_accel_dst.assume_init() }) };
    Ok((real_return_value,lp_accel_dst))
}
#[inline]
pub fn copy_icon(h_icon: Hicon) -> Result<Hicon> {
    let hIcon_win32 = h_icon.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CopyIcon(hIcon_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hicon::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn copy_image(h: Handle, r#type: u32, cx: i32, cy: i32, flags: u32) -> Result<Handle> {
    let h_win32 = h.into_raw();
    let r#type_win32 = r#type;
    let cx_win32 = cx;
    let cy_win32 = cy;
    let flags_win32 = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CopyImage(h_win32, r#type_win32, cx_win32, cy_win32, flags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Handle::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_accelerator_table_a(paccel: &[Accel], ) -> Result<Haccel> {
    let paccel_win32 = paccel.as_ptr() as _;
    let cAccel_win32 = paccel.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateAcceleratorTableA(paccel_win32, cAccel_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Haccel::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_accelerator_table_w(paccel: &[Accel], ) -> Result<Haccel> {
    let paccel_win32 = paccel.as_ptr() as _;
    let cAccel_win32 = paccel.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateAcceleratorTableW(paccel_win32, cAccel_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Haccel::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_caret(h_wnd: Hwnd, h_bitmap: Option<Hbitmap>, n_width: i32, n_height: i32) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let hBitmap_win32 = h_bitmap.map_or(0, Hbitmap::into_raw);
    let nWidth_win32 = n_width;
    let nHeight_win32 = n_height;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateCaret(hWnd_win32, hBitmap_win32, nWidth_win32, nHeight_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn create_cursor(h_inst: Option<Hinstance>, x_hot_spot: i32, y_hot_spot: i32, pv_and_plane: &[todo_void], pv_xor_plane: &[todo_void]) -> Result<Hcursor> {
//      let hInst_win32 = h_inst.map_or(0, Hinstance::into_raw);
//      let xHotSpot_win32 = x_hot_spot;
//      let yHotSpot_win32 = y_hot_spot;
//      let pvANDPlane_win32 = pv_and_plane.as_ptr() as _;
//      let nWidth_win32 = pv_and_plane.len() as _;
//      let pvXORPlane_win32 = pv_xor_plane.as_ptr() as _;
//      let nHeight_win32 = pv_xor_plane.len() as _;
//      let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateCursor(hInst_win32, xHotSpot_win32, yHotSpot_win32, nWidth_win32, nHeight_win32, pvANDPlane_win32, pvXORPlane_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = unsafe { Hcursor::new(return_value) };
//      Ok(real_return_value)
//  }
#[inline]
pub fn create_dialog_indirect_param_a<Dlgproc: FnMut(Hwnd, u32, Wparam, ) -> isize>(h_instance: Option<Hinstance>, lp_template: &Dlgtemplate, h_wnd_parent: Option<Hwnd>, lp_dialog_func: Option<Dlgproc>, ) -> Result<Hwnd> {
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    // SAFETY: type is a thin type
    let lpTemplate_win32 = unsafe { &*(lp_template as *const _ as *const _) };
    let hWndParent_win32 = h_wnd_parent.map_or(0, Hwnd::into_raw);
    unsafe extern "system" fn dlgproc_impl<Dlgproc>(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM) -> isize {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let closure = unsafe {
                &mut *(param3 as usize as *mut Dlgproc)
            };
            let return_value = (closure)(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpDialogFunc_win32 = Some(dlgproc_impl::<Dlgproc>);
    let mut lp_dialog_func = lp_dialog_func;
    let dwInitParam_win32 = unsafe { Lparam::from_ptr((&mut lp_dialog_func) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateDialogIndirectParamA(hInstance_win32, lpTemplate_win32, hWndParent_win32, lpDialogFunc_win32, dwInitParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_dialog_indirect_param_w<Dlgproc: FnMut(Hwnd, u32, Wparam, ) -> isize>(h_instance: Option<Hinstance>, lp_template: &Dlgtemplate, h_wnd_parent: Option<Hwnd>, lp_dialog_func: Option<Dlgproc>, ) -> Result<Hwnd> {
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    // SAFETY: type is a thin type
    let lpTemplate_win32 = unsafe { &*(lp_template as *const _ as *const _) };
    let hWndParent_win32 = h_wnd_parent.map_or(0, Hwnd::into_raw);
    unsafe extern "system" fn dlgproc_impl<Dlgproc>(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM) -> isize {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let closure = unsafe {
                &mut *(param3 as usize as *mut Dlgproc)
            };
            let return_value = (closure)(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpDialogFunc_win32 = Some(dlgproc_impl::<Dlgproc>);
    let mut lp_dialog_func = lp_dialog_func;
    let dwInitParam_win32 = unsafe { Lparam::from_ptr((&mut lp_dialog_func) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateDialogIndirectParamW(hInstance_win32, lpTemplate_win32, hWndParent_win32, lpDialogFunc_win32, dwInitParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_dialog_param_a<Dlgproc: FnMut(Hwnd, u32, Wparam, ) -> isize>(h_instance: Option<Hinstance>, lp_template_name: &CStr, h_wnd_parent: Option<Hwnd>, lp_dialog_func: Option<Dlgproc>, ) -> Result<Hwnd> {
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    let lpTemplateName_win32 = lp_template_name.as_ptr() as _;
    let hWndParent_win32 = h_wnd_parent.map_or(0, Hwnd::into_raw);
    unsafe extern "system" fn dlgproc_impl<Dlgproc>(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM) -> isize {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let closure = unsafe {
                &mut *(param3 as usize as *mut Dlgproc)
            };
            let return_value = (closure)(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpDialogFunc_win32 = Some(dlgproc_impl::<Dlgproc>);
    let mut lp_dialog_func = lp_dialog_func;
    let dwInitParam_win32 = unsafe { Lparam::from_ptr((&mut lp_dialog_func) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateDialogParamA(hInstance_win32, lpTemplateName_win32, hWndParent_win32, lpDialogFunc_win32, dwInitParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_dialog_param_w<Dlgproc: FnMut(Hwnd, u32, Wparam, ) -> isize>(h_instance: Option<Hinstance>, lp_template_name: &OsStr, h_wnd_parent: Option<Hwnd>, lp_dialog_func: Option<Dlgproc>, ) -> Result<Hwnd> {
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    let mut temp134: Vec<u16> = lp_template_name.encode_wide().collect();
    temp134.push(0);
    let lpTemplateName_win32 = temp134.as_ptr() as _;
    let hWndParent_win32 = h_wnd_parent.map_or(0, Hwnd::into_raw);
    unsafe extern "system" fn dlgproc_impl<Dlgproc>(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM) -> isize {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let closure = unsafe {
                &mut *(param3 as usize as *mut Dlgproc)
            };
            let return_value = (closure)(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpDialogFunc_win32 = Some(dlgproc_impl::<Dlgproc>);
    let mut lp_dialog_func = lp_dialog_func;
    let dwInitParam_win32 = unsafe { Lparam::from_ptr((&mut lp_dialog_func) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateDialogParamW(hInstance_win32, lpTemplateName_win32, hWndParent_win32, lpDialogFunc_win32, dwInitParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_icon(h_instance: Option<Hinstance>, c_planes: u8, c_bits_pixel: u8, lpb_an_dbits: &[u8], lpb_xo_rbits: &[u8]) -> Result<Hicon> {
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    let cPlanes_win32 = c_planes;
    let cBitsPixel_win32 = c_bits_pixel;
    let lpbANDbits_win32 = lpb_an_dbits.as_ptr() as _;
    let nWidth_win32 = lpb_an_dbits.len() as _;
    let lpbXORbits_win32 = lpb_xo_rbits.as_ptr() as _;
    let nHeight_win32 = lpb_xo_rbits.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateIcon(hInstance_win32, nWidth_win32, nHeight_win32, cPlanes_win32, cBitsPixel_win32, lpbANDbits_win32, lpbXORbits_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hicon::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_icon_from_resource(presbits: &[u8], f_icon: BOOL, dw_ver: u32) -> Result<Hicon> {
    let presbits_win32 = presbits.as_ptr() as _;
    let dwResSize_win32 = presbits.len() as _;
    let fIcon_win32 = f_icon;
    let dwVer_win32 = dw_ver;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateIconFromResource(presbits_win32, dwResSize_win32, fIcon_win32, dwVer_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hicon::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_icon_from_resource_ex(presbits: &[u8], f_icon: BOOL, dw_ver: u32, cx_desired: i32, cy_desired: i32, flags: u32) -> Result<Hicon> {
    let presbits_win32 = presbits.as_ptr() as _;
    let dwResSize_win32 = presbits.len() as _;
    let fIcon_win32 = f_icon;
    let dwVer_win32 = dw_ver;
    let cxDesired_win32 = cx_desired;
    let cyDesired_win32 = cy_desired;
    let Flags_win32 = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateIconFromResourceEx(presbits_win32, dwResSize_win32, fIcon_win32, dwVer_win32, cxDesired_win32, cyDesired_win32, Flags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hicon::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_icon_indirect(piconinfo: &Iconinfo) -> Result<Hicon> {
    // SAFETY: type is a thin type
    let piconinfo_win32 = unsafe { &*(piconinfo as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateIconIndirect(piconinfo_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hicon::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_mdi_window_a(lp_class_name: &CStr, lp_window_name: &CStr, dw_style: u32, x: i32, y: i32, n_width: i32, n_height: i32, h_wnd_parent: Option<Hwnd>, h_instance: Option<Hinstance>, l_param: Lparam) -> Result<Hwnd> {
    let lpClassName_win32 = lp_class_name.as_ptr() as _;
    let lpWindowName_win32 = lp_window_name.as_ptr() as _;
    let dwStyle_win32 = dw_style;
    let X_win32 = x;
    let Y_win32 = y;
    let nWidth_win32 = n_width;
    let nHeight_win32 = n_height;
    let hWndParent_win32 = h_wnd_parent.map_or(0, Hwnd::into_raw);
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    let lParam_win32 = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateMDIWindowA(lpClassName_win32, lpWindowName_win32, dwStyle_win32, X_win32, Y_win32, nWidth_win32, nHeight_win32, hWndParent_win32, hInstance_win32, lParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_mdi_window_w(lp_class_name: &OsStr, lp_window_name: &OsStr, dw_style: u32, x: i32, y: i32, n_width: i32, n_height: i32, h_wnd_parent: Option<Hwnd>, h_instance: Option<Hinstance>, l_param: Lparam) -> Result<Hwnd> {
    let mut temp135: Vec<u16> = lp_class_name.encode_wide().collect();
    temp135.push(0);
    let lpClassName_win32 = temp135.as_ptr() as _;
    let mut temp136: Vec<u16> = lp_window_name.encode_wide().collect();
    temp136.push(0);
    let lpWindowName_win32 = temp136.as_ptr() as _;
    let dwStyle_win32 = dw_style;
    let X_win32 = x;
    let Y_win32 = y;
    let nWidth_win32 = n_width;
    let nHeight_win32 = n_height;
    let hWndParent_win32 = h_wnd_parent.map_or(0, Hwnd::into_raw);
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    let lParam_win32 = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateMDIWindowW(lpClassName_win32, lpWindowName_win32, dwStyle_win32, X_win32, Y_win32, nWidth_win32, nHeight_win32, hWndParent_win32, hInstance_win32, lParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_menu() -> Result<Hmenu> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateMenu() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hmenu::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn create_popup_menu() -> Result<Hmenu> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreatePopupMenu() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hmenu::new(return_value) };
    Ok(real_return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn create_resource_indexer(project_root: &OsStr, extension_dll_path: Option<&OsStr>, ) -> (HRESULT, &mut todo_void_ret) {
//      let mut pp_resource_indexer = mem::MaybeUninit::zeroed();
//      let ppResourceIndexer_win32 = pp_resource_indexer.as_mut_ptr();
//      let mut temp137: Vec<u16> = project_root.encode_wide().collect();
//      temp137.push(0);
//      let projectRoot_win32 = temp137.as_ptr() as _;
//      let temp138 = extension_dll_path.map(|val| {
//          let mut temp138: Vec<u16> = val.encode_wide().collect();
//          temp138.push(0);
//          temp138
//      });
//      let extensionDllPath_win32 = temp138.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateResourceIndexer(projectRoot_win32, extensionDllPath_win32, ppResourceIndexer_win32) };
//      let real_return_value = return_value;
//      let pp_resource_indexer = unsafe { &mut *(unsafe { pp_resource_indexer.assume_init() } as *mut _) };
//      (real_return_value,pp_resource_indexer)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn create_window_ex_a(dw_ex_style: u32, lp_class_name: Option<&CStr>, lp_window_name: Option<&CStr>, dw_style: u32, x: i32, y: i32, n_width: i32, h_wnd_parent: Option<Hwnd>, h_menu: Option<Hmenu>, h_instance: Option<Hinstance>, lp_param: Option<&[todo_void]>) -> Result<Hwnd> {
//      let dwExStyle_win32 = dw_ex_style;
//      let lpClassName_win32 = lp_class_name.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let lpWindowName_win32 = lp_window_name.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let dwStyle_win32 = dw_style;
//      let X_win32 = x;
//      let Y_win32 = y;
//      let nWidth_win32 = n_width;
//      let hWndParent_win32 = h_wnd_parent.map_or(0, Hwnd::into_raw);
//      let hMenu_win32 = h_menu.map_or(0, Hmenu::into_raw);
//      let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
//      let lpParam_win32 = lp_param.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let nHeight_win32 = lp_param.len() as _;
//      let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateWindowExA(dwExStyle_win32, lpClassName_win32, lpWindowName_win32, dwStyle_win32, X_win32, Y_win32, nWidth_win32, nHeight_win32, hWndParent_win32, hMenu_win32, hInstance_win32, lpParam_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = unsafe { Hwnd::new(return_value) };
//      Ok(real_return_value)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn create_window_ex_w(dw_ex_style: u32, lp_class_name: Option<&OsStr>, lp_window_name: Option<&OsStr>, dw_style: u32, x: i32, y: i32, n_width: i32, h_wnd_parent: Option<Hwnd>, h_menu: Option<Hmenu>, h_instance: Option<Hinstance>, lp_param: Option<&[todo_void]>) -> Result<Hwnd> {
//      let dwExStyle_win32 = dw_ex_style;
//      let temp139 = lp_class_name.map(|val| {
//          let mut temp139: Vec<u16> = val.encode_wide().collect();
//          temp139.push(0);
//          temp139
//      });
//      let lpClassName_win32 = temp139.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let temp140 = lp_window_name.map(|val| {
//          let mut temp140: Vec<u16> = val.encode_wide().collect();
//          temp140.push(0);
//          temp140
//      });
//      let lpWindowName_win32 = temp140.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let dwStyle_win32 = dw_style;
//      let X_win32 = x;
//      let Y_win32 = y;
//      let nWidth_win32 = n_width;
//      let hWndParent_win32 = h_wnd_parent.map_or(0, Hwnd::into_raw);
//      let hMenu_win32 = h_menu.map_or(0, Hmenu::into_raw);
//      let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
//      let lpParam_win32 = lp_param.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let nHeight_win32 = lp_param.len() as _;
//      let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::CreateWindowExW(dwExStyle_win32, lpClassName_win32, lpWindowName_win32, dwStyle_win32, X_win32, Y_win32, nWidth_win32, nHeight_win32, hWndParent_win32, hMenu_win32, hInstance_win32, lpParam_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = unsafe { Hwnd::new(return_value) };
//      Ok(real_return_value)
//  }
#[inline]
pub fn def_dlg_proc_a(h_dlg: Hwnd, msg: u32, w_param: Wparam, l_param: Lparam) -> Lresult {
    let hDlg_win32 = h_dlg.into_raw();
    let Msg_win32 = msg;
    let wParam_win32 = w_param.into_inner();
    let lParam_win32 = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DefDlgProcA(hDlg_win32, Msg_win32, wParam_win32, lParam_win32) };
    let real_return_value = unsafe { Lresult::from_inner(return_value) };
    real_return_value
}
#[inline]
pub fn def_dlg_proc_w(h_dlg: Hwnd, msg: u32, w_param: Wparam, l_param: Lparam) -> Lresult {
    let hDlg_win32 = h_dlg.into_raw();
    let Msg_win32 = msg;
    let wParam_win32 = w_param.into_inner();
    let lParam_win32 = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DefDlgProcW(hDlg_win32, Msg_win32, wParam_win32, lParam_win32) };
    let real_return_value = unsafe { Lresult::from_inner(return_value) };
    real_return_value
}
#[inline]
pub fn def_frame_proc_a(h_wnd: Hwnd, h_wnd_mdi_client: Option<Hwnd>, u_msg: u32, w_param: Wparam, l_param: Lparam) -> Lresult {
    let hWnd_win32 = h_wnd.into_raw();
    let hWndMDIClient_win32 = h_wnd_mdi_client.map_or(0, Hwnd::into_raw);
    let uMsg_win32 = u_msg;
    let wParam_win32 = w_param.into_inner();
    let lParam_win32 = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DefFrameProcA(hWnd_win32, hWndMDIClient_win32, uMsg_win32, wParam_win32, lParam_win32) };
    let real_return_value = unsafe { Lresult::from_inner(return_value) };
    real_return_value
}
#[inline]
pub fn def_frame_proc_w(h_wnd: Hwnd, h_wnd_mdi_client: Option<Hwnd>, u_msg: u32, w_param: Wparam, l_param: Lparam) -> Lresult {
    let hWnd_win32 = h_wnd.into_raw();
    let hWndMDIClient_win32 = h_wnd_mdi_client.map_or(0, Hwnd::into_raw);
    let uMsg_win32 = u_msg;
    let wParam_win32 = w_param.into_inner();
    let lParam_win32 = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DefFrameProcW(hWnd_win32, hWndMDIClient_win32, uMsg_win32, wParam_win32, lParam_win32) };
    let real_return_value = unsafe { Lresult::from_inner(return_value) };
    real_return_value
}
#[inline]
pub fn def_mdi_child_proc_a(h_wnd: Hwnd, u_msg: u32, w_param: Wparam, l_param: Lparam) -> Lresult {
    let hWnd_win32 = h_wnd.into_raw();
    let uMsg_win32 = u_msg;
    let wParam_win32 = w_param.into_inner();
    let lParam_win32 = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DefMDIChildProcA(hWnd_win32, uMsg_win32, wParam_win32, lParam_win32) };
    let real_return_value = unsafe { Lresult::from_inner(return_value) };
    real_return_value
}
#[inline]
pub fn def_mdi_child_proc_w(h_wnd: Hwnd, u_msg: u32, w_param: Wparam, l_param: Lparam) -> Lresult {
    let hWnd_win32 = h_wnd.into_raw();
    let uMsg_win32 = u_msg;
    let wParam_win32 = w_param.into_inner();
    let lParam_win32 = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DefMDIChildProcW(hWnd_win32, uMsg_win32, wParam_win32, lParam_win32) };
    let real_return_value = unsafe { Lresult::from_inner(return_value) };
    real_return_value
}
#[inline]
pub fn def_window_proc_a(h_wnd: Hwnd, msg: u32, w_param: Wparam, l_param: Lparam) -> Lresult {
    let hWnd_win32 = h_wnd.into_raw();
    let Msg_win32 = msg;
    let wParam_win32 = w_param.into_inner();
    let lParam_win32 = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DefWindowProcA(hWnd_win32, Msg_win32, wParam_win32, lParam_win32) };
    let real_return_value = unsafe { Lresult::from_inner(return_value) };
    real_return_value
}
#[inline]
pub fn def_window_proc_w(h_wnd: Hwnd, msg: u32, w_param: Wparam, l_param: Lparam) -> Lresult {
    let hWnd_win32 = h_wnd.into_raw();
    let Msg_win32 = msg;
    let wParam_win32 = w_param.into_inner();
    let lParam_win32 = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DefWindowProcW(hWnd_win32, Msg_win32, wParam_win32, lParam_win32) };
    let real_return_value = unsafe { Lresult::from_inner(return_value) };
    real_return_value
}
#[inline]
pub fn defer_window_pos(h_win_pos_info: isize, h_wnd: Hwnd, h_wnd_insert_after: Option<Hwnd>, x: i32, y: i32, cx: i32, cy: i32, u_flags: u32) -> isize {
    let hWinPosInfo_win32 = h_win_pos_info;
    let hWnd_win32 = h_wnd.into_raw();
    let hWndInsertAfter_win32 = h_wnd_insert_after.map_or(0, Hwnd::into_raw);
    let x_win32 = x;
    let y_win32 = y;
    let cx_win32 = cx;
    let cy_win32 = cy;
    let uFlags_win32 = u_flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DeferWindowPos(hWinPosInfo_win32, hWnd_win32, hWndInsertAfter_win32, x_win32, y_win32, cx_win32, cy_win32, uFlags_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn delete_menu(h_menu: Hmenu, u_position: u32, u_flags: u32) -> Result<BOOL> {
    let hMenu_win32 = h_menu.into_raw();
    let uPosition_win32 = u_position;
    let uFlags_win32 = u_flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DeleteMenu(hMenu_win32, uPosition_win32, uFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn deregister_shell_hook_window(hwnd: Hwnd) -> Result<BOOL> {
    let hwnd_win32 = hwnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DeregisterShellHookWindow(hwnd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn destroy_accelerator_table(h_accel: Haccel) -> Result<BOOL> {
    let hAccel_win32 = h_accel.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DestroyAcceleratorTable(hAccel_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn destroy_caret() -> Result<BOOL> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DestroyCaret() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn destroy_cursor(h_cursor: Hcursor) -> Result<BOOL> {
    let hCursor_win32 = h_cursor.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DestroyCursor(hCursor_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn destroy_icon(h_icon: Hicon) -> Result<BOOL> {
    let hIcon_win32 = h_icon.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DestroyIcon(hIcon_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn destroy_menu(h_menu: Hmenu) -> Result<BOOL> {
    let hMenu_win32 = h_menu.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DestroyMenu(hMenu_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn destroy_resource_indexer(resource_indexer: Option<&todo_void>) -> () {
//      // SAFETY: type is a thin type
//      let resourceIndexer_win32 = resource_indexer.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
//      let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DestroyResourceIndexer(resourceIndexer_win32) };
//      let _ = return_value;
//  }
#[inline]
pub fn destroy_window(h_wnd: Hwnd) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DestroyWindow(hWnd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn dialog_box_indirect_param_a<Dlgproc: FnMut(Hwnd, u32, Wparam, ) -> isize>(h_instance: Option<Hinstance>, h_dialog_template: &Dlgtemplate, h_wnd_parent: Option<Hwnd>, lp_dialog_func: Option<Dlgproc>, ) -> isize {
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    // SAFETY: type is a thin type
    let hDialogTemplate_win32 = unsafe { &*(h_dialog_template as *const _ as *const _) };
    let hWndParent_win32 = h_wnd_parent.map_or(0, Hwnd::into_raw);
    unsafe extern "system" fn dlgproc_impl<Dlgproc>(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM) -> isize {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let closure = unsafe {
                &mut *(param3 as usize as *mut Dlgproc)
            };
            let return_value = (closure)(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpDialogFunc_win32 = Some(dlgproc_impl::<Dlgproc>);
    let mut lp_dialog_func = lp_dialog_func;
    let dwInitParam_win32 = unsafe { Lparam::from_ptr((&mut lp_dialog_func) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DialogBoxIndirectParamA(hInstance_win32, hDialogTemplate_win32, hWndParent_win32, lpDialogFunc_win32, dwInitParam_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn dialog_box_indirect_param_w<Dlgproc: FnMut(Hwnd, u32, Wparam, ) -> isize>(h_instance: Option<Hinstance>, h_dialog_template: &Dlgtemplate, h_wnd_parent: Option<Hwnd>, lp_dialog_func: Option<Dlgproc>, ) -> isize {
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    // SAFETY: type is a thin type
    let hDialogTemplate_win32 = unsafe { &*(h_dialog_template as *const _ as *const _) };
    let hWndParent_win32 = h_wnd_parent.map_or(0, Hwnd::into_raw);
    unsafe extern "system" fn dlgproc_impl<Dlgproc>(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM) -> isize {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let closure = unsafe {
                &mut *(param3 as usize as *mut Dlgproc)
            };
            let return_value = (closure)(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpDialogFunc_win32 = Some(dlgproc_impl::<Dlgproc>);
    let mut lp_dialog_func = lp_dialog_func;
    let dwInitParam_win32 = unsafe { Lparam::from_ptr((&mut lp_dialog_func) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DialogBoxIndirectParamW(hInstance_win32, hDialogTemplate_win32, hWndParent_win32, lpDialogFunc_win32, dwInitParam_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn dialog_box_param_a<Dlgproc: FnMut(Hwnd, u32, Wparam, ) -> isize>(h_instance: Option<Hinstance>, lp_template_name: &CStr, h_wnd_parent: Option<Hwnd>, lp_dialog_func: Option<Dlgproc>, ) -> isize {
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    let lpTemplateName_win32 = lp_template_name.as_ptr() as _;
    let hWndParent_win32 = h_wnd_parent.map_or(0, Hwnd::into_raw);
    unsafe extern "system" fn dlgproc_impl<Dlgproc>(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM) -> isize {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let closure = unsafe {
                &mut *(param3 as usize as *mut Dlgproc)
            };
            let return_value = (closure)(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpDialogFunc_win32 = Some(dlgproc_impl::<Dlgproc>);
    let mut lp_dialog_func = lp_dialog_func;
    let dwInitParam_win32 = unsafe { Lparam::from_ptr((&mut lp_dialog_func) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DialogBoxParamA(hInstance_win32, lpTemplateName_win32, hWndParent_win32, lpDialogFunc_win32, dwInitParam_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn dialog_box_param_w<Dlgproc: FnMut(Hwnd, u32, Wparam, ) -> isize>(h_instance: Option<Hinstance>, lp_template_name: &OsStr, h_wnd_parent: Option<Hwnd>, lp_dialog_func: Option<Dlgproc>, ) -> isize {
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    let mut temp141: Vec<u16> = lp_template_name.encode_wide().collect();
    temp141.push(0);
    let lpTemplateName_win32 = temp141.as_ptr() as _;
    let hWndParent_win32 = h_wnd_parent.map_or(0, Hwnd::into_raw);
    unsafe extern "system" fn dlgproc_impl<Dlgproc>(param0: HWND, param1: u32, param2: WPARAM, param3: LPARAM) -> isize {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input2 = unsafe { Wparam::from_inner(param2) };
            let closure = unsafe {
                &mut *(param3 as usize as *mut Dlgproc)
            };
            let return_value = (closure)(input0, input1, input2, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpDialogFunc_win32 = Some(dlgproc_impl::<Dlgproc>);
    let mut lp_dialog_func = lp_dialog_func;
    let dwInitParam_win32 = unsafe { Lparam::from_ptr((&mut lp_dialog_func) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DialogBoxParamW(hInstance_win32, lpTemplateName_win32, hWndParent_win32, lpDialogFunc_win32, dwInitParam_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn disable_process_windows_ghosting() -> () {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DisableProcessWindowsGhosting() };
    let _ = return_value;
}
#[inline]
pub fn dispatch_message_a(lp_msg: &Msg) -> Lresult {
    // SAFETY: type is a thin type
    let lpMsg_win32 = unsafe { &*(lp_msg as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DispatchMessageA(lpMsg_win32) };
    let real_return_value = unsafe { Lresult::from_inner(return_value) };
    real_return_value
}
#[inline]
pub fn dispatch_message_w(lp_msg: &Msg) -> Lresult {
    // SAFETY: type is a thin type
    let lpMsg_win32 = unsafe { &*(lp_msg as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DispatchMessageW(lpMsg_win32) };
    let real_return_value = unsafe { Lresult::from_inner(return_value) };
    real_return_value
}
#[inline]
pub fn drag_object(hwnd_parent: Hwnd, hwnd_from: Hwnd, fmt: u32, data: usize, hcur: Option<Hcursor>) -> u32 {
    let hwndParent_win32 = hwnd_parent.into_raw();
    let hwndFrom_win32 = hwnd_from.into_raw();
    let fmt_win32 = fmt;
    let data_win32 = data;
    let hcur_win32 = hcur.map_or(0, Hcursor::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DragObject(hwndParent_win32, hwndFrom_win32, fmt_win32, data_win32, hcur_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn draw_icon(h_dc: Hdc, x: i32, y: i32, h_icon: Hicon) -> Result<BOOL> {
    let hDC_win32 = h_dc.into_raw();
    let X_win32 = x;
    let Y_win32 = y;
    let hIcon_win32 = h_icon.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DrawIcon(hDC_win32, X_win32, Y_win32, hIcon_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn draw_icon_ex(hdc: Hdc, x_left: i32, y_top: i32, h_icon: Hicon, cx_width: i32, cy_width: i32, istep_if_ani_cur: u32, hbr_flicker_free_draw: Option<Hbrush>, di_flags: u32) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let xLeft_win32 = x_left;
    let yTop_win32 = y_top;
    let hIcon_win32 = h_icon.into_raw();
    let cxWidth_win32 = cx_width;
    let cyWidth_win32 = cy_width;
    let istepIfAniCur_win32 = istep_if_ani_cur;
    let hbrFlickerFreeDraw_win32 = hbr_flicker_free_draw.map_or(0, Hbrush::into_raw);
    let diFlags_win32 = di_flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DrawIconEx(hdc_win32, xLeft_win32, yTop_win32, hIcon_win32, cxWidth_win32, cyWidth_win32, istepIfAniCur_win32, hbrFlickerFreeDraw_win32, diFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn draw_menu_bar(h_wnd: Hwnd) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::DrawMenuBar(hWnd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enable_menu_item(h_menu: Hmenu, u_id_enable_item: u32, u_enable: u32) -> Result<BOOL> {
    let hMenu_win32 = h_menu.into_raw();
    let uIDEnableItem_win32 = u_id_enable_item;
    let uEnable_win32 = u_enable;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::EnableMenuItem(hMenu_win32, uIDEnableItem_win32, uEnable_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn end_defer_window_pos(h_win_pos_info: isize) -> Result<BOOL> {
    let hWinPosInfo_win32 = h_win_pos_info;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::EndDeferWindowPos(hWinPosInfo_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn end_dialog(h_dlg: Hwnd, n_result: isize) -> Result<BOOL> {
    let hDlg_win32 = h_dlg.into_raw();
    let nResult_win32 = n_result;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::EndDialog(hDlg_win32, nResult_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn end_menu() -> Result<BOOL> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::EndMenu() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_child_windows<Wndenumproc: FnMut(Hwnd, ) -> BOOL>(h_wnd_parent: Option<Hwnd>, lp_enum_func: Wndenumproc, ) -> Result<BOOL> {
    let hWndParent_win32 = h_wnd_parent.map_or(0, Hwnd::into_raw);
    unsafe extern "system" fn wndenumproc_impl<Wndenumproc>(param0: HWND, param1: LPARAM) -> BOOL {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let closure = unsafe {
                &mut *(param1 as usize as *mut Wndenumproc)
            };
            let return_value = (closure)(input0, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpEnumFunc_win32 = Some(wndenumproc_impl::<Wndenumproc>);
    let mut lp_enum_func = lp_enum_func;
    let lParam_win32 = unsafe { Lparam::from_ptr((&mut lp_enum_func) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::EnumChildWindows(hWndParent_win32, lpEnumFunc_win32, lParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_props_a(h_wnd: Hwnd, lp_enum_func: Option<unsafe extern "system" fn(HWND, PCSTR, HANDLE) -> BOOL>) -> Result<i32> {
    let hWnd_win32 = h_wnd.into_raw();
    let lpEnumFunc_win32 = lp_enum_func;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::EnumPropsA(hWnd_win32, lpEnumFunc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_props_ex_a(h_wnd: Hwnd, lp_enum_func: Option<unsafe extern "system" fn(HWND, PCSTR, HANDLE, usize) -> BOOL>, l_param: Lparam) -> Result<i32> {
    let hWnd_win32 = h_wnd.into_raw();
    let lpEnumFunc_win32 = lp_enum_func;
    let lParam_win32 = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::EnumPropsExA(hWnd_win32, lpEnumFunc_win32, lParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_props_ex_w(h_wnd: Hwnd, lp_enum_func: Option<unsafe extern "system" fn(HWND, PCWSTR, HANDLE, usize) -> BOOL>, l_param: Lparam) -> Result<i32> {
    let hWnd_win32 = h_wnd.into_raw();
    let lpEnumFunc_win32 = lp_enum_func;
    let lParam_win32 = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::EnumPropsExW(hWnd_win32, lpEnumFunc_win32, lParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_props_w(h_wnd: Hwnd, lp_enum_func: Option<unsafe extern "system" fn(HWND, PCWSTR, HANDLE) -> BOOL>) -> Result<i32> {
    let hWnd_win32 = h_wnd.into_raw();
    let lpEnumFunc_win32 = lp_enum_func;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::EnumPropsW(hWnd_win32, lpEnumFunc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_thread_windows<Wndenumproc: FnMut(Hwnd, ) -> BOOL>(dw_thread_id: u32, lpfn: Wndenumproc, ) -> Result<BOOL> {
    let dwThreadId_win32 = dw_thread_id;
    unsafe extern "system" fn wndenumproc_impl<Wndenumproc>(param0: HWND, param1: LPARAM) -> BOOL {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let closure = unsafe {
                &mut *(param1 as usize as *mut Wndenumproc)
            };
            let return_value = (closure)(input0, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpfn_win32 = Some(wndenumproc_impl::<Wndenumproc>);
    let mut lpfn = lpfn;
    let lParam_win32 = unsafe { Lparam::from_ptr((&mut lpfn) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::EnumThreadWindows(dwThreadId_win32, lpfn_win32, lParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_windows<Wndenumproc: FnMut(Hwnd, ) -> BOOL>(lp_enum_func: Wndenumproc, ) -> Result<BOOL> {
    unsafe extern "system" fn wndenumproc_impl<Wndenumproc>(param0: HWND, param1: LPARAM) -> BOOL {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let closure = unsafe {
                &mut *(param1 as usize as *mut Wndenumproc)
            };
            let return_value = (closure)(input0, );
            let real_return_value = return_value;
            real_return_value
        })
    }
    let lpEnumFunc_win32 = Some(wndenumproc_impl::<Wndenumproc>);
    let mut lp_enum_func = lp_enum_func;
    let lParam_win32 = unsafe { Lparam::from_ptr((&mut lp_enum_func) as *mut _ as *mut _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::EnumWindows(lpEnumFunc_win32, lParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn find_window_a(lp_class_name: Option<&CStr>, lp_window_name: Option<&CStr>) -> Result<Hwnd> {
    let lpClassName_win32 = lp_class_name.map_or(ptr::null(), |v| v.as_ptr() as _);
    let lpWindowName_win32 = lp_window_name.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::FindWindowA(lpClassName_win32, lpWindowName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn find_window_ex_a(h_wnd_parent: Option<Hwnd>, h_wnd_child_after: Option<Hwnd>, lpsz_class: Option<&CStr>, lpsz_window: Option<&CStr>) -> Result<Hwnd> {
    let hWndParent_win32 = h_wnd_parent.map_or(0, Hwnd::into_raw);
    let hWndChildAfter_win32 = h_wnd_child_after.map_or(0, Hwnd::into_raw);
    let lpszClass_win32 = lpsz_class.map_or(ptr::null(), |v| v.as_ptr() as _);
    let lpszWindow_win32 = lpsz_window.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::FindWindowExA(hWndParent_win32, hWndChildAfter_win32, lpszClass_win32, lpszWindow_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn find_window_ex_w(h_wnd_parent: Option<Hwnd>, h_wnd_child_after: Option<Hwnd>, lpsz_class: Option<&OsStr>, lpsz_window: Option<&OsStr>) -> Result<Hwnd> {
    let hWndParent_win32 = h_wnd_parent.map_or(0, Hwnd::into_raw);
    let hWndChildAfter_win32 = h_wnd_child_after.map_or(0, Hwnd::into_raw);
    let temp142 = lpsz_class.map(|val| {
        let mut temp142: Vec<u16> = val.encode_wide().collect();
        temp142.push(0);
        temp142
    });
    let lpszClass_win32 = temp142.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp143 = lpsz_window.map(|val| {
        let mut temp143: Vec<u16> = val.encode_wide().collect();
        temp143.push(0);
        temp143
    });
    let lpszWindow_win32 = temp143.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::FindWindowExW(hWndParent_win32, hWndChildAfter_win32, lpszClass_win32, lpszWindow_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn find_window_w(lp_class_name: Option<&OsStr>, lp_window_name: Option<&OsStr>) -> Result<Hwnd> {
    let temp144 = lp_class_name.map(|val| {
        let mut temp144: Vec<u16> = val.encode_wide().collect();
        temp144.push(0);
        temp144
    });
    let lpClassName_win32 = temp144.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp145 = lp_window_name.map(|val| {
        let mut temp145: Vec<u16> = val.encode_wide().collect();
        temp145.push(0);
        temp145
    });
    let lpWindowName_win32 = temp145.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::FindWindowW(lpClassName_win32, lpWindowName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn flash_window(h_wnd: Hwnd, b_invert: BOOL) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let bInvert_win32 = b_invert;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::FlashWindow(hWnd_win32, bInvert_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn flash_window_ex(pfwi: &Flashwinfo) -> Result<BOOL> {
    let temp146 = pfwi.to_win32();
    let pfwi_win32 = &temp146;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::FlashWindowEx(pfwi_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_alt_tab_info_a(hwnd: Option<Hwnd>, i_item: i32, pati: Alttabinfo, cch_item_text: u32) -> Result<(BOOL, Alttabinfo, CString)> {
    let mut psz_item_text = Vec::<u8>::with_capacity(cch_item_text as usize + 1);
    let pszItemText_win32 = psz_item_text.as_mut_ptr();
    let hwnd_win32 = hwnd.map_or(0, Hwnd::into_raw);
    let iItem_win32 = i_item;
    let mut pati_win32 = pati.to_win32();
    let cchItemText_win32 = cch_item_text;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetAltTabInfoA(hwnd_win32, iItem_win32, &mut pati_win32, pszItemText_win32, cchItemText_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    psz_item_text.truncate(return_value as usize);
    let psz_item_text = unsafe { CString::from_vec_unchecked(psz_item_text) };
    let pati = unsafe { Alttabinfo::from_win32(pati_win32) };
    Ok((real_return_value,pati, psz_item_text))
}
#[inline]
pub fn get_alt_tab_info_w(hwnd: Option<Hwnd>, i_item: i32, pati: Alttabinfo, cch_item_text: u32) -> Result<(BOOL, Alttabinfo, OsString)> {
    let mut psz_item_text = Vec::<u16>::with_capacity(cch_item_text as usize + 1);
    let pszItemText_win32 = psz_item_text.as_mut_ptr();
    let hwnd_win32 = hwnd.map_or(0, Hwnd::into_raw);
    let iItem_win32 = i_item;
    let mut pati_win32 = pati.to_win32();
    let cchItemText_win32 = cch_item_text;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetAltTabInfoW(hwnd_win32, iItem_win32, &mut pati_win32, pszItemText_win32, cchItemText_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    psz_item_text.truncate(return_value as usize);
    let psz_item_text = OsString::from_wide(&psz_item_text);
    let pati = unsafe { Alttabinfo::from_win32(pati_win32) };
    Ok((real_return_value,pati, psz_item_text))
}
#[inline]
pub fn get_ancestor(hwnd: Hwnd, ga_flags: u32) -> Result<Hwnd> {
    let hwnd_win32 = hwnd.into_raw();
    let gaFlags_win32 = ga_flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetAncestor(hwnd_win32, gaFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_caret_blink_time() -> u32 {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetCaretBlinkTime() };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_caret_pos() -> Result<(BOOL, Point)> {
    let mut lp_point = mem::MaybeUninit::zeroed();
    let lpPoint_win32 = lp_point.as_mut_ptr();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetCaretPos(lpPoint_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_point = unsafe { Point::from_win32(unsafe { lp_point.assume_init() }) };
    Ok((real_return_value,lp_point))
}
#[inline]
pub fn get_class_info_a(h_instance: Option<Hinstance>, lp_class_name: &CStr, ) -> Result<(BOOL, Wndclassa<'static>)> {
    let mut lp_wnd_class = mem::MaybeUninit::zeroed();
    let lpWndClass_win32 = lp_wnd_class.as_mut_ptr();
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    let lpClassName_win32 = lp_class_name.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClassInfoA(hInstance_win32, lpClassName_win32, lpWndClass_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_wnd_class = unsafe { Wndclassa::from_win32(unsafe { lp_wnd_class.assume_init() }) };
    Ok((real_return_value,lp_wnd_class))
}
#[inline]
pub fn get_class_info_ex_a(h_instance: Option<Hinstance>, lpsz_class: &CStr, ) -> Result<(BOOL, Wndclassexa<'static>)> {
    let mut lpwcx = mem::MaybeUninit::zeroed();
    let lpwcx_win32 = lpwcx.as_mut_ptr();
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    let lpszClass_win32 = lpsz_class.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClassInfoExA(hInstance_win32, lpszClass_win32, lpwcx_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpwcx = unsafe { Wndclassexa::from_win32(unsafe { lpwcx.assume_init() }) };
    Ok((real_return_value,lpwcx))
}
#[inline]
pub fn get_class_info_ex_w(h_instance: Option<Hinstance>, lpsz_class: &OsStr, ) -> Result<(BOOL, Wndclassexw<'static>)> {
    let mut lpwcx = mem::MaybeUninit::zeroed();
    let lpwcx_win32 = lpwcx.as_mut_ptr();
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    let mut temp147: Vec<u16> = lpsz_class.encode_wide().collect();
    temp147.push(0);
    let lpszClass_win32 = temp147.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClassInfoExW(hInstance_win32, lpszClass_win32, lpwcx_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpwcx = unsafe { Wndclassexw::from_win32(unsafe { lpwcx.assume_init() }) };
    Ok((real_return_value,lpwcx))
}
#[inline]
pub fn get_class_info_w(h_instance: Option<Hinstance>, lp_class_name: &OsStr, ) -> Result<(BOOL, Wndclassw<'static>)> {
    let mut lp_wnd_class = mem::MaybeUninit::zeroed();
    let lpWndClass_win32 = lp_wnd_class.as_mut_ptr();
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    let mut temp148: Vec<u16> = lp_class_name.encode_wide().collect();
    temp148.push(0);
    let lpClassName_win32 = temp148.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClassInfoW(hInstance_win32, lpClassName_win32, lpWndClass_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_wnd_class = unsafe { Wndclassw::from_win32(unsafe { lp_wnd_class.assume_init() }) };
    Ok((real_return_value,lp_wnd_class))
}
#[inline]
pub fn get_class_long_a(h_wnd: Hwnd, n_index: i32) -> u32 {
    let hWnd_win32 = h_wnd.into_raw();
    let nIndex_win32 = n_index;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClassLongA(hWnd_win32, nIndex_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_class_long_ptr_a(h_wnd: Hwnd, n_index: i32) -> usize {
    let hWnd_win32 = h_wnd.into_raw();
    let nIndex_win32 = n_index;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClassLongPtrA(hWnd_win32, nIndex_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_class_long_ptr_w(h_wnd: Hwnd, n_index: i32) -> usize {
    let hWnd_win32 = h_wnd.into_raw();
    let nIndex_win32 = n_index;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClassLongPtrW(hWnd_win32, nIndex_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_class_long_w(h_wnd: Hwnd, n_index: i32) -> u32 {
    let hWnd_win32 = h_wnd.into_raw();
    let nIndex_win32 = n_index;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClassLongW(hWnd_win32, nIndex_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_class_name_a(h_wnd: Hwnd, n_max_count: i32) -> Result<(i32, CString)> {
    let mut lp_class_name = Vec::<u8>::with_capacity(n_max_count as usize + 1);
    let lpClassName_win32 = lp_class_name.as_mut_ptr();
    let hWnd_win32 = h_wnd.into_raw();
    let nMaxCount_win32 = n_max_count;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClassNameA(hWnd_win32, lpClassName_win32, nMaxCount_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    lp_class_name.truncate(return_value as usize);
    let lp_class_name = unsafe { CString::from_vec_unchecked(lp_class_name) };
    Ok((real_return_value,lp_class_name))
}
#[inline]
pub fn get_class_name_w(h_wnd: Hwnd, n_max_count: i32) -> Result<(i32, OsString)> {
    let mut lp_class_name = Vec::<u16>::with_capacity(n_max_count as usize + 1);
    let lpClassName_win32 = lp_class_name.as_mut_ptr();
    let hWnd_win32 = h_wnd.into_raw();
    let nMaxCount_win32 = n_max_count;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClassNameW(hWnd_win32, lpClassName_win32, nMaxCount_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    lp_class_name.truncate(return_value as usize);
    let lp_class_name = OsString::from_wide(&lp_class_name);
    Ok((real_return_value,lp_class_name))
}
#[inline]
pub fn get_class_word(h_wnd: Hwnd, n_index: i32) -> u16 {
    let hWnd_win32 = h_wnd.into_raw();
    let nIndex_win32 = n_index;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClassWord(hWnd_win32, nIndex_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_client_rect(h_wnd: Hwnd, ) -> Result<(BOOL, Rect)> {
    let mut lp_rect = mem::MaybeUninit::zeroed();
    let lpRect_win32 = lp_rect.as_mut_ptr();
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClientRect(hWnd_win32, lpRect_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_rect = unsafe { Rect::from_win32(unsafe { lp_rect.assume_init() }) };
    Ok((real_return_value,lp_rect))
}
#[inline]
pub fn get_clip_cursor() -> Result<(BOOL, Rect)> {
    let mut lp_rect = mem::MaybeUninit::zeroed();
    let lpRect_win32 = lp_rect.as_mut_ptr();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetClipCursor(lpRect_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_rect = unsafe { Rect::from_win32(unsafe { lp_rect.assume_init() }) };
    Ok((real_return_value,lp_rect))
}
#[inline]
pub fn get_cursor() -> Result<Hcursor> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetCursor() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hcursor::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_cursor_info(pci: Cursorinfo) -> Result<(BOOL, Cursorinfo)> {
    let mut pci_win32 = pci.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetCursorInfo(&mut pci_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pci = unsafe { Cursorinfo::from_win32(pci_win32) };
    Ok((real_return_value,pci))
}
#[inline]
pub fn get_cursor_pos() -> Result<(BOOL, Point)> {
    let mut lp_point = mem::MaybeUninit::zeroed();
    let lpPoint_win32 = lp_point.as_mut_ptr();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetCursorPos(lpPoint_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_point = unsafe { Point::from_win32(unsafe { lp_point.assume_init() }) };
    Ok((real_return_value,lp_point))
}
#[inline]
pub fn get_desktop_window() -> Result<Hwnd> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetDesktopWindow() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_dialog_base_units() -> Result<i32> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetDialogBaseUnits() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_dlg_ctrl_id(h_wnd: Hwnd) -> Result<i32> {
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetDlgCtrlID(hWnd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_dlg_item(h_dlg: Option<Hwnd>, n_id_dlg_item: i32) -> Result<Hwnd> {
    let hDlg_win32 = h_dlg.map_or(0, Hwnd::into_raw);
    let nIDDlgItem_win32 = n_id_dlg_item;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetDlgItem(hDlg_win32, nIDDlgItem_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_dlg_item_int(h_dlg: Hwnd, n_id_dlg_item: i32, b_signed: BOOL) -> (u32, BOOL) {
    let mut lp_translated = mem::MaybeUninit::zeroed();
    let lpTranslated_win32 = lp_translated.as_mut_ptr();
    let hDlg_win32 = h_dlg.into_raw();
    let nIDDlgItem_win32 = n_id_dlg_item;
    let bSigned_win32 = b_signed;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetDlgItemInt(hDlg_win32, nIDDlgItem_win32, lpTranslated_win32, bSigned_win32) };
    let real_return_value = return_value;
    let lp_translated = unsafe { lp_translated.assume_init() };
    (real_return_value,lp_translated)
}
#[inline]
pub fn get_dlg_item_text_a(h_dlg: Hwnd, n_id_dlg_item: i32, cch_max: i32) -> (u32, CString) {
    let mut lp_string = Vec::<u8>::with_capacity(cch_max as usize + 1);
    let lpString_win32 = lp_string.as_mut_ptr();
    let hDlg_win32 = h_dlg.into_raw();
    let nIDDlgItem_win32 = n_id_dlg_item;
    let cchMax_win32 = cch_max;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetDlgItemTextA(hDlg_win32, nIDDlgItem_win32, lpString_win32, cchMax_win32) };
    let real_return_value = return_value;
    lp_string.truncate(return_value as usize);
    let lp_string = unsafe { CString::from_vec_unchecked(lp_string) };
    (real_return_value,lp_string)
}
#[inline]
pub fn get_dlg_item_text_w(h_dlg: Hwnd, n_id_dlg_item: i32, cch_max: i32) -> (u32, OsString) {
    let mut lp_string = Vec::<u16>::with_capacity(cch_max as usize + 1);
    let lpString_win32 = lp_string.as_mut_ptr();
    let hDlg_win32 = h_dlg.into_raw();
    let nIDDlgItem_win32 = n_id_dlg_item;
    let cchMax_win32 = cch_max;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetDlgItemTextW(hDlg_win32, nIDDlgItem_win32, lpString_win32, cchMax_win32) };
    let real_return_value = return_value;
    lp_string.truncate(return_value as usize);
    let lp_string = OsString::from_wide(&lp_string);
    (real_return_value,lp_string)
}
#[inline]
pub fn get_foreground_window() -> Result<Hwnd> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetForegroundWindow() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_gui_thread_info(id_thread: u32, pgui: Guithreadinfo) -> Result<(BOOL, Guithreadinfo)> {
    let idThread_win32 = id_thread;
    let mut pgui_win32 = pgui.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetGUIThreadInfo(idThread_win32, &mut pgui_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pgui = unsafe { Guithreadinfo::from_win32(pgui_win32) };
    Ok((real_return_value,pgui))
}
#[inline]
pub fn get_icon_info(h_icon: Hicon, ) -> Result<(BOOL, Iconinfo)> {
    let mut piconinfo = mem::MaybeUninit::zeroed();
    let piconinfo_win32 = piconinfo.as_mut_ptr();
    let hIcon_win32 = h_icon.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetIconInfo(hIcon_win32, piconinfo_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let piconinfo = unsafe { Iconinfo::from_win32(unsafe { piconinfo.assume_init() }) };
    Ok((real_return_value,piconinfo))
}
#[inline]
pub fn get_icon_info_ex_a(hicon: Hicon, piconinfo: Iconinfoexa) -> Result<(BOOL, Iconinfoexa)> {
    let hicon_win32 = hicon.into_raw();
    let mut piconinfo_win32 = piconinfo.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetIconInfoExA(hicon_win32, &mut piconinfo_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let piconinfo = unsafe { Iconinfoexa::from_win32(piconinfo_win32) };
    Ok((real_return_value,piconinfo))
}
#[inline]
pub fn get_icon_info_ex_w(hicon: Hicon, piconinfo: Iconinfoexw) -> Result<(BOOL, Iconinfoexw)> {
    let hicon_win32 = hicon.into_raw();
    let mut piconinfo_win32 = piconinfo.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetIconInfoExW(hicon_win32, &mut piconinfo_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let piconinfo = unsafe { Iconinfoexw::from_win32(piconinfo_win32) };
    Ok((real_return_value,piconinfo))
}
#[inline]
pub fn get_input_state() -> Result<BOOL> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetInputState() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_last_active_popup(h_wnd: Hwnd) -> Result<Hwnd> {
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetLastActivePopup(hWnd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_layered_window_attributes(hwnd: Hwnd, ) -> Result<(BOOL, u32, u8, u32)> {
    let mut pcr_key = mem::MaybeUninit::zeroed();
    let pcrKey_win32 = pcr_key.as_mut_ptr();
    let mut pb_alpha = mem::MaybeUninit::zeroed();
    let pbAlpha_win32 = pb_alpha.as_mut_ptr();
    let mut pdw_flags = mem::MaybeUninit::zeroed();
    let pdwFlags_win32 = pdw_flags.as_mut_ptr();
    let hwnd_win32 = hwnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetLayeredWindowAttributes(hwnd_win32, pcrKey_win32, pbAlpha_win32, pdwFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pdw_flags = unsafe { pdw_flags.assume_init() };
    let pb_alpha = unsafe { pb_alpha.assume_init() };
    let pcr_key = unsafe { pcr_key.assume_init() };
    Ok((real_return_value,pcr_key, pb_alpha, pdw_flags))
}
#[inline]
pub fn get_menu(h_wnd: Hwnd) -> Result<Hmenu> {
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenu(hWnd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hmenu::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_menu_bar_info(hwnd: Hwnd, id_object: i32, id_item: i32, pmbi: Menubarinfo) -> Result<(BOOL, Menubarinfo)> {
    let hwnd_win32 = hwnd.into_raw();
    let idObject_win32 = id_object;
    let idItem_win32 = id_item;
    let mut pmbi_win32 = pmbi.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenuBarInfo(hwnd_win32, idObject_win32, idItem_win32, &mut pmbi_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pmbi = unsafe { Menubarinfo::from_win32(pmbi_win32) };
    Ok((real_return_value,pmbi))
}
#[inline]
pub fn get_menu_check_mark_dimensions() -> Result<i32> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenuCheckMarkDimensions() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_menu_default_item(h_menu: Hmenu, f_by_pos: u32, gmdi_flags: u32) -> u32 {
    let hMenu_win32 = h_menu.into_raw();
    let fByPos_win32 = f_by_pos;
    let gmdiFlags_win32 = gmdi_flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenuDefaultItem(hMenu_win32, fByPos_win32, gmdiFlags_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_menu_info(param0: Hmenu, param1: Menuinfo) -> Result<(BOOL, Menuinfo)> {
    let param0_win32 = param0.into_raw();
    let mut param1_win32 = param1.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenuInfo(param0_win32, &mut param1_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let param1 = unsafe { Menuinfo::from_win32(param1_win32) };
    Ok((real_return_value,param1))
}
#[inline]
pub fn get_menu_item_count(h_menu: Option<Hmenu>) -> Result<i32> {
    let hMenu_win32 = h_menu.map_or(0, Hmenu::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenuItemCount(hMenu_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_menu_item_id(h_menu: Hmenu, n_pos: i32) -> u32 {
    let hMenu_win32 = h_menu.into_raw();
    let nPos_win32 = n_pos;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenuItemID(hMenu_win32, nPos_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_menu_item_info_a(hmenu: Hmenu, item: u32, f_by_position: BOOL, lpmii: Menuiteminfoa<'_>) -> Result<(BOOL, Menuiteminfoa<'static>)> {
    let hmenu_win32 = hmenu.into_raw();
    let item_win32 = item;
    let fByPosition_win32 = f_by_position;
    let mut lpmii_win32 = lpmii.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenuItemInfoA(hmenu_win32, item_win32, fByPosition_win32, &mut lpmii_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpmii = unsafe { Menuiteminfoa::from_win32(lpmii_win32) };
    Ok((real_return_value,lpmii))
}
#[inline]
pub fn get_menu_item_info_w(hmenu: Hmenu, item: u32, f_by_position: BOOL, lpmii: Menuiteminfow<'_>) -> Result<(BOOL, Menuiteminfow<'static>)> {
    let hmenu_win32 = hmenu.into_raw();
    let item_win32 = item;
    let fByPosition_win32 = f_by_position;
    let mut lpmii_win32 = lpmii.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenuItemInfoW(hmenu_win32, item_win32, fByPosition_win32, &mut lpmii_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpmii = unsafe { Menuiteminfow::from_win32(lpmii_win32) };
    Ok((real_return_value,lpmii))
}
#[inline]
pub fn get_menu_item_rect(h_wnd: Option<Hwnd>, h_menu: Hmenu, u_item: u32, ) -> Result<(BOOL, Rect)> {
    let mut lprc_item = mem::MaybeUninit::zeroed();
    let lprcItem_win32 = lprc_item.as_mut_ptr();
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let hMenu_win32 = h_menu.into_raw();
    let uItem_win32 = u_item;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenuItemRect(hWnd_win32, hMenu_win32, uItem_win32, lprcItem_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lprc_item = unsafe { Rect::from_win32(unsafe { lprc_item.assume_init() }) };
    Ok((real_return_value,lprc_item))
}
#[inline]
pub fn get_menu_state(h_menu: Hmenu, u_id: u32, u_flags: u32) -> u32 {
    let hMenu_win32 = h_menu.into_raw();
    let uId_win32 = u_id;
    let uFlags_win32 = u_flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenuState(hMenu_win32, uId_win32, uFlags_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_menu_string_a(h_menu: Hmenu, u_id_item: u32, cch_max: i32, flags: u32) -> Result<(i32, CString)> {
    let mut lp_string = Vec::<u8>::with_capacity(cch_max as usize + 1);
    let lpString_win32 = lp_string.as_mut_ptr();
    let hMenu_win32 = h_menu.into_raw();
    let uIDItem_win32 = u_id_item;
    let cchMax_win32 = cch_max;
    let flags_win32 = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenuStringA(hMenu_win32, uIDItem_win32, lpString_win32, cchMax_win32, flags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    lp_string.truncate(return_value as usize);
    let lp_string = unsafe { CString::from_vec_unchecked(lp_string) };
    Ok((real_return_value,lp_string))
}
#[inline]
pub fn get_menu_string_w(h_menu: Hmenu, u_id_item: u32, cch_max: i32, flags: u32) -> Result<(i32, OsString)> {
    let mut lp_string = Vec::<u16>::with_capacity(cch_max as usize + 1);
    let lpString_win32 = lp_string.as_mut_ptr();
    let hMenu_win32 = h_menu.into_raw();
    let uIDItem_win32 = u_id_item;
    let cchMax_win32 = cch_max;
    let flags_win32 = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMenuStringW(hMenu_win32, uIDItem_win32, lpString_win32, cchMax_win32, flags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    lp_string.truncate(return_value as usize);
    let lp_string = OsString::from_wide(&lp_string);
    Ok((real_return_value,lp_string))
}
#[inline]
pub fn get_message_a(h_wnd: Option<Hwnd>, w_msg_filter_min: u32, w_msg_filter_max: u32) -> Result<(BOOL, Msg)> {
    let mut lp_msg = mem::MaybeUninit::zeroed();
    let lpMsg_win32 = lp_msg.as_mut_ptr();
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let wMsgFilterMin_win32 = w_msg_filter_min;
    let wMsgFilterMax_win32 = w_msg_filter_max;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMessageA(lpMsg_win32, hWnd_win32, wMsgFilterMin_win32, wMsgFilterMax_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_msg = unsafe { Msg::from_win32(unsafe { lp_msg.assume_init() }) };
    Ok((real_return_value,lp_msg))
}
#[inline]
pub fn get_message_extra_info() -> Lparam {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMessageExtraInfo() };
    let real_return_value = unsafe { Lparam::from_inner(return_value) };
    real_return_value
}
#[inline]
pub fn get_message_pos() -> u32 {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMessagePos() };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_message_time() -> Result<i32> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMessageTime() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_message_w(h_wnd: Option<Hwnd>, w_msg_filter_min: u32, w_msg_filter_max: u32) -> Result<(BOOL, Msg)> {
    let mut lp_msg = mem::MaybeUninit::zeroed();
    let lpMsg_win32 = lp_msg.as_mut_ptr();
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let wMsgFilterMin_win32 = w_msg_filter_min;
    let wMsgFilterMax_win32 = w_msg_filter_max;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetMessageW(lpMsg_win32, hWnd_win32, wMsgFilterMin_win32, wMsgFilterMax_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_msg = unsafe { Msg::from_win32(unsafe { lp_msg.assume_init() }) };
    Ok((real_return_value,lp_msg))
}
#[inline]
pub fn get_next_dlg_group_item(h_dlg: Hwnd, h_ctl: Option<Hwnd>, b_previous: BOOL) -> Result<Hwnd> {
    let hDlg_win32 = h_dlg.into_raw();
    let hCtl_win32 = h_ctl.map_or(0, Hwnd::into_raw);
    let bPrevious_win32 = b_previous;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetNextDlgGroupItem(hDlg_win32, hCtl_win32, bPrevious_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_next_dlg_tab_item(h_dlg: Hwnd, h_ctl: Option<Hwnd>, b_previous: BOOL) -> Result<Hwnd> {
    let hDlg_win32 = h_dlg.into_raw();
    let hCtl_win32 = h_ctl.map_or(0, Hwnd::into_raw);
    let bPrevious_win32 = b_previous;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetNextDlgTabItem(hDlg_win32, hCtl_win32, bPrevious_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_parent(h_wnd: Hwnd) -> Result<Hwnd> {
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetParent(hWnd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_physical_cursor_pos() -> Result<(BOOL, Point)> {
    let mut lp_point = mem::MaybeUninit::zeroed();
    let lpPoint_win32 = lp_point.as_mut_ptr();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetPhysicalCursorPos(lpPoint_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_point = unsafe { Point::from_win32(unsafe { lp_point.assume_init() }) };
    Ok((real_return_value,lp_point))
}
#[inline]
pub fn get_process_default_layout() -> Result<(BOOL, u32)> {
    let mut pdw_default_layout = mem::MaybeUninit::zeroed();
    let pdwDefaultLayout_win32 = pdw_default_layout.as_mut_ptr();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetProcessDefaultLayout(pdwDefaultLayout_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pdw_default_layout = unsafe { pdw_default_layout.assume_init() };
    Ok((real_return_value,pdw_default_layout))
}
#[inline]
pub fn get_prop_a(h_wnd: Hwnd, lp_string: &CStr) -> Result<Handle> {
    let hWnd_win32 = h_wnd.into_raw();
    let lpString_win32 = lp_string.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetPropA(hWnd_win32, lpString_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Handle::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_prop_w(h_wnd: Hwnd, lp_string: &OsStr) -> Result<Handle> {
    let hWnd_win32 = h_wnd.into_raw();
    let mut temp149: Vec<u16> = lp_string.encode_wide().collect();
    temp149.push(0);
    let lpString_win32 = temp149.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetPropW(hWnd_win32, lpString_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Handle::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_queue_status(flags: u32) -> u32 {
    let flags_win32 = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetQueueStatus(flags_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_scroll_bar_info(hwnd: Hwnd, id_object: i32, psbi: Scrollbarinfo) -> Result<(BOOL, Scrollbarinfo)> {
    let hwnd_win32 = hwnd.into_raw();
    let idObject_win32 = id_object;
    let mut psbi_win32 = psbi.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetScrollBarInfo(hwnd_win32, idObject_win32, &mut psbi_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let psbi = unsafe { Scrollbarinfo::from_win32(psbi_win32) };
    Ok((real_return_value,psbi))
}
#[inline]
pub fn get_scroll_info(hwnd: Hwnd, n_bar: u32, lpsi: Scrollinfo) -> Result<(BOOL, Scrollinfo)> {
    let hwnd_win32 = hwnd.into_raw();
    let nBar_win32 = n_bar;
    let mut lpsi_win32 = lpsi.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetScrollInfo(hwnd_win32, nBar_win32, &mut lpsi_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpsi = unsafe { Scrollinfo::from_win32(lpsi_win32) };
    Ok((real_return_value,lpsi))
}
#[inline]
pub fn get_scroll_pos(h_wnd: Hwnd, n_bar: u32) -> Result<i32> {
    let hWnd_win32 = h_wnd.into_raw();
    let nBar_win32 = n_bar;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetScrollPos(hWnd_win32, nBar_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_scroll_range(h_wnd: Hwnd, n_bar: u32, ) -> Result<(BOOL, i32, i32)> {
    let mut lp_min_pos = mem::MaybeUninit::zeroed();
    let lpMinPos_win32 = lp_min_pos.as_mut_ptr();
    let mut lp_max_pos = mem::MaybeUninit::zeroed();
    let lpMaxPos_win32 = lp_max_pos.as_mut_ptr();
    let hWnd_win32 = h_wnd.into_raw();
    let nBar_win32 = n_bar;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetScrollRange(hWnd_win32, nBar_win32, lpMinPos_win32, lpMaxPos_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_max_pos = unsafe { lp_max_pos.assume_init() };
    let lp_min_pos = unsafe { lp_min_pos.assume_init() };
    Ok((real_return_value,lp_min_pos, lp_max_pos))
}
#[inline]
pub fn get_shell_window() -> Result<Hwnd> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetShellWindow() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_sub_menu(h_menu: Hmenu, n_pos: i32) -> Result<Hmenu> {
    let hMenu_win32 = h_menu.into_raw();
    let nPos_win32 = n_pos;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetSubMenu(hMenu_win32, nPos_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hmenu::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_sys_color(n_index: u32) -> u32 {
    let nIndex_win32 = n_index;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetSysColor(nIndex_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_system_menu(h_wnd: Hwnd, b_revert: BOOL) -> Result<Hmenu> {
    let hWnd_win32 = h_wnd.into_raw();
    let bRevert_win32 = b_revert;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetSystemMenu(hWnd_win32, bRevert_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hmenu::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_system_metrics(n_index: u32) -> Result<i32> {
    let nIndex_win32 = n_index;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetSystemMetrics(nIndex_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_title_bar_info(hwnd: Hwnd, pti: Titlebarinfo) -> Result<(BOOL, Titlebarinfo)> {
    let hwnd_win32 = hwnd.into_raw();
    let mut pti_win32 = pti.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetTitleBarInfo(hwnd_win32, &mut pti_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pti = unsafe { Titlebarinfo::from_win32(pti_win32) };
    Ok((real_return_value,pti))
}
#[inline]
pub fn get_top_window(h_wnd: Option<Hwnd>) -> Result<Hwnd> {
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetTopWindow(hWnd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_window(h_wnd: Hwnd, u_cmd: u32) -> Result<Hwnd> {
    let hWnd_win32 = h_wnd.into_raw();
    let uCmd_win32 = u_cmd;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindow(hWnd_win32, uCmd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_window_display_affinity(h_wnd: Hwnd, ) -> Result<(BOOL, u32)> {
    let mut pdw_affinity = mem::MaybeUninit::zeroed();
    let pdwAffinity_win32 = pdw_affinity.as_mut_ptr();
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowDisplayAffinity(hWnd_win32, pdwAffinity_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pdw_affinity = unsafe { pdw_affinity.assume_init() };
    Ok((real_return_value,pdw_affinity))
}
#[inline]
pub fn get_window_info(hwnd: Hwnd, pwi: Windowinfo) -> Result<(BOOL, Windowinfo)> {
    let hwnd_win32 = hwnd.into_raw();
    let mut pwi_win32 = pwi.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowInfo(hwnd_win32, &mut pwi_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let pwi = unsafe { Windowinfo::from_win32(pwi_win32) };
    Ok((real_return_value,pwi))
}
#[inline]
pub fn get_window_long_a(h_wnd: Hwnd, n_index: i32) -> Result<i32> {
    let hWnd_win32 = h_wnd.into_raw();
    let nIndex_win32 = n_index;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowLongA(hWnd_win32, nIndex_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_window_long_ptr_a(h_wnd: Hwnd, n_index: i32) -> isize {
    let hWnd_win32 = h_wnd.into_raw();
    let nIndex_win32 = n_index;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowLongPtrA(hWnd_win32, nIndex_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_window_long_ptr_w(h_wnd: Hwnd, n_index: i32) -> isize {
    let hWnd_win32 = h_wnd.into_raw();
    let nIndex_win32 = n_index;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowLongPtrW(hWnd_win32, nIndex_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn get_window_long_w(h_wnd: Hwnd, n_index: i32) -> Result<i32> {
    let hWnd_win32 = h_wnd.into_raw();
    let nIndex_win32 = n_index;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowLongW(hWnd_win32, nIndex_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_window_module_file_name_a(hwnd: Hwnd, cch_file_name_max: u32) -> (u32, CString) {
    let mut psz_file_name = Vec::<u8>::with_capacity(cch_file_name_max as usize + 1);
    let pszFileName_win32 = psz_file_name.as_mut_ptr();
    let hwnd_win32 = hwnd.into_raw();
    let cchFileNameMax_win32 = cch_file_name_max;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowModuleFileNameA(hwnd_win32, pszFileName_win32, cchFileNameMax_win32) };
    let real_return_value = return_value;
    psz_file_name.truncate(return_value as usize);
    let psz_file_name = unsafe { CString::from_vec_unchecked(psz_file_name) };
    (real_return_value,psz_file_name)
}
#[inline]
pub fn get_window_module_file_name_w(hwnd: Hwnd, cch_file_name_max: u32) -> (u32, OsString) {
    let mut psz_file_name = Vec::<u16>::with_capacity(cch_file_name_max as usize + 1);
    let pszFileName_win32 = psz_file_name.as_mut_ptr();
    let hwnd_win32 = hwnd.into_raw();
    let cchFileNameMax_win32 = cch_file_name_max;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowModuleFileNameW(hwnd_win32, pszFileName_win32, cchFileNameMax_win32) };
    let real_return_value = return_value;
    psz_file_name.truncate(return_value as usize);
    let psz_file_name = OsString::from_wide(&psz_file_name);
    (real_return_value,psz_file_name)
}
#[inline]
pub fn get_window_placement(h_wnd: Hwnd, lpwndpl: Windowplacement) -> Result<(BOOL, Windowplacement)> {
    let hWnd_win32 = h_wnd.into_raw();
    let mut lpwndpl_win32 = lpwndpl.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowPlacement(hWnd_win32, &mut lpwndpl_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lpwndpl = unsafe { Windowplacement::from_win32(lpwndpl_win32) };
    Ok((real_return_value,lpwndpl))
}
#[inline]
pub fn get_window_rect(h_wnd: Hwnd, ) -> Result<(BOOL, Rect)> {
    let mut lp_rect = mem::MaybeUninit::zeroed();
    let lpRect_win32 = lp_rect.as_mut_ptr();
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowRect(hWnd_win32, lpRect_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_rect = unsafe { Rect::from_win32(unsafe { lp_rect.assume_init() }) };
    Ok((real_return_value,lp_rect))
}
#[inline]
pub fn get_window_text_a(h_wnd: Hwnd, n_max_count: i32) -> Result<(i32, CString)> {
    let mut lp_string = Vec::<u8>::with_capacity(n_max_count as usize + 1);
    let lpString_win32 = lp_string.as_mut_ptr();
    let hWnd_win32 = h_wnd.into_raw();
    let nMaxCount_win32 = n_max_count;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowTextA(hWnd_win32, lpString_win32, nMaxCount_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    lp_string.truncate(return_value as usize);
    let lp_string = unsafe { CString::from_vec_unchecked(lp_string) };
    Ok((real_return_value,lp_string))
}
#[inline]
pub fn get_window_text_length_a(h_wnd: Hwnd) -> Result<i32> {
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowTextLengthA(hWnd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_window_text_length_w(h_wnd: Hwnd) -> Result<i32> {
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowTextLengthW(hWnd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_window_text_w(h_wnd: Hwnd, n_max_count: i32) -> Result<(i32, OsString)> {
    let mut lp_string = Vec::<u16>::with_capacity(n_max_count as usize + 1);
    let lpString_win32 = lp_string.as_mut_ptr();
    let hWnd_win32 = h_wnd.into_raw();
    let nMaxCount_win32 = n_max_count;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowTextW(hWnd_win32, lpString_win32, nMaxCount_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    lp_string.truncate(return_value as usize);
    let lp_string = OsString::from_wide(&lp_string);
    Ok((real_return_value,lp_string))
}
#[inline]
pub fn get_window_thread_process_id(h_wnd: Hwnd, ) -> (u32, u32) {
    let mut lpdw_process_id = mem::MaybeUninit::zeroed();
    let lpdwProcessId_win32 = lpdw_process_id.as_mut_ptr();
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowThreadProcessId(hWnd_win32, lpdwProcessId_win32) };
    let real_return_value = return_value;
    let lpdw_process_id = unsafe { lpdw_process_id.assume_init() };
    (real_return_value,lpdw_process_id)
}
#[inline]
pub fn get_window_word(h_wnd: Hwnd, n_index: i32) -> u16 {
    let hWnd_win32 = h_wnd.into_raw();
    let nIndex_win32 = n_index;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetWindowWord(hWnd_win32, nIndex_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn hide_caret(h_wnd: Option<Hwnd>) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::HideCaret(hWnd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn hilite_menu_item(h_wnd: Hwnd, h_menu: Hmenu, u_id_hilite_item: u32, u_hilite: u32) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let hMenu_win32 = h_menu.into_raw();
    let uIDHiliteItem_win32 = u_id_hilite_item;
    let uHilite_win32 = u_hilite;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::HiliteMenuItem(hWnd_win32, hMenu_win32, uIDHiliteItem_win32, uHilite_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn in_send_message() -> BOOL {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::InSendMessage() };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn inherit_window_monitor(hwnd: Hwnd, hwnd_inherit: Option<Hwnd>) -> Result<BOOL> {
    let hwnd_win32 = hwnd.into_raw();
    let hwndInherit_win32 = hwnd_inherit.map_or(0, Hwnd::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::InheritWindowMonitor(hwnd_win32, hwndInherit_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn insert_menu_a(h_menu: Hmenu, u_position: u32, u_flags: u32, u_id_new_item: usize, lp_new_item: Option<&CStr>) -> Result<BOOL> {
    let hMenu_win32 = h_menu.into_raw();
    let uPosition_win32 = u_position;
    let uFlags_win32 = u_flags;
    let uIDNewItem_win32 = u_id_new_item;
    let lpNewItem_win32 = lp_new_item.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::InsertMenuA(hMenu_win32, uPosition_win32, uFlags_win32, uIDNewItem_win32, lpNewItem_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn insert_menu_item_a(hmenu: Hmenu, item: u32, f_by_position: BOOL, lpmi: &Menuiteminfoa<'_>) -> Result<BOOL> {
    let hmenu_win32 = hmenu.into_raw();
    let item_win32 = item;
    let fByPosition_win32 = f_by_position;
    let temp150 = lpmi.to_win32();
    let lpmi_win32 = &temp150;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::InsertMenuItemA(hmenu_win32, item_win32, fByPosition_win32, lpmi_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn insert_menu_item_w(hmenu: Hmenu, item: u32, f_by_position: BOOL, lpmi: &Menuiteminfow<'_>) -> Result<BOOL> {
    let hmenu_win32 = hmenu.into_raw();
    let item_win32 = item;
    let fByPosition_win32 = f_by_position;
    let temp151 = lpmi.to_win32();
    let lpmi_win32 = &temp151;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::InsertMenuItemW(hmenu_win32, item_win32, fByPosition_win32, lpmi_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn insert_menu_w(h_menu: Hmenu, u_position: u32, u_flags: u32, u_id_new_item: usize, lp_new_item: Option<&OsStr>) -> Result<BOOL> {
    let hMenu_win32 = h_menu.into_raw();
    let uPosition_win32 = u_position;
    let uFlags_win32 = u_flags;
    let uIDNewItem_win32 = u_id_new_item;
    let temp152 = lp_new_item.map(|val| {
        let mut temp152: Vec<u16> = val.encode_wide().collect();
        temp152.push(0);
        temp152
    });
    let lpNewItem_win32 = temp152.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::InsertMenuW(hMenu_win32, uPosition_win32, uFlags_win32, uIDNewItem_win32, lpNewItem_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn internal_get_window_text(h_wnd: Hwnd, cch_max_count: i32) -> Result<(i32, OsString)> {
    let mut p_string = Vec::<u16>::with_capacity(cch_max_count as usize + 1);
    let pString_win32 = p_string.as_mut_ptr();
    let hWnd_win32 = h_wnd.into_raw();
    let cchMaxCount_win32 = cch_max_count;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::InternalGetWindowText(hWnd_win32, pString_win32, cchMaxCount_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    p_string.truncate(return_value as usize);
    let p_string = OsString::from_wide(&p_string);
    Ok((real_return_value,p_string))
}
#[inline]
pub fn is_child(h_wnd_parent: Hwnd, h_wnd: Hwnd) -> BOOL {
    let hWndParent_win32 = h_wnd_parent.into_raw();
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsChild(hWndParent_win32, hWnd_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn is_dialog_message_a(h_dlg: Hwnd, lp_msg: &Msg) -> BOOL {
    let hDlg_win32 = h_dlg.into_raw();
    // SAFETY: type is a thin type
    let lpMsg_win32 = unsafe { &*(lp_msg as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsDialogMessageA(hDlg_win32, lpMsg_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn is_dialog_message_w(h_dlg: Hwnd, lp_msg: &Msg) -> BOOL {
    let hDlg_win32 = h_dlg.into_raw();
    // SAFETY: type is a thin type
    let lpMsg_win32 = unsafe { &*(lp_msg as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsDialogMessageW(hDlg_win32, lpMsg_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn is_gui_thread(b_convert: BOOL) -> BOOL {
    let bConvert_win32 = b_convert;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsGUIThread(bConvert_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn is_hung_app_window(hwnd: Hwnd) -> BOOL {
    let hwnd_win32 = hwnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsHungAppWindow(hwnd_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn is_iconic(h_wnd: Hwnd) -> BOOL {
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsIconic(hWnd_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn is_menu(h_menu: Hmenu) -> BOOL {
    let hMenu_win32 = h_menu.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsMenu(hMenu_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn is_process_dpi_aware() -> BOOL {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsProcessDPIAware() };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn is_window(h_wnd: Option<Hwnd>) -> BOOL {
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsWindow(hWnd_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn is_window_unicode(h_wnd: Hwnd) -> BOOL {
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsWindowUnicode(hWnd_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn is_window_visible(h_wnd: Hwnd) -> BOOL {
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsWindowVisible(hWnd_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn is_wow64_message() -> BOOL {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsWow64Message() };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn is_zoomed(h_wnd: Hwnd) -> BOOL {
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::IsZoomed(hWnd_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn kill_timer(h_wnd: Option<Hwnd>, u_id_event: usize) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let uIDEvent_win32 = u_id_event;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::KillTimer(hWnd_win32, uIDEvent_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn load_accelerators_a(h_instance: Option<Hinstance>, lp_table_name: &CStr) -> Result<Haccel> {
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    let lpTableName_win32 = lp_table_name.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadAcceleratorsA(hInstance_win32, lpTableName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Haccel::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn load_accelerators_w(h_instance: Option<Hinstance>, lp_table_name: &OsStr) -> Result<Haccel> {
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    let mut temp153: Vec<u16> = lp_table_name.encode_wide().collect();
    temp153.push(0);
    let lpTableName_win32 = temp153.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadAcceleratorsW(hInstance_win32, lpTableName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Haccel::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn load_cursor_a(h_instance: Option<Hinstance>, lp_cursor_name: &CStr) -> Result<Hcursor> {
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    let lpCursorName_win32 = lp_cursor_name.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadCursorA(hInstance_win32, lpCursorName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hcursor::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn load_cursor_from_file_a(lp_file_name: &CStr) -> Result<Hcursor> {
    let lpFileName_win32 = lp_file_name.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadCursorFromFileA(lpFileName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hcursor::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn load_cursor_from_file_w(lp_file_name: &OsStr) -> Result<Hcursor> {
    let mut temp154: Vec<u16> = lp_file_name.encode_wide().collect();
    temp154.push(0);
    let lpFileName_win32 = temp154.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadCursorFromFileW(lpFileName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hcursor::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn load_cursor_w(h_instance: Option<Hinstance>, lp_cursor_name: &OsStr) -> Result<Hcursor> {
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    let mut temp155: Vec<u16> = lp_cursor_name.encode_wide().collect();
    temp155.push(0);
    let lpCursorName_win32 = temp155.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadCursorW(hInstance_win32, lpCursorName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hcursor::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn load_icon_a(h_instance: Option<Hinstance>, lp_icon_name: &CStr) -> Result<Hicon> {
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    let lpIconName_win32 = lp_icon_name.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadIconA(hInstance_win32, lpIconName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hicon::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn load_icon_w(h_instance: Option<Hinstance>, lp_icon_name: &OsStr) -> Result<Hicon> {
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    let mut temp156: Vec<u16> = lp_icon_name.encode_wide().collect();
    temp156.push(0);
    let lpIconName_win32 = temp156.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadIconW(hInstance_win32, lpIconName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hicon::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn load_image_a(h_inst: Option<Hinstance>, name: &CStr, r#type: u32, cx: i32, cy: i32, fu_load: u32) -> Result<Handle> {
    let hInst_win32 = h_inst.map_or(0, Hinstance::into_raw);
    let name_win32 = name.as_ptr() as _;
    let r#type_win32 = r#type;
    let cx_win32 = cx;
    let cy_win32 = cy;
    let fuLoad_win32 = fu_load;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadImageA(hInst_win32, name_win32, r#type_win32, cx_win32, cy_win32, fuLoad_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Handle::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn load_image_w(h_inst: Option<Hinstance>, name: &OsStr, r#type: u32, cx: i32, cy: i32, fu_load: u32) -> Result<Handle> {
    let hInst_win32 = h_inst.map_or(0, Hinstance::into_raw);
    let mut temp157: Vec<u16> = name.encode_wide().collect();
    temp157.push(0);
    let name_win32 = temp157.as_ptr() as _;
    let r#type_win32 = r#type;
    let cx_win32 = cx;
    let cy_win32 = cy;
    let fuLoad_win32 = fu_load;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadImageW(hInst_win32, name_win32, r#type_win32, cx_win32, cy_win32, fuLoad_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Handle::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn load_menu_a(h_instance: Option<Hinstance>, lp_menu_name: &CStr) -> Result<Hmenu> {
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    let lpMenuName_win32 = lp_menu_name.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadMenuA(hInstance_win32, lpMenuName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hmenu::new(return_value) };
    Ok(real_return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn load_menu_indirect_a(lp_menu_template: &todo_void) -> Result<Hmenu> {
//      // SAFETY: type is a thin type
//      let lpMenuTemplate_win32 = unsafe { &*(lp_menu_template as *const _ as *const _) };
//      let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadMenuIndirectA(lpMenuTemplate_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = unsafe { Hmenu::new(return_value) };
//      Ok(real_return_value)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn load_menu_indirect_w(lp_menu_template: &todo_void) -> Result<Hmenu> {
//      // SAFETY: type is a thin type
//      let lpMenuTemplate_win32 = unsafe { &*(lp_menu_template as *const _ as *const _) };
//      let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadMenuIndirectW(lpMenuTemplate_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = unsafe { Hmenu::new(return_value) };
//      Ok(real_return_value)
//  }
#[inline]
pub fn load_menu_w(h_instance: Option<Hinstance>, lp_menu_name: &OsStr) -> Result<Hmenu> {
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    let mut temp158: Vec<u16> = lp_menu_name.encode_wide().collect();
    temp158.push(0);
    let lpMenuName_win32 = temp158.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadMenuW(hInstance_win32, lpMenuName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hmenu::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn load_string_a(h_instance: Option<Hinstance>, u_id: u32, cch_buffer_max: i32) -> Result<(i32, CString)> {
    let mut lp_buffer = Vec::<u8>::with_capacity(cch_buffer_max as usize + 1);
    let lpBuffer_win32 = lp_buffer.as_mut_ptr();
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    let uID_win32 = u_id;
    let cchBufferMax_win32 = cch_buffer_max;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadStringA(hInstance_win32, uID_win32, lpBuffer_win32, cchBufferMax_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    lp_buffer.truncate(return_value as usize);
    let lp_buffer = unsafe { CString::from_vec_unchecked(lp_buffer) };
    Ok((real_return_value,lp_buffer))
}
#[inline]
pub fn load_string_w(h_instance: Option<Hinstance>, u_id: u32, cch_buffer_max: i32) -> Result<(i32, OsString)> {
    let mut lp_buffer = Vec::<u16>::with_capacity(cch_buffer_max as usize + 1);
    let lpBuffer_win32 = lp_buffer.as_mut_ptr();
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    let uID_win32 = u_id;
    let cchBufferMax_win32 = cch_buffer_max;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LoadStringW(hInstance_win32, uID_win32, lpBuffer_win32, cchBufferMax_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    lp_buffer.truncate(return_value as usize);
    let lp_buffer = OsString::from_wide(&lp_buffer);
    Ok((real_return_value,lp_buffer))
}
#[inline]
pub fn lock_set_foreground_window(u_lock_code: u32) -> Result<BOOL> {
    let uLockCode_win32 = u_lock_code;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LockSetForegroundWindow(uLockCode_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn logical_to_physical_point(h_wnd: Hwnd, lp_point: Point) -> Result<(BOOL, Point)> {
    let hWnd_win32 = h_wnd.into_raw();
    let mut lpPoint_win32 = lp_point.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LogicalToPhysicalPoint(hWnd_win32, &mut lpPoint_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_point = unsafe { Point::from_win32(lpPoint_win32) };
    Ok((real_return_value,lp_point))
}
#[inline]
pub fn lookup_icon_id_from_directory(presbits: &u8, f_icon: BOOL) -> Result<i32> {
    // SAFETY: type is a thin type
    let presbits_win32 = unsafe { &*(presbits as *const _ as *const _) };
    let fIcon_win32 = f_icon;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LookupIconIdFromDirectory(presbits_win32, fIcon_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn lookup_icon_id_from_directory_ex(presbits: &u8, f_icon: BOOL, cx_desired: i32, cy_desired: i32, flags: u32) -> Result<i32> {
    // SAFETY: type is a thin type
    let presbits_win32 = unsafe { &*(presbits as *const _ as *const _) };
    let fIcon_win32 = f_icon;
    let cxDesired_win32 = cx_desired;
    let cyDesired_win32 = cy_desired;
    let Flags_win32 = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::LookupIconIdFromDirectoryEx(presbits_win32, fIcon_win32, cxDesired_win32, cyDesired_win32, Flags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn map_dialog_rect(h_dlg: Hwnd, lp_rect: Rect) -> Result<(BOOL, Rect)> {
    let hDlg_win32 = h_dlg.into_raw();
    let mut lpRect_win32 = lp_rect.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::MapDialogRect(hDlg_win32, &mut lpRect_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_rect = unsafe { Rect::from_win32(lpRect_win32) };
    Ok((real_return_value,lp_rect))
}
#[inline]
pub fn menu_item_from_point(h_wnd: Option<Hwnd>, h_menu: Hmenu, pt_screen: Point) -> Result<i32> {
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let hMenu_win32 = h_menu.into_raw();
    let ptScreen_win32 = pt_screen.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::MenuItemFromPoint(hWnd_win32, hMenu_win32, ptScreen_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn message_box_a(h_wnd: Option<Hwnd>, lp_text: Option<&CStr>, lp_caption: Option<&CStr>, u_type: u32) -> i32 {
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let lpText_win32 = lp_text.map_or(ptr::null(), |v| v.as_ptr() as _);
    let lpCaption_win32 = lp_caption.map_or(ptr::null(), |v| v.as_ptr() as _);
    let uType_win32 = u_type;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::MessageBoxA(hWnd_win32, lpText_win32, lpCaption_win32, uType_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn message_box_ex_a(h_wnd: Option<Hwnd>, lp_text: Option<&CStr>, lp_caption: Option<&CStr>, u_type: u32, w_language_id: u16) -> i32 {
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let lpText_win32 = lp_text.map_or(ptr::null(), |v| v.as_ptr() as _);
    let lpCaption_win32 = lp_caption.map_or(ptr::null(), |v| v.as_ptr() as _);
    let uType_win32 = u_type;
    let wLanguageId_win32 = w_language_id;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::MessageBoxExA(hWnd_win32, lpText_win32, lpCaption_win32, uType_win32, wLanguageId_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn message_box_ex_w(h_wnd: Option<Hwnd>, lp_text: Option<&OsStr>, lp_caption: Option<&OsStr>, u_type: u32, w_language_id: u16) -> i32 {
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let temp159 = lp_text.map(|val| {
        let mut temp159: Vec<u16> = val.encode_wide().collect();
        temp159.push(0);
        temp159
    });
    let lpText_win32 = temp159.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp160 = lp_caption.map(|val| {
        let mut temp160: Vec<u16> = val.encode_wide().collect();
        temp160.push(0);
        temp160
    });
    let lpCaption_win32 = temp160.map_or(ptr::null(), |v| v.as_ptr() as _);
    let uType_win32 = u_type;
    let wLanguageId_win32 = w_language_id;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::MessageBoxExW(hWnd_win32, lpText_win32, lpCaption_win32, uType_win32, wLanguageId_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn message_box_indirect_a(lpmbp: &Msgboxparamsa<'_>) -> i32 {
    let temp161 = lpmbp.to_win32();
    let lpmbp_win32 = &temp161;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::MessageBoxIndirectA(lpmbp_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn message_box_indirect_w(lpmbp: &Msgboxparamsw<'_>) -> i32 {
    let temp162 = lpmbp.to_win32();
    let lpmbp_win32 = &temp162;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::MessageBoxIndirectW(lpmbp_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn message_box_w(h_wnd: Option<Hwnd>, lp_text: Option<&OsStr>, lp_caption: Option<&OsStr>, u_type: u32) -> i32 {
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let temp163 = lp_text.map(|val| {
        let mut temp163: Vec<u16> = val.encode_wide().collect();
        temp163.push(0);
        temp163
    });
    let lpText_win32 = temp163.map_or(ptr::null(), |v| v.as_ptr() as _);
    let temp164 = lp_caption.map(|val| {
        let mut temp164: Vec<u16> = val.encode_wide().collect();
        temp164.push(0);
        temp164
    });
    let lpCaption_win32 = temp164.map_or(ptr::null(), |v| v.as_ptr() as _);
    let uType_win32 = u_type;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::MessageBoxW(hWnd_win32, lpText_win32, lpCaption_win32, uType_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn modify_menu_a(h_mnu: Hmenu, u_position: u32, u_flags: u32, u_id_new_item: usize, lp_new_item: Option<&CStr>) -> Result<BOOL> {
    let hMnu_win32 = h_mnu.into_raw();
    let uPosition_win32 = u_position;
    let uFlags_win32 = u_flags;
    let uIDNewItem_win32 = u_id_new_item;
    let lpNewItem_win32 = lp_new_item.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ModifyMenuA(hMnu_win32, uPosition_win32, uFlags_win32, uIDNewItem_win32, lpNewItem_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn modify_menu_w(h_mnu: Hmenu, u_position: u32, u_flags: u32, u_id_new_item: usize, lp_new_item: Option<&OsStr>) -> Result<BOOL> {
    let hMnu_win32 = h_mnu.into_raw();
    let uPosition_win32 = u_position;
    let uFlags_win32 = u_flags;
    let uIDNewItem_win32 = u_id_new_item;
    let temp165 = lp_new_item.map(|val| {
        let mut temp165: Vec<u16> = val.encode_wide().collect();
        temp165.push(0);
        temp165
    });
    let lpNewItem_win32 = temp165.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ModifyMenuW(hMnu_win32, uPosition_win32, uFlags_win32, uIDNewItem_win32, lpNewItem_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn move_window(h_wnd: Hwnd, x: i32, y: i32, n_width: i32, n_height: i32, b_repaint: BOOL) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let X_win32 = x;
    let Y_win32 = y;
    let nWidth_win32 = n_width;
    let nHeight_win32 = n_height;
    let bRepaint_win32 = b_repaint;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::MoveWindow(hWnd_win32, X_win32, Y_win32, nWidth_win32, nHeight_win32, bRepaint_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn msg_wait_for_multiple_objects(p_handles: Option<&[Handle]>, f_wait_all: BOOL, dw_milliseconds: u32, dw_wake_mask: u32) -> u32 {
    let pHandles_win32 = p_handles.map_or(ptr::null(), |v| v.as_ptr() as _);
    let nCount_win32 = p_handles.len() as _;
    let fWaitAll_win32 = f_wait_all;
    let dwMilliseconds_win32 = dw_milliseconds;
    let dwWakeMask_win32 = dw_wake_mask;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::MsgWaitForMultipleObjects(nCount_win32, pHandles_win32, fWaitAll_win32, dwMilliseconds_win32, dwWakeMask_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn msg_wait_for_multiple_objects_ex(p_handles: Option<&[Handle]>, dw_milliseconds: u32, dw_wake_mask: u32, dw_flags: u32) -> u32 {
    let pHandles_win32 = p_handles.map_or(ptr::null(), |v| v.as_ptr() as _);
    let nCount_win32 = p_handles.len() as _;
    let dwMilliseconds_win32 = dw_milliseconds;
    let dwWakeMask_win32 = dw_wake_mask;
    let dwFlags_win32 = dw_flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::MsgWaitForMultipleObjectsEx(nCount_win32, pHandles_win32, dwMilliseconds_win32, dwWakeMask_win32, dwFlags_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn open_icon(h_wnd: Hwnd) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::OpenIcon(hWnd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn peek_message_a(h_wnd: Option<Hwnd>, w_msg_filter_min: u32, w_msg_filter_max: u32, w_remove_msg: u32) -> Result<(BOOL, Msg)> {
    let mut lp_msg = mem::MaybeUninit::zeroed();
    let lpMsg_win32 = lp_msg.as_mut_ptr();
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let wMsgFilterMin_win32 = w_msg_filter_min;
    let wMsgFilterMax_win32 = w_msg_filter_max;
    let wRemoveMsg_win32 = w_remove_msg;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::PeekMessageA(lpMsg_win32, hWnd_win32, wMsgFilterMin_win32, wMsgFilterMax_win32, wRemoveMsg_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_msg = unsafe { Msg::from_win32(unsafe { lp_msg.assume_init() }) };
    Ok((real_return_value,lp_msg))
}
#[inline]
pub fn peek_message_w(h_wnd: Option<Hwnd>, w_msg_filter_min: u32, w_msg_filter_max: u32, w_remove_msg: u32) -> Result<(BOOL, Msg)> {
    let mut lp_msg = mem::MaybeUninit::zeroed();
    let lpMsg_win32 = lp_msg.as_mut_ptr();
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let wMsgFilterMin_win32 = w_msg_filter_min;
    let wMsgFilterMax_win32 = w_msg_filter_max;
    let wRemoveMsg_win32 = w_remove_msg;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::PeekMessageW(lpMsg_win32, hWnd_win32, wMsgFilterMin_win32, wMsgFilterMax_win32, wRemoveMsg_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_msg = unsafe { Msg::from_win32(unsafe { lp_msg.assume_init() }) };
    Ok((real_return_value,lp_msg))
}
#[inline]
pub fn physical_to_logical_point(h_wnd: Hwnd, lp_point: Point) -> Result<(BOOL, Point)> {
    let hWnd_win32 = h_wnd.into_raw();
    let mut lpPoint_win32 = lp_point.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::PhysicalToLogicalPoint(hWnd_win32, &mut lpPoint_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lp_point = unsafe { Point::from_win32(lpPoint_win32) };
    Ok((real_return_value,lp_point))
}
#[inline]
pub fn post_message_a(h_wnd: Option<Hwnd>, msg: u32, w_param: Wparam, l_param: Lparam) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let Msg_win32 = msg;
    let wParam_win32 = w_param.into_inner();
    let lParam_win32 = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::PostMessageA(hWnd_win32, Msg_win32, wParam_win32, lParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn post_message_w(h_wnd: Option<Hwnd>, msg: u32, w_param: Wparam, l_param: Lparam) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let Msg_win32 = msg;
    let wParam_win32 = w_param.into_inner();
    let lParam_win32 = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::PostMessageW(hWnd_win32, Msg_win32, wParam_win32, lParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn post_quit_message(n_exit_code: i32) -> () {
    let nExitCode_win32 = n_exit_code;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::PostQuitMessage(nExitCode_win32) };
    let _ = return_value;
}
#[inline]
pub fn post_thread_message_a(id_thread: u32, msg: u32, w_param: Wparam, l_param: Lparam) -> Result<BOOL> {
    let idThread_win32 = id_thread;
    let Msg_win32 = msg;
    let wParam_win32 = w_param.into_inner();
    let lParam_win32 = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::PostThreadMessageA(idThread_win32, Msg_win32, wParam_win32, lParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn post_thread_message_w(id_thread: u32, msg: u32, w_param: Wparam, l_param: Lparam) -> Result<BOOL> {
    let idThread_win32 = id_thread;
    let Msg_win32 = msg;
    let wParam_win32 = w_param.into_inner();
    let lParam_win32 = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::PostThreadMessageW(idThread_win32, Msg_win32, wParam_win32, lParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn private_extract_icons_a(sz_file_name: &CStr, n_icon_index: i32, cx_icon: i32, cy_icon: i32, n_icons: u32, flags: u32) -> (u32, Hicon, u32) {
    let mut phicon = mem::MaybeUninit::zeroed();
    let phicon_win32 = phicon.as_mut_ptr();
    let mut piconid = mem::MaybeUninit::zeroed();
    let piconid_win32 = piconid.as_mut_ptr();
    let szFileName_win32 = sz_file_name.as_ptr() as _;
    let nIconIndex_win32 = n_icon_index;
    let cxIcon_win32 = cx_icon;
    let cyIcon_win32 = cy_icon;
    let nIcons_win32 = n_icons;
    let flags_win32 = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::PrivateExtractIconsA(szFileName_win32, nIconIndex_win32, cxIcon_win32, cyIcon_win32, phicon_win32, piconid_win32, nIcons_win32, flags_win32) };
    let real_return_value = return_value;
    let piconid = unsafe { piconid.assume_init() };
    let phicon = unsafe { Hicon::new(unsafe { phicon.assume_init() }) };
    (real_return_value,phicon, piconid)
}
#[inline]
pub fn private_extract_icons_w(sz_file_name: &OsStr, n_icon_index: i32, cx_icon: i32, cy_icon: i32, n_icons: u32, flags: u32) -> (u32, Hicon, u32) {
    let mut phicon = mem::MaybeUninit::zeroed();
    let phicon_win32 = phicon.as_mut_ptr();
    let mut piconid = mem::MaybeUninit::zeroed();
    let piconid_win32 = piconid.as_mut_ptr();
    let mut temp166: Vec<u16> = sz_file_name.encode_wide().collect();
    temp166.push(0);
    let szFileName_win32 = temp166.as_ptr() as _;
    let nIconIndex_win32 = n_icon_index;
    let cxIcon_win32 = cx_icon;
    let cyIcon_win32 = cy_icon;
    let nIcons_win32 = n_icons;
    let flags_win32 = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::PrivateExtractIconsW(szFileName_win32, nIconIndex_win32, cxIcon_win32, cyIcon_win32, phicon_win32, piconid_win32, nIcons_win32, flags_win32) };
    let real_return_value = return_value;
    let piconid = unsafe { piconid.assume_init() };
    let phicon = unsafe { Hicon::new(unsafe { phicon.assume_init() }) };
    (real_return_value,phicon, piconid)
}
#[inline]
pub fn real_child_window_from_point(hwnd_parent: Hwnd, pt_parent_client_coords: Point) -> Result<Hwnd> {
    let hwndParent_win32 = hwnd_parent.into_raw();
    let ptParentClientCoords_win32 = pt_parent_client_coords.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::RealChildWindowFromPoint(hwndParent_win32, ptParentClientCoords_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn real_get_window_class_a(hwnd: Hwnd, cch_class_name_max: u32) -> (u32, CString) {
    let mut ptsz_class_name = Vec::<u8>::with_capacity(cch_class_name_max as usize + 1);
    let ptszClassName_win32 = ptsz_class_name.as_mut_ptr();
    let hwnd_win32 = hwnd.into_raw();
    let cchClassNameMax_win32 = cch_class_name_max;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::RealGetWindowClassA(hwnd_win32, ptszClassName_win32, cchClassNameMax_win32) };
    let real_return_value = return_value;
    ptsz_class_name.truncate(return_value as usize);
    let ptsz_class_name = unsafe { CString::from_vec_unchecked(ptsz_class_name) };
    (real_return_value,ptsz_class_name)
}
#[inline]
pub fn real_get_window_class_w(hwnd: Hwnd, cch_class_name_max: u32) -> (u32, OsString) {
    let mut ptsz_class_name = Vec::<u16>::with_capacity(cch_class_name_max as usize + 1);
    let ptszClassName_win32 = ptsz_class_name.as_mut_ptr();
    let hwnd_win32 = hwnd.into_raw();
    let cchClassNameMax_win32 = cch_class_name_max;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::RealGetWindowClassW(hwnd_win32, ptszClassName_win32, cchClassNameMax_win32) };
    let real_return_value = return_value;
    ptsz_class_name.truncate(return_value as usize);
    let ptsz_class_name = OsString::from_wide(&ptsz_class_name);
    (real_return_value,ptsz_class_name)
}
#[inline]
pub fn remove_menu(h_menu: Hmenu, u_position: u32, u_flags: u32) -> Result<BOOL> {
    let hMenu_win32 = h_menu.into_raw();
    let uPosition_win32 = u_position;
    let uFlags_win32 = u_flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::RemoveMenu(hMenu_win32, uPosition_win32, uFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn remove_prop_a(h_wnd: Hwnd, lp_string: &CStr) -> Result<Handle> {
    let hWnd_win32 = h_wnd.into_raw();
    let lpString_win32 = lp_string.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::RemovePropA(hWnd_win32, lpString_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Handle::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn remove_prop_w(h_wnd: Hwnd, lp_string: &OsStr) -> Result<Handle> {
    let hWnd_win32 = h_wnd.into_raw();
    let mut temp167: Vec<u16> = lp_string.encode_wide().collect();
    temp167.push(0);
    let lpString_win32 = temp167.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::RemovePropW(hWnd_win32, lpString_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Handle::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn reply_message(l_result: Lresult) -> Result<BOOL> {
    let lResult_win32 = l_result.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ReplyMessage(lResult_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn scroll_dc(h_dc: Hdc, dx: i32, dy: i32, lprc_scroll: Option<&Rect>, lprc_clip: Option<&Rect>, hrgn_update: Option<Hrgn>, ) -> Result<(BOOL, Rect)> {
    let mut lprc_update = mem::MaybeUninit::zeroed();
    let lprcUpdate_win32 = lprc_update.as_mut_ptr();
    let hDC_win32 = h_dc.into_raw();
    let dx_win32 = dx;
    let dy_win32 = dy;
    // SAFETY: type is a thin type
    let lprcScroll_win32 = lprc_scroll.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    // SAFETY: type is a thin type
    let lprcClip_win32 = lprc_clip.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let hrgnUpdate_win32 = hrgn_update.map_or(0, Hrgn::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ScrollDC(hDC_win32, dx_win32, dy_win32, lprcScroll_win32, lprcClip_win32, hrgnUpdate_win32, lprcUpdate_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let lprc_update = unsafe { Rect::from_win32(unsafe { lprc_update.assume_init() }) };
    Ok((real_return_value,lprc_update))
}
#[inline]
pub fn scroll_window(h_wnd: Hwnd, x_amount: i32, y_amount: i32, lp_rect: Option<&Rect>, lp_clip_rect: Option<&Rect>) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let XAmount_win32 = x_amount;
    let YAmount_win32 = y_amount;
    // SAFETY: type is a thin type
    let lpRect_win32 = lp_rect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    // SAFETY: type is a thin type
    let lpClipRect_win32 = lp_clip_rect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ScrollWindow(hWnd_win32, XAmount_win32, YAmount_win32, lpRect_win32, lpClipRect_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn scroll_window_ex(h_wnd: Hwnd, dx: i32, dy: i32, prc_scroll: Option<&Rect>, prc_clip: Option<&Rect>, hrgn_update: Option<Hrgn>, flags: u32) -> Result<(i32, Rect)> {
    let mut prc_update = mem::MaybeUninit::zeroed();
    let prcUpdate_win32 = prc_update.as_mut_ptr();
    let hWnd_win32 = h_wnd.into_raw();
    let dx_win32 = dx;
    let dy_win32 = dy;
    // SAFETY: type is a thin type
    let prcScroll_win32 = prc_scroll.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    // SAFETY: type is a thin type
    let prcClip_win32 = prc_clip.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let hrgnUpdate_win32 = hrgn_update.map_or(0, Hrgn::into_raw);
    let flags_win32 = flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ScrollWindowEx(hWnd_win32, dx_win32, dy_win32, prcScroll_win32, prcClip_win32, hrgnUpdate_win32, prcUpdate_win32, flags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let prc_update = unsafe { Rect::from_win32(unsafe { prc_update.assume_init() }) };
    Ok((real_return_value,prc_update))
}
#[inline]
pub fn send_dlg_item_message_a(h_dlg: Hwnd, n_id_dlg_item: i32, msg: u32, w_param: Wparam, l_param: Lparam) -> Lresult {
    let hDlg_win32 = h_dlg.into_raw();
    let nIDDlgItem_win32 = n_id_dlg_item;
    let Msg_win32 = msg;
    let wParam_win32 = w_param.into_inner();
    let lParam_win32 = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SendDlgItemMessageA(hDlg_win32, nIDDlgItem_win32, Msg_win32, wParam_win32, lParam_win32) };
    let real_return_value = unsafe { Lresult::from_inner(return_value) };
    real_return_value
}
#[inline]
pub fn send_dlg_item_message_w(h_dlg: Hwnd, n_id_dlg_item: i32, msg: u32, w_param: Wparam, l_param: Lparam) -> Lresult {
    let hDlg_win32 = h_dlg.into_raw();
    let nIDDlgItem_win32 = n_id_dlg_item;
    let Msg_win32 = msg;
    let wParam_win32 = w_param.into_inner();
    let lParam_win32 = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SendDlgItemMessageW(hDlg_win32, nIDDlgItem_win32, Msg_win32, wParam_win32, lParam_win32) };
    let real_return_value = unsafe { Lresult::from_inner(return_value) };
    real_return_value
}
#[inline]
pub fn send_message_a(h_wnd: Hwnd, msg: u32, ) -> Lresult {
    let wParam_win32 = unsafe { mem::zeroed() };
    let lParam_win32 = unsafe { mem::zeroed() };
    let hWnd_win32 = h_wnd.into_raw();
    let Msg_win32 = msg;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SendMessageA(hWnd_win32, Msg_win32, wParam_win32, lParam_win32) };
    let real_return_value = unsafe { Lresult::from_inner(return_value) };
    real_return_value
}
#[inline]
pub fn send_message_callback_a<Sendasyncproc: FnMut(Hwnd, u32, Lresult)>(h_wnd: Hwnd, msg: u32, w_param: Wparam, l_param: Lparam, lp_result_call_back: Sendasyncproc, ) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let Msg_win32 = msg;
    let wParam_win32 = w_param.into_inner();
    let lParam_win32 = l_param.into_inner();
    unsafe extern "system" fn sendasyncproc_impl<Sendasyncproc>(param0: HWND, param1: u32, param2: usize, param3: LRESULT) -> () {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input3 = unsafe { Lresult::from_inner(param3) };
            let closure = unsafe {
                &mut *(param2 as usize as *mut Sendasyncproc)
            };
            let return_value = (closure)(input0, input1, input3);
        })
    }
    let lpResultCallBack_win32 = Some(sendasyncproc_impl::<Sendasyncproc>);
    let mut lp_result_call_back = lp_result_call_back;
    let dwData_win32 = (&mut lp_result_call_back) as *mut _ as *mut _ as usize;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SendMessageCallbackA(hWnd_win32, Msg_win32, wParam_win32, lParam_win32, lpResultCallBack_win32, dwData_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn send_message_callback_w<Sendasyncproc: FnMut(Hwnd, u32, Lresult)>(h_wnd: Hwnd, msg: u32, w_param: Wparam, l_param: Lparam, lp_result_call_back: Sendasyncproc, ) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let Msg_win32 = msg;
    let wParam_win32 = w_param.into_inner();
    let lParam_win32 = l_param.into_inner();
    unsafe extern "system" fn sendasyncproc_impl<Sendasyncproc>(param0: HWND, param1: u32, param2: usize, param3: LRESULT) -> () {
        abort_on_panic(move || {
            let input0 = unsafe { Hwnd::new(param0) };
            let input1 = param1;
            let input3 = unsafe { Lresult::from_inner(param3) };
            let closure = unsafe {
                &mut *(param2 as usize as *mut Sendasyncproc)
            };
            let return_value = (closure)(input0, input1, input3);
        })
    }
    let lpResultCallBack_win32 = Some(sendasyncproc_impl::<Sendasyncproc>);
    let mut lp_result_call_back = lp_result_call_back;
    let dwData_win32 = (&mut lp_result_call_back) as *mut _ as *mut _ as usize;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SendMessageCallbackW(hWnd_win32, Msg_win32, wParam_win32, lParam_win32, lpResultCallBack_win32, dwData_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn send_message_timeout_a(h_wnd: Hwnd, msg: u32, w_param: Wparam, l_param: Lparam, fu_flags: u32, u_timeout: u32, ) -> (Lresult, usize) {
    let mut lpdw_result = mem::MaybeUninit::zeroed();
    let lpdwResult_win32 = lpdw_result.as_mut_ptr();
    let hWnd_win32 = h_wnd.into_raw();
    let Msg_win32 = msg;
    let wParam_win32 = w_param.into_inner();
    let lParam_win32 = l_param.into_inner();
    let fuFlags_win32 = fu_flags;
    let uTimeout_win32 = u_timeout;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SendMessageTimeoutA(hWnd_win32, Msg_win32, wParam_win32, lParam_win32, fuFlags_win32, uTimeout_win32, lpdwResult_win32) };
    let real_return_value = unsafe { Lresult::from_inner(return_value) };
    let lpdw_result = unsafe { lpdw_result.assume_init() };
    (real_return_value,lpdw_result)
}
#[inline]
pub fn send_message_timeout_w(h_wnd: Hwnd, msg: u32, w_param: Wparam, l_param: Lparam, fu_flags: u32, u_timeout: u32, ) -> (Lresult, usize) {
    let mut lpdw_result = mem::MaybeUninit::zeroed();
    let lpdwResult_win32 = lpdw_result.as_mut_ptr();
    let hWnd_win32 = h_wnd.into_raw();
    let Msg_win32 = msg;
    let wParam_win32 = w_param.into_inner();
    let lParam_win32 = l_param.into_inner();
    let fuFlags_win32 = fu_flags;
    let uTimeout_win32 = u_timeout;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SendMessageTimeoutW(hWnd_win32, Msg_win32, wParam_win32, lParam_win32, fuFlags_win32, uTimeout_win32, lpdwResult_win32) };
    let real_return_value = unsafe { Lresult::from_inner(return_value) };
    let lpdw_result = unsafe { lpdw_result.assume_init() };
    (real_return_value,lpdw_result)
}
#[inline]
pub fn send_message_w(h_wnd: Hwnd, msg: u32, ) -> Lresult {
    let wParam_win32 = unsafe { mem::zeroed() };
    let lParam_win32 = unsafe { mem::zeroed() };
    let hWnd_win32 = h_wnd.into_raw();
    let Msg_win32 = msg;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SendMessageW(hWnd_win32, Msg_win32, wParam_win32, lParam_win32) };
    let real_return_value = unsafe { Lresult::from_inner(return_value) };
    real_return_value
}
#[inline]
pub fn send_notify_message_a(h_wnd: Hwnd, msg: u32, w_param: Wparam, l_param: Lparam) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let Msg_win32 = msg;
    let wParam_win32 = w_param.into_inner();
    let lParam_win32 = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SendNotifyMessageA(hWnd_win32, Msg_win32, wParam_win32, lParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn send_notify_message_w(h_wnd: Hwnd, msg: u32, w_param: Wparam, l_param: Lparam) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let Msg_win32 = msg;
    let wParam_win32 = w_param.into_inner();
    let lParam_win32 = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SendNotifyMessageW(hWnd_win32, Msg_win32, wParam_win32, lParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_caret_blink_time(u_m_seconds: u32) -> Result<BOOL> {
    let uMSeconds_win32 = u_m_seconds;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetCaretBlinkTime(uMSeconds_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_caret_pos(x: i32, y: i32) -> Result<BOOL> {
    let X_win32 = x;
    let Y_win32 = y;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetCaretPos(X_win32, Y_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_class_long_a(h_wnd: Hwnd, n_index: i32, dw_new_long: i32) -> u32 {
    let hWnd_win32 = h_wnd.into_raw();
    let nIndex_win32 = n_index;
    let dwNewLong_win32 = dw_new_long;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetClassLongA(hWnd_win32, nIndex_win32, dwNewLong_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn set_class_long_ptr_a(h_wnd: Hwnd, n_index: i32, dw_new_long: isize) -> usize {
    let hWnd_win32 = h_wnd.into_raw();
    let nIndex_win32 = n_index;
    let dwNewLong_win32 = dw_new_long;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetClassLongPtrA(hWnd_win32, nIndex_win32, dwNewLong_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn set_class_long_ptr_w(h_wnd: Hwnd, n_index: i32, dw_new_long: isize) -> usize {
    let hWnd_win32 = h_wnd.into_raw();
    let nIndex_win32 = n_index;
    let dwNewLong_win32 = dw_new_long;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetClassLongPtrW(hWnd_win32, nIndex_win32, dwNewLong_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn set_class_long_w(h_wnd: Hwnd, n_index: i32, dw_new_long: i32) -> u32 {
    let hWnd_win32 = h_wnd.into_raw();
    let nIndex_win32 = n_index;
    let dwNewLong_win32 = dw_new_long;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetClassLongW(hWnd_win32, nIndex_win32, dwNewLong_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn set_class_word(h_wnd: Hwnd, n_index: i32, w_new_word: u16) -> u16 {
    let hWnd_win32 = h_wnd.into_raw();
    let nIndex_win32 = n_index;
    let wNewWord_win32 = w_new_word;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetClassWord(hWnd_win32, nIndex_win32, wNewWord_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn set_coalescable_timer(h_wnd: Option<Hwnd>, n_id_event: usize, u_elapse: u32, lp_timer_func: Option<unsafe extern "system" fn(HWND, u32, usize, u32)>, u_tolerance_delay: u32) -> usize {
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let nIDEvent_win32 = n_id_event;
    let uElapse_win32 = u_elapse;
    let lpTimerFunc_win32 = lp_timer_func;
    let uToleranceDelay_win32 = u_tolerance_delay;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetCoalescableTimer(hWnd_win32, nIDEvent_win32, uElapse_win32, lpTimerFunc_win32, uToleranceDelay_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn set_cursor(h_cursor: Option<Hcursor>) -> Result<Hcursor> {
    let hCursor_win32 = h_cursor.map_or(0, Hcursor::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetCursor(hCursor_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hcursor::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn set_cursor_pos(x: i32, y: i32) -> Result<BOOL> {
    let X_win32 = x;
    let Y_win32 = y;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetCursorPos(X_win32, Y_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_debug_error_level(dw_level: u32) -> () {
    let dwLevel_win32 = dw_level;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetDebugErrorLevel(dwLevel_win32) };
    let _ = return_value;
}
#[inline]
pub fn set_dlg_item_int(h_dlg: Hwnd, n_id_dlg_item: i32, u_value: u32, b_signed: BOOL) -> Result<BOOL> {
    let hDlg_win32 = h_dlg.into_raw();
    let nIDDlgItem_win32 = n_id_dlg_item;
    let uValue_win32 = u_value;
    let bSigned_win32 = b_signed;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetDlgItemInt(hDlg_win32, nIDDlgItem_win32, uValue_win32, bSigned_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_dlg_item_text_a(h_dlg: Hwnd, n_id_dlg_item: i32, lp_string: &CStr) -> Result<BOOL> {
    let hDlg_win32 = h_dlg.into_raw();
    let nIDDlgItem_win32 = n_id_dlg_item;
    let lpString_win32 = lp_string.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetDlgItemTextA(hDlg_win32, nIDDlgItem_win32, lpString_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_dlg_item_text_w(h_dlg: Hwnd, n_id_dlg_item: i32, lp_string: &OsStr) -> Result<BOOL> {
    let hDlg_win32 = h_dlg.into_raw();
    let nIDDlgItem_win32 = n_id_dlg_item;
    let mut temp168: Vec<u16> = lp_string.encode_wide().collect();
    temp168.push(0);
    let lpString_win32 = temp168.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetDlgItemTextW(hDlg_win32, nIDDlgItem_win32, lpString_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_foreground_window(h_wnd: Hwnd) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetForegroundWindow(hWnd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_layered_window_attributes(hwnd: Hwnd, cr_key: u32, b_alpha: u8, dw_flags: u32) -> Result<BOOL> {
    let hwnd_win32 = hwnd.into_raw();
    let crKey_win32 = cr_key;
    let bAlpha_win32 = b_alpha;
    let dwFlags_win32 = dw_flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetLayeredWindowAttributes(hwnd_win32, crKey_win32, bAlpha_win32, dwFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_menu(h_wnd: Hwnd, h_menu: Option<Hmenu>) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let hMenu_win32 = h_menu.map_or(0, Hmenu::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetMenu(hWnd_win32, hMenu_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_menu_default_item(h_menu: Hmenu, u_item: u32, f_by_pos: u32) -> Result<BOOL> {
    let hMenu_win32 = h_menu.into_raw();
    let uItem_win32 = u_item;
    let fByPos_win32 = f_by_pos;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetMenuDefaultItem(hMenu_win32, uItem_win32, fByPos_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_menu_info(param0: Hmenu, param1: &Menuinfo) -> Result<BOOL> {
    let param0_win32 = param0.into_raw();
    let temp169 = param1.to_win32();
    let param1_win32 = &temp169;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetMenuInfo(param0_win32, param1_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_menu_item_bitmaps(h_menu: Hmenu, u_position: u32, u_flags: u32, h_bitmap_unchecked: Option<Hbitmap>, h_bitmap_checked: Option<Hbitmap>) -> Result<BOOL> {
    let hMenu_win32 = h_menu.into_raw();
    let uPosition_win32 = u_position;
    let uFlags_win32 = u_flags;
    let hBitmapUnchecked_win32 = h_bitmap_unchecked.map_or(0, Hbitmap::into_raw);
    let hBitmapChecked_win32 = h_bitmap_checked.map_or(0, Hbitmap::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetMenuItemBitmaps(hMenu_win32, uPosition_win32, uFlags_win32, hBitmapUnchecked_win32, hBitmapChecked_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_menu_item_info_a(hmenu: Hmenu, item: u32, f_by_positon: BOOL, lpmii: &Menuiteminfoa<'_>) -> Result<BOOL> {
    let hmenu_win32 = hmenu.into_raw();
    let item_win32 = item;
    let fByPositon_win32 = f_by_positon;
    let temp170 = lpmii.to_win32();
    let lpmii_win32 = &temp170;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetMenuItemInfoA(hmenu_win32, item_win32, fByPositon_win32, lpmii_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_menu_item_info_w(hmenu: Hmenu, item: u32, f_by_positon: BOOL, lpmii: &Menuiteminfow<'_>) -> Result<BOOL> {
    let hmenu_win32 = hmenu.into_raw();
    let item_win32 = item;
    let fByPositon_win32 = f_by_positon;
    let temp171 = lpmii.to_win32();
    let lpmii_win32 = &temp171;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetMenuItemInfoW(hmenu_win32, item_win32, fByPositon_win32, lpmii_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_message_extra_info(l_param: Lparam) -> Lparam {
    let lParam_win32 = l_param.into_inner();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetMessageExtraInfo(lParam_win32) };
    let real_return_value = unsafe { Lparam::from_inner(return_value) };
    real_return_value
}
#[inline]
pub fn set_message_queue(c_messages_max: i32) -> Result<BOOL> {
    let cMessagesMax_win32 = c_messages_max;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetMessageQueue(cMessagesMax_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_parent(h_wnd_child: Hwnd, h_wnd_new_parent: Option<Hwnd>) -> Result<Hwnd> {
    let hWndChild_win32 = h_wnd_child.into_raw();
    let hWndNewParent_win32 = h_wnd_new_parent.map_or(0, Hwnd::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetParent(hWndChild_win32, hWndNewParent_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn set_physical_cursor_pos(x: i32, y: i32) -> Result<BOOL> {
    let X_win32 = x;
    let Y_win32 = y;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetPhysicalCursorPos(X_win32, Y_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_process_dpi_aware() -> Result<BOOL> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetProcessDPIAware() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_process_default_layout(dw_default_layout: u32) -> Result<BOOL> {
    let dwDefaultLayout_win32 = dw_default_layout;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetProcessDefaultLayout(dwDefaultLayout_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_prop_a(h_wnd: Hwnd, lp_string: &CStr, h_data: Option<Handle>) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let lpString_win32 = lp_string.as_ptr() as _;
    let hData_win32 = h_data.map_or(0, Handle::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetPropA(hWnd_win32, lpString_win32, hData_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_prop_w(h_wnd: Hwnd, lp_string: &OsStr, h_data: Option<Handle>) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let mut temp172: Vec<u16> = lp_string.encode_wide().collect();
    temp172.push(0);
    let lpString_win32 = temp172.as_ptr() as _;
    let hData_win32 = h_data.map_or(0, Handle::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetPropW(hWnd_win32, lpString_win32, hData_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_sys_colors(lpa_elements: &i32, lpa_rgb_values: &[u32]) -> Result<BOOL> {
    // SAFETY: type is a thin type
    let lpaElements_win32 = unsafe { &*(lpa_elements as *const _ as *const _) };
    let lpaRgbValues_win32 = lpa_rgb_values.as_ptr() as _;
    let cElements_win32 = lpa_rgb_values.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetSysColors(cElements_win32, lpaElements_win32, lpaRgbValues_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_system_cursor(hcur: Hcursor, id: u32) -> Result<BOOL> {
    let hcur_win32 = hcur.into_raw();
    let id_win32 = id;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetSystemCursor(hcur_win32, id_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_timer(h_wnd: Option<Hwnd>, n_id_event: usize, u_elapse: u32, lp_timer_func: Option<unsafe extern "system" fn(HWND, u32, usize, u32)>) -> usize {
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let nIDEvent_win32 = n_id_event;
    let uElapse_win32 = u_elapse;
    let lpTimerFunc_win32 = lp_timer_func;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetTimer(hWnd_win32, nIDEvent_win32, uElapse_win32, lpTimerFunc_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn set_window_display_affinity(h_wnd: Hwnd, dw_affinity: u32) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let dwAffinity_win32 = dw_affinity;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowDisplayAffinity(hWnd_win32, dwAffinity_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_window_long_a(h_wnd: Hwnd, n_index: i32, dw_new_long: i32) -> Result<i32> {
    let hWnd_win32 = h_wnd.into_raw();
    let nIndex_win32 = n_index;
    let dwNewLong_win32 = dw_new_long;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowLongA(hWnd_win32, nIndex_win32, dwNewLong_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_window_long_ptr_a(h_wnd: Hwnd, n_index: i32, dw_new_long: isize) -> isize {
    let hWnd_win32 = h_wnd.into_raw();
    let nIndex_win32 = n_index;
    let dwNewLong_win32 = dw_new_long;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowLongPtrA(hWnd_win32, nIndex_win32, dwNewLong_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn set_window_long_ptr_w(h_wnd: Hwnd, n_index: i32, dw_new_long: isize) -> isize {
    let hWnd_win32 = h_wnd.into_raw();
    let nIndex_win32 = n_index;
    let dwNewLong_win32 = dw_new_long;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowLongPtrW(hWnd_win32, nIndex_win32, dwNewLong_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn set_window_long_w(h_wnd: Hwnd, n_index: i32, dw_new_long: i32) -> Result<i32> {
    let hWnd_win32 = h_wnd.into_raw();
    let nIndex_win32 = n_index;
    let dwNewLong_win32 = dw_new_long;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowLongW(hWnd_win32, nIndex_win32, dwNewLong_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_window_placement(h_wnd: Hwnd, lpwndpl: &Windowplacement) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    // SAFETY: type is a thin type
    let lpwndpl_win32 = unsafe { &*(lpwndpl as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowPlacement(hWnd_win32, lpwndpl_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_window_pos(h_wnd: Hwnd, h_wnd_insert_after: Option<Hwnd>, x: i32, y: i32, cx: i32, cy: i32, u_flags: u32) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let hWndInsertAfter_win32 = h_wnd_insert_after.map_or(0, Hwnd::into_raw);
    let X_win32 = x;
    let Y_win32 = y;
    let cx_win32 = cx;
    let cy_win32 = cy;
    let uFlags_win32 = u_flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowPos(hWnd_win32, hWndInsertAfter_win32, X_win32, Y_win32, cx_win32, cy_win32, uFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_window_text_a(h_wnd: Hwnd, lp_string: Option<&CStr>) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let lpString_win32 = lp_string.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowTextA(hWnd_win32, lpString_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_window_text_w(h_wnd: Hwnd, lp_string: Option<&OsStr>) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let temp173 = lp_string.map(|val| {
        let mut temp173: Vec<u16> = val.encode_wide().collect();
        temp173.push(0);
        temp173
    });
    let lpString_win32 = temp173.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowTextW(hWnd_win32, lpString_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_window_word(h_wnd: Hwnd, n_index: i32, w_new_word: u16) -> u16 {
    let hWnd_win32 = h_wnd.into_raw();
    let nIndex_win32 = n_index;
    let wNewWord_win32 = w_new_word;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowWord(hWnd_win32, nIndex_win32, wNewWord_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn set_windows_hook_a(n_filter_type: i32, pfn_filter_proc: Option<unsafe extern "system" fn(i32, WPARAM, LPARAM) -> LRESULT>) -> Result<Hhook> {
    let nFilterType_win32 = n_filter_type;
    let pfnFilterProc_win32 = pfn_filter_proc;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowsHookA(nFilterType_win32, pfnFilterProc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hhook::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn set_windows_hook_ex_a(id_hook: i32, lpfn: Option<unsafe extern "system" fn(i32, WPARAM, LPARAM) -> LRESULT>, hmod: Option<Hinstance>, dw_thread_id: u32) -> Result<Hhook> {
    let idHook_win32 = id_hook;
    let lpfn_win32 = lpfn;
    let hmod_win32 = hmod.map_or(0, Hinstance::into_raw);
    let dwThreadId_win32 = dw_thread_id;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowsHookExA(idHook_win32, lpfn_win32, hmod_win32, dwThreadId_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hhook::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn set_windows_hook_ex_w(id_hook: i32, lpfn: Option<unsafe extern "system" fn(i32, WPARAM, LPARAM) -> LRESULT>, hmod: Option<Hinstance>, dw_thread_id: u32) -> Result<Hhook> {
    let idHook_win32 = id_hook;
    let lpfn_win32 = lpfn;
    let hmod_win32 = hmod.map_or(0, Hinstance::into_raw);
    let dwThreadId_win32 = dw_thread_id;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowsHookExW(idHook_win32, lpfn_win32, hmod_win32, dwThreadId_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hhook::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn set_windows_hook_w(n_filter_type: i32, pfn_filter_proc: Option<unsafe extern "system" fn(i32, WPARAM, LPARAM) -> LRESULT>) -> Result<Hhook> {
    let nFilterType_win32 = n_filter_type;
    let pfnFilterProc_win32 = pfn_filter_proc;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SetWindowsHookW(nFilterType_win32, pfnFilterProc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hhook::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn show_caret(h_wnd: Option<Hwnd>) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.map_or(0, Hwnd::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ShowCaret(hWnd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn show_cursor(b_show: BOOL) -> Result<i32> {
    let bShow_win32 = b_show;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ShowCursor(bShow_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn show_owned_popups(h_wnd: Hwnd, f_show: BOOL) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let fShow_win32 = f_show;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ShowOwnedPopups(hWnd_win32, fShow_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn show_window(h_wnd: Hwnd, n_cmd_show: u32) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let nCmdShow_win32 = n_cmd_show;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ShowWindow(hWnd_win32, nCmdShow_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn show_window_async(h_wnd: Hwnd, n_cmd_show: u32) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let nCmdShow_win32 = n_cmd_show;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::ShowWindowAsync(hWnd_win32, nCmdShow_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn sound_sentry() -> Result<BOOL> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SoundSentry() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn switch_to_this_window(hwnd: Hwnd, f_unknown: BOOL) -> () {
    let hwnd_win32 = hwnd.into_raw();
    let fUnknown_win32 = f_unknown;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::SwitchToThisWindow(hwnd_win32, fUnknown_win32) };
    let _ = return_value;
}
#[inline]
pub fn tile_windows(hwnd_parent: Option<Hwnd>, w_how: u32, lp_rect: Option<&Rect>, lp_kids: Option<&[Hwnd]>) -> u16 {
    let hwndParent_win32 = hwnd_parent.map_or(0, Hwnd::into_raw);
    let wHow_win32 = w_how;
    // SAFETY: type is a thin type
    let lpRect_win32 = lp_rect.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let lpKids_win32 = lp_kids.map_or(ptr::null(), |v| v.as_ptr() as _);
    let cKids_win32 = lp_kids.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::TileWindows(hwndParent_win32, wHow_win32, lpRect_win32, cKids_win32, lpKids_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn track_popup_menu(h_menu: Hmenu, u_flags: u32, x: i32, y: i32, h_wnd: Hwnd, prc_rect: &[Rect]) -> Result<BOOL> {
    let hMenu_win32 = h_menu.into_raw();
    let uFlags_win32 = u_flags;
    let x_win32 = x;
    let y_win32 = y;
    let hWnd_win32 = h_wnd.into_raw();
    let prcRect_win32 = prc_rect.as_ptr() as _;
    let nReserved_win32 = prc_rect.len() as _;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::TrackPopupMenu(hMenu_win32, uFlags_win32, x_win32, y_win32, nReserved_win32, hWnd_win32, prcRect_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn track_popup_menu_ex(h_menu: Hmenu, u_flags: u32, x: i32, y: i32, hwnd: Hwnd, lptpm: Option<&Tpmparams>) -> Result<BOOL> {
    let hMenu_win32 = h_menu.into_raw();
    let uFlags_win32 = u_flags;
    let x_win32 = x;
    let y_win32 = y;
    let hwnd_win32 = hwnd.into_raw();
    let temp174 = lptpm.map_or(unsafe { mem::zeroed() }, |val| val.to_win32());
    let lptpm_win32 = &temp174;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::TrackPopupMenuEx(hMenu_win32, uFlags_win32, x_win32, y_win32, hwnd_win32, lptpm_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn translate_accelerator_a(h_wnd: Hwnd, h_acc_table: Haccel, lp_msg: &Msg) -> Result<i32> {
    let hWnd_win32 = h_wnd.into_raw();
    let hAccTable_win32 = h_acc_table.into_raw();
    // SAFETY: type is a thin type
    let lpMsg_win32 = unsafe { &*(lp_msg as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::TranslateAcceleratorA(hWnd_win32, hAccTable_win32, lpMsg_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn translate_accelerator_w(h_wnd: Hwnd, h_acc_table: Haccel, lp_msg: &Msg) -> Result<i32> {
    let hWnd_win32 = h_wnd.into_raw();
    let hAccTable_win32 = h_acc_table.into_raw();
    // SAFETY: type is a thin type
    let lpMsg_win32 = unsafe { &*(lp_msg as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::TranslateAcceleratorW(hWnd_win32, hAccTable_win32, lpMsg_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn translate_mdi_sys_accel(h_wnd_client: Hwnd, lp_msg: &Msg) -> Result<BOOL> {
    let hWndClient_win32 = h_wnd_client.into_raw();
    // SAFETY: type is a thin type
    let lpMsg_win32 = unsafe { &*(lp_msg as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::TranslateMDISysAccel(hWndClient_win32, lpMsg_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn translate_message(lp_msg: &Msg) -> BOOL {
    // SAFETY: type is a thin type
    let lpMsg_win32 = unsafe { &*(lp_msg as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::TranslateMessage(lpMsg_win32) };
    let real_return_value = return_value;
    real_return_value
}
#[inline]
pub fn unhook_windows_hook(n_code: i32, pfn_filter_proc: Option<unsafe extern "system" fn(i32, WPARAM, LPARAM) -> LRESULT>) -> Result<BOOL> {
    let nCode_win32 = n_code;
    let pfnFilterProc_win32 = pfn_filter_proc;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::UnhookWindowsHook(nCode_win32, pfnFilterProc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn unhook_windows_hook_ex(hhk: Hhook) -> Result<BOOL> {
    let hhk_win32 = hhk.into_raw();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::UnhookWindowsHookEx(hhk_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn unregister_class_a(lp_class_name: &CStr, h_instance: Option<Hinstance>) -> Result<BOOL> {
    let lpClassName_win32 = lp_class_name.as_ptr() as _;
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::UnregisterClassA(lpClassName_win32, hInstance_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn unregister_class_w(lp_class_name: &OsStr, h_instance: Option<Hinstance>) -> Result<BOOL> {
    let mut temp175: Vec<u16> = lp_class_name.encode_wide().collect();
    temp175.push(0);
    let lpClassName_win32 = temp175.as_ptr() as _;
    let hInstance_win32 = h_instance.map_or(0, Hinstance::into_raw);
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::UnregisterClassW(lpClassName_win32, hInstance_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn update_layered_window(h_wnd: Hwnd, hdc_dst: Option<Hdc>, ppt_dst: Option<&Point>, psize: Option<&Size>, hdc_src: Option<Hdc>, ppt_src: Option<&Point>, pblend: Option<&[Blendfunction]>, dw_flags: u32) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let hdcDst_win32 = hdc_dst.map_or(0, Hdc::into_raw);
    // SAFETY: type is a thin type
    let pptDst_win32 = ppt_dst.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    // SAFETY: type is a thin type
    let psize_win32 = psize.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let hdcSrc_win32 = hdc_src.map_or(0, Hdc::into_raw);
    // SAFETY: type is a thin type
    let pptSrc_win32 = ppt_src.map_or(ptr::null(), |val| unsafe { &*(val as *const _ as *const _) });
    let pblend_win32 = pblend.map_or(ptr::null(), |v| v.as_ptr() as _);
    let crKey_win32 = pblend.len() as _;
    let dwFlags_win32 = dw_flags;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::UpdateLayeredWindow(hWnd_win32, hdcDst_win32, pptDst_win32, psize_win32, hdcSrc_win32, pptSrc_win32, crKey_win32, pblend_win32, dwFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn update_layered_window_indirect(h_wnd: Hwnd, p_ulw_info: &Updatelayeredwindowinfo<'_>) -> Result<BOOL> {
    let hWnd_win32 = h_wnd.into_raw();
    let temp176 = p_ulw_info.to_win32();
    let pULWInfo_win32 = &temp176;
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::UpdateLayeredWindowIndirect(hWnd_win32, pULWInfo_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn wait_message() -> Result<BOOL> {
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::WaitMessage() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn window_from_physical_point(point: Point) -> Result<Hwnd> {
    let Point_win32 = point.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::WindowFromPhysicalPoint(Point_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn window_from_point(point: Point) -> Result<Hwnd> {
    let Point_win32 = point.to_win32();
    let return_value = unsafe { windows_sys::Win32::UI::WindowsAndMessaging::WindowFromPoint(Point_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hwnd::new(return_value) };
    Ok(real_return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn add_dll_directory(new_directory: &OsStr) -> &mut todo_void_ret {
//      let mut temp177: Vec<u16> = new_directory.encode_wide().collect();
//      temp177.push(0);
//      let NewDirectory_win32 = temp177.as_ptr() as _;
//      let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::AddDllDirectory(NewDirectory_win32) };
//      let real_return_value = unsafe { &mut *(return_value as *mut _) };
//      real_return_value
//  }
#[inline]
pub fn begin_update_resource_a(p_file_name: &CStr, b_delete_existing_resources: BOOL) -> Result<Handle> {
    let pFileName_win32 = p_file_name.as_ptr() as _;
    let bDeleteExistingResources_win32 = b_delete_existing_resources;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::BeginUpdateResourceA(pFileName_win32, bDeleteExistingResources_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Handle::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn begin_update_resource_w(p_file_name: &OsStr, b_delete_existing_resources: BOOL) -> Result<Handle> {
    let mut temp178: Vec<u16> = p_file_name.encode_wide().collect();
    temp178.push(0);
    let pFileName_win32 = temp178.as_ptr() as _;
    let bDeleteExistingResources_win32 = b_delete_existing_resources;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::BeginUpdateResourceW(pFileName_win32, bDeleteExistingResources_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Handle::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn disable_thread_library_calls(h_lib_module: Hinstance) -> Result<BOOL> {
    let hLibModule_win32 = h_lib_module.into_raw();
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::DisableThreadLibraryCalls(hLibModule_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn end_update_resource_a(h_update: Handle, f_discard: BOOL) -> Result<BOOL> {
    let hUpdate_win32 = h_update.into_raw();
    let fDiscard_win32 = f_discard;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EndUpdateResourceA(hUpdate_win32, fDiscard_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn end_update_resource_w(h_update: Handle, f_discard: BOOL) -> Result<BOOL> {
    let hUpdate_win32 = h_update.into_raw();
    let fDiscard_win32 = f_discard;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EndUpdateResourceW(hUpdate_win32, fDiscard_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_resource_languages_a(h_module: Option<Hinstance>, lp_type: &CStr, lp_name: &CStr, lp_enum_func: Option<unsafe extern "system" fn(HINSTANCE, PCSTR, PCSTR, u16, isize) -> BOOL>, l_param: isize) -> Result<BOOL> {
    let hModule_win32 = h_module.map_or(0, Hinstance::into_raw);
    let lpType_win32 = lp_type.as_ptr() as _;
    let lpName_win32 = lp_name.as_ptr() as _;
    let lpEnumFunc_win32 = lp_enum_func;
    let lParam_win32 = l_param;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EnumResourceLanguagesA(hModule_win32, lpType_win32, lpName_win32, lpEnumFunc_win32, lParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_resource_languages_ex_a(h_module: Option<Hinstance>, lp_type: &CStr, lp_name: &CStr, lp_enum_func: Option<unsafe extern "system" fn(HINSTANCE, PCSTR, PCSTR, u16, isize) -> BOOL>, l_param: Option<isize>, dw_flags: u32, lang_id: u16) -> Result<BOOL> {
    let hModule_win32 = h_module.map_or(0, Hinstance::into_raw);
    let lpType_win32 = lp_type.as_ptr() as _;
    let lpName_win32 = lp_name.as_ptr() as _;
    let lpEnumFunc_win32 = lp_enum_func;
    let lParam_win32 = l_param;
    let dwFlags_win32 = dw_flags;
    let LangId_win32 = lang_id;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EnumResourceLanguagesExA(hModule_win32, lpType_win32, lpName_win32, lpEnumFunc_win32, lParam_win32, dwFlags_win32, LangId_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_resource_languages_ex_w(h_module: Option<Hinstance>, lp_type: &OsStr, lp_name: &OsStr, lp_enum_func: Option<unsafe extern "system" fn(HINSTANCE, PCWSTR, PCWSTR, u16, isize) -> BOOL>, l_param: Option<isize>, dw_flags: u32, lang_id: u16) -> Result<BOOL> {
    let hModule_win32 = h_module.map_or(0, Hinstance::into_raw);
    let mut temp179: Vec<u16> = lp_type.encode_wide().collect();
    temp179.push(0);
    let lpType_win32 = temp179.as_ptr() as _;
    let mut temp180: Vec<u16> = lp_name.encode_wide().collect();
    temp180.push(0);
    let lpName_win32 = temp180.as_ptr() as _;
    let lpEnumFunc_win32 = lp_enum_func;
    let lParam_win32 = l_param;
    let dwFlags_win32 = dw_flags;
    let LangId_win32 = lang_id;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EnumResourceLanguagesExW(hModule_win32, lpType_win32, lpName_win32, lpEnumFunc_win32, lParam_win32, dwFlags_win32, LangId_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_resource_languages_w(h_module: Option<Hinstance>, lp_type: &OsStr, lp_name: &OsStr, lp_enum_func: Option<unsafe extern "system" fn(HINSTANCE, PCWSTR, PCWSTR, u16, isize) -> BOOL>, l_param: isize) -> Result<BOOL> {
    let hModule_win32 = h_module.map_or(0, Hinstance::into_raw);
    let mut temp181: Vec<u16> = lp_type.encode_wide().collect();
    temp181.push(0);
    let lpType_win32 = temp181.as_ptr() as _;
    let mut temp182: Vec<u16> = lp_name.encode_wide().collect();
    temp182.push(0);
    let lpName_win32 = temp182.as_ptr() as _;
    let lpEnumFunc_win32 = lp_enum_func;
    let lParam_win32 = l_param;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EnumResourceLanguagesW(hModule_win32, lpType_win32, lpName_win32, lpEnumFunc_win32, lParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_resource_names_a(h_module: Option<Hinstance>, lp_type: &CStr, lp_enum_func: Option<unsafe extern "system" fn(HINSTANCE, PCSTR, PCSTR, isize) -> BOOL>, l_param: isize) -> Result<BOOL> {
    let hModule_win32 = h_module.map_or(0, Hinstance::into_raw);
    let lpType_win32 = lp_type.as_ptr() as _;
    let lpEnumFunc_win32 = lp_enum_func;
    let lParam_win32 = l_param;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EnumResourceNamesA(hModule_win32, lpType_win32, lpEnumFunc_win32, lParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_resource_names_ex_a(h_module: Option<Hinstance>, lp_type: &CStr, lp_enum_func: Option<unsafe extern "system" fn(HINSTANCE, PCSTR, PCSTR, isize) -> BOOL>, l_param: isize, dw_flags: u32, lang_id: u16) -> Result<BOOL> {
    let hModule_win32 = h_module.map_or(0, Hinstance::into_raw);
    let lpType_win32 = lp_type.as_ptr() as _;
    let lpEnumFunc_win32 = lp_enum_func;
    let lParam_win32 = l_param;
    let dwFlags_win32 = dw_flags;
    let LangId_win32 = lang_id;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EnumResourceNamesExA(hModule_win32, lpType_win32, lpEnumFunc_win32, lParam_win32, dwFlags_win32, LangId_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_resource_names_ex_w(h_module: Option<Hinstance>, lp_type: &OsStr, lp_enum_func: Option<unsafe extern "system" fn(HINSTANCE, PCWSTR, PCWSTR, isize) -> BOOL>, l_param: isize, dw_flags: u32, lang_id: u16) -> Result<BOOL> {
    let hModule_win32 = h_module.map_or(0, Hinstance::into_raw);
    let mut temp183: Vec<u16> = lp_type.encode_wide().collect();
    temp183.push(0);
    let lpType_win32 = temp183.as_ptr() as _;
    let lpEnumFunc_win32 = lp_enum_func;
    let lParam_win32 = l_param;
    let dwFlags_win32 = dw_flags;
    let LangId_win32 = lang_id;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EnumResourceNamesExW(hModule_win32, lpType_win32, lpEnumFunc_win32, lParam_win32, dwFlags_win32, LangId_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_resource_names_w(h_module: Option<Hinstance>, lp_type: &OsStr, lp_enum_func: Option<unsafe extern "system" fn(HINSTANCE, PCWSTR, PCWSTR, isize) -> BOOL>, l_param: isize) -> Result<BOOL> {
    let hModule_win32 = h_module.map_or(0, Hinstance::into_raw);
    let mut temp184: Vec<u16> = lp_type.encode_wide().collect();
    temp184.push(0);
    let lpType_win32 = temp184.as_ptr() as _;
    let lpEnumFunc_win32 = lp_enum_func;
    let lParam_win32 = l_param;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EnumResourceNamesW(hModule_win32, lpType_win32, lpEnumFunc_win32, lParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_resource_types_a(h_module: Option<Hinstance>, lp_enum_func: Option<unsafe extern "system" fn(HINSTANCE, PCSTR, isize) -> BOOL>, l_param: isize) -> Result<BOOL> {
    let hModule_win32 = h_module.map_or(0, Hinstance::into_raw);
    let lpEnumFunc_win32 = lp_enum_func;
    let lParam_win32 = l_param;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EnumResourceTypesA(hModule_win32, lpEnumFunc_win32, lParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_resource_types_ex_a(h_module: Option<Hinstance>, lp_enum_func: Option<unsafe extern "system" fn(HINSTANCE, PCSTR, isize) -> BOOL>, l_param: isize, dw_flags: u32, lang_id: u16) -> Result<BOOL> {
    let hModule_win32 = h_module.map_or(0, Hinstance::into_raw);
    let lpEnumFunc_win32 = lp_enum_func;
    let lParam_win32 = l_param;
    let dwFlags_win32 = dw_flags;
    let LangId_win32 = lang_id;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EnumResourceTypesExA(hModule_win32, lpEnumFunc_win32, lParam_win32, dwFlags_win32, LangId_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_resource_types_ex_w(h_module: Option<Hinstance>, lp_enum_func: Option<unsafe extern "system" fn(HINSTANCE, PCWSTR, isize) -> BOOL>, l_param: isize, dw_flags: u32, lang_id: u16) -> Result<BOOL> {
    let hModule_win32 = h_module.map_or(0, Hinstance::into_raw);
    let lpEnumFunc_win32 = lp_enum_func;
    let lParam_win32 = l_param;
    let dwFlags_win32 = dw_flags;
    let LangId_win32 = lang_id;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EnumResourceTypesExW(hModule_win32, lpEnumFunc_win32, lParam_win32, dwFlags_win32, LangId_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn enum_resource_types_w(h_module: Option<Hinstance>, lp_enum_func: Option<unsafe extern "system" fn(HINSTANCE, PCWSTR, isize) -> BOOL>, l_param: isize) -> Result<BOOL> {
    let hModule_win32 = h_module.map_or(0, Hinstance::into_raw);
    let lpEnumFunc_win32 = lp_enum_func;
    let lParam_win32 = l_param;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::EnumResourceTypesW(hModule_win32, lpEnumFunc_win32, lParam_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn find_resource_a(h_module: Option<Hinstance>, lp_name: &CStr, lp_type: &CStr) -> Result<Hrsrc> {
    let hModule_win32 = h_module.map_or(0, Hinstance::into_raw);
    let lpName_win32 = lp_name.as_ptr() as _;
    let lpType_win32 = lp_type.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::FindResourceA(hModule_win32, lpName_win32, lpType_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hrsrc::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn find_resource_ex_a(h_module: Option<Hinstance>, lp_type: &CStr, lp_name: &CStr, w_language: u16) -> Result<Hrsrc> {
    let hModule_win32 = h_module.map_or(0, Hinstance::into_raw);
    let lpType_win32 = lp_type.as_ptr() as _;
    let lpName_win32 = lp_name.as_ptr() as _;
    let wLanguage_win32 = w_language;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::FindResourceExA(hModule_win32, lpType_win32, lpName_win32, wLanguage_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hrsrc::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn find_resource_ex_w(h_module: Option<Hinstance>, lp_type: &OsStr, lp_name: &OsStr, w_language: u16) -> Result<Hrsrc> {
    let hModule_win32 = h_module.map_or(0, Hinstance::into_raw);
    let mut temp185: Vec<u16> = lp_type.encode_wide().collect();
    temp185.push(0);
    let lpType_win32 = temp185.as_ptr() as _;
    let mut temp186: Vec<u16> = lp_name.encode_wide().collect();
    temp186.push(0);
    let lpName_win32 = temp186.as_ptr() as _;
    let wLanguage_win32 = w_language;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::FindResourceExW(hModule_win32, lpType_win32, lpName_win32, wLanguage_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hrsrc::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn find_resource_w(h_module: Option<Hinstance>, lp_name: &OsStr, lp_type: &OsStr) -> Result<Hrsrc> {
    let hModule_win32 = h_module.map_or(0, Hinstance::into_raw);
    let mut temp187: Vec<u16> = lp_name.encode_wide().collect();
    temp187.push(0);
    let lpName_win32 = temp187.as_ptr() as _;
    let mut temp188: Vec<u16> = lp_type.encode_wide().collect();
    temp188.push(0);
    let lpType_win32 = temp188.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::FindResourceW(hModule_win32, lpName_win32, lpType_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hrsrc::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn free_library(h_lib_module: Hinstance) -> Result<BOOL> {
    let hLibModule_win32 = h_lib_module.into_raw();
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::FreeLibrary(hLibModule_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn free_library_and_exit_thread(h_lib_module: Hinstance, dw_exit_code: u32) -> () {
    let hLibModule_win32 = h_lib_module.into_raw();
    let dwExitCode_win32 = dw_exit_code;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::FreeLibraryAndExitThread(hLibModule_win32, dwExitCode_win32) };
    let _ = return_value;
}
#[inline]
pub fn free_resource(h_res_data: isize) -> Result<BOOL> {
    let hResData_win32 = h_res_data;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::FreeResource(hResData_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn get_dll_directory_a(n_buffer_length: u32, ) -> (u32, CString) {
    let mut lp_buffer = Vec::<u8>::with_capacity(n_buffer_length as usize + 1);
    let lpBuffer_win32 = lp_buffer.as_mut_ptr();
    let nBufferLength_win32 = n_buffer_length;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::GetDllDirectoryA(nBufferLength_win32, lpBuffer_win32) };
    let real_return_value = return_value;
    lp_buffer.truncate(return_value as usize);
    let lp_buffer = unsafe { CString::from_vec_unchecked(lp_buffer) };
    (real_return_value,lp_buffer)
}
#[inline]
pub fn get_dll_directory_w(n_buffer_length: u32, ) -> (u32, OsString) {
    let mut lp_buffer = Vec::<u16>::with_capacity(n_buffer_length as usize + 1);
    let lpBuffer_win32 = lp_buffer.as_mut_ptr();
    let nBufferLength_win32 = n_buffer_length;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::GetDllDirectoryW(nBufferLength_win32, lpBuffer_win32) };
    let real_return_value = return_value;
    lp_buffer.truncate(return_value as usize);
    let lp_buffer = OsString::from_wide(&lp_buffer);
    (real_return_value,lp_buffer)
}
#[inline]
pub fn get_module_file_name_a(h_module: Option<Hinstance>, n_size: u32) -> (u32, CString) {
    let mut lp_filename = Vec::<u8>::with_capacity(n_size as usize + 1);
    let lpFilename_win32 = lp_filename.as_mut_ptr();
    let hModule_win32 = h_module.map_or(0, Hinstance::into_raw);
    let nSize_win32 = n_size;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::GetModuleFileNameA(hModule_win32, lpFilename_win32, nSize_win32) };
    let real_return_value = return_value;
    lp_filename.truncate(return_value as usize);
    let lp_filename = unsafe { CString::from_vec_unchecked(lp_filename) };
    (real_return_value,lp_filename)
}
#[inline]
pub fn get_module_file_name_w(h_module: Option<Hinstance>, n_size: u32) -> (u32, OsString) {
    let mut lp_filename = Vec::<u16>::with_capacity(n_size as usize + 1);
    let lpFilename_win32 = lp_filename.as_mut_ptr();
    let hModule_win32 = h_module.map_or(0, Hinstance::into_raw);
    let nSize_win32 = n_size;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::GetModuleFileNameW(hModule_win32, lpFilename_win32, nSize_win32) };
    let real_return_value = return_value;
    lp_filename.truncate(return_value as usize);
    let lp_filename = OsString::from_wide(&lp_filename);
    (real_return_value,lp_filename)
}
#[inline]
pub fn get_module_handle_a(lp_module_name: Option<&CStr>) -> Result<Hinstance> {
    let lpModuleName_win32 = lp_module_name.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::GetModuleHandleA(lpModuleName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hinstance::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_module_handle_ex_a(dw_flags: u32, lp_module_name: Option<&CStr>, ) -> Result<(BOOL, Hinstance)> {
    let mut ph_module = mem::MaybeUninit::zeroed();
    let phModule_win32 = ph_module.as_mut_ptr();
    let dwFlags_win32 = dw_flags;
    let lpModuleName_win32 = lp_module_name.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::GetModuleHandleExA(dwFlags_win32, lpModuleName_win32, phModule_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let ph_module = unsafe { Hinstance::new(unsafe { ph_module.assume_init() }) };
    Ok((real_return_value,ph_module))
}
#[inline]
pub fn get_module_handle_ex_w(dw_flags: u32, lp_module_name: Option<&OsStr>, ) -> Result<(BOOL, Hinstance)> {
    let mut ph_module = mem::MaybeUninit::zeroed();
    let phModule_win32 = ph_module.as_mut_ptr();
    let dwFlags_win32 = dw_flags;
    let temp189 = lp_module_name.map(|val| {
        let mut temp189: Vec<u16> = val.encode_wide().collect();
        temp189.push(0);
        temp189
    });
    let lpModuleName_win32 = temp189.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::GetModuleHandleExW(dwFlags_win32, lpModuleName_win32, phModule_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let ph_module = unsafe { Hinstance::new(unsafe { ph_module.assume_init() }) };
    Ok((real_return_value,ph_module))
}
#[inline]
pub fn get_module_handle_w(lp_module_name: Option<&OsStr>) -> Result<Hinstance> {
    let temp190 = lp_module_name.map(|val| {
        let mut temp190: Vec<u16> = val.encode_wide().collect();
        temp190.push(0);
        temp190
    });
    let lpModuleName_win32 = temp190.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::GetModuleHandleW(lpModuleName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hinstance::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn get_proc_address(h_module: Hinstance, lp_proc_name: &CStr) -> Option<unsafe extern "system" fn() -> isize> {
    let hModule_win32 = h_module.into_raw();
    let lpProcName_win32 = lp_proc_name.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::GetProcAddress(hModule_win32, lpProcName_win32) };
    let real_return_value = Some(return_value);
    real_return_value
}
#[inline]
pub fn load_library_a(lp_lib_file_name: &CStr) -> Result<Hinstance> {
    let lpLibFileName_win32 = lp_lib_file_name.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::LoadLibraryA(lpLibFileName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hinstance::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn load_library_ex_a(lp_lib_file_name: &CStr, h_file: Handle, dw_flags: u32) -> Result<Hinstance> {
    let lpLibFileName_win32 = lp_lib_file_name.as_ptr() as _;
    let hFile_win32 = h_file.into_raw();
    let dwFlags_win32 = dw_flags;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::LoadLibraryExA(lpLibFileName_win32, hFile_win32, dwFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hinstance::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn load_library_ex_w(lp_lib_file_name: &OsStr, h_file: Handle, dw_flags: u32) -> Result<Hinstance> {
    let mut temp191: Vec<u16> = lp_lib_file_name.encode_wide().collect();
    temp191.push(0);
    let lpLibFileName_win32 = temp191.as_ptr() as _;
    let hFile_win32 = h_file.into_raw();
    let dwFlags_win32 = dw_flags;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::LoadLibraryExW(lpLibFileName_win32, hFile_win32, dwFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hinstance::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn load_library_w(lp_lib_file_name: &OsStr) -> Result<Hinstance> {
    let mut temp192: Vec<u16> = lp_lib_file_name.encode_wide().collect();
    temp192.push(0);
    let lpLibFileName_win32 = temp192.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::LoadLibraryW(lpLibFileName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hinstance::new(return_value) };
    Ok(real_return_value)
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn load_module(lp_module_name: &CStr, lp_parameter_block: &todo_void) -> u32 {
//      let lpModuleName_win32 = lp_module_name.as_ptr() as _;
//      // SAFETY: type is a thin type
//      let lpParameterBlock_win32 = unsafe { &*(lp_parameter_block as *const _ as *const _) };
//      let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::LoadModule(lpModuleName_win32, lpParameterBlock_win32) };
//      let real_return_value = return_value;
//      real_return_value
//  }
#[inline]
pub fn load_packaged_library(lpw_lib_file_name: &OsStr, reserved: u32) -> Result<Hinstance> {
    let mut temp193: Vec<u16> = lpw_lib_file_name.encode_wide().collect();
    temp193.push(0);
    let lpwLibFileName_win32 = temp193.as_ptr() as _;
    let Reserved_win32 = reserved;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::LoadPackagedLibrary(lpwLibFileName_win32, Reserved_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hinstance::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn load_resource(h_module: Option<Hinstance>, h_res_info: Hrsrc) -> isize {
    let hModule_win32 = h_module.map_or(0, Hinstance::into_raw);
    let hResInfo_win32 = h_res_info.into_raw();
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::LoadResource(hModule_win32, hResInfo_win32) };
    let real_return_value = return_value;
    real_return_value
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn lock_resource(h_res_data: isize) -> &mut todo_void_ret {
//      let hResData_win32 = h_res_data;
//      let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::LockResource(hResData_win32) };
//      let real_return_value = unsafe { &mut *(return_value as *mut _) };
//      real_return_value
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn remove_dll_directory(cookie: &todo_void) -> Result<BOOL> {
//      // SAFETY: type is a thin type
//      let Cookie_win32 = unsafe { &*(cookie as *const _ as *const _) };
//      let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::RemoveDllDirectory(Cookie_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      Ok(real_return_value)
//  }
#[inline]
pub fn set_default_dll_directories(directory_flags: u32) -> Result<BOOL> {
    let DirectoryFlags_win32 = directory_flags;
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::SetDefaultDllDirectories(DirectoryFlags_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_dll_directory_a(lp_path_name: Option<&CStr>) -> Result<BOOL> {
    let lpPathName_win32 = lp_path_name.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::SetDllDirectoryA(lpPathName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_dll_directory_w(lp_path_name: Option<&OsStr>) -> Result<BOOL> {
    let temp194 = lp_path_name.map(|val| {
        let mut temp194: Vec<u16> = val.encode_wide().collect();
        temp194.push(0);
        temp194
    });
    let lpPathName_win32 = temp194.map_or(ptr::null(), |v| v.as_ptr() as _);
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::SetDllDirectoryW(lpPathName_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn sizeof_resource(h_module: Option<Hinstance>, h_res_info: Hrsrc) -> u32 {
    let hModule_win32 = h_module.map_or(0, Hinstance::into_raw);
    let hResInfo_win32 = h_res_info.into_raw();
    let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::SizeofResource(hModule_win32, hResInfo_win32) };
    let real_return_value = return_value;
    real_return_value
}
//  Not generated due to containing a void type
//  #[inline]
//  pub fn update_resource_a(h_update: Handle, lp_type: &CStr, lp_name: &CStr, w_language: u16, lp_data: Option<&[todo_void]>, ) -> Result<BOOL> {
//      let hUpdate_win32 = h_update.into_raw();
//      let lpType_win32 = lp_type.as_ptr() as _;
//      let lpName_win32 = lp_name.as_ptr() as _;
//      let wLanguage_win32 = w_language;
//      let lpData_win32 = lp_data.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let cb_win32 = lp_data.len() as _;
//      let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::UpdateResourceA(hUpdate_win32, lpType_win32, lpName_win32, wLanguage_win32, lpData_win32, cb_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      Ok(real_return_value)
//  }
//  Not generated due to containing a void type
//  #[inline]
//  pub fn update_resource_w(h_update: Handle, lp_type: &OsStr, lp_name: &OsStr, w_language: u16, lp_data: Option<&[todo_void]>, ) -> Result<BOOL> {
//      let hUpdate_win32 = h_update.into_raw();
//      let mut temp195: Vec<u16> = lp_type.encode_wide().collect();
//      temp195.push(0);
//      let lpType_win32 = temp195.as_ptr() as _;
//      let mut temp196: Vec<u16> = lp_name.encode_wide().collect();
//      temp196.push(0);
//      let lpName_win32 = temp196.as_ptr() as _;
//      let wLanguage_win32 = w_language;
//      let lpData_win32 = lp_data.map_or(ptr::null(), |v| v.as_ptr() as _);
//      let cb_win32 = lp_data.len() as _;
//      let return_value = unsafe { windows_sys::Win32::System::LibraryLoader::UpdateResourceW(hUpdate_win32, lpType_win32, lpName_win32, wLanguage_win32, lpData_win32, cb_win32) };
//      if return_value == 0 {
//          return Err(crate::last_win32_error());
//      }
//      let real_return_value = return_value;
//      Ok(real_return_value)
//  }
#[inline]
pub fn choose_pixel_format(hdc: Hdc, ppfd: &Pixelformatdescriptor) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let temp197 = ppfd.to_win32();
    let ppfd_win32 = &temp197;
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::ChoosePixelFormat(hdc_win32, ppfd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn describe_pixel_format(hdc: Hdc, i_pixel_format: i8, n_bytes: u32, ) -> Result<(i32, Pixelformatdescriptor)> {
    let mut ppfd = mem::MaybeUninit::zeroed();
    let ppfd_win32 = ppfd.as_mut_ptr();
    let hdc_win32 = hdc.into_raw();
    let iPixelFormat_win32 = i_pixel_format;
    let nBytes_win32 = n_bytes;
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::DescribePixelFormat(hdc_win32, iPixelFormat_win32, nBytes_win32, ppfd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let ppfd = unsafe { Pixelformatdescriptor::from_win32(unsafe { ppfd.assume_init() }) };
    Ok((real_return_value,ppfd))
}
#[inline]
pub fn get_enh_meta_file_pixel_format(hemf: Henhmetafile, cb_buffer: u32, ) -> (u32, Pixelformatdescriptor) {
    let mut ppfd = mem::MaybeUninit::zeroed();
    let ppfd_win32 = ppfd.as_mut_ptr();
    let hemf_win32 = hemf.into_raw();
    let cbBuffer_win32 = cb_buffer;
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::GetEnhMetaFilePixelFormat(hemf_win32, cbBuffer_win32, ppfd_win32) };
    let real_return_value = return_value;
    let ppfd = unsafe { Pixelformatdescriptor::from_win32(unsafe { ppfd.assume_init() }) };
    (real_return_value,ppfd)
}
#[inline]
pub fn get_pixel_format(hdc: Hdc) -> Result<i32> {
    let hdc_win32 = hdc.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::GetPixelFormat(hdc_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn set_pixel_format(hdc: Hdc, format: i32, ppfd: &Pixelformatdescriptor) -> Result<BOOL> {
    let hdc_win32 = hdc.into_raw();
    let format_win32 = format;
    let temp198 = ppfd.to_win32();
    let ppfd_win32 = &temp198;
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::SetPixelFormat(hdc_win32, format_win32, ppfd_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn swap_buffers(param0: Hdc) -> Result<BOOL> {
    let param0_win32 = param0.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::SwapBuffers(param0_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn wgl_copy_context(param0: Hglrc, param1: Hglrc, param2: u32) -> Result<BOOL> {
    let param0_win32 = param0.into_raw();
    let param1_win32 = param1.into_raw();
    let param2_win32 = param2;
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglCopyContext(param0_win32, param1_win32, param2_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn wgl_create_context(param0: Hdc) -> Result<Hglrc> {
    let param0_win32 = param0.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglCreateContext(param0_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hglrc::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn wgl_create_layer_context(param0: Hdc, param1: i32) -> Result<Hglrc> {
    let param0_win32 = param0.into_raw();
    let param1_win32 = param1;
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglCreateLayerContext(param0_win32, param1_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hglrc::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn wgl_delete_context(param0: Hglrc) -> Result<BOOL> {
    let param0_win32 = param0.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglDeleteContext(param0_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn wgl_describe_layer_plane(param0: Hdc, param1: i32, param2: i32, param3: u32, param4: Layerplanedescriptor) -> Result<(BOOL, Layerplanedescriptor)> {
    let param0_win32 = param0.into_raw();
    let param1_win32 = param1;
    let param2_win32 = param2;
    let param3_win32 = param3;
    let mut param4_win32 = param4.to_win32();
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglDescribeLayerPlane(param0_win32, param1_win32, param2_win32, param3_win32, &mut param4_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let param4 = unsafe { Layerplanedescriptor::from_win32(param4_win32) };
    Ok((real_return_value,param4))
}
#[inline]
pub fn wgl_get_current_context() -> Result<Hglrc> {
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglGetCurrentContext() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hglrc::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn wgl_get_current_dc() -> Result<Hdc> {
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglGetCurrentDC() };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = unsafe { Hdc::new(return_value) };
    Ok(real_return_value)
}
#[inline]
pub fn wgl_get_layer_palette_entries(param0: Hdc, param1: i32, param2: i32, param3: i32, param4: u32) -> Result<(i32, u32)> {
    let param0_win32 = param0.into_raw();
    let param1_win32 = param1;
    let param2_win32 = param2;
    let param3_win32 = param3;
    let mut param4_win32 = param4;
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglGetLayerPaletteEntries(param0_win32, param1_win32, param2_win32, param3_win32, &mut param4_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let param4 = param4_win32;
    Ok((real_return_value,param4))
}
#[inline]
pub fn wgl_get_proc_address(param0: &CStr) -> Option<unsafe extern "system" fn() -> isize> {
    let param0_win32 = param0.as_ptr() as _;
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglGetProcAddress(param0_win32) };
    let real_return_value = Some(return_value);
    real_return_value
}
#[inline]
pub fn wgl_make_current(param0: Hdc, param1: Hglrc) -> Result<BOOL> {
    let param0_win32 = param0.into_raw();
    let param1_win32 = param1.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglMakeCurrent(param0_win32, param1_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn wgl_realize_layer_palette(param0: Hdc, param1: i32, param2: BOOL) -> Result<BOOL> {
    let param0_win32 = param0.into_raw();
    let param1_win32 = param1;
    let param2_win32 = param2;
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglRealizeLayerPalette(param0_win32, param1_win32, param2_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn wgl_set_layer_palette_entries(param0: Hdc, param1: i32, param2: i32, param3: i32, param4: &u32) -> Result<i32> {
    let param0_win32 = param0.into_raw();
    let param1_win32 = param1;
    let param2_win32 = param2;
    let param3_win32 = param3;
    // SAFETY: type is a thin type
    let param4_win32 = unsafe { &*(param4 as *const _ as *const _) };
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglSetLayerPaletteEntries(param0_win32, param1_win32, param2_win32, param3_win32, param4_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn wgl_share_lists(param0: Hglrc, param1: Hglrc) -> Result<BOOL> {
    let param0_win32 = param0.into_raw();
    let param1_win32 = param1.into_raw();
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglShareLists(param0_win32, param1_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn wgl_swap_layer_buffers(param0: Hdc, param1: u32) -> Result<BOOL> {
    let param0_win32 = param0.into_raw();
    let param1_win32 = param1;
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglSwapLayerBuffers(param0_win32, param1_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn wgl_use_font_bitmaps_a(param0: Hdc, param1: u32, param2: u32, param3: u32) -> Result<BOOL> {
    let param0_win32 = param0.into_raw();
    let param1_win32 = param1;
    let param2_win32 = param2;
    let param3_win32 = param3;
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglUseFontBitmapsA(param0_win32, param1_win32, param2_win32, param3_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn wgl_use_font_bitmaps_w(param0: Hdc, param1: u32, param2: u32, param3: u32) -> Result<BOOL> {
    let param0_win32 = param0.into_raw();
    let param1_win32 = param1;
    let param2_win32 = param2;
    let param3_win32 = param3;
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglUseFontBitmapsW(param0_win32, param1_win32, param2_win32, param3_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    Ok(real_return_value)
}
#[inline]
pub fn wgl_use_font_outlines_a(param0: Hdc, param1: u32, param2: u32, param3: u32, param4: f32, param5: f32, param6: i32, param7: Glyphmetricsfloat) -> Result<(BOOL, Glyphmetricsfloat)> {
    let param0_win32 = param0.into_raw();
    let param1_win32 = param1;
    let param2_win32 = param2;
    let param3_win32 = param3;
    let param4_win32 = param4;
    let param5_win32 = param5;
    let param6_win32 = param6;
    let mut param7_win32 = param7.to_win32();
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglUseFontOutlinesA(param0_win32, param1_win32, param2_win32, param3_win32, param4_win32, param5_win32, param6_win32, &mut param7_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let param7 = unsafe { Glyphmetricsfloat::from_win32(param7_win32) };
    Ok((real_return_value,param7))
}
#[inline]
pub fn wgl_use_font_outlines_w(param0: Hdc, param1: u32, param2: u32, param3: u32, param4: f32, param5: f32, param6: i32, param7: Glyphmetricsfloat) -> Result<(BOOL, Glyphmetricsfloat)> {
    let param0_win32 = param0.into_raw();
    let param1_win32 = param1;
    let param2_win32 = param2;
    let param3_win32 = param3;
    let param4_win32 = param4;
    let param5_win32 = param5;
    let param6_win32 = param6;
    let mut param7_win32 = param7.to_win32();
    let return_value = unsafe { windows_sys::Win32::Graphics::OpenGL::wglUseFontOutlinesW(param0_win32, param1_win32, param2_win32, param3_win32, param4_win32, param5_win32, param6_win32, &mut param7_win32) };
    if return_value == 0 {
        return Err(crate::last_win32_error());
    }
    let real_return_value = return_value;
    let param7 = unsafe { Glyphmetricsfloat::from_win32(param7_win32) };
    Ok((real_return_value,param7))
}
