how yaww works (notes):

 - Creating a new instance of the GuiThread object spawns the GUI thread, which is the home
   thread for all of the primitives we use.
 - GUI thread's main responsibility is constantly calling GetMessage() for message
   handling. Since it also calls DispatchMessage(), it's where the WNDPROC is run.
 - The outer program has access to two channels: the directive sending channel and the
   response receiving channel. To make the Win32 program do stuff, directives are sent into
   the sender channel.
  - Each directive is assigned a unique ID to keep everything synced.
  - Each directive has an associated response, either to tell the user that everything is
    A-Ok or to provide response data.
 - Due to the fact that the main GUI thread is currently processing window messages,
   incoming directives are handled via an auxillary thread that wraps directives in window
   messages and passes them onto the GUI thread's message queue.
 - In addition, the outer program also provides an "event handler". This is a function that
   gets called for a variety of events in the WNDPROC.
 - When the event handler is called within the WNDPROC, it may generate new events. The
   problem arises when the event handler sends directives. Since we're currently in the
   GUI thread waiting for the event handler to finish, waiting for events in the handler
   will freeze the program.
  - This is solved by running the event handler on a seperate thread dedicated to running
    the event handler. In addition, we set it up so the auxillary directive thread
    mentioned above no longer processes threads, and offload that capability onto the GUI
    thread while it's waiting for the event handler thread to stop.
